Concat_Text
Simplified integration of Prolog with RDBMS
Mod-PROLOG, a modular, microcomputer oriented PROLOG
EPILOG = PROLOG + Data Flow: arguments for combining PROLOG with a data driven mechanism
Improving Prolog programs
"Prolog compared with LISP?In the recent ACM Symposium on LISP and Functional Programming, there was a paper with the title ""Prolog Compared With LISP"" [2] . In it, Gutierrez presents a program in LISP, and a related program in Prolog, and uses the inferior performance of the latter to suggest in strong terms that advocates of Prolog may have over-stated its performance. However, his program makes very poor use of Prolog. In this article, I point out which features of Prolog have been misused and give guidelines for their proper use. I also compare a new Prolog and LISP program performing a similar task, and find that the execution times are comparable.O'Keefe 1 In the recent ACM Symposium on LiSP and FunctionaJ Programming, there was a paper with the title ""Prolog Compared With LISP"" [2]. In it, Gutierrez presents a program in LISP, and a related program in Prolog, and uses the inferior performance of the latter to suggest in strong terms that advocates of Prolog may have over-stated its performance. However, his program makes very poor use of Prolog. have been misused and give guidelines for their proper use. in this article, I point out which features of Prolog I also compare a new Prolog and LiSP program performing a similar task, and find that the execution times are comparable. 1. Now, it is difficult to under-estimate[sic] the importance of lists in programming, at least in AI, even if Prolog offers some beautiful ways of doing things that do not involve lists."
"LFG system in prologLexical Functional Grammar (LFG) [Kaplan, Bresnan 82] is a powerful formalism for that purpose. In this paper, the Prolog implementation of LFG system is described. Prolog provides a good tools for the implementation of LFG.LFG ystsm in Prolog Hide Yau'awa The Second Laboratory Institute for New Generation Computer Technology (ICOT) To/o, 108, Japan ef.rl handed the baby a toy"" ([Kaplan,Bresnan 82]). Lexlcal Functional Grammar (LFG) [Kaplan, Bresnan 82] is a powerful formalism for that purpose, In this paper, the Prolog implementation of LFG system is described. Prolog provides a Eood tools for the implementation of LFG. LFG is adopted for our prelimlnay version of the formal system and the Prolog implementation of LFG is described in this paper."
Prolog in 10 figuresIn the fall of 1981, a Japanese report officially initiated the quest for fifth-generation computers that would encompass the functions of knowledge processing and artificial intelligence. The conceptual underpinnings behind Prolog-Japan's language of choice for these activities-are presented here in a way that suggests why Prolog or a similar language might be considered a model for designing the computers of the future.PROILOG IN 10 FIGURES In the fall of 1981, a Japanese report officially initiated the quest for fifthgeneration computers that would encompass the functions of knowledge processing and (artificial intelligence. The conceptual underpinnings behind Prolog-Japan `s language of choice for these activities-are presented here in a way that suggests why Prolog or a similar language might be considered a model for designing the computers of the future. ALAIN COLMERAUER Prolog-an acronym for Programming in Logic-was created over a decade ago at the Faculty of Sciences at Luminy in Marseilles, France. K 1985 ACM OOOI-0782/85~1200-1L'Yf 756 This model, which has now benefited from over a decade of experience and polishing, [lo. 11. 13. 141 is presented in this article through a sequence of 10 figures beginning on page 1299. The first 8 figures trace the workings of a Prolog program. The last z give additional examples of Prolog programs.
Prolog as a simulation languageProlog is a rather new language and is very different from traditional languages. Prolog is favored by the Japanese for their Fifth Generation Computer Systems. The acronym PROLOG is derived from PROgramming in LOGic and emphasizes the derivation of the language from predicate logic.He is presently working on an Ada Simulation Support Environment (ASSE) and a Prolog based process oriented discrete event simulation system. Prolog is favored by the Japanese for their Fifth Generation Computer Systems. The paper consists of two parts: a survey of' the language Prolog and a description of T-Prolog, a Prolog based simulation language, using a process interaction approach.
Systems programming in concurrent prologConcurrent Prolog [28] combines the logic programming computation model with guarded-command indeterminacy and dataflow synchronization. This paper explores the feasibility of programming such a machine solely in Concurrent Prolog (in the absence of a lower-level programming language), by implementing in it a representative collection of systems programming problems.Abstract SYSTEMS PROGRAMMING IN CONCURRENT PROLOG Ehud Shapiro Department of Applied Mathematics The Weizmann Institute of Science Rehovot 76100, Israel 1. Will a machine that implements Concurrent Prolog in hardware or firmware be usable as a general-purpose, Concurrent Prolog [28] combines the logic programming computation model with guarded-command indeterminacy and dataflow synchronization. This paper explores the feasibility of programming such a machine solely in Concurrent Prolog (in the absence of a lower-level programming language), by implementing in it a representative collection of systems programming problems. 1.
"Test case generation using PrologA prototype version is currently implemented in Prolog. The knowledge base consists essentially of three parts: test case specifications of the various system calls, a test suite generator with predicates including information about UNIX system properties and sound test practices, and a test protocol archive including utilities to extract and prepare reports about the test results. All information in the knowledge base is stored as Horn clauses, i.e. facts and rules immediately to be consulted and executed by a Prolog interpreter.A prototype version is currently implemented in Prolog. The knowledge base consists essentially of three parts: test case specifications of the various system calls, a test suite generator with predicates including information about UNIX system properties and sound test practices, and a test protocol archive including utilities to extract and prepare reports about the test results. All information in the knowledge base is stored as Horn clauses, i.e. facts and rules immediately to be consulted and executed by a Prolog interpreter. 1) UNIX is a Trademark of Bell Laboratories. 1. The Prolog implementation chosen is IF/Prolog [LEIE841 4) because it is easily portable on any not too small UNIX and supports an interactive test environment which turns out exceedingly valuable when doing ""experimental"" prototyping work. 4."
A parallel Prolog: The construction of a data driven modelAn argument is presented for the implementation of a Prolog-like language using data driven execution, as a step towards the solution of the problems associated with multiprocessor machine architectures. To facilitate this, a number of changes and extensions to the execution control mechanism of Prolog have been implemented. Among the notable features of the system are the use of conditional AND (CAND) and conditional OR (COR) constructs to allow the programmer sequential control in the context of a parallel execution system, and mechanisms supporting dataflow execution within groups of parallel literals.Abstract An argument is presented for the implementation of a Prolog-like language using data driven execution, as a step towards the solution of the problems associated with multiprocessor machine architectures. To facilitate this, a number of changes and extensions to the execution control mechanism of Prolog have been implemented. Among the notable features of the system are the use of conditional AND (CAND) and conditional OR (COR) constructs to allow the programmer sequential control in the context of a parallel execution system, and mechanisms supporting dataflow execution within groups of parallel literals. To copy otherwise, or to republish, requires a fee and/or specific permission. © 1982 ACM0-89791-082-6/82/008/0056 $00.75 56 A PARALLEL PROLOG: the construction of a data driven model Michael J.
Prolog compared with LISPThis is a report on a very concrete experiment to compare the relative speeds of DEC-10 Prolog (Edinburgh implementation) and DEC-10 LISP (Texas implementation of UCI-LISP, or TLISP). Nevertheless, the results are interesting enough so as to make us consider them worth divulging, especially because they seem to contradict the notion, repeatedly argued for by Prolog advocates, that performances of the two languages are similar in relation to speed.PROLOG COMPARED Claudio Universidad This is a report on a very concrete periment to compare the relative exspeeds of DEC-10 Prolog (Edinburgh implementa tion) and DEC-10 LISP (Texas implementa tion of UCI-LISP, or TLISP). The following are some samples of claims that have been made about the similarity of performance between Prolog and LISP. DEC-10 compiled Prolog compares favourably with DEC-10 compiled LISP ... For simple functions over lists, Prolog is somwhat slower than Lisp (by a factor of about 0.6).
On eliminating loops in PrologRecent papers have explained how infinite loops in a Prolog search tree can be avoided by the use of subgoal deletion.On eliminating loops in Prolo g David Pool e Randy Goebe l Logic Programming and Artificial Intelligence Grou p Department of Computer Scienc e University of Waterlo o Waterloo, Ontario, Canada N2L 3G 1 Recent papers have explained how infinite loops in a Prolog search tree can b e avoided by the use of subgoal deletion . Introductio n It is relatively easy to generate infinite loops in Prolog, e .g ., the assertion s p(X) <- p(Y ) p ( a) , and the goal tp(a) , generate the infinite branc h p(a) X <- a p(Y)Y' <- Y p (Y ' ) Although the Prolog search space, defined by SLD resolution (e .g ., see [Lloyd 82]), is complete , Prolog 's depth first left-to-right search strategy is incomplete .
A direct execution PROLOG systemThis paper presents a direct execution PROLOG system. It does syntax check at token level and reports errors even before a clause is completed.A DIRECT EXECUTION PROLOG SYSTEM Loke-Soo Hsu* Department of information Systems and Computer Science National University of Singapore Singapore 0511 Republic of Singapore. CONTENTS ---we--- ----e--w This paper presents a direct executioin PROLOG system. It does syntax check at token level and reports errors even before a clause is completed. The Direct Execution Shell 3.1 The monitor 3.2 The input processor 3.3 The Text Editor 3.4 The File Processor 4. The PROLOG Subsys tern 4.1 The Syntax Analyser 4.2 The Unification Processor 4.3 The run-time System 5.
A static analysis of prolog programsA static analysis of Prolog programs was made for the purposes of revealing the behavior of Prolog programs and of getting useful information for system design. This analysis consists of two parts: one analyzes general aspects of Prolog programs, the other evaluates some compiler techniques which have a great deal of interest. This work has been done using a program written in Prolog, which collects data from test programs. This document summarizes the results of this static analysis.A Static AI --.8-- Analysis of Prolog Programs Hidekazu Matsumoto Applications institute, University of Edinburgh, Hope Park Square, Meadow Lane, Edinburgh, EH8 9NW U.K. ABSTRACT A static analysis of Prolog of revealing the behavior programs was made for the purposes of Prolog programs and of getting useful information for system design. one analyzes general aspects evaluates some compiler This analysis consists of two parts: of Prolog programs, the other techniques which have a great deal of interest. This work Prolog, which collects summarizes the results has been done using a program written in data from test programs.
Eliminating unwanted loops in PrologModifications to Prolog are proposed that make it possible to express transitive and symmetrical relations and biconditionals.Covingto n Advanced Computational Methods Cente r University of Georgi a Athens, Georgia 3060 2 ABSTRACT : Modifications to Prolog are propose d that make it possible to express transitiv e and symmetrical relations and biconditionals . This is done by blocking recursion under circumstances that would lead to infinite loops . Introductio n Consider the following Prolog program : [1] f(A) . [2] f(x) if f(x) . Not surprisingly, if we ask the computer for all values of x such tha t f(x)is true, we get the infinite sequence A, A, A . . ., obtained a s follows : [i] In f(x), instantiate x as A (Rule 1) . (Note that (B,D) is never generated - - this proves that Prolog is incomplete .) The derivations are : [i-iii] from Rules 1-3 directly .
A note on sorting Prolog assertionsIn Prolog programs, arguments are often used to exchange information between relations. They are typically managed by the addition and deletion of clauses. However, most of the Prolog implementations offer little support for these operations. In C-Prolog [1], for example, a clause can only be added as the first or last clause of a relation.McCorduck, Pamela, M_achines Who Think, Freeman & Co., San Francisco, 1979. A Note on Sorting Prolog Assertions C.S. Kwok Center of Computer Science and Applications Press, W.H. University of Hong Kong Pokfulam Road Hong Kong In Prolog programs, arguments are often used to exchange information between relations. In C-Prolog [1], for example, a clause can only be added as the first or last clause of a relation.
"Sequential Prolog machine: Image and host architecturesA modified version of D. Warren's sequential Prolog machine architecture is described. Data and instruction formats are given.1. Abstract SEQUENTIAL PROLOG MACHINE: IMAGE AND HOST ARCHITECTURES ""¢ Evan Tick Computer Systems Laboratory Stanford University, Stanford CA 94035 The paper consists of two parts. The first part reviews A modified version of D. Warren's sequential Prolog machine architecture 1 is described. Data and instruction formats are given. A sequential Prolog machine architecture described by D. Warren 1 is particularly amenable to implementation with a microcontrolled processor."
Describing Prolog by its interpretation and compilationSince its conception, Prolog has followed a developmental course similar to the early evolution of LISP. Although the version of Prolog described here typifies that currently in use, it should be considered within the framework of language evolution.DESCRIBING PROLOG BY ITS INTERPRETATION AND COMPILATION Since its conception, Prolog has followed a developmental course similar to the early evolution of LISP. Although the version of Prolog described here typifies that currently in use, it should be considered within the framework of language evolution. JACQUES COHEN Prolog is a language developed about 10 years ago by Alain Colmerauer and his coworkers at the Artificial Intelligence Group (GIA-Groupe d'lntelligence Artificielle) in Marseilles, France.
The prolog phenomenon
"Parsing free word order languages in PrologThe Prolog programming language allows the user to write powerful parsers in the form of metamorphosis grammars. However, the metamorhosis grammars, as defined by Colmerauer2, have to specify strictly the order of terminal and nonterminal symbols. A modification of Prolog has been implemented which allows ""floating terminals"" to be included in a metamorphosis grammar together with some information enabling to control the search for such a terminal in the unprocessed part of the input.PARSING FREE WORD ORDER LANGUAGES IN PROLOG ]anusz Stanistaw Biefi+ Krystyna Laus- Mczyrlska ++ S tanislaw Szpakowicz + • + Institute of Informatics, Warsaw, Poland Warsaw University ++Institute for Scientific Technical and Economic Information, Warsaw, Poland The Prolog programming language allows the user to write powerful parsers in the form of metamorphosis grammars. However, the metamorphosis grammars, as defined by Colmerauer 2 , have to specify strictly the order of terminal and nonterminal symbols. A modification of Prolog has been implemented which allows""floating terminals"" to be included in a metamorphosis grammar together with some information enabling to coritrol the search for such a terminal in the unprocessed part of the input. Their convenience is due to their straightforward relation to the programming language Prolog. A metamorphosis grammar is an ordinary part of a Prolog program."
"Beyond PROLOG: software specification by grammarI. Introduction -34-Beyond PROLOG: Software Specification by Grammar Walter W. Wilson The University of Texas at Arlington In the programming language PROLOG, specifying it in a form of logic one writes software by functionally [Bowen 79, Kowalski 79] This paper proposes a language similar to PROLOG in which software generates hierarchical expressions° is specified by a type of grammar that This language, which is called ""axiomatic language"", was developed with the following objectives: I. very high level -- It should be a formalism wit6 spi yg an implementation for functionally specifying software -- the programmer tells the computer what to do without telling it how to do it [Wulf 80]. since the implementatiodetails The programmer's task is simpfied are assumed by the (intelligent) language processor. A language with this property would be general purpose, yet would allow the programmer to define useful specialized applications. language constructs for particular PROLOG is a very high level language and is simple and extensible. This is claimed as its primary advantage over PROLOG. Section 2 defines axiomatic language as an abstract formal system and section 3 gives examples of its use and merits. interpreted, with programs defined Section 4 shows how this formal system is in a more nonprocedural manner than in PROLOG."
A further note on looping in PrologIn an earlier paper (Covington 1984) I proposed that looping in Prolog should be prevented by blocking all derivations in which the current goal matches a higher goal.Abstrac t In an earlier paper (Covington 1984) I proposed that looping i n Prolog should be prevented by blocking all derivations in whic h the current goal matches a higher goal . SIGPLAN Notices, V20 #$, August 1985 _2g _ Symmetric and transitive relations and biconditional implication s are common in human thought, and the inability to express the m successfully is a serious limitation of Prolog . In order t o handle them correctly, the Prolog inference engine should bloc k all the looping derivations, while allowing all other derivation s to proceed normally . Inadequacy of Algorithm Alph a Consider the following Prolog rule set : [i] s(a,b) . [2] s (b, c) . [3] s(c, d) . (4) s (x, y) if s (x, z) and s (z, y) .
How to define a language using PROLOGFor a complete definition of the syntax, attribute grammars are gaining increasing acceptance while more practically minded language designers will use one of the compiler definition languages such as Meta4 or CDL. At the same time as the PROLOG language was defined, a grammar system called Metamorphosis Grammar (M-grammar for short) was invented by Colmerauer (1978). This definition is not simply of theoretical interest. Since PROLOG is a practical programming language, though with a sound theoretical basis (Warren, Pereira, Pereira 1977), the definition can be used as a prototyping tool for a new language. With the addition of plan-formation techniques one might form a PROLOG based compiler generator and by adding other axioms form a program proving system.How to define a language using PROLOG Chris D. S. Moss * Dept. of Computing, Imperial College, 180 Queen's Gate, London S.W.7, England There have been many papers, conferlanguage. With the addition of planences and theses concerned with the of defining programming languages. twenty years after McCarthy's (1962) inal paper there is still no widely cepted method which will deal with task formation techniques one might form a Yet, PROLOG based compiler generator and by semadding other axioms form a program proving acsystem. all parts of a language clearly and concisely. Everyone who invents a language writes a PROLOG and M-Grammars BNF definition and the more theoretically minded will attempt a denotational semantics.
An easy implementation of PiL (Prolog in Lisp)Much attention has been drawn to Prolog, the implementation of logic as a programming language. The decision of the Japanese to use Prolog as the core language of the Fifth Generation Computer [Warren, 1982] has given rise to some concern that Prolog may emerge as the chief rival to Lisp in artificial intelligence programming. I [Wallace, 1983] and others [Robinson and Sibert, 1982, Komorowski, 1982] have argued the benefits of extending Lisp to do what Prolog does. Here I present a simple procedure for implementing Prolog in Lisp (PiL), in order to demonstrate that it is easy to extend Lisp to do what Prolog does.PiL Much attention has been drawn to Prolog, the implementation of logic as a programming language. The decision of the Japanese to use Prolog as the core language of the Fifth Generation Computer [Warren, 1982] has given rise to some concern that Prolog may emerge as the chief rival to Lisp in artificial intelligence programming. I [Wallace, 1983] and others [Robinson and Sibert, 1982, Komorowski, 1982] have argued the benefits of extending Lisp to do what Prolog does. Here I present a simple procedure for implementing Prolog in Lisp (PiL), in order to demonstrate that it is easy to extend Lisp to do what Prolog does. 2.
New approaches to parsing conjunctions using prologIt modifies the union of phrase marker model proposed by Goodall [1984], where conjunction is considered as the linearization of a three-dimensional union of a non-tree based phrase marker representation. A PROLOG grammar for conjunctions using this new approach is given.New Approaches to Parsing Conjunctions Using Prolog Sand,way Fong Robert C. Berwick Artificial hitelligence Laboratory M.I.T. 545 Technology Square C,'umbridge MA 02t39, U.S.A. The corresponding term for the modified definition (given in the next sectiou) is O(1). The Implementation in Prolog This section describes a runnable specification written in Prolog. In this section we will describe the cases corresponding to each Prolog clause necessary in the specification of [inearization.
An Executable Prolog SemanticsA Denotetional Semantics of the logic programming language Prolog is expressed in Algo1-68. The result is a formal definition that is also executable. Its declarative semantics are to be understood as first-order logic but Prolog implementations invariably include non-logical features for various reasons, notably for efficiency but As 5Op.H An Executable Prolog Semantics also to make some programs work at all. Lassez and Maher[12] give a denotetional definition much closer to the declarative interpretation of Prolog. Prolog. A very simple example is given here to illustrate some of Prolog.
The versatility of PROLOGBaxter Department of Computer Science York University Downsview, Ontario M3J IP3 PROLOG is a general purpose programming language based on predicate logic [I].
Compiling prolog programs for parallel execution on a cellular machineThis paper investigates features of a PROLOG compiler for Mago's cellular machine. The compiler generates parallel FFP (Formal Functional Programming) code. Hence high efficiency in the execution of PROLOG programs can be achieved on this machine, owing to the almost unbounded parallelism it can accommodate. An FFP representation of the run-time environment of PROLOG is given. It is based on a previously published FFP implementation of unification.COMPILING PROLOG PROGRAMS FOR PARALLEL EXECUTION ON A CELLULAR MACHINE Alexis Koster Information Systems Department San Diego State University Mago imago 1979, 1980] has described a machine Abstract This paper Investigates features of a PROLOG compiler for Mago's cellular machine. The compiler generates parallel FFP (Formal Functional Programming) code. Hence high efficiency in the execution of PROLOG programs can be achieved on this machine, owing to the almost unbounded parallelism it can accommodate. An FFP representation of the run-tlme environment of PROLOG is given. It is based on a previously published FFP implementation of unification.
PROLOG applications for database design with the information centerThe feasibility of PROLOG use on micropromputers and in the Information Center environment is examined. PROLOG is shown to be well suited for such use because of its simplicity and power. Different PROLOG applications on microcomputers are investigated.PROLOG APPLICATIONS FOR DATABASE DESIGN WITH THE INFORMATION (`ENTER Alexis Kost cr Information Systems Department Snn Diego State Uniuersi~y The feasibility of PROLOG use on micropromputers and in the lnformation Center environment is examined. PROLOG is shown to be well suited for such use because of its simplicity and power. Different PROLOG applications on microcomputers are investiga.ted.
"Alternative proposals for implementing Prolog concurrently and implications regarding their respective microarchitecturesProlog has become a subject of much discussion of late. A parallel variant is said to be the language of the Japanese 5th Generation Project. In this paper the standard Prolog language is defined and shown to be a restriction of Logic Programming. Several alternative schemes, which have been proposed for improving the performance of Prolog, are examined. Some schemes change the semantics of the language, these effects are discussed.Abstract ALTERNATIVE PROPOSALS FOR IMPLEMENTING PROLOG CONCURRENTLY AND IMPLICATIONS REGARDING THEIR RESPECTIVE MICROARCHITECTURES Carl G. The more complicated clause (I) states that if any {X,Y,Z} can be found satisfying ""G(X,Z),"" ""H(X,Y,Z),"" ""G(Z,a),"" ... then ""F(X,a,Y)"" is true for that particular X and Y. Dialect Logic Programming Sequential Prolog Table One: Overview Comparison of Proposed Prologs Search Resolution Strategy Tree Nondeterminism Fully evaluated Depth-First, Generated parallelizable depth-first Dado Depth-First AND levels, Breadth-First OR levels Epilog Breadth-First Priolog Adjustable AND/OR Multiple Model depth-first, goals reordered Concurrent Multiple, Prolog Depth-First, limited alternatives Parlog Depth-First Partially evaluated at OR levels, fully at AND levels Fully generated Fully generated Partially generated One chain from top to bottom One chain at AND levels, OR levels partially or fully generated Functions may also be used in the place of atoms. Specific Proposals We examine seven proposed parallel Prologs. These are grouped into three categories: Logic-Programming oriented, Prolog-Oriented, and Concurrent-Programming oriented."
Prolog technology as a basis for verification systemsProlog presents an interesting alternative technology to Lisp and Pascal-like languages for implementing verification systems. The AFFIRM Specification and Verification System has been partially re-implemented successfully in Prolog. Experiences and conjectures about the future role of Prolog are discussed.
"Playing Mastermind more logically or writing Prolog more efficientlyIn the last few issues of SIGART there have appeared (#82, 83 & 85) three articles on Mastermind programmes, the latest of which, by Ehud Shapiro [1], presents a PROLOG version of the best known algorithm for the oldest form of the game-Bull-cow. This paper presents some improvements to this programme and uses it as an example in making some general points about PROLOG. Shapiro's programme is simple and demonstrates the power of PROLOG for implementing a quick solution using a well understood algorithm.., ""Artificial Intelligence,"" Addison-Wes'ley Publishing Company, 1979. Playing Mastermind More Logically or Writing PROLOG More Efficiently David M. W. Powers Department of Computer Science University of New South Wales In the last few issues of SIGART there have appeared (#82, 83 & 85) three articles on Mastermind programmes, the latest of which, by Ehud Shapiro [I], presents a PROLOG version of the best known algorithm for the oldest form of the game bull-cow. Putting it another way, ease and efficiency of programme writing is a major plus of PROLOG, along with the brevity and readability of programmes. This is a very common deficiency PROLOG programmes which involve rules for in parsing or for algebraic manipulation."
A programming solution to certain problems with loops in PrologRepresenting transitive relations in the obvious way in Prolog results in unwanted loops. A programming solution to this problem is provided and limitations and possible extension of this solution to other looping problems is discussed.University of Georgi a Athens, Georgia 3060 2 ABSTRACT : Representing transitive relations in th e obvious way in Prolog results in unwanted loops . A programming solution to this problem is provided an d limitations and possible extension of this solution to other looping problems is discussed . Introductio n The logic programming language Prolog implements a piece of th e first order predicate calculus . In other words, Prolog is incomplete wit h respect to its underlying logic since it cannot make ever y response which the logic validates .
Experiments with Prolog design descriptions and tools in CAEDE: an iconic design environment for mutltitasking, embedded systemsWe report on experiments with Prolog design descriptions and tools in CAEDE (Carleton Embedded System Design Environment), an experimental, iconic design environment for multitasking, embedded systems. The iconic information is converted automatically into a Prolog design data base of facts and rules. CAEDE aims to support incremental design and to be incrementally extensible. The aim is to show how Prolog is contributing to the framework of a powerful, extensible design environment.EXPERIMENTS WITH PROLOG DESIGN DESCRIPTIONS AND TOOLS IN CAEDE: AN ICONIC DESIGN ENVIRONMENT FOR MULTITASKING, EMBEDDED SYSTEMS R.J.A. Lewis Department of Systems and Computer Engineering, Carleton University, Ottawa, Ontario, CANADA KlS5B6 ABslRAcr We report on experiments with Prolog design descriptions and tools in CAEDE (Carleton Embedded System Design Environment), an experimental, iconic design environment for multitasking, embedded systems. The iconic information is converted automatically into a Prolog design data base of facts and rules. CAEDE aims to support incrementi design and to be incrementally extensible.
A comparison of Lisp, Prolog, and Ada programming productivity in AI areaAn experiment comparing programming productivity of Lisp, Prolog, and Ada used in the AI (Artificial Intelligence) area is reported. Lisp and Prolog have been the main languages used for AI programming because of their symbol manipulation and list processing facilities. In the experiment, several AI software components are programmed in three languages: Lisp, Prolog, and Ada, and the languages' effects on programming productivity are examined.A comPABIson OF LISP. PROLOG. AIID ADA* PRotsRAmmInG PRODUCTIVITY In AI AREA F. WASAn IlTT Yokosuka Electrical Communication Laboratories l-2356 Take, Yokosuka, 238-03 JAPAIl An experiment comparing programming productivity of Lisp, Prolog. and Ada used in the AI (Artificial Intelligence1 area is reported. Lisp and Prolog have been the main languages used for AI programming because of their symbol manipulation and list processing facilities.
"An optimizing prolog front-end to a relational query systemAn optimizing translation mechanism for the dynamic interaction between a logic-based expert system written in PROLOG and a relational database accessible through SQL is presented.An Op t i m i z i n g Prolog Fr o n t - E nd to a Re l a t i o n a l Query S y stem Matthias Jarke, Jim Clifford, and Yann i s V assiliou Graduate School of Business Administration N e w Y o r k University 90 Trinity Place, New York, N.Y. 10006 An optimizing translation mechanism for the dynamic interaction between a logic-based expert system written in PROLOG and a relational database accessible through SQL is presented. After a definition of the DBCL subset to be used in this paper in section 3"" section 4 briefly reviews the translation process from PROLOG to DBCL. The DBCL-SQL translation has been implemented in PROLOG using a syntax tree mapping approach (section 5). The central idea involves the introduction of an intermediate language of database calls (DBCL), which is set-oriented and uses base relations but is still expressed in PROLOG (to be precise: in a variable-free subset of PROLOG)."
"Transaction restarts in Prolog database systemsTransaction Restarts in Prolog Database Systems Shridhar Acharya Gael Buckley Department of Computer Science State Unlverslty of New York Stony Brook, NY 11794 This paper considers the problem of transaction restarts m a database system When a transactlon cannot be completed, most concurrency control mechanisms abort the transaction and reelecute the entlre transaction We propose an alternate scheme that allows a transaction to restart from an mtermedlate state Restarting a falled transactlon from an intermediate state can result m Tubstantlal reduction of unnecessary computation which would be done if the entlre transaction were reexecuted We mtroduce a notion of state and consistent state of a transaction, and present a scheme that restarts tranqactlons from consistent Intermediate states A Implementntlon of the scheme usmg Prolog as the query language 15 presented 1. mg database problems Prolog execution uses bachtrackmg, and hence relies on mechamqms that save intermediate states of the computation We show that the same mechamsms can be adapted and used to restart transactlons from mtermedlate consistent states We use two different concurrency controls to illustrate how a transactlon which 1s aborted due to nonserlahzablhty can be restarted from some intermediate state, thus avoiding the need to redo slgmficant valid computation There are several myor approaches to concurrencv control, including locking schemes[3, 11, 141, timestamp schemes(TS) 12, 8) and optlmlstlc schemes [l, 6, S] Optlmlstlc schemes allow unrestricted access to the database during the execution of transactions, and rhech for serlahzablhty only when a transaction completes Hence, such schemes have no locbmg and deadlock detection overhead and, if conflicts are rare, allow a large number of transactions to run concurrently [5] These characteristics provide two maJor reasons why we devote our myor Interest m this paper to adapting Prolog mechamrms to optlmlstlc concurrency control for two reasons First, It seems a good choice when dealing with such systems as expert systems, which are query dommant and have complex searches In this case, the slight overhead incurred 1s more than compensated by the savings to avoid recomputing states Second, the optlmlstlc concurrency control scheme uyeq Prolog mechanisms for concurrency which simple locking schemes cannot take advantage of, as IS illustrated m a later section The rest of the paper 1s organized as follows We present an overview of the Prolog state maintenance mechanisms m section 2 In Section 3 we describe optlmlstlc concurrency control schemes m detail, define a consistent state of a transaction, and give the restart algorithm Section 4 contains how the restart algorithm can be used rn Prolog qystems, and m Section 5 we present the modlficatlons needed m the Prolog mechanisms to accommodate our scheme Section 6 outlmes the overheads involved m our Implementation, and m Section 7 we briefly discuss additional research areas 2. Prolog In this section we mformally explain the Prolog execution strategy The Implementatlon of our transactlon restart scheme uses existing mechamsms of Prolog systems, and requires some knowledge of the behavior of Prolog lmplementatlons We begin by briefly describing the pertinent aspects of such prolog Implementations, which are described m detail m (121 Database prolog IS similar to ordinary prolog except that the facts are stored m a relational database Users can have their own set of facts as well as access the facts m the database In the dlscusslon that follows we assume, for the sake of slmphclty, that all the facts are stored m the database To avoid dlscussmg Prolog execution m detail, we present an example whhtch uses the mechanisms we will alter for the concurrency control algorithm, and that can also be easily read as a logical query with mmlmal reference to exact Prolog execution Consider an environment where a supervisor wishes to fire anyone who does not produce adequately and has been on the Job for less than 2 years We execute this query on the datdbaqe glben m Example 1 Example 1 1 notprod - poorworker(X),longlunch(X) 2 notprod - dbqPnt(X,Z), Z > 39 3 poorlcorher(hlark) 4 absent(Irma,40) 5 employ ed(Marh,l 5) 6 emplo> ed(Irma,l 5) Rules 1 and 2 m Example I can be rend as the conJunction of subgoals on the right side of the "" -"" notation implies the left side The left side IS called the head of the rule and the right side the body Hence, this database states that X does not produce adequately if X IS a poor worker and takes a long lunch (by rule l), or If X IS absent more than 39 (days, presumably), bv rule 2 Rules 3 through 6 are tuples of relations, or facts, about the employees Mark and Irma Whenever more than one rule has a head which matches the same goal, the execution faces different alternatives Prolog uses a depth first search combined with backtracking to find all the alternatives The execution of example 1 will explain the Prolog execution strategy Let the goal be to find the employees who don't produce enough and have been with the company for less than 2 years This can be stated as - notprod(X),employed(X,Y),Y < 2, where each predlcate to be solved IS referred to s a eubgoal A subgoal IS solved by placing an activation record for It m the stack and applying a rule whose head matches the subgoal Since the goal statement is a conJunctIon of subgoals, the system first tries to solve the left most subgoal and, only If that succeeds, does It try to solve the rest of the subgoal3 In our example, notprod can be solved by either rule 1 or rule 2, which are termed avahble procedures, denoted by av Prolog systems apply these m order of appearance, and so an actlvatlon record for notprod 1s placed on the stach, rule 1 IS selected to solve notprod( notprod 1s replaced by the body of rule 1, and the new goal statement becomes - poorworher(X), longlunch(X),employed(X,Y),Y c 2 The system continues the above process of applymg rules to the left most subgoal qnd producing a new goal statement, until the goal qtatement becomes empty The only way that the goal statrmrnt can become empty IS when the apphcd protrdurrs are facts In this example the near goal ~tatrnwnt has poorworher(X) solted by rule 3, and X gets bound to Mark Since rule 3 IS a fact the new goal"
Compiling Prolog into microcode: a case study using the NCR/32-000A proven method of obtaining high performance for Prolog programs is to first translate them into the instruction set of Warren's Abstract Machine, or W-code [1]. This paper describes one of them:- the compilation of W-code directly into the vertical microcode of a general purpose host processor, the NCR/32-000. The result is the fastest functioning Prolog system known to the authors. We describe the implementation, provide benchmark measurements, and analyze our results.Compiling Prolog Into Microcode: A Case Study Using the NCR/32-000 Barry Fugin Yale Patt Vason Srini Alvin Despain Division of Computer Science University of California Berkeley, CA 94720 A proven method of obtaining high performance for Prolog programs is to first translate them into the instruction set of Warren's Abstract Machine, or W-code [l]. This paper describes one of them:- the compilation of W-code directly into the vertical microcode of a general purpose host processor, the NCR/32-000. The result is the fastest functioning Prolog system known to the authors. We describe the implementation, provide benchmark measurements, and analyze our results. 1. Introduction Substantial current interest in the high performance execution of Prolog programs demands investigation into the various alternative models of execution.
Specification and verification of distributed systems using prolog interpreted petri nets.The basic choices concern Petri Nets as a modeling tool and PROLOG as a programming environment. The key elements of the introduced approach are a symbolic interpreter for Predicate Transition Nets, and a technique for interfacing concurrent processes.SPECIFICATION AND VERIFICATION OF DISTRIBUTED SYSTEMS USING PROLOG INTERPRETED PETRI NETS. Pierre AZEMA Guy JUANOLE Eric SANCHIS Michel MONTBERNARD. The basic choices concern Petri Nets as a modeling tool and PROLOG as a programming environment. The key elements of the introduced approach are a symbolic i n t e r p r e t e r f o r Predicate Transition Nets, and a technique for i n t e r f a c i n g concurrent processes. The main contribution of t h i s paper concerns the development of a symbolic i n t e r p r e t e r written in PROLOG, associated with a specific model for i n t e r f a c i n g distant processes.
The design and implementation of a flexible retrieval language for a Prolog database systemThis paper describes the design and implementation of a data retrieval language for a Prolog-based database system. The language itself is implemented in Prolog, and it forms part of a more comprehensive project to build an intelligent database system which incorporates deductive capabilities, enforcement of integrity constraints, and automatic normalisation. Although the language is not relational complete, actual user experience indicate that it is much more powerful than the native Prolog query interface, and it provides a versatile enhancement to the database capability of Prolog.The Design and Implementation of a Flexibl e Retrieval Language for a Prolog Database System C . Hornsby and C .H .C . Leun g Department of Computer Scienc e University College Londo n Gower Stree t London WC1E 6B T Abstract . This paper describes the design and implementation of a data retrieval language for a Prolog-based database system . Th e language itself is implemented in Prolog, and it forms part of a more comprehensive project to build an intelligent database syste m which incorporates deductive capabilities, enforcement of integrit y constraints, and automatic normalisation . Although the language i s not relational complete, actual user experience indicate that it i s much more powerful than the native Prolog query interface, and i t provides a versatile enhancement to the database capability o f Prolog . 1 .
Performance studies of a Prolog machine architecturePERFORMANCE STUDIES of a PROLOG MACHINE ARCHITECTURE T. P. Dobry A. M. Despain Y. Patt Computer Science Division University of California,Berkeley Berkeley, California 94720 Abstract The PLM is a co-processor architecture designed for efficient execution of Prolog programs. the It is the first prototype of a logic processor for our 2. It is compiled prior to execution from PROLOG or other high-level, logicprogramming languages.
Connecting prolog with relational databases
Design of a high-speed Prolog machine (HPM)Design of a High-speed Prolog Machine (HPM) Ryosei Nakazaki(), Akihiko Konagaya(}, Shin'ichi Habata(), Hideo Shimazu(}, Mamoru Umemura{*}, Masahiro Yamamoto(*), Minoru Yokota/**} and Takashi Chikayamall I*) CgC Systems Research Laboratories, NEC 4-i-1 Miyazaki iyamae-ku, Kawasaki (**} ICOT Research Center Institute for New Corporation, 213, Japan Generation ComputerTechnology, Mita Kokusai Bldg. 21F, 4-28 Mita l-chome, inato-ku, Tokyo 108, Japan ABSTRACT This paper describes a High-speed Prolog Machine (HIM) architecture and its hardware structure, which are developed as a product of Fifth Generation Computer System (FGCS} project in Japan. Realizing a Prolog programming environment on the Prolog machine is also very important for developing practical application programs. A High-speed Prolog Machine (HPM) is designed to satisfy these goals.
Efficient Prolog access to CODAYSL and FDM databasesEFFICIENT PROLOG ACCESS TO CODASYL AND FDfl DATABASES P. M. D. Gray Dept of Computing Science* University of Aberdeen, KIngIs College, ABERDEEN AB9 2UB. A method 1s proposed for accessing Codasyl and Functional Data Ho de1 databases from Prolog. It uses tokens or references to ObJects as values, instead of the more usual method of using relational attributes as values. This pa per explores an alternative method which allows access to a wider range of databases than purely relational ones. It represents n-ary relations by Prolog cl auses that are written in terms of predicates referencing surrogate keys.
A prolog implementation of lexical functional grammar as a base for a natural language processing systemThe paper consists of three sections:(1) We give a detailed description of the PROLOG - implementation of the parser which is based on the theory of lexical functional grammar (LFG). This universal interpretation of the LFG-metavariables ↑ and ↓ corresponds to the universal quantification of variables appearing in PROLOG-clauses. The procedural semantics of PROLOG is such that the instantiation of the variables in a clause is inherited from the instantiation given by its subgoals, if they succeed. -there is a canonical way of translating LFG into a PROLOG programme.(II) For the semantic representation of texts we use the Discourse Representation Theory developped by Hans Kamp.ABSIRACr ne aim of this paper is to present parts of our system A PROLOG IMPLEMENTATION OF LEXICAL FUNCTIONAL GRAMMAR AS A BASE FOR A NATURAL LANGUAGE PROCESSING SYSTEM Werner Frey and Uwe Reyle Department of Llngulstlcs University of Stuttgart W-Germany transportion of information. The paper consists of three sections: (I) We give a detailed description of the PROLOG implementation of the parser which is based on the theory of lexical functional grammar (I/V.). -there is a canonical way of translati LFG into a PROLOG progz,. (II) For the sentic representation of texts we use the Discourse Representation q]neory developped by Psns [,ap.
Design decisions influencing the microarchitecture for a Prolog machineDESIGN DECISIONS INFLUENCING the MICROARCHITECTURE for a PROLOG MACHINE T. P. Dobry Y. N. Patt A. M. Despain Computer Science Division University of California,Berkeley Berkeley, California 94720 Abstract The PLM-1 is the first step in the hardware implementation of a heterogeneous MIMD processor for logic programming. Our first prototype (PLM-1), being built now, is an attached sequential coprocessor for executing compiled Prolog. Our design is based on an abstract instruction set initially described by Warren[10]. Data Types There are four data types in Prolog. They have the format shown in Figure I. Two primary tag bits, and a cdr-bit described below identify the data type.
Databases, Prolog, and Rule-Based Systems (Session Overview)
Computer-Assisted Circuit Evaluation in PROLOG for VLSI
Database Management, Knowledge Base Management, and Expert System Development in PROLOG
Automatic Classification of Office Documents by Coupling Relational Data Bases and PROLOG Expert Systems
"Review of ""Programming in PROLOG"" by W. F. Clocksin and C. S. Mellish. Springer-Verlag 1981."
Partial evaluation as a means for inferencing data structures in an applicative language: a theory and implementation in the case of prologAn operational semantics of the Prolog programming language is introduced. Meta-IV is used to specify the semantics. One purpose of the work is to provide a specification of an implementation of a Prolog interpreter. Another one is an application of this specification to a formal description of program optimization techniques based on the principle of partial evaluation. The theoretical investigation is then shortly related to research in rule-based systems and logic.An efficient well-integrated partial evaluation system is available in Qlog --- a Lisp programming environment for Prolog.PARTIAL EVALUATION AS A MEANS FOR INFERENCING DATA STRUCTURES IN AN APPLICATIVE LANGUAGE: A THEORY AND IMPLEMENTATION IN THE CASE OF PROLOG H. Jan Komorowski Software Systems Research Center Linktsping University S-581 83 LinkUping, Sweden The growing interest in applicative languages programming An operational semantics of the Prolog programming language is introduced. One purpose of the work is to provide a specfication of an implementation of a Prolog interpreter. Another one is an application of this specification to a formal description of program optimization techniques based on the principle of partial evaluation. In this paper we investigate partial evaluation of Prolog programs as a part of a theory of interactive, incremental programming.
On executable models for rule-based prototypingThe main example is an executable model of a backtracking Prolog interpreter, which is specified using five transition rules adapted from the formal-semantic literature. All models in the paper are executable and written in Prolog, minimal familiarity with Prolog is assumed.The main example is an executable model of a backtracking Prolog interpreter, which is specified using five transition rules adapted from the formal-semantic literature. All models in the paper are executable and written in Prolog: minimal familiarity with Prolog is assumed. Keywords executable specifications, rapid prototyping, formal specifications, state-transition system, Prolog, operational semantics of Prolog 1. Section 4 presents a larger example, an interpreter for a significant subset of Prolog. The interpreter is specified using five state-transition rules adapted from a formal operational-semantic model of Prolog in [Jones&Mycroft84].
"TAO: a harmonic mean of Lisp, Prolog and SmalltalkTAO -•-- A harmonic mean of Lisp, Prolog and Smalltal k Ikuo Takeuchi, Hiroshi Okuno, and Nobuyasu Ohsat o Musashino Electrical Communication Laborator y Nippon Telegraph and Telephone Public Corporatio n 3-9-11, Midoricho, Musashino, Tokyo, Japan 18 0 Introductio n This paper presents a new language, TAO, designed for an intelligent tota l programming system called NUE (New Unified Environment) . Though TAO looks lik e another newcomer of Lisp dialects at a glance, it takes in features of Prolog [1] , Smalltalk [2] and even Fortran . Indeed, TAO unifies procedural and functiona l programming with logic programming and object oriented programming in the contex t of Lisp's s-expression . TAO is a ""harmonic"" mean of Lisp, Prolog and Smalltalk i n the sense : 3 TAO = • ° 1 1 Lisp Prolog 1 Smalltal k instead of a simple arithmetic mean : Lisp + Prolog + Smalltal k TAO = 3 1."
Logic enhancement: A method for extending logic programming languagesWith experience, several problems with the most popular such language, Prolog, have come to light. Several proposals for changes and extensions to Prolog have been made, but proposals have been expensive to build and evaluate. An inexpensive method for extension is described that relies on preprocessors and checkers written in Prolog itself. The method is efficient and applies to any logic programming language that permits manipulation of programs as objects.With experience, several problems with the most popular such language, Prolog, have come to light. Several proposals for changes and extensions to Prolog have been made, but proposals have been expensive to build and evaluate. An inexpensive method for extension is described that relies on preprocessors and checkers written in Prolog itself. The method is efficient and applies to any logic programming language that permits manipulation of programs as objects. Prolog's advantages include built in pattern matching, backtracking and flexible use of parameters as input and output variables.
A logic interpreter to handle time and negation in logic data basesThese ideas have been realized in an extension to the query language Query-By-Example, which has been implemented in the logic programming language Prolog.These ideas have been realized in an extension to the query language 0uery-By-Example, language Prolog. which has been implemented in the logic programming key words: Logic Data Base, Query-By-Example, Assumption, Prolog. 1. Introduction The importance of logic programming and languages such as Prolog (Roussel (I), Warren (2)) for the next generation computer systems has been recog nized in various quarters. The relational data model (Codd (4)) was chosen as the working data base model due to its affinity to the subset of predicate logic known as the Horn clausal form of predicate Logic, o£ which the programming language Prolog is a qualified realisation. One of the problems addressed in this paper is that ofrepresenting temporal knowledge and temporal reasoning.
Horn clauses and the fixpoint query hierarchyDavid Hare1 t The Weizmann Institute of Science Rehovot. Israel. Keywords: Horn clause, Logic program, PROLOG, Query language, Relational data base. A logic program consists of a set of Horn clauses, and can be used to express a query on relational data bases. This approach forms the basis for the programming language PROLOG [RI (see also [CCP] for an extended bibliography). How to solve it IW [El [=I [GM1 WI PI WI [RI with PROLOG. Report, Laborat6rio National de Engen haria Civil, Ministtrio da Habitacao e Obras Publicas, Lisbon (19X0).
An environment for logic programmingWe describe a programming environment for Prolog, a common logic programming language. The services offered by our system assist a Prolog user in the tasks of composing, editing, and storing logic (rule-based) programs, as well as in the control of their execution for debugging purposes. In order to facilitate effective debugging of Prolog programs, we propose a new model of computation that can handle both pure Prolog and impure (side-effect causing) Prolog operations quite gracefully. We also describe a Prolog oriented editor with which the user may easily create and update Prolog source programs and, further, inspect states of computation as generated by the debugger.Pinter Michael Tiomkin Shalom Tsur,t IBM Israel Scientific Center Technion Ci Haifa 32 000 ISRAEL Abstract. We describe a programming environment for Prolog, a common logic programming language. The services offered by our system assist a Prolog user in the tasks of composing, editing, and storing logic (rule-based) programs, as well as in the control of their execution for debugging purposes. In order to facilitate effective debugging of Prolog programs, we propose a new model of computation that can handle both pure Prolog and impure (sideeffect causing) Prolog operations quite gracefully. We also describe a Prolog oriented editor with which the user may easily create and update Prolog source programs and, further, inspect states of computation as generated by the debugger. t main affiliation: Computer Science Department, Technion, Haifa, Israel.
A technique for prototyping directly from a specificationThe technique uses the logic programming language Prolog and involves translating the specification into a Prolog form. This is used in conjunction with a set of functions, also written in Prolog, which provide an operational interpretation of the semantics of the specification language, and a user interface which allows the user to exercise the specification and examine its behaviour.The technique uses the logic programming language Prolog and involves translating the specification into a Prolog form. This is used in conjunction with a set of functions, also written in Prolog, which provide an operational interpretation of the semantics of the specification language, and a user interface which allows the user to exercise the specification and examine its behaviour. 1 INTRODUCTION Advances in rapid prototyping 111 have increased the awareness of the software industry to the possible benefits to be gained from the use of prototyping. The Prolog form of the specification does not constitute an executable prototype by itself.
"An efficient easily adaptable system for interpreting natural language queriesChat-80 has been designed to be both efficient and easily adaptable to a variety of applications. The system is implemented entirely in Prolog, a programming language based on logic. With the aid of a logic-based grammar formalism called extraposition grammars, Chat-80 translates English questions into the Prolog subset of logic. The resulting logical expression is then transformed by a planning algorithm into efficient Prolog, cf. ""query optimisation"" in a relational database. Finally, the Prolog form is executed to yield the answer. On a domain of world geography, most questions within the English subset are answered in well under one second, including relatively complex queries.Chat-80 has been designed to be both efficient and easily adaptable to a variety of applications. programming language based on logic. The system is implemented entirely in Prolog, a With the aid of a logic-based grammar formalism called extraposition grammars, Chat-80 translates English questions into the Prolog subset of logic. The resulting logical expression is then transformed by a planning algorithm into efficient Prolog, cf. ""query optimisation"" in a relational database. Finally, the Prolog form is executed to yield the answer. On a domain of world geography, most questions within the English subset are answered in well under one second, including relatively complex queries. 1."
TABLOG: The deductive-tableau programming languageTABLOG (Tableau Logic Programming Language) is a language combining functional and logic programming using first-order (quantifier-free) predicate logic with equality. TABLOG incorporates advantages of LISP and PROLOG. A program in TABLOG is a list of formulas in a first-order logic (including equality, negation, and equivalence) that is more general and more expressive than PROLOG'S Horn clauses. Whereas PROLOG programs must be relational, TABLOG programs may define either relations or functions.Abstract TABLOG: The Deductive-Tableau Programming Language Yonathan Malachi Zohar Manna Computer Science Department Stanford University Richard Waldinger Artificial Intelligence Center SRI International TABLOG employs the Manna-Waldinger deductivetableau proof system as an interpreter in the same way TABLOG (Tableau Logic Programming Language) is a language combining functional and logic programming using first-order (quantifier-free) predicate logic with equality. TABLOG incorporates advantages of LISP and PROLOG. A program in TABLOG is a list of formulas in a firstorder logic (including equality, negation, and equivalence) that is more general and more expressive than PROLOG'S Horn clauses. Whereas PROLOG programs must be relational, TABLOG programs may define either relations or functions. The is construct is used in PROLOG to force the evaluation of an arithmetic expression.
An overview and example of application of CAEDE: a new, experimental design environment for AdaThe design data base is automatically represented in Prolog and the majority of the design tools are written in Prolog. This paper describes both the ideas behind CAEDE and an example of a CAEDE tools written in Prolog for representing and analyzing the temporal behaviour of Ada tasking designs, without having to program them in Ada first.The design data base is automatically represented in Prolog and the majority of the design tools are writ. ten in Prolog. This paper describes both the ideas behind CAEDE and an example of a CAEDE tool written in Prolog for representing and analyzing the temporal behaviour of Ada tasking designs, without having to program them in Ada first. The design data base is automatically represented in Prolog and the majority of the design tools are written in Prolog (Buhr et. al., 1985).
Using λ-calculus to represent meanings in logic grammarsThis paper describes how meanings are represented in a semantic grammar for a fragment of English in the logic programming language Prolog. The conventions of Definite Clause Grammars are used. The second section describes how λ-calculus meaning representations can be constructed and manipulated directly in Prolog. This 'programmed' representation motivates a suggestion, discussed in the third section, for an extension to Prolog so that the language itself would include a mechanism for handling the λ-formulas directly.USING %-CALCULUS TO REPRESENT MFkNINGS IN LOGIC GRAMMARS* David Scott Warren Computer Science Department SUNY at Stony Brook Stony Brook, NY 11794 ABSTRACT This paper descrlbes how meanings are represented in a semantic grammar for a fragment of English in the logic programming language Prolog. The conventions of Definite Clause Grammars are used. The first section discusses general issues concerning the use of first-order logic or the h-calculus to represent meanings, The second section describes how h-calculus meaning representations can be constructed and manipulated directly in Prolog. This 'programmed' representation motivates a suggestion, discussed in the third section, for an extension to Prolog so that the language itself would include a mechanism for handling the -formulas directly. This is clearly and explicitly the program used in Montague grammar. It is also the program used in Prolog-based natural language grammars with a semantic component, the Prolog language itself essentially forces this methodology.
An overview of the HORNE logic programming systemHORNE is a PROLOG-based logic-programming system embedded in LISP. After a brief overview of the basic system, this paper highlights those aspects of HORNE that differ from more conventional PROLOG systems. We assume that the reader is familiar with the rudiments of PROLOG and LISP.Mien Mark Giuliano December 1982 Computer Science Department The University of Rochester Rochester, New York 14627 INTRODUCTION HORNE is a PROLOG-based logic-programming system embedded in LISP. After a brief overview of the basic system, this paper highlights those aspects of HORNE that differ from more conventional PROLOG systems. We assume that the reader is familiar with the rudiments of PROLOG and LISP. All of these facilities are implemented as LISP functions. The HORNE interpreter is a traditional PROLOG-style LUSH resolution theorem prover, also implemented as a LISP function.
Advanced programming aids in PROGRAPHIn particular, the PROGRAPH editor/interpreter is described, which allows prographs to be simultaneously constructed and executed, using sophisticated graphics in interactions with the user. The micro-PROLOG implementation of the editor/interpreter is described, and the reasons are discussed for choosing Prolog as the implementation language for PROGRAPH on small computers.Pietrzykowski Technical University of Nova Scotia CANADA The graphical functional language PROGRAPH is briefly described, followed by a more extensive discussion of prograph development facilities. in particular, the PROGRAPH editor/interpreter is described, which allows prographs to be simultaneously constructed and executed, using sophisticated graphics in interactions with the user. The micro-PROLOG implementation of the editor/interpreter is described, and the reasons are discussed for choosing Prolog as the implementation language for PROGRAPH on small computers. The current implementation of PROGRAPH is written in micr'o-PROLOG [83, which is available on a variety of microcomputers, and has been reported in preliminary form in [4,53. This program interacts with the user via the screen, keyboard and mouse, translating the graphical structures that the user builds into a Prolog structure. It allows the user to develop, and at the same time test prographs.
"Mastering Master Mind logicallySome readers of the recent note by Ehud Shapiro on ""Playing Master Mind Logically"" (SIGART 85, July 1983) may reasonably have concluded that Prolog was a suitable language for a ""generate and test"" strategy, as the author stated, but that perhaps there was something intrinsic to Prolog that made anything much more subtle unwieldy.THE PROGRAM: FIRST CUT The main program, written in micro-Prolog and presented here in micro-Prolog's internal syntax (see below), closely follows Ehud Shapiro's. One may venture to predict however, that it will be without the assistance of a computer that the secrets of M(m,n), the maximum number of guesses required to ascertain an answer using an optimal strategy, will be unlocked. A NOTE ON THE MICRO-PROLOG IMPLEMENTATION All the capitalized predicate names apart from TRUE are standard in micro-Prolog. "", 2. a relation ""name(argl, ar 2,...)"" is represented in internal syntax simply as a micro-Prolog list: (name argl arg 2...), 3. the list-constructor character is J."
An informal overview of CADA: a design environment for AdaThe design data base and the majority of the design tools are written in Prolog. The use of Prolog facilitates the incremental addition of design tools. A skeleton version of CADA was demonstrated in September 84, showing the use of graphics to capture the logical structure of the system under design in a Prolog design data base and the generation from this design data base of partial Ada source code for the system under design.Its claim to being a design environment arises from its integration of (I) a design methodology, (2) a design entry system (graphical paradigms), design tools, for evaluation, data base and the majority (3) a design data base, and (4) analysis and output. The design of the design tools are written in Prolog. The use of Prolog facilitates design tools. The environment the incremental addition of facilitates the incremental development and analysis of designs. was demonstrated in September 84, A skeleton version of CADA showing the use of graphics to capture the logical structure of the system under design in a Prolog design data base and the generation from this design data base of partial Ada source code for the system under design. This skeleton version demonstrated the use of graphics to capture IV,5-49 :he logical structure of the system under design in a Prolog lesign data base and the generation )artial Ada source code for the significant points to note about from this design data base of system under design. Both of these functions can be encompassed Prolog language - because within a single framework - the of the uniform way in which Prolog represents both data and operations confers a number of advantages, on data.
The architecture of the hardware unification unit and an implementationThe HUU performs the literal unification operation in Prolog processing. It is designed as a coprocessor to a host system that handles other operations of Prolog processing such as bookkeeping and sequencing.The HUU performs the literal unification operation in Prolog processing. It is designed as a coprocessor to a host system that handles other operations of Prolog processing such as bookkeeping and sequencing. Introduction The unification operation is known to be one of the fundamental operations of Prolog processing. It is also known that the unification operation takes 60- 70% of the total query processing time in a typical Prolog interpreter [l]. Therefore, one way to increase the performance of Prolog processing is to reduce the time taken by the unification operation.
Formal specifications for modeling and developing human/computer interfacesThis paper describes the nature of the formal specifications written in first order logic using Prolog, and the successful specification and development of a carrier air traffic controller (CATC) dialogue. These experiments demonstrate the utility of Prolog as a high level specification language and point the way to a full dialogue development system that can incorporate a multi-layered concept of human/computer interaction.This paper describes the nature of the formal specifications written in first order logic using Prolog, and the successful specification and development of a carrier air traffic controller (CATC) dialogue. These experiments demonstrate the utility of Prolog as a high level specification language and point the way to a full dialogue development system that can incorporate a multi-layered concept of human/ computer interaction. Rule-based languages such as Prolog allow users to add new rules or replace rules to change a program or interface specification.
"Compiling the graphical functional language PROGRAPHThese applications require higher level declarative languages such as Lisp and Prolog. A brief description is given of the functional language PROGRAPH, which overcomes some of the shortcomings of Lisp by replacing the usual textual representation of programs by pictures called ""prographs"". An abstract machine is defined having an architecture similar to most conventional computers, and suitable as a target machine for compiling prographs. An outline is given of an implementation in Prolog of a PROGRAPH compiler, based on this abstract machine.These applications reauire higher level declarative languages such as Lisp and Prolog. A brief description is given of the functional language PROGRAPH, which overcomes some of the shortcomings of Lisp by replacing the usual textual representation of programs by pictures called ""prographs"". An abstract machine is defined having an architecture similar to most conventional computers, and suitable as a target machine for compiling prographs. An outline is given of an implementation in Prolog of a PROGRAPH compiler, based on this abstract machine. The current version of PROGRAPH, of which the compiler is a part, is implemented in micro-PROLOG CSI, which IS available on several microcomputers."
Logic programming in APLTo be true, the assertion has to be based upon fact or upon an inference derived from facts. This paper describes an implementation of a PROLOG-like language in APL. The intent is to achieve logic programming capability while retaining the full facility of APL. PROLOG is both an extension of LISP, thereby satisfying the needs of the Artificial Intelligence community, and a language for relational databases.To be true, the assertion has to be based upon fact or upon an inference derived from facts. This paper describes an implementation of a PROLOG-Iike language in APL. The intent is to achieve logic programming capability while retaining the full facility of APL. PROLOG is both an extension of LISP, thereby satisfying the needs of the Artificial Intelligence community, and a language for relational data bases. PROLOG was selected as the model or base from which to proceed.
Treating coordination in logic grammarsLogic grammars are grammars expressible in predicate logic. Implemented in the programming language Prolog, logic grammar systems have proved to be a good basis for natural language processing. This paper describes a logic grammar formalism, modifier structure grammars (MSGs), together with an interpreter written in Prolog, which can handle coordination (and other natural language constructions) in a reasonable and general way.McCord 2 Computer Science Department University of Kentucky Lexington, KY 40506 Logic grammars are grammars expressible in predicate logic. Implemented in the programming language Prolog, logic grammar systems have proved to be a good basis for natural language processing. This paper describes a logic grammar formalism, modifier structure grammars (MSGs), together with an interpreter written in Prolog, which can handle coordination (and other natural language constructions) in a reasonable and general way. In natural language processing, useful grammar formalisms have been developed and incorporated in Prolog: metamorphosis grammars, due to Colmerauer (1978), and extraposition grammars, defined by F.
Logic programming applied to hardware design specification and verificationWe discuss how Horn clause logic, which has a procedural interpretation, and predicate logic programming language, Prolog, can be used as a hardware description language to specify and verify the correctness of hardware systems. The Prolog system possesses a backtracking mechanism and a powerful pattern-matching feature which is based on unification.We discuss how Horn clause logic, which has a procedural interpretation, and predicate logic programming language, Prolog, can be used as a hardware description language to specify and verify the correctness of hardware systems. The Prolog system possesses a backtracking mechanism and a powerful pattern-matching feature which is based on unification. The technique is based on Horn clause logic and the predicate logic programming language Prolog. A specification written using this technique is formal and directly executable with the help of a Prolog interpreter.
A model and an implementation of a logic programming environmentThe shell bears similarities to an expert system since it has explanation mechanisms and provides programming-knowledge acquisition. Currently, it supports single user Prolog programming and runs in C-Prolog. The shell is generic in that it provides support for activities ranging from artificial intelligence programming to formal specification development.The shell bears similarities to an expert system since it has explanation mechanisms and provides programming-knowledge acquisition. Currently, it supports single user Prolog programming and runs in C-Prolog. The shell is generic in that it provides support for activities ranging from artificial intelligence programming to formal specification development. Our approach is related to reflection [Weyhrauch], [Smith] and to the amalgamation of the object theory (a conventional Prolog interpreter) with its meta-theory (a meta-lnterpreter of an extended Prolog) [Bowen, Kowalski]. This will not impede generality since tools to handle other models and aspects of logic programming, eg. Concurrent Prolog [Shapiro 83], can be added. 2. BACKGROUND Rather than build a number of facilities, tools, and extensions to Prolog which would support programming in Prolog along classical lines (exemplified by Interlisp-D, or Lisp Machine Lisp), we explore the theoretical foundations of logic programming.
An enhanced inference mechanism for generating relational algebra queriesA system for interfacing Prolog programs with relational algebra is presented.An Enhanced Inference Mechanism for Generating Relational Algebra Queries Haruo Yokota, Susumu Kunifuji, Take0 Kakuta, Nobuyoshi Miyazaki, Shigeki Shibayama,Kunio Murakami Institute for New Generation Computer Technology (ICGT) Mita Kokusai Building. 21 F l-4-28 Mita, Minato-ku, Tokyo 108Japan ABSTRACTI A system for interfacing Prolog programs with relational algebra is presented. They must explicitly specify which executes relational algebra commands using a Prolog fact Prolog predicates are stored in Delta. Otherwise, a user as a relation's tuple. Their approaches call for dividing Prolog programs (which are treated as a collection of Horn clauses) into two parts: an extensional database (EDB) which collects the majority of the Prolog facts (unit Horn clauses containing no variables), and an intensional database (IDB) which collects all Prolog rules (Horn clauses except facts) and a few Prolog facts for temporary use.
Parallel algorithms for unification and other complete problems in pUnification is a basic operation in theorem proving, in type inference algorithms, and in logic programming languages such as Prolog. Prolog will play a major role in software development for the Fifth Generation project, and thus developing fast algorithms for unification is an important goal.Unification is a basic operation in theorem proving, in type inference algorithms, and in logic programming languages such as Prolog. Prolog will play a major role in software development for the Fifth Generation project, and thus developing fast algorithms for unification is an important goal. Unification is a basic operation in Prolog, an effective use of multiple processors could offer a tremendous improvement in program performance. This is especially important for the Fifth Generation project, since Prolog will play an integral role in software development.
Modular Logic GrammarsThere is a syntax rule compiler (compiling into Prolog) which takes care of the building of analysis structures and the interface to a clearly separated semantic interpretation component dealing with scoping and the construction of logical forms. The grammar formalism includes two devices which cause the automatically built syntactic structures to differ from derivation trees in two ways: (1) There is a shift operator, for dealing with left-embedding constructions such as English possessive noun phrases while using right-recursive rules (which are appropriate for Prolog parsing). (2) There is a distinction in the syntactic formalism between strong non-terminals and weak non-terminals, which is important for distinguishing major levels of grammar.There is a syntax rule compiler (compiling into Prolog) which takes care of the building of analysis structures and the interface to a clearly separated semantic interpretation component dealing with scoping and the construction of logical forms. A sue terminal is of the form +A, where A is any Prolog term. Surface terminals correspond to ordinary terminals in DCG's (they match elements of the surface word string), and the notation is often [A] in DCG's. A goal is of the form $A, where A is a term representing a Prolog goal. (This is the usual provision for Prolog procedure calls, which are often indicated by enclosure in braces DCG's.) in A shifted non-terminal is either of the form%A, or of the form F%A, where A is a weak nonterminal and F is any erm.
Playing mastermind logicallyIn this note I suggest a simpler algorithm for playing mastermind, and describe a miniature Prolog implementation of it.The algorithm is an instance of the generate-and-test scheme. We find the control-structure of Prolog - nondeterministic choice, simulated by backtracking - ideal for implementing it. 3 A Prolog Implementation The following implementation of the algorithm is written in Waterlo Prolog. PiL Much attention has been drawn to Prolog, the implementation of logic as a programming language. I [Wallace, 1983] and others [Robinson and Sibert, 1982, Komorowski, 1982] have argued the benefits of extending Lisp to do what Prolog does. Here I present a simple procedure for implementing Prolog in Lisp (PiL), in order to demonstrate that it is easy to extend Lisp to do what Prolog does. 2.
"Integrating PC's into the information center (session overview)The feasibility of using microcomputer-based implementations of PROLOG within the Information Center environment is studied. Several distinct applications are examined and examples of PROLOG programs are presented. The paper concludes that PROLOG is particularly well suited to both business and scientific problems often faced by microcomputer users.It considers the ""best"" programming language aspect of the problem, The feasibility of using microcomputer-based implementations of PROLOG within the Information Center environment is studied. Several distinct applications are examined and examples of PROLOG programs are presented. The paper concludes that PROLOG is particularly well suited to both business and scientific problems often faced by microcomputer users."
Making control and data flow in logic programs explicitNew control constructs are proposed to replace Prolog's notorious cut. Totality assertions are introduced to enable a language-oriented editor to display the control structure of a procedure.New control constructs are proposed to replace Prolog's notorious cut. Totality assertions are introduced to enable a language-oriented editor to display the control structure of a procedure. Algorithms for their verification are given. 1. Introduction Prolog suffers in that it does not provide an adequate means to restrict the generality of its basic concepts. None of these properties can be stated explicitly in Prolog. This paper presents concepts to overcome this shortcoming.
Semantics of temporal queries and temporal dataThis paper analyzes the requirements for adding a temporal reasoning component to a natural language database query system, and proposes a computational model that satisfies those requirements. A preliminary implementation in Prolog is used to generate examples of the model's capabilities.Hafner College of Computer Science Northeastern University Boston, MA 02115 Abstract This paper analyzes the requirements for adding a temporal reasoning component to a natural language database query system, and proposes a computational model that satisfies those requirements. A prelim-Inary implementation in Prolog is used to generate examples of the model's capabi Iltles. For experimental purposes, we have defined our database as a collection of Prolog facts, as proposed by Warren[ 16] , thus, the database can be queried directly in Prolog. We can now express the sample query in Proiog: resuit(EHPlO, 5AL, OLDSAL):- teday(DT), trueon(makes(EHPlD, $AL), OT), n_caL.elts_ago(year, 5, DFYA), trueordmakes(EHPlO, OLDSAL), DYFA), SAL >= 2 * OLDSAL. This Prolog rule would be the desired output of the linguistic comoonent of a NL query system.
"Standard LISP for the VAX: a provisional implementationWe also report its use in ""logic programming"", as the basis of an implementation of Prolog.Other features provided at a basic level are pattern-matching the generation of multiple solutions backtracking. and by Prolog is today rapidly gaining interest as a tool in Artificial Intelligence. Clocksin and C.S. Mellish, 1981) ""Programming in Prolog"", Springer-Verlag (Berlin 11. L.M. Pereira, F. R. Fogelholm, ""Exeter Prolog - an Experimental LISP"", unpubl. (1982) Prolog System Written in Standard 13."
A formalism for the structural analysis of dialoguesThe formalism, composed by a grammar of dialogues (syntax and semantic component) and a collection of attached scenarios (pragmatic component), is written in Prolog and implemented in a program which converses in Portugue se to provide a library service.The formalism, composed by a grammar of dialogues (syntax and semantic component) and a collection of attached scenarios (pragmatic component), is written in Prolog and implemented in a program which converses in Portugue se to provide a library service. Consider another exampleof a dialogue (numbers appendedto the natural language contributions correspond to the conversational states). (I) u-Crie Prolog p-Prolog e conhecido (2) u-Quero criar uma categoria (3) p-Por favor, qual o homeda nova categoria? E que mais? The history of this dialogue is: (Create Prolog)(Prolog is known) (I want to generate a category,) Please, what is the nameof the new category?)
Computer aided design (CAD) using logic programmingWe will also compare the use of logic programming (PROLOG) to current algorithmic solutions to VLSI design problems and discuss some future research in this area.We will also compare the use of logic programming (PROLOG) to current algorithmic solutions to VLSI design problems and discuss some future research in this area. Logic Programming To implement our prototype applications, We chose the logic programming language PROLOG. As a language, PROLOG had three major attributes that influenced our decision. An important feature of the DEMO system is that it also allows the observation of the PROLOG resolution process by another set of PROLOG clauses.
Parsing against lexical ambiguityIn this paper, the addition of part-of-speech ambiguity to a deterministic parser written in Prolog is described. To handle this ambiguity, it was necessary to add no special mechanisms to the parser.In this paper, the deterministic parser written in Prolog was necessary to add no special parsing included almost no part-of-speech addition of part-of-speech ambiguity to a is described. THE DEFAULT CASE I have implemented a deterministic parser in Prolog [Pereira 78] similar to Marcus' but extended it to allow words to be defined as multiple parts of speech. The parser has appoximately 80% of Marcus' original grammar, but the grammar has been extended to cover the domain of mechanics problems. (MECHO) [Bundy 79a,79b]. To extend the Prolog parser, each word in the dictionary was syntactically defined as all parts-of-speech it could function as, given the grammar.
XPL: an expert systems framework in APLHowever, perhaps surprisingly to PROLOG programmers, it turns out that one can code all the standard PROLOG backtracking and similar logic capability into APL user-defined functions (i.e.. into a subroutine library). It makes it fun to develop expert systems in PROLOG, but awfully hard to sell them. So far I keep seeing demonstrations of PROLOG expert systems telling me how to water my houseplants, but the florist down the road isn't selling the package yet. DOES 'IRAD IS-OFFSPRING-OF MEHUJAEL' FALSE Funny syntax, isn't it? I'm trying to stick to PROLOG though, and this is it. Now is it mindbogglingly hard to code this in XPL?However, perhaps surprisingly to PROLOG programmers, it turns out that one can code all the standard PROLOG backtracking and similar logic capability into APL user-defined functions (ie. into a subroutine library). It makes it fun to develop expert systems in PROLOG, but awfuily hard to sell them. So far I keep seeing demonstrations of PROLOG expert systems telling me how to water my houseplants, but the florist down the road isn't selling the package yet. DOES `IRAD IS-OFFSPRING-OF MEHUJAEL' FALSE Funny syntax, isn't it? I'm trying to stick to PROLOG though, and this is it. Now is it mindbogglingly hard to code this in XPL?
Saving traces for Ada debuggingIn this approach, trace information is captured in an historical database and queried using Prolog. This model was used to build a prototype debugger, called Your Own Debugger for Ada (YODA).In this approach, trace information is captured in an historical database and queried using Prolog. This model was used to build a prototype debugger, called Your Own Debugger for Ada (YODA). Some important aspects of this model are the use of Prolog, temporal logic, and a uniform representation of program states and events. Prolog is a programming language based on symbOlic logic.
"Dealing with conjunctions in a machine translation environmentThe paper presents an algorithm, written in PROLOG, for processing English sentences which contain either Gapping, Right Node Raising (RNR) or Reduced Conjunction (RC).ABSTRACT The paper presents an algorithm, written in PROLOG, for processing English sentences which contain either Gapping, Right Node Raising (RNR) or Reduced Conjunction (RC). III THE ALGORITHM The following algorithm, implemented in PROLOG Version 3.3 (shown here in much abridged form), produces correct syntactlco-semantic representations for all the sentences given in Section 2. The most difficult deletions to handle (for previous systems) are those from the left conjuncts, ie. the deleted objects of RNR (Group BI) and the deleted preposition objects of RC (Group B2), because when the left conJuncts are being parsed, the deleted parts are not avallabl This is dealt with neatly in PROLOG DCG by using logical variables which stand for the deleted parts, are ""holes"" In the structures built, and get filled later by unification as the parsing proceeds. sentence(Stn, P Sub j, P Subj Head Noun, P Verb, P V Type, P Contentverb, P Tense, POb-j, PObJHdNoun)--> % P means ""possible"": P arguments only % ve values if ""sentenCe' is called by % 'sentence_conjunctlon' to parsea second % (right) conjunct."
Using focus to generate complex and simple sentencesThe implementation uses tests on functional information such as focus of attention within the Prolog definite clause grammar formalism to determine when to use complex sentences, resulting in an efficient generator that has the same benefits as a functional grammar system.The implementation uses tests on functional information such as focus of attention within the Prolog definite clause grammar formalism to determine when to use complex sentences, resulting in an efficient generator that has the same benefits as a functional grammar system. 1. A second goal of this paper is to introduce a formalism for surface generation that uses aspects of Kay's functional grammar (Kay, 1979) within a Prolog definite clause grammar (Pereira and Warren, 1980). To analyze a sentence, the sentence is encoded as an argument to a Prolog goal. Prolog attempts to prove this goal by matching it against the set of grammar clauses.
Functional programming and logical programming for the telegram analysis problemWe propose rigorous specification methods, and describe how programs can be derived from those in two different ways. One is from BNF to Definite Clause Grammar in Prolog and the other is a functional programming by which procedural programs can be easily derived from a formal specification in the form of an abstract sequential machine, too.In Section 3, we propose the first rigorous method for transforming a problem specification in Backus-Naur Form (abbreviated BNF) into a Prolog program through Definite Clause Grammar (abbreviated as DCG), which is automatically executable in the DECsystem-10 Prolog [Pere 78]. It provides not only a description of a language, also an effective means for analyzing strings but of that language, since the DCG is an executable program of the programming language Prolog. Using a standard Prolog compiler, the DCG can be compiled into Prolog, making it feasible to implement practical language analysers directly as DCGs [Pere 80]. In order to obtain the Prolog program using DCG, we will use a BNF description of the output report, from which terms and extra conditions in DCG can be derived.
M'PAL: a programming language based on natural English definitionsThe objective was to discover the salient features such a compiler would have to have --- in particular, whether a programming language based on this style of programming might be more natural a way to eliminate control flow than production systems or PROLOG are.The objective was to discover the salient features such a compiler would have to have -m- in particular, whether a programming language based on this style of programming might be mor e natural a way to eliminate control flow than production systems or PROLOG are . Introductio n Large software systems seem to grow more inter-twined as they grow older . M'Pal was created in order to discover some unknown control flow that could be eliminated b y the M'Pal style . Therefore, PROLOG and languages based on production systems, such as OPSS , are a more relevant comparison . Thus, Klahr [K1], modeling a child's seriation behavior, incorporates into each of his productions a goal in such a way that only one sequence of firings is ever possible . And PROLOG, a languag e based on Horn clauses of logic, is known to lead in actual practice to an unfortunate reliance o n control flow --- PROLOG programmers tend to rely heavily on the order in which their clauses expand and this makes changing a PROLOG program very difficult .
"An eclectic approach to building natural language interfacesThe system is written in Smalltalk and, in INKA, produces rules for a Prolog inference engine.The system is written in Sms/ltalk and, in INK,A, produces rides for a Prolog inference engine. INTRODUCTION The ides/ natural language interface would let any user, without any prior training, interact with a computer. In particular, the version of INKA to be discussed here accepts input in a sublanguage called GLIB which permits the statement of facts and rules relevant to the troubleshooting of electronic systems (Freiling et al., 1984), and translates these statements into Prolog unit clauses for later proceng by a specialized inference mechanism. The interface to the diagnnszi¢ engine is in the ""Prolog"" window. The ""INGLISII"" window shows a recently added rule, with its Prolog translation immediately below it."
Automated testing of protocol specifications and their implementationsThese representations are encoded in a relatively mechanical way as procedures in sequential PROLOG, a very high level language. The approach is extremely flexible, straight-forward to use, and particularly appropriate to layered protocol architectures.These representations are encoded in a relatively mechanical way as procedures in sequential PROLOG, a very high level language. The approach is extremely flexible, straightforward to use, and particularly appropriate to layered protocol architectures. These PROLOGprocedures serve more than one function, e.g., the PROLOG procedure implementing representation K can be executed both as a generator of potential traces of representation K+I (called trajectories) and as a reference for checking traces observed during the execution of representation K+I. Prolo 9 Encoding of Representations We implement the attributed grammar representations in the logic programming language PROLOG [Kowa 79, Colm 78]. Figure 1 shows the correspondence in style and semantics between an attributed grammar and its implementation in PROLOG.
On database systems development through logicFinally, an experimental database query system with a natural language front end, implemented in PROLOG, is presented as an illustration of these concepts.Finally, an experimental database query system with a natural language front end, implemented in PROLOG, is presented as an illustration of these concepts. Categories and Subject Descriptors: F.4.1 [Mathematical ematical Logic--logic programming, H.2.m [Database H.2.3 [Database Management]: Languages-query Logic and Formal Languages]: Math Management]: Miscellaneous-PROLOG, languages Additional Key Words and Phrases: relational 1. These considerations led us to develop the first database system implemented in PROLOG, a powerful language for logic programming [26].
ILEX an intelligent relational database systemA universal interface supporting three typical query languages: ML based on ISBL, EL based on SQL, and PL based on QBE, has been implemented entirely in PROLOG. The translation of queries from a variety of query languages into a canonical logic form is illustrated.A universal interface supporting three typical query languages: ML based on ISBL, EL based on SQL, and PL based on QBE, has been implemented entirely in PROLOG. The translation of queries from a variety of query languages into a canonical logic form is illustrated. In other words, logic programming languages, such as PROLOG, can be applied to the task of writing compilers for high level query languages [i0]. The major advantage of PROLOG as a language for writing compilers is that it specifies algorithms in a human-oriented way.
Pattern driven lazy reduction: A unifying evaluation mechanism for functional and logic programsOn the other hand, functional programs can be equipped with the power of logic programming languages, e.g., Prolog.You Department ofComputer Science University of Utah Salt Lake City, Utah 84112 has been evidenced to be a simple and powerful language. However, current Prolog systems suffer from a number of A novel lazy evaluation mechanism, pattern-driven lazy reduction, is developed that serves as a unifying evaluation mechanism for both functional and logic programs. The prototypical representative of logic programming is Prolog (see, for example, [1, 4, 5, 12, 19]), which This Research was sponsored in part by the Defense Advanced Research ProjectsAgency,US Departmentof Defense,Contract No. The major drawback of these languages, as compared to Prolog, is the lack of knowledge-based inferencing abilitiesto cope with search-based computations.
A structure-sharing representation for unification-based grammar formalismsThe structure-sharing method was designed to eliminate most such copying, indeed, practical tests suggest that the use of this technique reduces parsing time by as much as 60%.The present work is inspired by the structure-sharing method for theorem proving introduced by Boyer and Moore and on the variant of it that is used in some Prolog implementations.The present work is inspired by the structure-sharing method for theorem proving introduced by Boyer and Moore and on the variant of it that is used in some Prolog implementations. 1 Overview In this paper I describe a method, structure sharing, for the representation of complex phrase types in 'a parser for PATR-II, a unification-based grammar formalism. This reasoning applies in particular to dag instances that are the result of adding attribute values to other instances. 138 As in the variant of Boyer and Moore's method [1] used in Prolog [9], I shall represent a dag instance by a molecule (see Figure 2) consisting of 1. Reprinted as T,,'hnical Note 290, Artificial Intelligence Center, SRI, Intornational, Menlo Park, California. {10] David H. D. Warren, Logarithmic access arrays for Prolog. Unpublished program, 1983. 144
Computational realization of a generalized phrase structure grammar: University of Sussex, EnglandThe realization will be in a form which is neutral with respect to parsing or generating sentences, and which is capable of being used with a variety of programs. Programs written in POP2 and PROLOG will be used to test the grammar.The realization will be in a form which is neutral with respect to parsing or generating sentences, and which is capable of being used with a variety of programs. Programs written in POP2 and PROLOG will be used to test the grammar. In the last three years there has been the most astonishing resurgence of interest in phrase structure grammar (PSG) as a theory of natural language syntax.
Dialogue management in the personal sequential inference machine (PSI)The entire system is implemented in ESP (Extended Self-contained Prolog), an enhanced logic programming language incorporating an object/class methodology similar to that of Smalltalk-80.The entire system is implemented in ESP (Extended Self-contained Prolog), an enhanced logic programming language incorporating an object/class methodology similar to that of SmaIltalk-$0. The Programming and Operating System for PSI, called SIMPOS [22], is also under development. It is written entirely in ESP, a PROLOG-Iike logic programming language [3]. Here 9 we present the dialogue management component of SIMPOS. Concurrent Prolog [l 6] provides another method, but it is not usable at the present time.
Automatic analysis of descriptive textsThe resulting output is a standardised hierarchical structure holding only significant features of the description.The system, implemented in the PROLOG programming language, uses keywords to identify the way segments of the text relate to the object described.The resulting output is a standardined hierarchical structure holding only significant features of the description. The system, implemented in the PROLOG programming language, uses keywords co identify the way segments of the text relate to the object described. The skeleton plant and keyword lists are held as facts in the PROLOG database. The implementation of the suffix stripping algorithm is a good example of the ease of expressing algorithms in PROLOG. Departmnc Clocksln, William F. and Christopher $. Hellish. Programalng in PROLOG. Heidelberg: Verlag, 1961. Springer-DeJong, Gerald F.
End user touch searching for cancer therapy literature: a rule based approachWork is progressing on an implementation using the expert systems programming language PROLOG, which has been found a very suitable language for representing rules and provides a ready made rule interpreter.Work is progressing on an implementation using the expert systems programming language PROLOG, which has been found a very suitable language for representing rules and provides a ready made rule interpreter. The rule-based approach seems to provide a flexible and powerful means of programming the interaction without the explicit linking of individual rules found elsewhere, although it is expected that explicit linking may be necessary in interacting with MEDLINE, the boards will be used to make program construction modular and independent. 5.3. Implementation in PROLOG There is considerable interest in the use of PROLOG for programming expert systems (ref. 2 ). Vol 63 pp 23-28 1977. 2. Clocksin W.F., Mellish C.S. Programming in Prolog. Springer Verlag. Berlin 1981. 3. Davis R. King J.
Special section on architectures for knowledge-based systemsThe first generation was marked by the development of enhanced AI languages like Interlisp and PROLOG. The second generation saw the development of knowledge representation tools at AI research institutions, Stanford, for instance, produced EMYCIN, The Unit System, and MRS.The first generation was marked by the development of enhanced AI languages like Interlisp and PROLOG. The second generation saw the development of knowledge representation tools at AI research institutions, Stanford, for instance, produced EMYCIN, The Unit System, and MRS.
Database design tools: an expert system approachIn this paper, we report on the implementation of SECSI, an expert system for database design written in Prolog. Starting from an application description given with either a subset of the natural language, or a formal language, or a graphical interface, the system generates a specific semantic network portraying the application.
Efficient processing of interactive relational data base queries expressed in logicThe paper describes a simple but effective strategy for planning a query so that it can be efficiently executed by the elementary deductive mechanism provided in the programming language Prolog. This planning algorithm has been implemented as part of a natural language question answering system, called Chat-80.
Data constructors: on the integration of rules and relationsMoreover, it is shown to provide expressive power at least equivalent to the declarative semantics of PROLOG while avoiding some disadvantages of it, for example, poor modularity and infinite loops.
An optimizing compiler for LISP for the Z80The first phase is an extended peephole optimization, the second removes function prologs and epilogs from routines which do not need stack frames. Second Optimization Pass The second optimization pass removes the function prolog and epilog if no stack frame is used. Thus the function: (DZ CAAAAR (X) (CAAR (CR X))) is compiled without optimization into: ENTRY CAAAAR, EXPR CALL ALLOC DEFB 2 STOX HL, -1 LDX HL, -1 CALL CAAR CALL CAAR CALL DALLOC DEFB -2 RET This version uses 19 bytes.
"A hardware unification unit: design and analysisIn particular, the hardware unification unit is designed to replace the software ""unify"" function of an existing (UNSW) Prolog interpreter: at the same time. hardware circuits are used extensively to enhance its performance. Because the unification is a fundamental operation of Prolog processing and because the 'unify' function is the most time consuming function during query processing, this hardware unification unit can be used to build high performance Prolog machines. 1. Introduction High performance Prolog machines are desirable in various applications."
Inference machine: From sequential to parallel-To develop an efficient programming environment for Prolog ( KL0 ) as being given by LISP on the personal machine. -A system description language, Extended Self-contained Prolog also be designed for ESP: will systems programmers. Subset concurrent prolog is now running on 2060. Its interpreter was implemented DEC-10 prolog by E.Shapiro.
Towards a western Fifth-Generation Computer System projectThe Japanese FGCS project has received plenty of attention, but its technical basis (logic programming and Prolog) has been largely ignored. We argue that this choice of technical approach is not a whim, but has important advantages for a near-term FGCS project. All that is needed is the LISP machine analog for Prolog. And this is just the role played by PSI, ICOT's personal sequential inference machine. Shapiro's version of concurrent Prolog [17] has been shown to be an attractive formalism for objectoriented programuling [18]. • Met alevel programming.
"Parallel interpretation of logic programsMore specifically, logic roin refers to programming with Horn clauses. Prolog is a high-level applicative language based on logic programming. There are a number of other, more ""intelligent"" interpreters. IC-Prolog [1] has control annotations to help guide the search by using certain runtime information. Logic Programming This section contains definitions, some simple logic computations, and a brief introduction Prolog (using the syntax of DECsystem-10 to Prolog). We only discuss the procedural semantics of Prolog, the declarative semantics can be found in [4]."
"Functional programing and the logical variableThe result is an applicative analog of Lisp's nconc. However. the same problems arise here (and in Prolog) that arise in Lisp: nconc([a, al) makes 8 become (or asserts that 8 IS. if you wish, in Prolog) the tail of (1. (Is this not, in large part, is what Shapiro means when he says Concurrent Prolog is an oblect-oriented language ""par excellence""? However, the semantics of FUNLOG are given only informally, and parallel evaluation effects, while clearly a strong motivation, have not been fully elucidated. 9.3. Concurrent Prolog Finally, the connections of FGL+LV with Concurrent Prolog [22) are unmistakable."
"TAO: A fast interpreter-centered system on LISP machine ELISIn other words, s-expression accommodates Lisp, Prolog, Smalltalk, Fortran semantics in a harmonic Users can program by selecting and and way. mixing the following programming paradigms: - Procedural, like Lisp and Fortran - Object-oriented, like Smalltalk - Logic, like Prolog By ""harmonic"", it is meant that these programming paradigms are fused in ""eval"". 3.1 Features in Lisp TAO is almost compatible with major Lisps (especially MacLisp's family). Hence, the user can combine these functions to make up his Prolog(-like) system without loss efficiency and generality. As for Lisp, TAO almost compatible with major Lisps. is TAO is also semantically compatible with DEC-10 Prolog and Smalltalk-80. (Indeed, DEC-10 Prolog surface syntax will supported.)"
AbstractsCS83-06 Ehud Y. Shapiro, A SUBSET OF CONCURRENT PROLOG AND ITS INTERPRETER Concurrent Prolog is a variant of the programming language Prolog, which is intended to support concurrent progra 1ning and parallel execution. It describes in full detail an interpreter for the language, written in Prolog, which can execute these programs° 53 CS83-07 !] Shapiro: CONCURRENT PROLOG AS A MULTIPROCESSOR'S KERNEL LANGUAGE. (b) L. Hellerstein and Ehud Shapiro: ALGORITHMS IMPLEMENTING PARALLEL IN CONCURRENT PROLOG: THE MAXFLOW EXPERIENCE.
"Constraining-unification and the programming language unicornThe approach is essentially the same, the axioms are translated into Prolog clauses which mimic the rewrite.rule approach. This is similar to the way that equality theorems are used in Prolog-with-Equality [8] (the differences will be discussed in section 3). The following is an example of such a Prolog predicate: convert(C,F) :- var(F) -> (nonvar(C), F is 32+(9""(C/5))), C is ((F-32)/9)'5."
Formal representation of a conceptual knowledge model for a database based expert systemThis distinct separation is due to the fact that we are dealing with a large amount of data which are beyond the PROLOG storage capacity. Dialog component is used to permit the interaction with the expert, user and designers. A user-friendly dialog interface with natural language will play an important role in this respect. The transformation of files which PROLOG cannot process directly into PROLOG format is logically contained here. The final reason is that formal definition can be transformed into an executable language (such as PROLOG) which constitutes the representation of t,he knowledge.
AbstractsCS83-06 Ehud Y. Shapiro, A SUBSET OF CONCURRENT PROLOG AND ITS INTERPRETER Concurrent Prolog is a variant which is intended to support of the programming language Prolog, concurrent progranning and parallel execution. This paper reports on a subset have developed a working and a commitment mechanism similar of Concurrent Prolog, for which we interpreter° It demonstrates expressive power of the language benchmark concurrent detail an interpreter via Concurrent Prolog programs that solve progranning p'roblems. Shapiro: CONCURRENT PROLOG AS A MULTIPROCESSOR'S KERNEL LANGUAGE. (b) L. Hellerstein and Ehud Shapiro: IMPLEMENTING PARALLEL ALGORITHMS IN CONCURRENT PROLOG: THE MAXFLOW EXPERIENCE.
The fifth generation project — a trip reportHe found a photocopy of a photocopy of a photocopy of the sources of the Marseilles Prolog interpreter. He brought it back with him to Fuchi, his boss at ETL. I completed a design for a self-contained subset of the programming language Concurrent Prolog, implemented an interpreter for it in Prolog, and tested several Concurrent Prolog programs, which I had previously written in Israel as a thought experiment. My main contribution to the project during the visit relates to imple-2Logical inferences per second, a fancy way of saying Prolog procedure calls per second. For example, micro-Prolog [5]for the Z-80 performs around 120 LIPS, Prolog intepreters written in C for the VAX are estimated to run 1 to 3K UPS: Waterloo Prolog runs around 25 K LIPS on large IBM machines: compiled Prolog-10 [11 runs 30K LIPS on a DEC System 2060 and is the best Prolog available today. menting multitasking on the PSI machine.
Jade: a distributed software prototyping environmentThe only other serious contender is Lisp, however, the strong foundations of Prolog in first-order predicate calculus seem to ease proofs of programs greatly. A screen-handling module is being developed as part of Jade and integrated into the Prolog run-time system. This will enable Prolog programs to be entered, displayed, and viewed as ordinary office forms. This has in fact been done, and a (spectacularly slow) interpreter now exists, in Prolog. Real-time systems expect their programs to run indefinitely, so that garbage collection of activation records must be used to prevent Prolog's memory requirements from growing for ever. • Can proof techniques environment?
Impressions from the 1982 ACM Symposium on Lisp and Functional ProgrammingThe problem of size of expressions is a technical problem and seems solvable. There were papers in this conference on PROLOG, justified on the grounds that Pure PROLOG does not allow side effects and promotes parallelism. Paul Eggert (UC, Santa Barbara) and D. Val Schorre (SDC) calm the stormy seas of Prolog extensions, by showing a preprocessing technique for doing what many people construe as extensions to Prolog. They show us how to introduce modules, macro expansions and functional notation into Prolog by preprocessing. I think the value of their contribution lies in asking those making extensions to Prolog to deliberate a little on whether these extensions are truly necessary.
Authorsauthors JACQUES COHEN Describing Prolog by Its Znterpretation and Compilation page 1311 Jacques Cohen is professor and chairman of the computer science department at Brandeis University. Colmerauer's group has been active in doing research in logic programming, particularly in new extensions of Prolog. His research interests are also in areas of natural language processing in expert systems. He is assistant professor of MIS and director of the Post-Graduate Certificate Prodeveloping applications of Prolog in gram in MIS at the Weatherhead artificial intelligence.
MIXER: an expert system for microprogrammingFig. 2 also represents a PROLOG clause implementing a piece of macro-knowledge within the clause. Fig. 3 also shows a PROLOG clause implementing a piece of semantic knowledge within the clause. There are usually two or more sets of microoperations implementing the same 171 intermediate operation, a piece of micro-knowledge specifies one of these. Micro-knowledge mented as PROLOG clauses: microknowledge( Source pattern, Obiect pattern). is imple-Fig.4 also shows a PROLOG clause implementing micro-knowledge within the clause.
"Surveyor's Forum: Determining a SearchSURVEYORS' FORUM Determining a Search Walter Wilson provides an example of a control mechanism in the language PROLOG to illustrate a nondeterministic framework not dealt with in Jacques Cohen's paper that appeared in COMPUTING SURVEYS II, 2 (June 1979), 79-94. POPLER [DAD173], MICRO-PLANNER [Suss 70], CONNIVER [McDE72], and PROLOG [KoWA74], for example, provide for nondeterminism as a basic control framework of the language. Readers interested in Cohen's article would do well to pursue one or two of the References listed below. To illustrate, I will use a dialect of PROLOG (perhaps the ""purest"" nondeterministic language to date), expressed in a syntax compatible with that used by Cohen."
A course in applied logicThe important notions of recursion , computability, and the complexity o f computations have their foundations i n programming language semantics (6) . Additionally, a programming languag e called Prolog exists whose design is base d on logic (5) . Recently Prolog has gaine d great prominence since it was picked a s the language for the Japanes e Fifth-Generation Computer Project (7) . Thus Prolog can be describe d as a special type of resolution theore m prover for Horn clauses . Unification is discussed in th e context of resolution theorem proving . The next topic is Prolog (3 weeks) . This includes the syntax and features o f Prolog (for our implementation) as well a s the relationship of Prolog to logic .
Toward computational description of written Polish: Warsaw University, PolandMore than half of them have been incorporated into an experimental parser for Polish, written in the Prolog programming language/6/,/7/. The description is very broad and, consequently, rather general. We believe that logic programming/8/, and specifically Prolog, is an extrcmely useful tool for implementing natural language processing systems. Tile team is involved in development and maintenance of •Prolog translators, cf./11/. We are in the course of designing a version 149 of Prolog, capable of efficient handling of large amounts of linguistic data.
"Issues in natural language access to databases from a logic programming perspectiveISSUES IN NATURAL LANGUAGE ACCESS TO DATABASES FROM A LOGIC PROGRAMMING PERSPECTIVE David H D Warren Artificial Intelligence Center SRI International, Menlo Park, CA 94025, USA relational database system. The resulting Prolog I INTRODUCTION I shall discuss issues in natural language (NL) access to databases in the light of an experimental NL questlon-answering system, Chat, which I wrote with Fernando Perelra at Edinburgh University, and which is described more fully elsewhere [8] [6] [5]. Chat processes a NL question in three main stages: translation planning execution English .... > logic .... > Prolog .... > answer corresponding roughly to: ""What does the question mean?"" Prolog can be viewed either as an extension of pure Lisp, or as an extension of a relational database query language."
Architectures for expert-DBMS (panel session)Prolog offers the functionality needed to accomplish basic knowledge management tasks: storage and manipulation of complex information structures. It is simultaneously a powerful, well-defined programming environment. (2) A transparent connections from Prolog to relational databases is the best approach, in the short term, for an Expert DBMS architecture. Implementations exist that permit not only access of relational data within Prolog, but storage of Prolog information on disk. Such an architecture combines the best aspects of both artificial intelligence and database environ- ments in a single system. [ The abstract from Matthias Jarke was not received on time to be included in this write up]
A generalized interval package and its use for semantic checkingINT was built for a different purpose, namely, for checking the conditions of rewrite rules and the solutions to equations in an algebraic manipulation program, PRESS written in PROLOG [8]. For instance, the rewrite rule U*V -- W ==#U _ W/V has the condition that v be positive, that is, lie in the open interval (0, oo). Another major reason for using rational number arithmetic was that, at the time INT was built, PROLOG was still a new and experimental artificial intelligence (AI) language without floating-point arithmetic. Richard O'Keefe had implemented the rational arithmetic package, LONG in PROLOG, so this was a readily available alternative. Several implementations of PROLOG now do have floating-point arithmetic but not, at the time of writing, the DEC10 implementation in which INT was built.
"Logic for problem solvingThis is perhaps an unfair way to begin a review of a book about logic programming which happens t0 tend to express itself primarily in the new PROLOG language. In fact, I personally elected to read this book for myself after having had several rather frustrating bouts with PROLOG evangelists-- mostly in the context of small-scale seminars. This book was published as part of a series of titles in artificial intelligence, which indicates where some of the current interest in PROLOG resides. This newsletter, however, is concerned with software engineering, and I would like to try to address the issue of the extent to which software engineers should be paying heed to logic programming as a technique, without necessarily dwelling upon the details of PROLOG as a programming language. One is promised that their interpretation will lend itself to ""many of the facilities for intelligent program execution, such as non-determinism, parallelism, and procedure call by patternmatching."" One is even told ofa ""PROLOG compiler written in PROLOG for the PDP10"" which ""executes LISPlike logic programs as efficiently as compiled LISP."""
"System analysis and design: a foundation for the 1980'sOne wonders just how many people are really interested in ""PROLOG Applications i n Hungary ."" (Actually, this paper is more than a catalogue , but one has to get to the very end befor e finding any discussion of conclusions concerning the usefulness of PROLOG in the various tasks to which it has been applied .) Similarly, the paper by Hogge r starts with the assumption that IC-PROLOG is controlled by serial connectives and considers ho w such operators may be replaced by parallel connectives . My regret is that there was not a similar paper discussing the original PROLOG in the sam e terms . One could definitely benefit by being able to draw comparisons ."
Some requirements for architectural support of software debuggingSPAM and X-Tree provide such traps, in both cases with data descriptors. Trap on Procedure Prolog and Epilog The ability to trap at the beginning and ending of procedure activations (prolog and epilog traps) supports several high-level debugging functions: Interlisp-style advising, frequency or execution-time cost profiles, and procedure call traces. SPAM and X-Tree provide the latter. SPAM 143 supports all four types of prolog/epilo 9 traps, X-Tree supports after-entry and before-exit traps only. The tradeoffs are essentially same as for prolog and epilog traps. Summary the Tables I, II, and III summarize the issues we have discussed.
Translating Spanish into logic through logicSecondly, programming in logic [19,29] has become possible since the development of the PROLOG programming language at Marseille [3,5,27]. Logic can now be used both as the underlying formalism and as the programming tool. As has been shown in [30], no loss in efficiency need be involved with respect to languages such as LISP, even though higher level features are supported in PROLOG (e.g. non-determinism). Thirdly, most PROLOG implementations include a version of metamorphosis grammars (MGs), a logicbased formalism useful in particular for describing NL processors in terms of very powerful rewriting rules [5]. Finally, we show a step-by-step development of a PROLOG analyser for Spanish, after an informal description of our programming tools.
Ada measurement based on software quality principlesMetrics-Definition Language number of must specify We chose the logic programming language, Prolog, basis for the metrics-definition language. as the The metricsdefinition language is expressed in Prolog notation, using a set of predicates designed to define metrics. The use of Prolog notation allows us to capitalize the Prolog interpreter for the easy development on of a set of automated support functions, collectively Framework Assistant. We have established a knowledge representation scheme for software-quality-improvement transformations, including supporting primitives written in Prolog. A prototype inference engine is implemented in Prolog. 5.
The Analyst—a workstation for analysis and designWhile the system was successful functionally, response times were unacceptably slow. This was primarily due to the exclusive use of Prolog [4] as the implementation language. Prolog is well suited for knowledge based applications but compilers available for the VAX in 1983 generated relatively slow run-time code. To take advantage of the expressive power of Prolog and still achieve quick response times, we adopted a mixed language approach. PASCAL [5] is used for graphics and window manipulations, Prolog is used to express the method rules and to store and retrieve application information.
Logic programmingIn processing a query of the form G( Art, z ) , PROLOG enumerates Art's children and tries to find a child for each. If the conditions had been written in the opposite order, PROLOG would enumerate all parent-child pairs and check to see whether Art is a parent for each. Clocksin. W.F.. and Mellish. C.S. Programming in PROLOG. Springer Verlag. New York. 1981. 2. Genesereth, M.R.
Extending the spreadsheet interface to handle approximate quantities and relationshipsThese rules can be straightforwardly represented in PROLOG, the popular logic programrning language (Roussel 1975, Cloeksin and ]V[ellish 1981). Figure 3 shows PROLOG versions of all the rules in Figures 1 and 2. ASP. ASP is a demonstration program written in PROLOG and REXX under IBM's VM/CMS operating system. The PROLOG portion implements the rules shown in Figure 3, while the REXX portion handles the presentation of the spreadsheet interface on a display terminal, translating spreadsheet entries into PROLOG assertions and translating propagated assertions hack into the appropriate form for display in the spreadsheet.
The provision of procedural and functional interfaces for the maintenance of program design language and program language notationsThe extraction of the information being carried language or by means of clauses PROLOG. out either by means of a simple procedural in the functional programming language 3- A model of program desig n language and program language notations using binar relations. The first involves storing the net as a data structure and using a simple, which has the net as a built in type. interactive,procedural language This provides a procedural interface • The second method of implementation of clauses in the functional involves storing the net as a series programming language PROLOG. A maintenance programmer can then derive useful information by constructing further PROLOG clauses. The value of *A is then printed out. 4.2 The functional interface The equivalence between a semantic net and clauses expressed in the programming language PROLOG means that the same process whereby a semantic net is generated can be easily modified so as to generate PROLOG clauses.
Neurolinguistics and psycholinguistics as a basis for computer acquisition of natural language., Univ. of Rochester, 1983. Komorowski, H.J. QLOG - The software for PROLOG and logic programming. In K. Clark and S. A. Tamlund (Eds.), Logic programming. Technical Report, School of Computer and Information Science, Syracuse Univ., December, 1981. Warren, D.H.D. Implementing PROLOG - compiling predicate logic programs. Research Reports 39 and 40, Dept. of Artificial Intelligence, Univ. of Edinburgh, 1977. The September 1979 special issue of Scientific American on the brain [Stev 79a, Naut 79a, Kand 79a, Crlc 79a, Hube 79a, Gesc 79a], the PROLOG text [Cloc 81a], the Psychollngulstics work [Derr 77a] and the Tagmemlcs text [Pike 77a] should be accessible to anyone.
Nial: A candidate language for fifth generation computer systemsThere is a temptation to design a fifth generation Prolog machine - as the Japanese are doing [Utta 182]. The reader is assumed to be familiar with the basic principles of resolution logic as used in Prolog. The method of control used in Prolog is a form of resolution referred to as top-down interpretation of Horn clauses. We propose, and have experimented with, replacing the Prolog strategy with the and/or tree formalism coupled with programmer specified heuristics.
Expert database systems (workshop review)Reasonmg with time, events, and cause-effect rela tlonshlps 2 3 Logic Programmmg and Databases This Working Group was chaired by D Stott Parker, Jr, and had featured speakers Michael Carey (Umverslty of Wlsconsm), Forouzan Golsham (Arizona State University), Matthias Jarke (New York University), Edward Sclore (Boston Umverslty) and Adrian Walker (IBM Research, Yorktown Heights) The interface between Logic Programmmg and Databases 1s an Important aspect of a much larger phenomenon the confluence of the znfomnatwn scaences As the emphasis on mformatlon processmg has grown, previously independent symbohc processing dlsclplmes have begun borrowmg concepts heavily from one another A great deal of excitement 1s resulting from this confluence Unfortunately, a great deal of confusion 1s resultmg as well, since the flelds all refer to slmllar concepts with different terminology, and use concepts that are ad hoc or lack a solid foundation Logic Programmmg offers a dlrectlon out of the confusion It is unique m that it offers a consolidation of what has already been done, as well as a sound formal basis on which to build predicate calculus with Horn clauses It 1s surprising that the merging of Logic Programmmg and Databases has taken this long to occur The two fields followed parallel lmes of development throughout the 1970's, but have largely ignored one another m spite of a great deal of work at the interface Perhaps only the selection of Prolog by the Japanese FGCS prolect has precipitated reevaluation of maccurate perceptions of Logic Programmmg, such as dlfflculty of use or of learning (Prolog is taught m some British elementary schools) mferlorlty to LISP, mefflclency. etc Much has been written recently about Knovrledge Bases (also called Inferential Databases, Deductive Databases, and Expert System kernels) These are the mformatlon management systems of the future, and will mcorporate the results of several decades of work in the Database, Knowledge Representation. Expert System, and Automated Theorem Provmg fields They are now being developed directly using Logic Programming systems Both Databases and Logic Programmmg have much to obtain from confluence Logic Programmmg extends Relatlonal Databases with deductlon, storage of nonrecord-oriented mformation, and the ablhty to combine schema, metadata and constraints with database facts Logic Programming also provides an elegant and uniform way of Implementmg views, query languages, and null values However, Logic Programmmg systems such as Prolog do not yet have all the qualities one would want of a Database system Prolog does not directly support some types of queries, mtegrlty constraints, schema defimtlon, and so forth Moreover most Prolog amplementations are zn-memory systems all information is loaded mto memory (possibly virtual memory) before execution Secondary storage media are not used to store and query the current state of the mformation. unless the underlying operatmg system uses paging Clearly there are many issues to be resolved We have chosen to focus on two key Issues (0 (2) 24 Eztendang Logzc Programmmg for Database Apphca t%OnS How can Logic Programming systems be augmented to support query interfaces that are more responsive to user needs? Los Angeles), Larry Kerschberg (University of South Carolma), and David Maler (Oregon Graduate Center) The concept of objects and object-oriented archltectures represent a most mterestmg unifying trend m the design of both Knowledge Based and Database Systems Versatility and flexibility represent proven virtues of this approach, that has been successfully applied to a wide spectrum of applications and programming envlronments Important apphcatlon areas include (1) Programming Languages (2) CAD Systems and Engmeermg Design Databases (3) Office Informatlon Systems (4) Knowledge Representation Systems (5) Database Management Systems The flexlbdlty of the concept of objects is also demonstrated by Its realization in the framework of functional programmmg languages and Logic Programming Because of their apphcablhty to different programming environments, It is hoped that objects will supply a basis for unifying and integrating different programmmg environments The issue of Implantmg database facdlties in an object-orlented programming language was addressed by Maler and Copeland Zamolo has shown that a better mterface between Prolog and a database system can be constructed by adding to Prolog the notion of obJect Identlflers The ObJective of this working group is to clarify the principal research Issues relating to the concept of objects and object-based system architectures In particular, we want to identify the potentially important roles that ObJt?
"Algorithmic program diagnosis""Purified"" versions of many existing and proposed programming languages satisfy the above description. For example. pure Lisp. pure Prolog, loop-free Algol-like languages with no side-effects and a provision for enforcing monotonicity, procedural APL with no goto's, Backus' applicative languages, HareI's And/Or programs, etc., We define semantics for programs. Well known transformations (which may take the program outside the ""pure"" part of Prolog) can easily eliminate the problem, probably at the cost of the program's readability. We quicksort program. We start by typing into the Prolog interpreter a (hopelessly?) buggy program for quicksort."
"The new generation of computer architectureVery hlgh level programming languages provide improved programming methodologies, the best examples being logic (e.g. PROLOG) and functional (e.g. Pure LISP) languages• For example, In a PROLOG program [5,8] statements are relations of a restricted form called ""clauses"", and the execution of such a program is a suitably control]ed logical deduction from the clauses forming the program. Programming will use very high level languages such as PROLOG. Architectures will support concurrency, utillslng concepts such as data flow. SIM is designed to attain 20-30 KLIPS and will be implemented in TTL ICs. This PROLOG machine is to logic programming what LISP machines are to functional programming."
SAUMER: sentence analysis using metarulesIMPLEMENTATION The SAUMER system is currently implemented in highly portable C-Prolog (Pereira. 1984). and runs on a Motorola 68000 based SUN Workstation supporting UNIX 4. Calls to Prolog are allowed by the system, thus providing useful tools for debugging grsmmars, and tracing derivations. For a DCG rule. each nonterminal is converted into a Prolog predicate, with two additional arguments, that can be processed by a top-down parser.
The processing of Portuguese based upon logic: LNEC, Centro de Informatica, Lisboa, PortugalMotivation and Actual Status Several logic programming achievements have been combining since 1976 to yield successive experimental data base query systems entirely written in Prolog [2]. Yet, many problems remain open with respect to logic grammars. Thesis, Univ. of Edinburgh, 1979. [2] COELHO,H. - Elementos para uma ensenharia da linguagem, LNEC, 1980. [3] COELHO,H., COTI'A, J.C., PEREIRA, L.M. - How to solve it with Prolog. LNEC, 2nd edition, 1980. [4] COELHO,H. - Database interrogation by means of natural language (Portuguese) dialogues represented in logic. Workshop on Natkral Communication with Computers, Warsaw (Poland), 1980. [11] GASPAR,M. - Programacao em Prolog de alguns mccanismos cognitivos da conversa entre um computador e. os seus utilizadores, LNEC, 1980. 68
"Implementation of logical query languages for databasesThis relation can be expressed by the rules: (1) SecureEDS(e, d, s) :- EDS(e, d, s) s < 100,000 (2) SecureEDS(e, d, 0) :- EDS(e, d, s), s 2 100,000 Above, and throughout this paper, we express clauses in the Prolog style, where A:-Bl,..., B, means that B1 and . . + and B, implies A. Rather, Prolog does a depth-first search of the tree, obtaining one tuple each time it comes to a node labeled by a database relation. RULE/GOAL GRAPHS AND CAPTURE RULES Despite the possible utility of Prolog as a database language, the fact is that Prolog forces the programmer frequently to use features of the language, such as term and clause ordering and the ""cut"" operator, to influence the way queries are evaluated."
A new generation of symbolic and algebraic computation systemsComparisons,following standard specifications,is needed between existing languages underneath SACS such as LISP, C and PROLOG or other logic programming language that might appear. In Venezuela we have very small groups working in border areas on topics such as the following.. -Semantics of natural Languages. 13 -PROLOG implementations -Editors for Theorem Proving. -Logical Data Bases. -Development of a Computer Algebra System based on PROLOG. -Applications of REDUCE to problems of border areas.
"EXPERIPLAN an expert system that selects statistical analyses for research studies., ""Artificial Intelligence,"" Addison-Wes'ley Publishing Company, 1979. Playing Mastermind More Logically or Writing PROLOG More Efficiently David M. W. Powers Department of Computer Science University of New South Wales In the last few issues of SIGART there have appeared (#82, 83 & 85) three articles on Mastermind programmes, the latest of which, by Ehud Shapiro [I], presents a PROLOG version of the best known algorithm for the oldest form of the game bull-cow. This paper presents some improvements to this programme and uses it as an example in making some general points about PROLOGo Shapiro's programme is simple and demonstrates the power of PROLOG for implementing a quick solution using a well understood algorithm. Putting it another way, ease and efficiency of programme writing is a major plus of PROLOG, along with the brevity and readability of programmes."
Mastermind in SIGARTLet us look at such a simple and yet extremely useful implementation of the Prolog language Represent the rules as follows: R1 = +LCL -LCLi...LCL n R2 = +LCL -LCLi...LCL m Rn = +LCL -LCLi... That is, every rule is in the standard logic programming form which is written in Prolog is LOGIC-CLAUSE :- LCL1, LCL2, LCL3 ... LCLn Reordering these rules can bring great improvement in the time to compute results. This is a lot easier to implement than a compiler for Prolog, too. (I should refer to more serious work in optimization at the University of Edinburgh, Aix-Marseille, Acadia University and University of Ottawa (exponential improvement of plan-based logic programs).
"Review of ""Machine Intelligence and Related Topics: An Information Scientist's Weekend Book by Donald Michie"", Gordon & Breach, Science Publishers, Inc., ISBN 0-677-05560-9, 1982.In this note I suggest a simpler algorithm for playing mastermind, and describe a miniature Prolog implementation of it. The version of mastermind we used to play as kids is slightly simpler than the one described by Rao, and needs less hardware (only pencil and paper). The algorithm is an instance of the generate-and-test scheme. We find the control-structure of Prolog - nondeterministic choice, simulated by backtracking - ideal for implementing it. 3 A Prolog Implementation The following implementation of the algorithm is written in Waterlo Prolog."
Modelling database based expert systems at the conceptual levelThis distinct separation is due to the fact that we are dealing with a large amount of data which are beyond the Prolog storage capacity. meto knowledge or control knowledge (knowledge about knowledge). A user friendly dialog interface with natural language will play an important role in this respect. The transformation of files which prolog cannot process directly into prolog format is logically contained here. The result of axiomatization will be a set of axioms prepared in the form .of general clauses. 3.2.4 Verification Whether the theory we created is not inconsistent i.c. whether the - rules we have created are correctly formulated or not (free from redundance, contradiction, deadlock ) is a matter of validation which is normally done by means of a theorem prover, or other techniques as Petri nets. 3.2.5 Implementation The programming Language PROLOG is used for the implementation. PROLOG is a high level, interactive, non-procedural language with a very simple syntax.
Keynote Address-Artificial Intelligence and simulationIn the United States, LISP and it's dialects has been far and away the favorite for AI research and applications while in Europe and the Far East, PROLOG prevails. The Japanese have decided upon PROLOG for their fifth generation projects. But if I were to guess right now, the edge would go to PROLOG. PROLOG is a much smaller program than LISP (although not as small as Forth) and has been implemented on a variety of computers including microcomputers. Japan has announced that it intends to build a sequential PROLOG based personal computer by 1986, featuring 1OK logical inferences per second, and by 1999 a parallel processing computer running PROLOG at i billion inferences per second.
"Magic sets and other strange ways to implement logic programs (extended abstract)Introduction We assume that the reader is familiar with the notion of a logic program and with the notation of Prolog. We follow Prolog notation, although we do not assume the leftto-right execution of literals that is inherent in that language. The first, top-down, or ""backward chaining,"" is the one Prolog would do. Actually, Prolog would run forever on rr and 1'2, but we can fix the problem by reordering goals, replacing r2 by rh: sg(X, Y) :- pur(X, Xl), sg(X1, Yl), pur(Y, Yl). However, given goal sg(u,W), the Prolog program would consider each parent of a, say b and c."
"A fifth generation approach to intelligent information retrievalOnly high level inferences require the recourse to real ""inference engines"" of the type encountered in MYCIN or PROLOG, which must make use of the complex information in the rule base. The kind of match performed by the PARSER certain characteristics which differentiate from a normal unification even if has it the mechanism is, as in PROLOG (Colmerauer basic 1983 , Colmerauer et al. 1983), a comparison of labelled trees. BRUYNOOGHE, M. (1982) ""The Memory Management of PROLOG Implementations"", in Logic Programming, Clarck, K.L., and Trnlund, B.A., eds."
Derivation of Logic ProgramsHowever, the theory of logic programs and their computations can be formalized in terms of the theory of resolution proof procedures, and, in fact, our present implementations of logic interpreters directly reflect this. The first such interpreter (Prolog) was developed in 1972 by Colmerauer, Roussel, and others at the University of Aix-Marseille and has served as a model for many other interpreters, especially notable implementations include the one at Edinburgh University developed by Warren [15] and another at the University of Waterloo. For instance, MarseiUe-Prolog allows use of the / symbol to control backtracking, while IC-Prolog at Imperial College accepts program annotations specifying coroutined calls. For instance, Prolog will not discover the refutation admitted by the following simple program: -- list(x) list(y) -- list(u.y) list(f) 380 C.J.
AnnouncementsIt is followed by a presentatioi of first-order logic, the PROLOG language and metamorphosis grammars, and the formalism of ramifications [tree-like structures, as defined by Pair] used in the third part for the definition of RW-grammars. In the second part, three experiences of implementation in PROLOG of languages defined by a W-grammar are presented. The first one is a transcription in PROLOG of the W-grammar of ASPLE, A Simple Programming Language, already used for comparing methods of definition of languages.
Quantitative artificial intelligence: how much is enough?University of Hong Kong Pokfulam Road Hong Kong In Prolog programs, arguments are often used to exchange information between relations. They are typically managed by the addition and deletion of clauses. However, most of the Prolog implementations offer little support for these operations. In C-Prolog [1], for example, a clause can only be added as the first or last clause of a relation.
"A parallel execution model of logic programsImOgOCTIOg Kowalski proposed a procedural semantics of predicate calculus [Kowalski 74], and based on this idea Prolog and other similar programming languages have been proposed [Warren 77a] [Clark 80]. Because of their semantic clarity and potential abilities as future programming languages, they are now becoming a significant alternative to Lisp in the domain of symbolic processing [Warren 77b] and intensively studied especially in Europe and Japan [Treleaven 82]. A program written in Prolog-type languages is fundamentally a set of Horn clauses, which are the restricted forms of general clauses of first order predicate logic, and its execution is conceptually an AND-OR tree search based on resolution proof procedure [Furukawa 82]. [Warren 77b] D.H.D. Warren, L.M. Pereira Pereira, ""prolog the language implementation compared with Lisp,"" Symp. on AI and programming and F. and its Proc."
Parsing as deductionThe basic notion, which goes back to Kowaiski (Kowalski, 1980} and Colmerauer {Colmeraucr, 1978), h'zs seen a very efficient, if limited, realization in tile use of the logic programming language Prolog for parsing {Colmerauer, 1978, Pereira and Warren, 1980). When using a definiteclause proof procedure, such as Prolog (Roussel. 1975), a goal statement requests the proof procedure to find provable instances of P. 2.2. The Prolog proof procedure can be implemented very efficiently, but it has the same theoretical problems of the top-d¢.wn backtrack parsing algorithms after which it is motif?
"Some remarks about the inference techniques of RESEDA, an ""intelligent"" information retrieval systemEach of the is interpreted as a procedure call which gives rise, at the end, to search patterns Note that, as in PROLOG, procedure to be tested in the fact database. calls Yi are executed left to right in the order in which they are written , thus, in the hypothesis in figure 6, condition schema A will be interpreted Two remarks of a general before schema B. nature can be made immediately : - The functioning inference engine the top-down of the execution modules of RESEDA's which we have just defined corresponds to functioning of PROLOG's interpreter (Kowalski 1982 , Colmerauer similarity exists of ""resolution by et al. 1983). Faced with these backtracking, implementers of ""cut operator"", which they, theoretical point of view"" and failures associated with the different obviously, this can be computationally the criticisms of Charniak et al. (1980 : problems, and wishing to avoid wild PROLOG have added ""patches"" such as the themselves, define as ""horrible, from a (Colmerauer et al. 1983 : 274). COLMERAUER, Hillsdale: Lawrence Erlbaum A., KANOUI, H., th 6oriques et et VAN CANEGHEM, M. (1983). PROLOG, bases developpements actuels. TSI Technique et science informatiques, FRISCH, A.M. (1983)."
An experiment in partial evaluation: the generation of a compiler generatorOn the other hand, logic programming languages such as Prolog seem to have all the desirable characteristics mentioned above, so it seems likely that a Prolog-based mix could be con - structed . Sondergaard , An Es:periment in Partial Evaluation , The Generation or- a Complier Genera - tor, DIKU Report no . 85/1, University of Copenhagen, Denmark (1985 ) Kahn, K . & M . Carlsson , The compilation of Prolog programs without the use of a Prolog compiler .
Automatic tuning of multi-task programs for real-time embedded systemsSection 4 explains the implemenlalion of TRUE by Prolog. Section 5 presents an example of how to use TRUE. TRUE expresses its working state by unit clauses in C-Prolog. The clauses includes data of user's requests, results of the analysis of the program and data of the structure of the program. Application of rules is implemented by pattern-matching mechanisms of C-Prolog. The working state is modified by the application.
SOVA - software environment for NLU of Slovenian language: U. of Edvard Kardelj in Ljubljana, YugoslaviaData base manipulation and knowledge representation, i.e semantic processing, in our system are realized with a PROLOG subsystem which brings into the LISP environment the Horn clausal form of first order predicate calculus and the corresponding deductive capabilities. One is able to express various theories of NLU in PROLOG, while on the other hand, PROLOG is a very convenient tool for maintaining and searching small experimental data bases.
"The simulation of stress patterns in synthetic speech: a two-level problemPart III deals with the actual algorithms developed to deal with the problems. A fair nount of familiarity with Prolog is assned, but the code itself is not examined too deeply. Each word is read in and instantiated to an item in a Prolog list. Element separations are indicated by commas. ""Length"" in this context refers to the length of a Prolog list, thus the list above would have a length of seven elements, each element being delimited by a comma."
Application of axiomatic methods to a specification analyserConstruction of an executable specification of an analyser like PSA is in progress using Prolog 124, 4]. The step to proving properties about that specification would be a translation of {constrained} Prolog programs to axioms and then the normal statement and proof of theorems like those in this paper. The additional liberality of Prolog (AFFIRM is a strict type and rule checker) and executability of Prolog programs (for comparison with real PSL/PSA) seems worthwhile since much time during our modeling was spent in satisfying AFFIRM's constraints. 4. Johnston, E. M. Logic Programming in AFFIRM, LISP, and Prolog. {Unpublished manuscript, GTE Laboratories) 20.
"Parsing with logical variablesOne of the Computational Linguistics made contributions to which can be concatenated together to produce a by the Logic sentence, ""S."" Prolog, a programulng language Programming Paradigm has been the Definite Clause Grammar. The resolution theorem prover that ""interprets"" the Prolog clauses would take the oegatlon of S as the goal and try and produce the null clause. Thus the preceding clause can be interpreted procedurally as, ""To establish goal S, try and establish subgoals, NP, VP and Concatenate."" DCG's provide syntactic sugar on top of Prolog so that the arrow can be reversed and the ""Concatenate"" predicate can be dispensed with."
"Abstracts of current literatureA DCG provides not only a description of a language, but also an effective means for analysing strings of that language, since the DCG, as it stands, is an executable program of the programming language PROLOG. Using a standard PROLOG compiler, the DCG can be compiled into efficient code, making it feasible to implement practical language analysers directly as DCG's. The concept of ""logic programming,"" and its practical application in the programming language PROLOG, are explained from first principles. The ideas are illustrated by describing in detail one sizable PROLOG program which implements a simple compiler. The advantages and practicability of using PROLOG for ""real"" compiler implementation are discussed."
"Prettyprinting styles for various languagesAda Style PL/I Style Ada [10] PL/I [9] Pascal [15] CSP/k [14] Edison [7] CLU [18] Modula-2 [23] Algol 68 [21] Concurrent Pascal [6] LISP Style LISP [22] BCPL [20] ML [12] COBOL [2] Prolog [8] MDL [11] One should not take the sheer number of languages in any one category as some indication of ""goodness"". If a language has a uniform, and small (typically single character) closing keyword which is also a punctuation symbol (such as ')' in LISP or '.' in COBOL and Prolog), then programmers tends to use LISP style prettyprinting. 2. SoftwareMPractice and Experience 11 (1981), 8. Clocksin, W. and Mellish, C. Programming in Prolog. Springer-Verlag, New York, N.Y., 1981. -79-9."
"Review of ""Logic for problem solving"" by Robert Kowalski. Elsevier North Holland 1979.When interpreted by a suitable theorem prover, such as a version of PROLOG, they can transform a text into its representation (and often a representation into a text) with practical efficiency. Several chapters discuss the problems and techniques for processing axioms in full clausal form, however, which shows that this book presents logic programming as a concept that is independent of any particular PROLOG implementation. Logic for Problem Solving The last part of the book introduces more advanced topics. Artificial Intelligence 13, 3, (May 1980), 231-278. [6] Silva, Georgette, and Dwiggins, Don. Toward a PROLOG Text Grammar. ACM Sigart Newsletter 73, (October 1980), 20-25. 46 American Journal of Computational Linguistics, Volume 7, Number 1, January-March 1981"
"An investigation into inference with restricted quantification and a taxonomic representationAn informative candidate list (sequence of the digits to be considered) may then be constructed for the next guess. [11 Pereira, F. (editor), C-Prolog User's Manual, EdCAAD, University of Edinburgh, Feb. 1984. [2] Shapiro, E.Y., ""Playing Master Mind Logically,"" SIGART Newsletter, No. 85, ACM, July 1983. Logic Programming: Using Restricted Quantification in Computation This section illustrates how a simple deductive problem can be handled better by a Prolog-style system once it is extended with restricted quantification and a taxonomic representation. A goal of this investigation is to find precisely when a Prolog system with restricted quantification is more efficient than one with standard quantification."
"Toward automating the software-development cycleWhat resulted was a domain knowledge base of 100 rules written in Prolog that describe the general class of real-time systems with processescommunicating by exchanging messages. The fact that it is also somewhat faster is secondary. given the current software approach. Seviora and Gupta wrote their expert system in Prolog, but even though speed was not the main priority, they found the system ""a shade slow."" One reason for their choice was the availability of good Prolog support at their university, but because Prolog has a huge knowledge base, ""You have to be careful how Prolog searches through it,"" says Gupta."
Abstracts of current literatureThis manual describes the GLISP language and use of GLISP within INTERLISP. How to Solve It with PROLOG Helder Coelho, Jose C. Cotta, and Luis M. Pereira Centro de Informatica Laboratorio Nacional de Engenharia Civil 101, Av. do Brasil 1799 Lisboa Codex, PORTUGAL Research Report, 2nd edition, 1980, 215 pages. Our purpose is to present the outstanding features of PROLOG through a collection of small problems and exercises, divided in general application areas such as deductive reasoning over data bases, natural language, symbolic calculus, etc. This is a provisional version of an evolving bibliography on logic programming and PROLOG, covering field work carried out in all known groups spread over the whole world.
Parsing with discontinuous constituentsThe utterante (1) (after lexical analysis} would be represented as in (4). Those familiar with Prolog should note that [ [lave reversed the usual orthographic convention by writing variables with a lower cae intial letter (they are also italicized), while constants begin with an upper case letter. (3) S(z ,: ) -- NP(.r ,y ,0) & VP{V ,: }. This method, top down recursive descent, is the method the programming language Prolog uses to perform deduction on definite clauses systems, so Prulog can easily be used to make very efficient top*down parsers. The command 'print state' prints the state of the deduction sy,tem, since new inferences are always added to the bottom of the state, it provides a chonnlogica/ records of the deductions made by the system. The state is printed in Prolog notation: variables are written a.s '_I', '_.~', etc., and the implication symbol (re) aprologeariey atucnscr UNSW-PROLOG : p([yarragaagamun,gudaa, gunday,hiibangun])?
"Transforming English interfaces to other natural languages: an experiment with PortugueseINTRODUCTION The CHAT-80 program for English (Warren & Pereira, 1981, Pereira, 1983) was transformed and a dapted to Portuguese. Logic Programming as a mental aid, and Prolog (Coelho, 1983, Clocksin & Melish , 1981) and Extraposition Grammars (Pereira, 1983) as practical tools, were adopted to implement a natural language interface for Portuguese. If such a match does not suc ceed, this means that the input word does not belong to the foreseen grammatical category. As a co) sequence, a failure occurs and the Prolog mecha - nism for backtracking is automatically activated. COELHO, H., ""The art of knowledge engineering with Prolog"", INFOLOGPROJ, Faculdade de Cincias, Universdade Clssica de Lisboa, 1983."
"Extraposition grammarsWhen using a definite clause interpreter, such as PROLOG [9], a goal statement ?-19 . specifies that the relation instances that match P are required. The computing facilities I used to experiment with XGs and to prepare this paper were made available by British Science Research Council grants. Appendix I. Translating XGs The following PROLOG program (for the DEC-10 PROLOG system) defines a predicate 'grammar(File)' which translates and stores the XG rules contained in File. Harman (ed.): On Noam Chomsky: Critical Essays, Anchor Books, 1974. 9. Roussel, P. ""PROLOG : Manuel de Reference et Utilisation."" Groupe d'Intelligence Artificielle, U.E.R. de Luminy, Universit 6 d'Aix-Marseille II, 1975."
Abstracts of current literatureThe program is implemented 126 American Journal of Computational Linguistics, Volume 7, Number 2, April-June 1981 The FINITE STRING Newsletter in PROLOG, a simple and powerful programming language essentially identical in syntax and semantics to a subset of predicate calculus in clausal form. In this paper, the addition of part-of-speech ambiguity to a deterministic parser written in PROLOG is described. To handle this ambiguity, it was necessary to add no special mechanisms to the parser. Chat-80 has been designed to be both efficient and easily adaptable to a variety of applications. The system is implemented entirely in PROLOG, a programming language based on logic. With the aid of a logic-based grammar formalism called extraposition grammars, Chat-80 translates English questions into the PROLOG subset of logic.
Where do we go from here?The user-oriented output format for the same event is shown in Figure 24.5, while Figure 24.6 presents the air penetration template in the Prolog language. As is apparent from Table 24.1, templates are essentially propositional structures, of varying degrees of complexity. The Prolog language is particularly well suited for handling this type of knowledge representation, providing an efficient and natural formalism for representing linguistic and extralinguistic knowledge. Fjure 24.6Air penetrationevent'templateexpressedin the Prolog language An experimental implementation of the data acquisition component which handles two subject domains for a particular type of event reporting text is operational on a PDP 11/45 processor, using Prolog as the primary implementation language.
"Listlessness is better than laziness: Lazy evaluation and garbage collection at compile-timeNext, the machine executes the output step ys 4-- cons y ys yielding the new state I i If this step is unclear, it may help to visualize how it could be written in an imperative language, ys -- new l i s t c e l l y * - @(('ys).head) ys -- @ ( ( A y s ) . t a i l ) Here i indicates ""address of"" and "" indicates dereferencing. Readers familiar with Prolog [Kowalski 79] may observe that output variables in the listless machine and logical variables in Prolog are similar in that both specify a location where output is to be placed. Because Prolog allows backtracking, logical variables are more powerful than output variables, but more difficult to implement. PhD thesis, Carnegie-Mellon University, 1984. [Warren 80] An improved Prolog implemenation which optimizes taU-recursion- Dept. of AI Research Report 141, University of Edinburgh, 1980."
The future of symbolic computation: mathematics versus languagesBesides the functional style languages, we find specially relevant the object-oriented languages, such as SMALLTALK or PLASMA, and the logical style languages, such as PROLOG. A PROLOG program is nothing else than a set of first-order specifications, whose interpreter is a theorem prover for Horn clauses. Thus PROLOG is a natural bridge between theoremproving and computation.
Relating sentences and semantic networks with procedural logicWith a growing interest in resolution theorem proving, he collaborated in the development of a more general language, Prolog, i.e., procedural logic, and developed an effective system for understanding French sentences in that formal system. Kowalski [14, 15] developed this idea of logic as procedure, and showed that suitably ordered axiom systems could be interpreted as effective procedures for solving blocks world problems, factorials, list operations, and parsing sentences. Prolog was a practical interpretation of procedural logic which convincingly showed the value of this approach to programming. These implementations had the effect of adding the very high level of operations sought by Planner [25] with very little overhead cost, resulting in an augmented LISP system that like Prolog was excellently suited for computations on natural languages.
"What not to sayA new model A new version is currently being inplemented in Prolog on a VAX11/730, avoiding many of the drawbacks and limitations of the BASIC model. On the other hand, it does include some interactive components, and some facilities for (simple) machine translation the specified domains, using Prolog intermediary level of representation. within as an The major aim, however, is not to re-implement a slightly more sophisticated version of the original Commentator, which is basically a monologue generator, but instead to develop a new, highly interactive model, nick-named CONVERSATOR, in order to study the properties of discourse. For an excellent introduction to unification and its linguistic applications see Karttunen (1984). Unification also very much at the heart of Prolog, Fornell,Jan (1983): ""Commentator - ett mikrodatorbaserat forskningsredskap for is llngvister"", Praktisk Ilngvistlk 8, Dept of Linguistics, Lund University."
Programming language issues for the 1980's: SIGPLAN '83: symposium on programming languages issues in software systemsJerry Otto (NRC) : What do you think o f Japan's 5th generation project selecting Prolog a s the language of the 80's ? Winograd: I don't think Prolog is going t o work that well . The y wished to have an attack on the problem tha t would set them clearly apart . I think Prolog i s an interesting language, with an interestin g idea . Concurrent Prolog, being done b y Shapiro, also has some very interesting ideas .
Composite document extended retrieval: an overviewAt Virginia Tech, a version of Prolog called HC has undergone substantial development [89] and has been used to construct one type of pattern parser [88]. Based on the software available as part of the Virginia Tech Prolog project, this system will aim at representing homes and children using frames and other knowledge structures. Sci., 1982. [69] Roach, J. and Fowler, G., The HC Manual: Virginia Tech Prolog. Technical Manual, Virginia Poly. Inst. and State Univ., Dept of Comp.
The extended closed world assumption and its relationship to parallel circumscriptionTo give an example of such a situation consider a simple logical statement: (1) T = Teach(pasca1) A Teach(prolog). which formalizes our knowledge about our teaching load this fall. The first requirement can be easily explained by the following example. Let T be: Teach(pasca1) v Teach(prolog). CWA for T is: T A lTeach(pasce1) h lTeach(prolog) and is obvious 1y i neons i'stent.
Chairman's columnThe main chapters deal with operations on the basic algebraic domains (integers, rationals, polynomials, rational functions, integers modulo some prime), theory and application of the Chinese remainder algorithm and interpolation algorithms, computation of greatest common divisors of polynomials (nonmodular and modular algorithms) and factorization of polynomials. Erfahrungen in Micro-PROLOG yon LPA (German) CAMP83-1.0 B. Kutzler In this paper we describe some experience with Micro-PROLOG of LPA. First we give an introduction to predicate logic as a programming language. Then the basic concepts of Micro-PROLOG for Z80-based microcomputers are presented. Emphasis is put on examples dealing with a family tree, planar map colouring, factorial of numbers, systems of distinct representatives, sorting of lists, and latin squares.
Firmware engineering and microprogramming at Colorade State UniversityThe flrst version of the system is currently being written in the logic programming language 20 Prolog with the help of doctoral student Joseph Varghese. Facilities to support VAX-11/750 In the Computer this research consists of a DEC Science Department (running Berkeley UNIX and Edlnburgh's Prolog), two CDC Cyber 720's and a Cyber 205 located in the University Computer Center.
Abstracts of current literatureThe system translates general domain English sentences into grammatical Chinese sentences in a fully automatic manner. It is written in Prolog and implemented on the DEC-10, the GEC, and the SUN workstation. SDCG is an augmentation of the DCG (Definite Clause Grammar, Pereira et al. 1980) which in turn is based on CFG (Context Free Grammar). Implemented in Prolog, the SDCG is highly suitable for NLP in general, and MT in particular. However, although I will argue for the inte-Computational Linguistics, Volume 11, Number 4, October-December 1985 The FINITE STRING LMT: A PROLOG-Based Machine Translation System Michael C. McCord IBM T.
Tutorial on artificial intelligence researchAn example of a logical representation scheme is PROLOG, a programming language in which a user program is a collection of assertions. In order to get around the drawback of not being able to represent heuristic information, PROLOG allows one to provide a dual interpretation to any one assertion. Planner, which was mentioned earlier, and Actors, which were also developed by Hewitt, and used this idea of a knowledge base simply being a collection of active agents that can pass messages between each other. Hayes: Why didn't you include PROLOG? Mylopoulos: I see PROLOG starting with the logical viewpoint and going some distance toward procedural accounting for some aspects of generic representations.
"Review of ""Approches Formelles De La Semantique Naturelle (Formal Approaches to Natural Semantics) by A. Borillo, M. Borillo, L. Farinas del Cerro & J. Virbel"", Laboratoire de Langages et Systemes Informatiques Toulouse, France 1982As in most collection of papers, those in this report vary in quality, but we suspect that many AI researchers in natural language (presuming fluency in French) might find something of interest and certainly a different perspective in this book. ARTICLE may reasonably have concluded that Prolog was a suitable MASTERING MASTER MIND LOGICALLY Peter Koppstein Department of Political Science Washington University St. Louis March 1, 1984 INTRODUCTION Some readers of the recent note by Ehud Shapiro on ""Playing Master Mind Logically"" (SIGART 85, July 1983) language for a ""generate and test"" strategy, as the author stated, but that perhaps there was something intrinsic to Prolog that made anything much more subtle unwieldy. The present note at any rate shows how a more ""logical"" strategy incorporating that previously described may readily be implemented without compromising the elegance and simplicity of Ehud Shapiro's original problem."
"A hierarchical structuring method for functional software systemsOur method for well-structuring software systems would be applicable to logic programming languages such as Prolog. Moreover the unification mechanism of Prolog seems to be amenable to parameterization. So we think that Prolog-like logic programming languages are very promising as a base system for our structuring method. Joint Conf. on Artificial Intelligence, Jui.1977, 1045-1058 [6] W.F.Cloekin and C.S.Mellish, Programming in Prolog, Springer-Verlag, 1981 [7] J.Darlington, The structured description of algorithm derivations, in ""Algorithmic Languages"", Eds. de Bakker and van Vliet, North Holland, 1981, 221-250 [8] E.W.DiJkstra, Notes on structured programming, in ""Structured programming"", Academic Press, 1972, 1-82 [9] K.Futatsugi and K.Okada, Specification writing as construction of hierarchically structured clusters of operators, Proc. of IFIP Congress 80, Tokyo, Oct.1980, 287-292 [10] K.Futatsugi, Hierarchical software development in HISP, in ""Computer Science & Technologies 1982"", Japan Annual Reviews in Electronics, Computers & Telecommunications Series, OHM/North Holland, 1982, 151-174 [11] J.A.Goguen, J.W.Thatcher and E.G.Wagner, An initial algebra approach to the specification, correctness, and implementation of abstract data types, in ""Current trends in programming methodology, VoI.IV: Data Structuring"", Ed."
"Review of ""ACM'84 Conference""In summary, it was pointed out that Fifth Generation means long-term research, and was not the big story at ACM'84, however, the big story turned out to be Artificial Intelligence. In spite of the origin of LISP in America and PROLOG in Europe, both AI languages seemed to have comparable strength in their followers. One vendor, Teknowledge, Inc. used both languages, LISP for its S.I, an integrated package of software designed to assist knowledge engineers in the development of large-scale knowledge systems to solve practical problems, and PROLOG for M.1. The M.1 software tool is appropriate for developing small-scale applications of knowledge engineering, requiring up to 200 knowledge base entries to be loaded at any one time on an IBM PC."
"Review of ""Unsolvable classes of quantificational formulas"" by Harry R. Lewis. Addison-Wesley 1979. and ""The decision problem: solvable classes of quantificational formulas"" by Burton Dreben and Warren D. Goldfarb. Addison-Wesley 1979.This interest arises from work in artificial intelligence (theorem proving and its applications in expert systems, robotics, program proving, and intelligent query systems), in data base systems (particulary relational data bases), and in new programming language concepts (PROLOG). Both the existence of algorithms to solve first order logic problems and the efficiency of such algorithms are of interest. The development of heuristics for the unsolvable cases takes on increasing importance in light of the preliminary choice of PROLOG as the programming language for Japan's Fifth Generation Computer effort."
Parallel evaluation of recursive rule queriesThesequeriesare a subset of first-order relational queries augmentedwith recursion. They form an importantpsrt of the PROLOG languageaud canbe eva!uatedin PTIME. In [32] Sagivhas shownthatit isdecidablewhetheratypedrecursiverulequery is equivalentto a first-orderrelationalquery. To copy otherwise, or to republish, requires a feeand/or specific permission, In this paperwe study recursiverule queriesdetinedby Horn &uses, e.g.,[4,39,26,8,16J. Suchquerieslie at the heartof PROLOG(whenusedas3 relationalquerylanguage), The expressivepowerof Horn clauseshasbeen examinedin m. Our approachis motivatedby the current researchon pamIle implementations of PROLOG (e.g. [33?). We will considerthata querycanbeevaluatedeffrciendyin parallelif it can be evaluatedby a NC algorithm[ll, 311.
The Art and Science of ProgrammingA Denotetional Semantics of the logic programming language Prolog is expressed in Algo1-68. The result is a formal definition that is also executable. It is presented as an example of high-order programming' in Algo1-68, the eventual aim is to use this to compare differing brands and implementations of Prolog formal Iy and experimental Iy. Introduction. Pagan [i] suggested the use of Algo1-68 as a metalanguage to write denotetional definitions in, but he recognised that to translate the highly curried functions in e I-I manner would require partial parameterisation[2]. Its declarative semantics are to be understood as first-order logic but Prolog implementations invariably include non-logical features for various reasons, notably for efficiency but
Knowledge based systems versus thesaurus: an architecture problem about expert systems designDefude: KBS versus thesaurus 275 - Production rules : The thesaurus is mainly composed of static relations connectina items to each others, hence the formalism of production rules which expresses actions does not seem to be an appropriate one. 3.2 The impact of inteoration : - Several kinds of important, semantical actions can be foreseen within an integrated thesaurus: If we use first order predicate calculus we can use as deduction tool some problem solver or some logical languaoe interpreter (like PROLOG (Roussel the deduction process. 1975)) for example. Rachine intellioence Y.H Pao. LOGLISP : an alternative to PROLOG. 10, edited by J.E Hayes, D Hichie and P Roussel (1975). PROLOG Manuel de reference el d'utilisation. Groupe d'intelligence artificielle, UER Nsrseille Luminy.
"Tracing occurrences of patterns in symbolic computations., say, searches for possible factors of the last symbolic expression given in Section 4, in which it may be desired to find resolutions of each numerical coefficient into a product of two integers). Our experience with PROLOG (7), which supports and even unduly encourages this kind of computational behaviour, suggests that the only safe automatic searches may need such tight limitations that they become trivial, and therefore of trivial value to the user. We intend, nevertheless, to try to escape from that impasse by implementing more selective forms of automatic backtracking (8) than have been used in general for PROLOG and similar systems for work in artificial intelligence. Coelho, J.C. Cotta and L.M. Pereira, ""How to solve it with PROLOG"" (Laboratrio Nacional de Engenharia Civil, Lisbon, 1979) 8: L.H."
Expression evaluation in the icon programming languageSuch difficulties in Algol-like languages illustrate the motivation for higher-level languages with nondeterministic expression evaluation and patternmatching facilities with search and backtrack strategies -- languages like SNOBOL4 [1], Prolog [2], and Icon [3]. Languages like these are oriented toward features that allow the programmer to express relationships at a high level. Clocksin, W. F. and C. S. Mellish. Programming in Prolog, Springer-Verlag, New York. 1981. 3. Griswold, Ralph E. and Madge T. The Icon Programming Language, Prentice-Hall, Inc., Englewood Cliffs, New Jersey. 1983. . 5. Campbell, J. A., ed. Implementations of Prolog, Halstead Press, New York. 1984. Griswold, Ralph E.
Programming with EquationsThe style of semantics based on logical consequences seems most appropriate to descriptive or applicative languages such as LISP, Lucid, PROLOG, and the Red languages, although ALGOL-like languages may also be defined in such a way. Theoretically, any logical language with a complete proof system could be used to describe programs. The PROLOG language [26] uses the first-order predicate calculus as a programming language. The implementation of PROLOG is based on backtracking, a potentially costly strategy.
Generators in IconMost artificial intelligence languages deal with lists and are usually based on the syntax of LISP [29]. PLANNER [23] and PROLOG [4, 39], which use theorem-proving techniques for AI research, provide pattern-directed procedure invocation. In PROLOG, for example, the theorem to be proved is used to select the procedures to invoke. WARREN,D.H.D., PEREIRA,L.M., AND PEREIRA,F. Revised report on the algorithmic language PROLOG--The language and its implementation compared with LISP.
"Present and future paradigms in the automatized translation of natural languagesThese systems rely on a general algorithm over which the rules have no control. Systems allowing such controls (PROLOG [52], ATEF [14, 15], ROBRA [50], ATNs [47] and derived models like REZO [32], PLATO, DEDUKT [18, 20]) were created in the seventies. Many recent specialized programming languages include a form of non-determinism, but very few have parallelism (ROBRA) or control functions for heuristics (PROLOG, ATEF, REZO). Of course, these metalanguages should include more classical control structures such as iteration, recursion or selection. Van Caneghem (1979), ""Etude et ralisation d'un systme PROLOG"", Groupe d'Intelligence Artificielle, Univ. d'Aix-Marseille II."
"A relational data base machine: First step to knowledge base machineRelational model was chosen as the data base model for Delta because of its affinity to logic programming languages such as Prolog and ICOT's Fifth Generation Kernel Language, that is SIM's machine language. Murakami: A Relational Date Base Machine ""Delta"", ICOT TM-O03. [4] S. Kunifuji and H. Yokota: PROLOG and relational databases for fifth Generation Computer Systems, Proceedings of the CERT82 workshop on ""Logical Bases for Data Bases"", 1982. 425"
A semantic prototyping systemThe basic modification is the removal of the so-called occurrence check in the algorithm, as is done in many Prolog implementations. [LA. Robinson, personal communication]. In addition, we have used the type-checker by itself on several problems (including a second implementation of Prolog), with good results. The following table shows the approximate size of the various modules in the system: Section Lines Auxiliaries 161 Unifier 93 Checker 416 Transducer 54 Yacc interface 195 Global type dcfs 104 Total: 1013 Implementation time was approximately 2 man-weeks spread over a period of about 2 months. Description Applicative Lang. with input/output Imperative Lang. with blocks and declarations Mini-Prolog Multiprocessing Parameter Passing Storage Allocation ASPLE [Marcotty et.al. 76] Lines Author 300 M.
A course in programming languages for educational computingSmalltalk object-oriented programming . an d Smar t programming tools, mice, etc . PROLOG an d non-procedural languages . Since no text was considere d suitable, I distributed notes on mos t topics . This led to a discussion of CAI and its problems . Smalltalk and PROLOG were presente d (in class , no interpreters were availabl e for lab use) as showing two possibl e directions in .which the future might tak e us, and were used also to illustrate th e difficulty of language design an d implementation .
Functional requirements for very large knowledge basesCurrently, there appears to be no discipline to control computability in current logic languages such as PROLOG. Using FCP, infinite looping is still possible but unlikely. The wealthy user could then involve logic machines all over the world in his search for an answer to a particularly important question. I. Babb, E, The logic language PROLOG=M in database technology and intelligent knowledge-based systems.
"Stanford emulation laboratoryWe are continuing our DEL studies by looking at both Lisp and Prolog languages as well as ""C"" architecture. Personnel and Research Projects Staff includes pre- and post-doctoral researchers as well as visitors. Tick: Machine architecture for concurrent execution of Prolog programs. • J. Johnson: Machine organization for high-speed interpretation of directly executed language instruction streams. • R."
Abstracts of current literatureThis paper describes how meanings are represented in a semantic grammar for a fragment of English in the logic programming language Prolog. The conventions of Definite Clause Grammars are used. The second section describes how ),-calculus meaning representations can be constructed and manipulated directly in Prolog. This 'programmed' representation motivates a suggestion, discussed in the third section, for an extension to Prolog so that the language itself would include a mechanism for handling the )`-formulas directly.
Introducing computer algebra to users and to studentsTechnically this means using some techniques of artificial intelligence. 3 Once the principle of point 2 is adopted, it is natural to also add theorem proving to the capabilities of such a system. This is better done using PROLOG than any other language. Now at least two versions of PROLOG implemented in LISP are available.
The design of the kernel architecture for the Eurotra softwareWe have therefore chosen to express data definitions in the precise, but over general terms of first order logic, which are then embedded with very little syntactic transformation into the database of a standard Prolog implementation (Pereira & Byrd 1982). The augmented interpreter then constitutes the MMU referred to above. (that contains rather more odd symbols) conforms to the input requirements of the Unix 'make' program. targettext : ((cpu< eurotra)< sourcetext > targettext /*capply*/ eurotra : compiler < usd >eurotra /*apply I*/ COMPILER : yacc controldef MMU : echo 'save(mmu)' I prolog dd CPU : echop '(damplisp cpu)' I lisp Lesk, M.E. (1975) -Lex : a Lexical Analyzer Generator, Computing Science Technical Report No. 39, Bell Laboratories, NJ. Pereira & Byrd (1982) - C-Prolog, Ed CAAD, Department of Architecture, University of Edinburgh.
"Linguistic and computational semanticsProgramming language semantics, for reasons that can at least be explored, if not wholly explained, have focused primarily on q,, although in ways that tend to confuse it with . Except for PROLOG, which borrows its • straight from a subset of first-order logic, and the LIsPs mentioned earlier, is we have never seen a semantical account of a programming language that gave independent accounts of • and ,1,. What is perhaps surprising about aII of this machinery is that it must be brought to bear on a purely procedural language -- all three relationships (O, 4,, and .) figure crucially in an account even of LISP. we are not suggesting that LzsP is like natural languages: to point out just one crucial difference, there is no way in LISP or in any other programming language (except PROLOG)tO say anything, whereas the ability to say things is clearly a foundational aspect of any human language. Clocksin. W. F., and Mellish, C. S., Programming in Prolog, Berlin: Springer-Verlag, 1981. Donnellan, K., ""Referencesnd Definite Descriptions"", Philosophical Review 75:3 (1966) pp. 281-304, reprinted in Rosenberg and Travis (eds.), Readings in the Philosophy of Language, Prentice-Hall, 1971."
A survey of available systemsOr more precisely, how it may be automatically interpreted in Prolog language. Finally we describe how this methodology respects the independence of the types and how it authorizes the implementation of hierarchical types in a way which takes its inspiration partly from the Martin-LOf's theory of types (1972-80) and partly from Burstall and Goguen (1977). Then we discuss implementation problems of a programming language, PROLOG (see in [1,2]), i.e. those theoretical considerations which are expected to result considerable improvements for PROLOG's implementations. Kowalski, Logic for problem solving, North-Holland, New York (1979). [2] P. Szeredi, I. Fut 6, PROLOG manual (Hungarian), Journal SZAMOLOGEP VII No. 3-4 (1977), pp. 5-130. [3] V.
"Adaptive interpretation as a means of exploiting complex instruction setsWhen considering support for languages such as LISP and PROLOG [7] the situation is somewhat different. These languages are very demanding in terms Of runtlme environment which leads us to suspect that more direct support at the machine level would offer a substantial improvement over the usual implementations on conventional machines. For non-numerlc processing where operations such as pattern matching ape important, efficient interpretation of languages such as LISP and PROLOG will probably derive great benefit from hardware support different from what is provided on the VAX. Eleventh Annual Workshop M"" , November 1978. [6] Unix_r_Qgr_ammez'_ila/_, 7th edition, Vol 2b, Jan 1979, Bell Telephone Labs Inn, Murray Hill, NJ. [7J D. H. Warren, and L. M. Perelra, ""PROLOG - The Language and its Implementation Compared with LISP,"" SIGART Newsletter, No. 64, pp. 109-115. [8] James R."
"Expert systems and other new techniques in MT systemsThe first is inserted at the junction between analysis and transfer, and the second between transfer and generation. 469 The control structure of a corrector system is as follows : (1) transform the result of analysis suitable form , into a (2) while there is some error configuration solve (using meta- or extralinguistie knowledge) , if solving has failed then exit endif (4) perform a partial reconstruction do , of the structure, according to the solution found , endwhile , (5) output the final structure in ARIANE-78 format. (2) relies on metalinguistic knowledge only. The implementation has been done in FolI-PROLOG (8). The lingware used corresponds to a small English-French system developed for teaching purposes. Thse de 3me cycle, USMG, Grenoble, juillet 1983. (8) Donz Ph. ""Foil, une extension au langage PROLOG"". Document CRISS, Grenoble, Universit II, fvrier ]983. (9) Gerber R."
The Fifth Generation grail: A survey of related researchWe believe that this deficiency is rooted in the fact that most current logic-based systems (in particular PROLOG/Rob 65/) are implemented on singleprocessor von Neumann architectures. These systems have their roots in Colmerauer's metamorphosis grammars/Co 175/, consisting of rules that map directly into the PROLOG subset of logic. Even though the scope of possibl queries that may be expressed by each system is limited to a small subset of natural language, the research demonstrates clearly the applicability of logic programming in the domain of natural language processing.
Rule-based systemsIn this regard, they have much in common with object-oriented architectures like Smalltalk and Ada@packages. PROLOG was the first general-purpose logic-based programming language. PROLOG is essentially an RBS that uses stored facts and rules to deduce solutions to goal patterns. M.l marries the rule-based programming capabilities of PROLOG, RITA, and ROSIE to the evidence-combining capabilities of MYCIN.
A method of large-scale software developmentProgrammers is can create programs in a high-level language image without knowing the prolog and epilog codes. A procedure declaration (PROC) states whether a module is a master module or a slave module and, if it is a slave module, which master module it belongs to. necessary, the exception processing exit for the entire CCTS is also declared. t i Slave Module I II i CCTS 1 Slave odule tI Slave Module [ CCTS I Figure.2 The CCTS rules The module linkage macros are listed below: PROC: Procedure declaration (master/slave), prolog processing, stack push-down, linkage establishment, common control table fetching, error processing exit registration (master only) END: Procedure termination declaration, epilog processing, stack pop-up, release of areas acquired under memory management RTN: Normal return processing EXIT: Jump to exception processing exit CALL: Procedure call (through DISPATCHER) The relationships between these macros are shown in Figure 3. 2.2 CCTS and Memory Management The periods during which work areas are required vary considerably with the program logic.
Machine translation of natural languagesNon-Latin alphabets: not an immediate problem 19. a. VAX 11/750 running UNIX b. PROLOG, soon to be POPLOG c. not known yet 20. menu-driven grammar rule, dictionary entry input 21. not known II. The implementation: A DCG parser of English sentences written in PROLOG, and a Chinese generator working on the parse tree. 17. Non-Latin alphabets: Hanyupinyin, a romanization system for spelling Chinese. 19. a. DEC-10, Tops 10 and GEC, Unix, respectively b. PROLOG 1.3 (Edinburgh) c. 30 thousand words Boguraev, B.
The design of a computer language for linguistic information. • A ZETALISP version for the Symbolics 3600 using a left-corner parsing algorithm and the KIMMO morphological analyzer, with an extensive programming environment {due primarily to Mabry Tyson} that includes incremental compilation, multiple window debugging facilities, tracing, and an integrated editor. • A Prolog version (DEC-10 Prolog) running on the DEC-2060 by Fernando Pereira, designed primarily as a testbed for experimentation with efficient structuresharing DAG unification algorithms, and incorporating an Earley-style parsing algorithm.
"Negation as failure for first-order queriesMotivation The ""negation by failure"" rule forms the basis of negation in logic programming Languages based on definite clauses such as Prolog. Apt and van Emden's theory of finite failure sets provides a theoretical basis for this ""negation by failure"" rule. This rule forms the basis of negation in logic programming languages such as Prolog. It is further shown by Apt and van Emden. and by Clark [1978]. that if -Q can be inferred under finite failure from a set S of definite clauses then there exists a first-order proof of -Q from S"". "" where S is called Clark's completed database and is derived from S by a process which. roughly speaking. replaces all ""if"" clauses by ""iff"" clauses."
Abstracts in software engineeringWe discuss Horn claus e logic, which has a procedural interpretation, and the predicate logic programming language , PROLOG, to specify and verify the functional correctness of secure systems . The PROLOG syste m possesses a powerful pattern-matching feature which is based on unification .
Pattern matching algebraic identitiesThere are many examples of pattern MACSYMA include such systems. matching systems • Both REDUCE and PROLOG is a programming language based on pattern matching. The time taken symmetric functions with less than increases factorially with the number of parameters. The PROLOG pattern marcher does not have facilities to handle s3nmnetric functions.
The problem of producing teachers with computing expertise within the school systemIndeed, no w computes are used as a teaching aid i n primary schools with LOGO and PROLOG . A further defficiency that teacher s had to cope with is that the class size s are usually quite large (25 - 30), an d often schools may have only 1 or 2 micros . A progra m for teaching school children to program i n a logic based language (PROLOG) has bee n underway for a couple of year [5] .
Abstracts of current literatureThis frees the grammar writer from determining each point at which such ambiguities can occur. The paper presents an algorithm, written in PROLOG, for processing English sentences which contain either Gapping, Right Node Raising, or Reduced Conjunction. Lexical Function Grammar (LGF) (Kaplan, Bresnan 1982) is a powerful formalism for that purpose. In this paper, the Prolog implementation of and LFG system is described. Prolog provides a good tool for the implementation of LFG.
Abstracts of current literatureCognitive Science Research Paper CSRP 035, April 1984, 106 pages Abstracts of Current Literature Abstracts of Current Literature This is the manual for the ProGram grammar development system (written in Prolog) intended for use by linguists and computational linguists developing grammars for significant fragments of natural languages. Computational Linguistics, Volume 10, Number 1 January-March 1984 The FINITE STRING Knowledge Engineering Approach to Morphological Analysis Harri Jappinen, Aarno Lehtola, Esa Nelimarkka, Matti Ylilammi Helsinki University of Technology Helsinki, Finland Proc. EACL 1983, pp. 49-51 A PROLOG Implementation of Lexical Functional Grammar as a Base for a Natural Language Processing System Werner Frey, Uwe Reyle Department of Linguistics University of Stuttgart West Germany Proc. The paper consists of three sections: (I) We give a detailed description of the PROLOG implementation of the parser, which is based on the theory of lexical functional grammar.
The future of APLFor example, several people have written a form of PROLOG in APL. Now if we were to compile the PROLOG functions we would effectively have, subject to working out the details, an extended specialty language for logic applications which would operate with equal eflciency on the PROLOG primitives and on the APL primitives.
Declaration-free type checkingHOPE ill, Standard ML (11). SASL 1201 FEL [6, 121 and Prolog (31). Consider the following definitions in such a language: Flatten nil = nil Pletten [x] = [xl-nil flatten (x.y) = append [flatten x, flatten yl append [nil, yl = y append [a.x, yl = a . appendlx,yI for example: flatten ([11.([21.[31)). Clocksin, W. F., Melllsh, C. S.. Programming in Prolog. Springer-Verlag, New York, 1981. Dames, L., Milner, R. University of Utah, 1983. Mishra, P. Towards a theory of types in PrOlOg. International symposium on logic programming.
Query Optimization in Database SystemsA tool often proposed in this context is the logic programming language Prolog [Kowalski 1981]. Parsaye [1983] proposes extensions to Prolog specifically designed for database and knowledge-base management. JARKE, M., CLIFFORD,J., AND VASS1LIOU,Y. 1984. An optimizing Prolog front-end to a relational query system. In SIGMOD 84, Proceedings of Annual Meeting (Boston, Mass., June 18-21). Unpublished manuscript, Computer Science Dept., Imperial College, London. KUN1FUJI, S., AND YOKOTA,H. 1982. Prolog and relational databases for Fifth Generation Computer Systems.
The aggregate update problem in functional programming systemsA similar controversy arises in logic programming, where arrays have been introduced .tunctionally' into certain dialects such as LM-Prolog. For example, the primitive call select(r, i, v> might bind v to the ith element in the array a, and upd8ts (olda, i, v,nerrr) might bind neua to a new version of oldo whose itb element has the value v. For example, in a functional 2Perhaps a more fundamental aggregate issue in Prolog is the use of ASSERT and RETRACT to add clauses to and delete clauses from the .databasea. language we can use operators such a6 TREPLACE in FEL [IO], or RPLACA and RPLACD in Lisp. A better alternative is to employ a variation of 8 technique first introduced by Ken Kahn for implementing arrays in LM-Prolog (91. The strategy is as follows: When an update upd(r,i,x) is about to be perlormed, modify the aggregate in place, but leave a truiler at the head of the old references to the aggregate that indicates that position i has been modified, and its correct value is sel(a,i).
"Special issue on AI and Database researchA given logical specification may have any number of different realizations which may or may not ""look like"" logic. For example, PROLOG based realizations reveal their logical foundations while semantic networks and most knowledge representation languages, with their specialized interpreters, disguise it. In Chakravathy et al. [1981, 1982] alternative methods of interfacing a predicate logic program with relational database in a system such as PROLOG are described, Approaches discussed are modifications to PROLOG interpreters and meta-level constructs. Cark and F. McCabe (1979), The control facilities of IC-PROLOG, Expert Systems in the Micro-Electronic Age, D."
Logic and algebraic computationFinally, for the time being computational logic very concretely may be of practical use by providing logic-based programming languages such as PROLOG for the implementation of symbofic algorithms.
PROMPTER: a knowledge based support tool for code understandingIt is written in PROLOGand SPOOL (an object-oriented language based on PROLOG.) Figure 2 shows the sample inputs and outputs of PROMPTER. 3.1 ORGANIZATION OF PROMPTER Reflecting the discussion of the previous sections, PROMPTER consists of the following four parts. Given the source code of.a program, it produces a higher level description of the program using the domain knowledge. It is based on an object-oriented language on PROLOG. This language helps us organize the knowledge and make it reusable.
Using restriction to extend parsing algorithms for complex-feature-based formalismsThe indexing can be done by discrimination nets, or specialized hashing functions akin to the partial-match retrieval techniques designed for use in Prolog implementations [16]. 6 Conclusion We have presented a general technique of restriction with many applications in the area of manipulating complexfeature-based grammar formalisms. Miyoshi. and H. Yasukawa. BUP: a bottom-up parser embeddad in Prolog. New Generation Computing, 1:145-158, 1983. [8] Montague, R.
HOPE: An experimental applicative languageIt bears some resemblance to a number of other languages, including PROLOG [30], ML [17], SASL [28], OBJ [15], SCRATCHPAD [22], and languages by Burge [4] and Backus [2]. Warren, D.H.D, Pereira, L.M. and Pereira, F.C.N. PROLOG -- The Language and Its Implementation Compared With LISP.
"Concurrency control mechanisms and the serializability of concurrent tree algorithmsThe node to which the operation is applied is called the critical a, the events prior to the critical operation constitute the transaction prolog, and the interval between critical operation invocation and ""commit"" is the critical interval. Proof (sketch): For each transaction T in L, identify its critical operation, determine if it involves recovery, and appiy the following transformations: (1) for each recovery on behalf of T in L involving node""X"", create a new sequence by removing all event 6 on behalf of T involving the original version of node""X"", (2) move all events unrelated to T out of T's critical interval, forming a sequence such that the events in T's critical interval are serial in T, (3) move all events unrelated to T out of T's epilog, forming a sequence such that the events in T's epilog are serial in T, and (4) move all events unrelated to T out of its prolog, forming a sequence L'(T) that is serial in T."
"Abstracts of current literatureChat-80 has been designed to be both efficient and easily adaptable to a variety of applications. The system is implemented entirely in PROLOG, a programming language based on logic. With the aid of a logic-based grammar formalism called extraposition grammar, Chat-80 translates English questions into the PROLOG subset of logic. The resulting logical expression is then transformed by a planning algorithm into efficient PROLOG, cf. ""query optimization"" in a relational database. Finally the PROLOG form is executed to yield the answer. On a domain of world geography, most questions within the English subset are answered in well under one second, including relatively complex queries."
Reducing program development costsThe root file serves as a director y to the rest of the workspace . The prolog file contains parametric information such as IDS (integrated display system ) tab stops, parameters (such as line number increments ) used for editing, file equations to be used at execution and the like . _p. 280 PRINT USING Det.Il 1 Enid_ ,..M, Rey_hour ., O1_hourt, Nour Iy_ _ Figure 7 data in the active workspace ' s prolog file, source text in an y module of any workspace to which the user has legitimate access, listings and maps produced by the compiler, segmenter, linker and the like .
VLSI: machine architecture and very high level languagesHowever a number E includes notations such as LISP, COBOL of interesting languages, having the advantages of both groups, lie at the intersection of DL and E. These include Prolog, SASL and the dataflow languages. This allows a problem to be specified in a variety of notations tics are given) familiar to the requester intersection language denoting (as long as the formal semanand then transformed into an an efficient computation. Sickel referred to Hoare's program FIND in its first order predicate calculus specification gram. and transformed it into a Prolog pro-Daniel Friedman of Indiana University continued the theme of applicative programming, discussing ing parallel processes within the encapsulation and control of contenddata structures.
Abstracts of current literatureThis paper discusses the system described above and outlines additional advantages this approach has for explanation. Last Steps towards an Ultimate PROLOG A. Colmerauer, H. Kanoui, and M. Van Caneghem Groupe d'lntelligence Artificielle Faculte des Sciences de Luminy Universite d'Aix-Marseille II 13288 Marseille Cedex 9, FRANCE Proc. 7th /JCA/, vo/. 2, August 1981, 947-948. 276 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 The FINITE STRING Newsletter A portable version of PROLOG, an Artificial Intelligence language, is presented. The general methodology of the implementation is discussed in terms of an abstract machine (Micromegas) supporting a language (Candide) in which the PROLOG system is written. Six Topics in Search of a Parser: An Overview of AI Language Research Eugene Charniak Department of Computer Science Brown University Providence, Rhode Island 02912 Proc. 7th IJCAI, vol. 2, August 1981, 1079-1087.
Architecture of the Symbolics 3600The 3600 is optimized for Lisp (3,4), but is designed to accomodate other languages as well, including symbolic languages such as Prolog, and conventional languages such as Fortran and Pascal. As an example, this paper briefly discusses the implementation of Pascal. The Prolog machine model is somewhat different,its architecture willbe discussed in a companion paper (5).
About This Issue…They briefly describe the relationship between these concepts and the programming language PROLOG, and con-Computing Surveys, Vol. 16, No. 2,June 1984 100 • About This Issue clude with a lengthy list of current research problems in the field.
Operating systems: a perspective on future trendsThe Japanese have made an 'all out' commitment to build the Fifth Generation computer system and assert themselve: as industry leaders in the computer fie!d. are VI$I, Data Flow, Prolog, and knowledge based systems. The main ingredients of the project An important focus of the Japanese effort is on intelligence.
LESK: a language synthetizing natural language, computer language and logicA partial implementation has been developed in DEC 10 PROLOG. A LESK system should be capable of answering any question (expressed in LESK) which a person could answer from the same LESK knowledge base.
18th edition of Computer-Oriented Bibliography lists 303 new booksA good one is Toure tzky's LIS P: A Gemle Introduction to Symbolic Computation. Another AI-related language book is Micro- PROLOG by Clark and McCabe. Six new books were published on ADA and three on the C language.
My view of the future of symbolic and algebraic computationAn effort of similar intent h been the Newspad project at IBM. 5. Expertise Prolog advocates have entered the field of algebraic manipulation.
"The software knowledge baseSTATE OF THE SYSTEM After the initial' specification and design phase, the SRR project currently (June 1985) pursues the following tasks: l The CRAC calculus has been defined preciseIy'3 and is being further refined to include diverse kinds of object manipulation and user queries. l A prototype has been implemented in Prolog"", an alternative approach, using the relational data base management system Ingres, is pursued concurrently. McLennan, ""Overview of Relational Programming,"" SIGPLAN Notices, vol. 18, no. 3, pp. 3&44, March 1983. Lucia Dimas dos Santos Mendes. ""A Prolog Implementation of the Software Knowledge Base,`* Forthcoming Master's Thesis, University of California, Santa Barbara, 1985."
small-X — a language and interpreter for building expert systemsSome AI products have made their way to personal computers. There are versions of LISP and PROLOG that are readily available for personal computer systems.
"Relational algebras, logic, and functional programmingFor some applications lists are an appropriate structure, but all too frequently they are inappropriate, both as a means of expressing the problem, and as a representation to assist computation. Lists have even intruded into PROLOG! [e.g. CM 81]. Indeed one could conjecture a paper titled, ""Lists considered harmful"". Vol. 1, N o 1976, page 9-36. 1, March CM 81 Clocksin W.F. and Mell i s h ""Programming in Prolog"" Springer 1981. C.S. CODD 70 Codd E.F. ""A Relational Model of Data for Large Shared Data Banks"" CACM Vol."
Text knowledge bases: University of Texas at AustinProgramming was accomplished in LISP and in a procedural logic system, HCPRVR, based on PROLOG, but embedded in LISP. The current result of these efforts is a system of parsers, grammars, and discourse analyzers that are reasonably effective for translating expository text into structured conceptual hierarchies, resolving pronominal and definite NP References as a subprocess of of the translation.
"An informal approach to formal specificationsFinally, systems based on theorem-proving, e.g. Prolog [WPP], can run specifications expressed in logic. A. van Wijngaarden et al (eds.) - ""Revised report on the algorithmic language AlgOL 68"" - Acta Informatica, 5 (1975) 1-236. D.H.D. Warren, L.M. Perelra and F. Pereira -""PROLOG - the language and its implementation compared with LISP"" - Proe."
Predicative programming Part IIt has been the goal of at least three distinct research efforts to be able to reason directly, mathematically, in the programming notation: the functional programming of Backus [1], the LUCID project of Ashcroft and Wadge [0], and the PROLOG project of van Emden and Kowalski [4]. In spirit, the PROLOG project is closest to the present work, choosing the language of predicates for reasoning.
Themes from 1972It is presented to give using the a sense of how the program appears in Dan Chester's version of PROLOG. The rest of the LISP program follows the poem, verse, and Keats-LINE given above.
Generative communication in LindaOther reports discuss Linda in relationship to Shapiro's Concurrent Prolog [14] and to several AI languages [13]. We also omit any discussion of formal semantics here, some semantics issues are discussed elsewhere [ 131. 2. It also resembles in a rudimentary but significant way the pattern-matching features that are part of some AI and logic languages, particularly Prolog [26]. The in( ) statement and the Prolog assertion both deal with tuples whose unspecified components (the formals) may be inferred (the values). from some arbitrary specified subset Just as components of -t may be actuals, any component of a +t tuple, except for the initial name-valued actual, may be a formal.
"An informal approach to formal specificationsFinally, systems based on theorem-proving, e.g. Prolog [WPP], can run specifications expressed in logic. mning speciflc•tions allow testing and experimentation (prototyping), the importance of this feature comes from the impossibility to prove the euiv•lence between an initial informal description and (any kind of) formal specification. A. van Wijngaarden et al (eds.) - ""Revised report on the algorithmic language ALGOL 68"" - Acts Informatica, 5 (1975) 1-236. D,H.D. Warren, L.M. Pereira and F. Pereira - ""PROLOG - the language and its implementation compared with LISP"" - Proc."
Projects at Technische Universitaet BerlinHeart' of this system is the propositional representation language MSRL (Modal Semantic Representation Language) a logical language similar to PROLOG, but with vital extensions. We distinguish between terms and formulas, whereas only formulas can be true or false.
Fredkin Match at IJCAI-81. & Van Caneghem, M.: Last steps towards an ultimate PROLOG. Proc, 7th IJCAI-81, Vancouver, Aug. 1981. [6] Coppo, M.: An extended polymorphic type system for applicative languages.
Constraint languages for computer aided designWe can teach Bertrand how to satisfy new constraints by giving it rules. These rules are similar to clauses in Prolog or production rules in production systems. Other Constraint Languages One of the first computer aided design systems, Sketchpad, written by Ivan Sutherland at MIT in the early 60's, was also one of the first constraint languages.
On the scope of static checking in definitional languagesThere have been designed two basic forms of expressing assertions in assertive programming t Horn clauses, used in logic programming with the most eminent example of PROLOG language (adopted as a main software development tool in Fifth Cneration Computer Project in Japan [P/chi, 1983] ) and conditional equations being the basic notion of so called functional or definitional languages. Such an approach was taken by [Milner, 1972] in his Logic of Computable Function system for Lisp programs and recently proposed for PROLOG program development. Once the tools for verifying specification inclusion are developed a recommended systematic dovolopmont process could be based on specification Proceedings acm'84 Annual Conference The Fifth Generation Challenge 1984 October 8-10 transformations.
A new universal microprogram converter(i) Pre-checking rules: Before conversion, check to see if there are any rules for conversion of n statements (2) Conversion rules: The real conversion is done in this phase (n statements convert to m statements). (3) Post checking rules: After conversion, check to see if m statements contradictions Although PROLOG is used in this have any kind of processing (i) as rule description and interpreter, system dependent languages as an are defined and another interpreter is developed this time. at Table 1 shows the conversion description language. rule Old microprogram Source statements Universal converter Micro-operation New microprogram Definition Source statements Assembler Linker New microprogram Object Fig. 1 The system flow for conversion of microprograms ] F Conversion Execution F--- Rules Translator Table Old microprogram Source , 1 statements Execution Control New .... .....
Software engineering for undergraduatesClocksin, W . F . and Mellish, C. S ., Programmin g in Prolog, Springer-Verlag, 1981 . ******a*****•**•aa***a**a*****a aaaa a*a*a a s a*****aa **a'*a a*aa .
Pseudo-oracles for non-testable programsFor reason, we envision the use of a very level language, such as PROLOG [6], this high or SETL [10], for implementing the testing program.
A rational reconstruction of the proteus sentence plannerA completely revised version of Proteus has been implemented in Prolog on a DEC System iO, and this paper describes the working of its sentence planner.
"Architecture qualityHiah-9evg/ K_o_aimjDS : TbJs J rdJ(ares whether tbe architecture can support very high-level prograndng style, like functional languages (e.g, pure PROLOG), etc. LISP), logic pogramming (e.g, • $1131:9_ui,39.liD_kiig_ _& plr 999_dI119 _cg_ll : Efficient mechanisms for subroutine linkage and parameter passing Jn procedure ¢e]]s depends on the architecture's support of structures like stack., etc. izlx/r_t fgl q.y_tg5_PK_Qg/glmdDg : Trds is related to the features of an architecture that support systems programming concepts like : • I]lGbIgDiz.t_ig,a p]L'iIriy_e : Dijkstra's P & V s3DchropJzation primitives (D be easily implemented Jf the architecture supports some form of a ']'STAND SET"" instruction."
Implementation considerations of mapping LISP onto a cellular computer systemThese are : Imperative language (ADA ) Functional language (LISP ) Logic programming language Object-oriented language (PROLOG ) (SMALLTALK ) Among these languages, the functional language LISP i s chosen as a suitable language for future uses in thi s paper .
Fourth-generation languages (4GLs) and personal computersThis concept introduces students to the desirability and viability of personal computing on powerful work stations connected in a high-speed resource-sharing network rather than on standalone hobby microcomputers.13 At Brown the language PROLOG is considered to be a 4GL rather than the 4GLs identified by this discussion.
A note on the utility of computing inferences in a real data base query environmentWhen interpreted by a suitable theorem prover, such as a version of PROLOG, they can transform a text into its representation (and often a representation into a text) with practical efficiency.
SIGART special issue on machine learningHe has been experimenting with implementations of several different general algorithms in PROLOG. These algorithms are theoretically complete in the sense of the Blums' work, and also may lead to practical realizations. A large part of the system has already been implemented in PROLOG. References: 1. Banerji, R. Using a Descriptive Language as a Programming Language, Fourth International Joint Conference on Pattern Recognition, 1978. 2. Pereira and D. Warren. User's Guide to DECsystem-lO PROLOG. Technical Report 03/13/5570, Labortorio Nacional De Engenharia Civil, Lisbon, September, 1978.
An innovative two-week computer science program for employed professionalsImplementation of relational data bases, experimental and commercial: query optimization and design methodology. PROLOG and contrast with knowledge bases in artificial intelligence.
Architecture quality. • High,eygl pLojD@ : TbJ s ,dJ(ares hethe[ the architecture can support very high-level progrnsdng s%y]e, ]Jke functional languages (e.g, pure PROLOG), etc. LISP), logic programming (e.g, • $bZD_uJJD9 iJD_k.q _& P1999(_]I,9c,is for subroutine linkage : Efficient mechani[, and parameter passirg Jn pr¢edue c] ] depends on the architecture's support of structures ]Jke stacks, etc.
"Eurotra: a multilingual system under developmentThe behaviour of the pattern matcher is defined externally through statements in a data definition language, much in the same way as the meaning of system control constructs is defined in FP. At the present time, we are using Prolog to supply both the data base manager and the definition language. 'To give a flavour of our data definitions, we give a single example of the definition and use of a tree, in pseudo-Prolog. First we define some basic relations, using built-in higher-order relations: antisymetric (dom) intransitive(dom) irre flexive (dom) $dom(x,x) $dom(x,y):- dom(x,z), $dom(z,y) /* reflexive transitive closure */ tree (R,x) :- Sdom(R,x) /* tree x with root R */ If the notation #x in the user program means ""bind x to a tree"", then we define our compiler to translate #x to [tree x]."
Recherches sur la representation des connaissances le systeme ARCHESSon objectif est d'obtenir de nouvelles connaisscces dont la production est determin@e par des modes de raisonnement fond@s sur des mecanismes de dduction compatables ceux utiliss dans les sciences exrimentales, c'est--dire proches de la realit observe - on part de suppositions ou d'hypothses pour en tirer ensuite les consequences que l'on rend indpendantes des hypotheses de d@part par des rgles appropri 6es -, et dont la fomalisation et la manipulation restent pour des raisons op@ratoires dans les limites de la logique du premier ordre - ce qui permet en particulier l'utilisation d'outils existants, comme PROLOG par exemple. En l'absence de toute th 6orie dans ce secteur d'activit@, nous pensons que les hypotheses qui fondent la conception de ARCHES ont @t6 dfinies de manire systmatique (nature des domaines de connaissances tudis et leur rapport avec le langage naturel, types de domaines symbbliquos vis@s et leur rapport avecla logique, relations entre domaines rels et do,mines symboliques, etc.), et forment ainsi un cadre de rfrence et d'analyse coherent et precis, pouvant tre utilis 6 @galement con,e une aide la repr@sentation et la constitution des bases de connaissances associes ARCHES.
"Table-driven rules in expert systems""ACE: An Expert System Supporting Analysis and Management Decision Making"" Technical Report, Columbia University, Department of Computer Science, 1982. Walker, A. ""Data Bases, Expert Systems, and Prolog"" Technical Report RJ 3870, IBM Research Laboratory San Jose, 1983."
Natural language processing at Battelle-Columbus., Ada). They will be pushing to convert from LISP or PROLOG at the earliest possible moment. This paper, which is about my experiences recoding from LISP to C, and moving from a mainframe to a micro, may help others understand what's involved.
Making smalltalk a database systemFinally, th e c o m b in a tio n of a re la tio n a l d a ta b a s e s y s te m w ith a logic p ro g ra m m in g la n g u ag e, su c h a s Prolog, h a s g a th e re d m a n y a d h e re n ts [Da, P a l, Pa 2, Via]. 8. D a ta b a se m a n a g e m e n t, know led g e b a se m a n a g e m e n t an d e x p e rt s y s te m d e v e lo p m e n t in Prolog. ACM S1GM0D D a ta b a se Week, D a ta b a se s fo r B u sin ess an d Office A p p lic atio n s, S a n Jose, May 1983, 159-178.
"A CAD system for logic design based on frames and demonsSimulation Method Pi P2 DEI(((rt 0TS (U'E (RR) (ccr ((Eg 8) 1) ((EO AG 1) 0) ((EO rRG ""X) ""X) ((Eo (OqRAR) ') ( ( ARG)) (T (LIST '"" i:R(,)) ) ) ))) DE}'LIST(((mS ( ' (I:R(,SA) (PR (V VI.BLE,) LOOP (GOND((&LLCR) (GOPRC(_OG))) (T0 V (EWL (GORR¢5) A)) (oor ((F V B) CRElt B)) P2 ((E0 V 1)) ((ME V VIAL)) (T (SEXOVtIIJ (MGONC',RIAB-3 (LZr V))))) (sEro R (C, PRGS)) (GO LCP) PROLOG(CCI ((EOLL ( WRIP.BL5) e) (IETLI 1)) (¥ (IURM (CONS '& VARIP.L)))) DE}'tISI(((ECR ( L ( I : R) (PRIG (V FIG VAI.)"
LISP - notes on its past and futureWe can see this in LISP in certain macro expansion systems like that of the LISP machine (Weinreb and Moon 1978). 6. I should mention Prolog, but I don't understand it well enough to comment.
An architecture design systemFortunately, we fruits of the Artificial Intelligence community, which has provided interactive computers and us with tools such as LISP, PROLOG, expert system development capability, to name a few.
"Automatic construction of discourse representation structuresGuenthner, F. (1984b) ""Representing Discourse Representation Theory in PROLOG"", forthcoming. Guenthner, F., H. Lehmann (1983) ""Rules for Pronominalization"", Proc. 1st Conference and Inaugural Meeting of the European Chapter of the ACL, Pisa, 1983. 113M (1981) : User Language Generator: Program DescriptionOperation Manual, SB10-7352, Prance, Paris."
"Review of ""Artificial Intelligence: An MIT Perspective, Volume 1: Expert Problem Solving, Natural Language Understanding, Intelligent Computer Coaches, Representation and Learning by Patrick Henry Winston and Richard Henry Brown"", The MIT Press, Cambridge, Massachusetts, 1979, ISBN 0-262-73058-8.Hussmann Ellipsenrekonstruktion im Kotext: Forderungen an eine Ellipsenkomponente und ihre Realisierung in SWYSS (Ellipsis Reconstruction in Co-text: Requirements for an Ellipsis Component and their Actualization in SWYSS) C.B. Schwind Natural Language Access to PROLOG Database Systems BOOKREVIEW Artificial Intelligence: An MIT Perspective, Volume 1: Expert Problem Solving, Natural Language Understanding, Intelligent Computer Coaches, Representation and Learning Reviewed by: Varol Akman Electrical, Computer and Systems Engin."
"Extracting semantic hierarchies from a large on-line dictionaryMcCord (1985), ""The lexical base for semantic interpretation in a Prolog parser"" presented at the CUNY Workshop on the Lexicon, Parsing, and Semantic Interpretation, 18 January 1985."
Abstracts of selected journal articlesThe objective of designing this system was the development of a feasible method for consulting and creating data bases in natural Portuguese. The system is implemented in Prolog, a programming language essentially identical in syntax and semantics to a subset of predicate calculus in clausal form.
Meta-rules as a basis for processing ill-formed inputSemantic constraints may be expressed in several formalisms, such as semantic nets (Bobrow and Webber 1980a,b, Sondheim-American Journal of Computational Linguistics, (for example, PROLOG, Warren et al. 1977). It is generally agreed that all are formally equivalent to first-order logic. Sondheimer Warren, D.H.D., Pereira, L.M., and Pereira, F. 1977 PROLOG - The Language and its Implementation Compared to LISP.
Architecture quality. • High-99291 p/_orr: : Tld s Jd (£tes whether the architecture can support very high-level progan,Jng style, ]Jke functional languages (e.g, pure PROLOG), etc. LISP), logic plog[aning (e.g, • $]brg_uD_e l)D_k_g9 _& p19_cg(_]l,19Fg,]Is for subroutine linkage : Efficient mechanis, and parameter passirg Jn Frocedu[e ca 3], depends on the arcbitectuze's support of structures ]Jke stack, etc.
Uses of c-graphs in a prototype for automatic translationIMPLEMENTATION. A small system has been programmed in PROLOG [4] (mainly operations) and in PASCAL (TS and RSC).
Diagnosing faults through responsibilityIn this brief paper, the implementation details have been left out, although the PROLOG user will recognize the role for unification. These are the only troubleshooting rules we need.
Software templatesThere currently exists a prototype instantiator written in Prolog, and a small library of implementations. So far, only `C' and Pascal have been used as implementing languages but we expect to use other languages as well.
A Program Design Language for software engineeringThe notation's syntax an d semantics are easily revised by modifying the rule sets which drive the PD L processor . The implementation of interfaces to Prolog and Pascal, and to a complexity measurement package are in progress .
"Representing knowledge about knowledge and mutual knowledgeThese reversal rules will be used as ""production rules""• The meaning of each production expressed in terms of the progranting language PROLOG is an implication• It can be shown [24J that the following strategy is a complete proof procedure : • The formula to prove is at the star-197 ring node, • Queue the minimal parts in the given formula, • Grow the tree by using the rule (R|) in priority , followed by the rule (R2), then by the rule (R3)."
Using an on-line dictionary to find rhyming words and pronunciations for unknown wordsIn thisfile,each pronunciation of a word has stored with it a mapping from its phonetic segments onto the lettersof the spellingof the word. These mappings were generated by a PROLOG program that uses 148 spelling-to-pronunciation rules for English (e.g..ph ->/f/).
Abstracts of the papers to be presented at the sixth annual international ACM SIGIR conferenceOriginal program development was in PASCAL but a rule-based approach, which is independent of a particular programming language, has been developed for search term and frame selection which adopts a 24 13. 14. blackboard' philosophy in tracing progressing on an implementation the process of selection Work is using the expert systems programming language PROLOG, which has been found a very suitable language for representing rules and provides a ready made rule interpreter° It is suggested that this approach is superior formance compared with alternative in tenms of retrieval perapproaches to end-user searching which fail to exhibit detailed knowledge regarding the subject matter of the search° Transactional Lo Analysis: John E Tolle Online Catalo OCLC Online Computer Library Center, Dublin, Ohio Inco In September 1981, OCLC's Office of Research proposed (Online Computer Library Center, Inc.) to the Council on Library Resources, Inco to continue and expand its research into Online Public Access Catalogs Systems (OPACs).
Input-directed program designThe complete paper will contain the definition of the attributed grammar, which has been programmed in Prolog by D.S. Skuce. Future work will deal with the problem of taking into consideration the output data structure, as well as the input-output relationship.
CYBIL: cyber implementation languageCYBIL, like PASCAL , does not let you disable type checking, This has prove d to be invaluable in developing reliable software , CYBIL has now been used to build a full operating syste m (NOS/VE), several compilers/interpreters (itself, FORTRAN 77 . COBOL, APL, PROLOG), their associated run-time librarie s (excepting mathematical routines done in assembler for maximu m performance and accuracy control), an indexed sequentia l access method, and a large collection of support tools .
Algorithms, concurrent processors, and computer science education: or, “think concurrently or capitulate?”Hardly have we finished upgrading our courses to reflect data abstraction, message-based communication, and objects for system modelling and problem solving, hardly have we adjusted to the Ada/Modula reality, to the new and more powerful dialects of Lisp, and to Prolog and other very high level languages, hardly have we adjusted to windows, rnouses, menus and spreadsheets, hardly have we come to understand how hardware and logic design systems can be driven by advances in specification and description methodologies, languages, and verification techniques, ....
Reaserch on human-computer interfaces at Virginia TechThe execution environment also makes it possible to use different languages for the independent components, for example, we are writing modules in a language we call concurrent Prolog, which makes it possible to write smart dialogue programs and device drivers.
Some notes on the representation of the user's conceptual modelCertainly , Iverson understood this principle and explains to some extent th e continued existence and popularity of the programming language APL . Similar cases can be made for Lisp and Prolog . With the widespread us e of voice input, I would not expect to see a return of natural languag e as either the primary or most 'friendly' language for communicatio n with a computer system .
"Some mistakes are worse than others: an open letter to professor David GriesThe restrictio n co first order is strongly justified for applications such as automati c program proving , if, however, development by human beings, the emphasis is on systematic progra m then expressiveness is more important , first-order logic in this case may be viewed as a kind of low-level, "" machine "" assertion language (look at Prolog :) . What is at stake here is abstraction . Ways of expressing properties at a sufficiently high level of abstraction, using intermediary definitions to hid e lower-level details, are needed for specifications as they are for programs ."
"Effective use of virtual grid compaction in macro-module generatorsHill, ""CAD Systems for VLSI Design,"" National Commzmication Forum, Chicago, 1984. [Hill 851 D. D. Hill , S. Roy . "" PROLOG in CMOS Circuit Design ,"" COMPCON 85 , San Francisco, 1985 ."
HPS, a new microarchitecture: rationale and introductionFirst, we are attempting to design, at high performance, three very dissimilar architectures: the microVAX, a C machine, and a Prolog processor. Equally important, we are investigating the limits of this microarchitecture, both from the standpoint of a minimal implementation and from the standpoint of a cadilIac version.
A framework for the fifth generationThe chip surplus problem is resolved by aiming for consumer markets, and this requires that anyone be able to use a computer and have the motivation to do so in a domestic THE PROBLEM AND TOO MANY CHIPS THE OPPORTUNITY THERE WILL BE A WORLD SURPLUS OF MANUFACTURING CAPACITY FOR VERY LARGE SCALE INTEGRATED CIRCUITS (VLSI) THE BASIS FOR CONSUMER MARKETS A SOLUTION THE ONLY MARKETS LARGE ENOUGH ENOUGH TO ABSORB THE LONG-TERM SURPLUS CAPACITY ARE IN CONSUMER PRODUCTS A NEW STRATEGY TARGET CONSUMERS NEW COMPUTER TECHNOLOGIES ARE NEEDED THAT ARE ATTRACTIVE AND EASY TO USE THE NEW TACTICS ANYONE CAN USE A COMPUTER IMPROVE THE SIMULATE PERSON-COMPUTER REAL AND FANTASY INTERFACE WORLDS ^HIGH-RESOLUTION GRAPHICS ^.PATTERN RECOGNITION ^.SPEECH RECOGNITION ROBOT LOCOMOTION ENCODE EXPERTIZE FOR USE BY OTHERS LISP, PROLOG,, SMALLTALK, AUTOMATIC PROGRAMMING, ..SPEECH SYNTHESIS .NATURAL LANGUAGE NEW ARCHITECTURES, EXPERT SYSTEMS, INTELLIGENT KNOWLEDGE-BASED SYSTEMS THE RESULT Figure 1-The logic behind the development of fifth-generation computer systems context.
Distinguishing fact from opinion and events from meta-eventsA teethed system called MATRES has been constructed In Prolog to run under the UNiX operating system on the POP 11/70.
Argumentation in representation semanticsThe programming languages used for this study are PROLOG and LISP. The programming of syntax and of the informative aspects of semantic follows the ideas of Friedman and Warren 78 ar79 and of Hobhs and Rosenschein 78.
Experiences in the establishment of a microcomputer support laboratoryConcurrently, they take advanced assembly language programming and are introduced to other languages (C, Lisp, PROLOG, etc.). Their programming environment has been on campus-wide mainframes, and they have experience with the PDP-10 (TOPS-10), the Cyber 825 (NOS-2) and the VAX-11/780 (VMS).
ACM - SIGCSE award speechThey als o wanted to hear if I had a book coming o n prolog . I don't know if that constitutes a clue of any kind to the direction tha t Japanese research toward the fifth - generation machine is taking, But I thought you might be interested .
PASES: a programming environment for PASCALIn most interactive debugging systems one can set break points and examine the runtime state. Only in a very few of them (notably the LISP, PROLOG and APL environments) can one execute another piece of code while in a break point.
The Darwin software-evolution environmentIt also seems that Darwin is based on relatively few basic ideas -- frames, privileges, rules for their exchange and propagation -- so that its implementation is r,31atively simple, and we plan to complete a prototype in PROLOG in the near future. [Ambler 76] Ambler, A., Good D.
"A framework for choosing a database query languageFor example, the fixpoint query level is exactly the level of queries available in Horn clause-based deductive query languages, such as Prolog [Clocksin and Mellish Beyond this level, full first-order logic allows the representation of incomplete knowledge [Levesque 19841, this permits the statement and querying of disjunctive information, such as ""John is in New York or in Toronto"" (but it is unknown in which of the two). Immerman [1982] has provided a theoretical underpinning to the use of Horn clause query languages (such as Prolog) by proving that the fixpoint queries can be computed with polynomial data complexity."
A calculus for complex objects., wn} is a well formed formula. We shall adopt the Prolog notation for variables and constants,i.e. an identifier starting with an upper caseletter denotesa variable and an integer or a string starting with a lower case letter denotes a constant.
Right attachment and preference semanticsThis strategy, implemented within Huang's (1984a, 1984b) CASSEX program, correctly parses all of the example sentences in this paper. CASSEX, which is written in Prolog on the Essex GEC63, uses a definite clause grammar (DCG) to recognize syntactic constituents and Preference Semantics to provide their semantic interpretation.
An examination of information center implementation and impactThese developments in communication technology are being paralleled by developments in database software and in nonprocedural language developments, such as relational database systems and the PROLOG language [Rauch 841. College graduates entering the work force will be expected to take advantage of this increased accessibility.
Semantics-directed machine architectureWe see no conceptual obstacle to performing the same kind of analysis for Micro-Planner [4] or Prolog, though the resulting machines may look quite different.
Experiments with a supercompilerPartial evaluation as a means for inferencing data structures in an applicative lanaguage: a theory and implementation Record of The Ninth AMC Symp. on Principles of Prog. 6. in the case of PROLOG, Conference Lang. (1982), pp. 255-267. Vuillemin, J.
Design for testability in a silicon compilation environmentThey claim the method can be applied to the selection of candidate flip-flops for inclusion in an incomplete scan path and suggest the use of a MUX and shift-register combination to reduce the cost of adding many I/O pins to the circuit. 22ndDesign Automation Conference Paper 14.1 Horstmann [7, 8, 91 takes a logic programming approach to ADFT, exploiting the power of the Prolog language and inferencing system to check DFT rules supporting the LSSD methodology.
Development concerns for a software design quality expert systemFor example, if the DQE were implemented in Lisp, S-expressions would be the appropriate syntax. For a Prolog implementation, Horn clauses would be appropriate.
On what exactly is going on when software is developed step-by-step(Note that some compilers implement automatic translation between two theories in different linguistic systems. For example, an two PROLOG programs can be compiled into machine language run on conventional machines.)
Programming languages for computer music synthesis, performance, and compositionOther recent trends in the programming language field, such as the widespread interest in explicitly logic-based computational paradigms (e.g., Prolog), have not yet found their echo among computer musicians. An interesting development would be languages that allow a very high-level approach, such as that of Prolog, without sacrificing the possibility of speaking in a low-level idiom, such as would be appropriate for signal processing and synthesis.
"AbstractsAn outline of an apprcach tc implementation of such rules in an ""expert system"" in PROLOG for symbolic computing is presented. Yazdani, M. (1982) ""How to Write a Story"" Abstract: A scenario for story writing is presented which attempts tc improve that of TALE-SPIN."
A Functional Description of ANALYZE: A Computer-Assisted Analysis System for Linear Programming ModelsA more recent exercise was conducted to simplify EIA's gas supply model, called PROLOG. First, ANALYZE was used to audit the model with its statistical reporting, including the use of CLASSIFY to obtain insights into the model's structure. Using the pictures produced by ANALYZE to gain further insights, the problem was simplified to near triviality: only one interregional constraint remained (cash expenditures for rigs), the others were intraregional, The interre. gional constraint was put into the objective with a multiplier, thus decoupling PROLOG into six independent LP models, one per region.
Computational linguistics research at the University of PennsylvaniaWork on the first area is just getting started, with the implementation of a Prolog-based expert system that can reason about whether to ask for some information or try to deduce it.
A case for rule-driven semantic processing., and Weiner, Implementations as Program Specifications: Semantic Processer in Prolog, J., A (submitted IJCAI, Vancouver, August 1981). [13] Simmons, R.F., Semantic Networks: Computation and Use for Understanding Their English Sentences, Computer Models of Thought Language, Schank and Colby (eds.)
"Formal program testing[Warren and Pereira 77] Warren, D. and Pereira, L., `""PROLOG: The Language and Its Implementation Compared with LISP,"" Proceedings ---------- of the ---------- ACM Symposium on ---------- Art. ---------- Intel. ---------- and Prog. ---------- Lang., SIGART/SIGPLAN"
TEAM: a transportable natural-language interface systemStatus and Future Research An initial version of TEAM was implemented a combination of Incerlisp (acquisition DIALOGIC components) and Prolog (data in and access component) on the DEC2060, but address space llmicatlons made continued development difficult.
"Introduction to relational programmingFinally, we must mention ""logic gramming"" systems, such as PROLOG [15, which use predicate logic to describe putational processes."
Some common misconceptions about LucidThe mathematical approach has also been used, to varying extents, to design LISP, ISWIM, APL and PROLOG, and we certainly expect other new languages to be designed this way, especially since there are now many powerful new results in the theory of domains [15] that can be used.
A curriculum model for a graduate degree program in systems analysisLanguages for artificial intelligence applications (LISP, PROLOG, etc . ) Expert systems : architecture, tools an d languages .
"Formes: An object and time oriented system for music composition and synthesisWinograd, ""Beyond Programming Languages,"" ACId(7)(July 1979). [Wise 82] M. Wise, A Paraltet Prolog: the construction o.I""a dat der model, Conference Record of the 1982 ACM symposium on LISP and Functional Programming, Pittsburgh (1982)."
Towards a self-extending lexiconAnother approach IPereiraS01 is to implement unification using PROLOG. Since our task is to provide lenient parsing, namely also ill-formed sentences must be handled by the parser, these two approaches are not suitable.
On the implementation of a simple class of logic queries for databasesIntroduction We assume the reader familiar with the basic concepts of refational databases (Ul] and with the logical query language for databases, using PROLOG's notation, described in [U2]. A database logic query is expressed as a triple , where G is a goal to be solved using the rules of the logic program LP and the facts of the relational database D.
Really arguing with your computer in natural languageWhether an arguing system is implemented in a logicprogramming language, such as PROLOG,25 or a functional programming language, such as LISP,26 the choice made is actually neutral toward the problems raised in modeling human argumentation.
Computing programs in small colleges., as well as compilers for a variety of programming languages ranging from the more traditional languages, like Fortran, COBOL, and Pascal, to the new languages, like Modula-2 and Ada, and including some of the special purpose languages like Snobol, Lisp, and Prolog. Software support should also include good word processing, spreadsheet, and statistical package support (SAS, SPSS).Access to database systems and authoring languages should also be provided.
Type inference and type checking for functional programming languages: A reduced computation approachIntroduction It is well recognized that type checking and inference systems are very important to develop correct programs if the programming languages used are typeless such as Backus F'P, Lisp, Prolog and Smalltalk. In these languages it is sometime hard to understand programs due to the lack of type information, and we have to resort to costly run time debugging instead of efficient compile-time error checking for finding program errors.
A user-friendly software environment for the novice programmerOne tempting solution is to apply the lessons learned from SOLO to the development of a two-week introduction to a more widely available AI language such as LISP or PROLOG. This is now under active exploration at the Open University because the Cognitive Psychology course for which SOLO was originally developed is being totally remade for presentation in 1986.
"R for SemanticsOther examples include APL, Landin's ISWIM [18], Scott's LAMBDA [24], Turner's SASL [29], the coroutine language of Kahn and McQueen [15], Dijkstra's ""guarded command"" language [8], PROLOG [17], Lucid [2-4], and ML of Gordon, Milner, Morris, Newey, and Wadsworth [13]."
Analysis of conjunctions in a rule-based parserIn logic grammars (Definite Clause Granmars (Pereira & Warren, 1980), Extraposition Grammars (Pereira, 1981), Mdifier Structure Grammars (Dahl & L-Drd, 1983)) this book-keeping need not be completely explicit, but the interpreter of the language (usually a dialect of PROLOG) has to keep track of the binding of the variables, of the clauses that have not been used (but could be used in case of failure of the current path), and so on.
Context-freeness and the computer processing of human languagesMediating programs (e.g. a compiler or interpreter), of considerable complexity, will be needed for the interpretation of computer input in either Prolog or Japanese. In the latter case the level of complexity will be much higher, but the assumption is that we are talking quantitainterested in the computational properties of either kind of language, we will be interested in their language-theoretic properties, as well as properties of the grammars that define them and the parsers that accept them.
Natural language processing and the automatic acquisition of knowledge: a simulative approachThis is a critical, and not at all obvious, choice. 80 Norton (1983), for example, adopts as the representational formalism for his target system statements in the PROLOG language which can be interpreted both declaratively and procedurally.
How does natural language quantify?Under the standard interpretation of Horn-clauses (as in Prolog) a variable is implicitly universally quantified if it appears on the left hand side of a clause, but existentially quantified if it appears exclusively on the right hand side.
"Recent SRI work in verificationWeiner of the University of New Hampshire is working on an implementation of OBJ in Prolog . Reference [12], entitled ""Algebraic Denotational Semantics using Parameterized Abstract Modules,"" develops some new technique s for defining the semantics of programming languages, based on the features of OBJ ."
"An overview of Knowledge RepresentationThe second is a procedural semantics which interprets the formula as ""If you want to establish A, try to establish B 1 and B 2 and ... and Bn"" The language PROLOG [Kowalski 74] realizes this idea and has gained many supporters as it combines advantages from logical and procedural representation schemes."
Towards an integrated environment for accessing external databasesThe Lisp system is augmented with facilities for using knowledge about external databases. In particular, it supports simple, Prolog-style, system a of rules. Such rule systems have been in common use in artificial intelligence for a number of years, and research the basic principles are well understood.
Managing graphical resourcesThey are : - A graphics front-end for the logic programmin g language Prolog[3], providing the user with a windo w for text interaction, and others for graphics .
Continuous execution: the VisiProg environmentIn addltlon, VlslProg permlts the user to view and modify the programs in the network, assuming these are represented using an appropriate `user-understandable' language (e.g., Pascal. PL/I, Prolog, assembler, etc.). Indeed, we view VlslProg as being language independent in that, ideally, any function can be expressed using any appropriate programmlng language.
Inductive Inference: Theory and MethodsShapiro's Model Inference system [Shapiro 1981a, 1981b], for instance, infers Prolog programs corresponding to the Peano axiomatizations of the predicates plus(x, y ,z) and times(x, y, z) over the unary numbers. 2.3 Stochastic Languages A stochastic language is a language together with a probability distribution on its elements. Shapiro [1982a, 1982b] suggests that examples and specifications may be combined to provide a useful, partially automated debugging tool for Prolog programs. A slightly different emphasis is given by Siklossy and Sykes [1975], who suggest that an induction mechanism may be useful to a robot in generalizing solutions it has found for specific problems.
Framework of the decision support expert systemsINFERENCE ENGINE a deductive program making conclussions from the facts present in the Knowledge Base• Usually it is a Resolution Principle based Theorem Prover written in LISP or PROLOG. KNOWLEDGE ACQUIRER an inductive inference program guiding interaction with the expert.
"Artificial intelligence in the personal computer environment, today and tommorrow (panel session)M.l's English-like syntax and use of certainty factors retain EfIYCIN's ease of use, but its powerful logic-based representation makes an""escape"" to LISP or PROLOG unnecessary. An tI.l knowledge system is built by preparing a text file of general facts and rules about some problem domain."
Decentralised control flow - based on UNIXSmalltalk [3]), and loglc models [15] and logic languages (e.g. Prolog [14]). 192 Prog ]conven-]stngle [object-]pred.
The Semantic Binary Relationship Model of information. : The SBRM of information directed relations unless the inverse functions This may impose a direction 134 are all explicitly specified. on the stored functions, whereas the relations (I.e. predicates of logic) can be accessed in any direction. For instance compare PROLOG and the functional Finally, the class language DAPLEX (Shipman 1981). organisations, hierarchies and inheritance mechanisms of semantic networks, if enriched with deduction and integrity processing, could be an ideal choice for the conceptual model, indeed in a semantic network, binary 2-place predicates of FOPC. represented by n+l 2-place would result in increased relationships can be thought of as modelling In general n-place predicates of logic can be predicates.
Document structure and modularity in mentorIn Mentor, constraints (e.g. type and scope checking of programs) and semantical properties may be expressed in a specialized language called Typol [Des 83] based on conditional rewriting rules semantics [Plo 81]. Typol constraints may be compiled into a Prolog program that actually verifies the constraints and signals errors.
An applicative compiler for a parallel machineA structure editor for HOPE and a compiler for a relational PROLOG-like language for ALICE [Clark and Gregory 1981] are also being written.
"A simple software environment based on objects and relationsExamples of value-oriented programming languages include ""pure LISP,"" PROLOG, KRC and Backus's FP. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commcrcial advantage, the ACM copyright notice and the titleof the publication and itsdate appear, and notice is given that copying is by permission of the Association for Computing Machinery."
Assessing Test Data Adequacy through Program InferenceThe assessment of specification-adequacy can be made easier by producing IT in a very-high-level language such as SETL [4] or Prolog [15]. Although the general equivalence problem is still undecidable, a major virtue of considering programs in such languages is that the programs look very much like the specifications, and hence as a practical matter it is easier to determine equivalence.
Completion of a set of rules modulo a set of equationsDuring the ten past years, the Knuth and Be,ld[x's completion procedure was shown to be a major tool for a wide class of problems, mainly the word problem in universal algebra [K&B,70], equivalence proofs of sets of axioms in algebra [LES, 83], unlflcation in equational theories [JKK,83], inductive proofs in data types [H&H,80], theorem proving in various logics [H&D,83], program synthesis from specification [DER,82], computing with rewrite programs [DER,82], describing PROLOG's semantics [DER,83], constructing initial algebras and executing equational speclfi-Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery.
BehaviourHayes: I was going to suggest an alternative, which may be the same as dataflow and which is used in PROLOG, that is, invocation when a binding is made to a variable.
"Data independent recursion in deductive databasesInitially we consider a relation T defined by a linear recursive rule T :- T, P, and a nonrecursive or exit rule T :- E, where P and E are conjunctions of base or EDB predicates. The syntax used here is similar to that of Prolog - the `5"" symbol can be read as ""if."" A linear recursive rule is a rule with exactly one recursive predicate."
Compiling a functional languageML pattern matching is less powerful than, for example, Prolog pattern matching, because every variable can occur only once in an ML pattern.
An object oriented architectureWith a differentset of instruction definitions it could easily be made to directly interpret A.PL, Prolog, SNOBOL, FP, or FBAPP as well. LISP, Backus Abstract instruction decoding, although slow in software can be mitigated by the use of a associative mechanism in the instruction translation step which bears remarkable similarity to virtual address translation.
ASK is transportable in half a dozen waysOur present plans are to include FORTRAN, ASK is installed in an existing COBOL, C, and Prolog. When a system like computer environment, this environment can be expected to include a large investment mer expertise.
Abstracts of current literatureIn particular, three forms of knowledge are required: why each operator is useful, when to apply each operator, and what each operator does. A PROLOG implementation, named PET, demonstrates the learning approach in the domains of simultaneous linear equations and symbolic integration.
Abstracts of current literatureThe Appendix contains an example grammar and samples of parses and semantic interpretations into logical form. The system is implemented in Prolog. 132 American Journal of Computational Linguistics, Volume 6, Number 2, April-June 1980 The FINITE STRING Newsletter An Experimental Study of Natural Language Programming Alan W.
PresentationI, or something like that. The strategies in KRL and in Prolog are no good. There is a tradeoff between how much behlior should bespecifiedand how much annotation you have to put on to obtain that behavior.
ASCOF: a modular multilevel system for French-German translationFor the computer scientist, COMSKEE is a procedural (imperative) format-free, block-oriented programming language such as ALGOL and Pascal, yet comprising some of the qualities of functional languages (such as LISP or PROLOG). For the linguist, COMSKEE is a powerful device especially due to its dynamic data types - dictionary, set, sentence, and string - and its dynamic operations - such as positional and contextual substring access and assignment.
Browsing in a loosely structured databaseRepresentation of information as a collection of facts is a method that has been employed in knowledge representation, in the form of semantic networks (see [8] for a recent review of this topic). The programming system PROLOG [4] also uses such collections of facts as part of the deduction systems that constitute •programs*.
Lolita: a low level intermediate language for AdaIn LOLITA, all these a ctions are d e s c r i b e d explicitly, thus, a p r o c e d ure call has three c o m p onents e x pr e s s i n g the actions to do before the call, the call itself, and the acti o n s to be p erformed the call. p r o c e d u r e ^ c a l l I I prolog call epilog i I I I STM OPERAND STM after A f u n c t i o n call has a similar structure, but also repres e n t s the o perand cont a i n i n g the result after the call. 5.6 Checks The kind of checks required by Ada, w h i c h m a y result in actions at runtime are in part i c u l a r constraint and numeric checks.
An Efficient Unification AlgorithmIntell. 5, 3 (Fall 1974), 25. WARREN, D.H.D., PEREIRA, L.M., AND PEREIRA, F. PROLOG--The language and its implementation compared with LISP.
An imperative sentence processor for voice interactive office applicationsHarriet Deas did a study of training methods for voice interactive systems and contributed considerable code. Barry Koster wrote a PROLOG simulator for the micromodel to test its correctness.
An architecture for object management in OISThe scratch pad is similar to the work space of an APL, a Prolog, or a LISP system, and can be stored with the packet if necessary.
Principles of OBJ2Recent work 1231on Eqlog explores combining the equational logic (and other powerful features) of OBJ with the Horn clause logic (and other powerful features) of Prolog. Two other research directions that we hope to pursue for rewrite rule languages are graphical programming methods and parallel architectures.
This gives a valuable perspective on the higher level languages. LISP, PROLOG, SNOBOL, and other special purpose languages are also important resources for the CSIS programs. 2.4.2 Software Packages The selection of software packages will also vary with the nature of the school.
Contributions to the Theory of Logic ProgrammingWe are more interested in the use of such procedures for automatic computation, the interpreter for the programming language PROLOG [5, 6] can be regarded as an SLD-refutation procedure.
Automatic normalistation and entity: relationship generation through attributes and rolesThese require some logic which will allow their placement next to both or all items which have an ownership Subject Role to them. More recent reading has suggested that a small PROLOG program would accomplish solution with a larger base. 91 the same purpose in a cleaner The results of the operation to assign Role-Categories is shown below.
Repairing reference identification failures by relaxationWe represent information from knowledge source as a set of relaxation rules. are for each These rules are written in a PROLOG-Iike language. illustrates one such linguistic knowledge Figure 5 relaxation rule.
Reflections on building two Go programs., Ada). They will be pushing to convert from LISP or PROLOG at the earliest possible moment. This paper, which is about my experiences recoding from LISP to C, and moving from a mainframe to a micro, may help others understand what's involved.
"From English to logic: context-free computation of ""conventional"" logical translationOne is by Rosenschein & Shieber (1982), another by Gawron et al. (1982), in conception these are based quite directly on the generalized phrase structure grammar of Gazdar and his collaborators, and use reeursive descent parsers. A related Prolog-based approach is described by McCord (1981, 1982)."
Reflection and semantics in LISPWork has begun, however, is a standard metacircular on designing reflective dialects of a side-effect-free Lisp and of Prolog, and on studying a reflective version of the X-calculus (the last being an obvious candidate for a mathematical study of reflection).
Reasoning about structure, behavior and functionIn this brief paper, the implementation details have been left out, although the PROLOG user will recognize the role for unification. These are the only troubleshooting rules we need. Christian Pellegrini, Mike Rosner, and Carlo Cecchi, University of Geneva, Switzerland: Programming languages for exp.e_[t systems LISP 5. Same as above with PROLOG For more information contact: SGAICO - P. Shann ISSCO, University of geneva 54, route do Acacias CH-1227 Geneve, Switzerland Tel: (022) 20 93 33 ext. 2116 NEW BOOKS Qualitative Reasoning about Physical Systems Edited by Daniel G.
Abstracts of current literatureThe resulting output is a standardised hierarchical structure holding only significant features of the description. The system, implemented in the PROLOG programming language, uses keywords to identify the way segments of the text relate to the object described.
"Research in music and artificial intelligenceIn AI research, the ""modeless"" programming environment of symbolic computers (LISP and Prolog Machines) developed for AI research is a good starting point [Bawden et al., 1979, Sandewall 19781."
"A survey of machine translation: its history, current status, and future prospectsUntil GETA receives enough funding that programmers can be hired to rewrite the software in a high-level language (LISP/PROLOG is being evaluated), facilitating present and future redesign, the Computational Linguistics, Volume 11, Number 1, January-March 1985 Jonathan Slocum GETA group is ""stuck"" with the current software - now showing clear signs of age, to say nothing of non-transportability (to other than IBM machines)."
Formal semantics for time in databasesAn analogous situation is occurring in the field of artificial intelligence, which is witnessing the same proliferation of knowledge representation languages (KRLs): frames [34], KRL [4], PROLOG [27], and RLL [20], to name only a few. Considerable discussion and often heated arguments have ensued over which language is better.
"MULTILISP: a language for concurrent symbolic computationThese ""parallel imperative"" languages include Concurrent Prolog [50], Ada [34], and Multilisp. Algorithms may have opportunities for parallelism at any of several levels of granularity, ranging from short sequences of primitive operations to large program modules."
Ergonmics in the automated office environmentSome of the issues contributing to the increase in worker discomfort with the advent of automated equipment include: * prologed periods of immobility, * repetitious,and demanding work, * viewing an image at an unusual and often uncomfortable distance, * viewing a lighted screen with a flickering image, * limited viewing distance, * lack of adjustability of furniture and/or equipment, * poor ventilation due to excessive heat from machinery, * noise, * open offices.
Prolog
Parsing free word order languages in Prolog
The versatility of PROLOG
Prolog - the language and its implementation compared with LispProlog is a simple but powerful programming language founded on symbolic logic. The remainder of the paper discusses techniques for implementing Prolog efficiently, in particular we describe how to compile the patterns involved in the matching process. These techniques are as incorporated in our DECsystem-10 Prolog compiler (written in Prolog). The code it generates is comparable in speed with that produced by existing DEC10 Lisp compilers.PROLOG - THE LANGUAGE AND ITS IMPLEMENTATION COMPARED WITH LISP David H D Warren Department of Artificial Intelligence University of Edinburgh Scotland Abstract Prolog is a Simple but powerful programming language founded on symbolic logic. The remainder of the paper discusses techniques for implementing Prolog efficiently, in particular we describe how to compile the patterns involved in the matching process. These techniques are as incorporated in our DECsystem-lO Prolog compiler (written in Prolog). The code it generates is comparable in speed with that produced by existing DECIO Lisp compilers.
Applicative programmingThe idea is to do without assignment and rely on functions which produce results. Developments for this style include PROLOG and the school of logic programming, (Colmerauer,Kowalski), also the functional programming of Backus which avoids variables altogether, rather in the manner of combinatory logic.The idea is to do without assignment and rely on functions which produce results. Developments for this style include PROLOG and the school of logic programming, (Colmerauer,Kowalski), also the functional programming of Backus which avoids variables altogether, rather in the manner of combinatory logic.
Logical design of deductive natural language consultable data basesThis article examines data base description problems from the point of view of logic programming, and presents an experimental deductive data base system implemented in PROLOG. We first discuss the advantages of logic for describing data bases, in a general manner, and then its application to our particular data base system.
Some aspects of symbolic integration via predicate logic programmingAn earlier version can be found in (2), (3), (6). In section I we give a brief summary of Prolog and some typical examples. Section II is a short overview of the system. Implementation of algorithms and examples of computation will be detailed. 29 SECTION I: Prolog is an implementation of 1st order logic, it is interpreted partly in Fortran, partly in Prolog itself and can therefore be run on any computer. We give here a brief survey of Prolog. More detailed explanations can be found in (i0).
"An application of automated language understanding techniques to the generation of data base elementsThe Event Representation Language is implementedin a subset of Prolog, a formalism using a clausal form of logic restricted to ""Horn"" clauses. For ease of implementation, the compiler for the subset of Prolog utilized in this application was written in SOBOL4. The use of FORTHand the Prolog formalism allowed fairly easy developmentof the system even without the powerful structure manipulation capabilities of a language like LISP."
European AISB summer school on knowledge systemsThese are tne projects which are currently being worked on: - the programming language mechanical theorem-provng PROLOG and its interpretor, based on a approach. - a question-answering (all written in PROLOG). - a heuristic theorem system in French with automatic inference prover (also written in PROLOG). - the development of basic made by the French Company, software for a small T1600 computer Telemecanique. 5e 5f g 6 6a
"Surveyor's Forum: Determining a Search., Cambridge, Mass., May 1972. ROBERTS, G. An Implementation of PROLOG, M.A. Thesis, Univ. Waterloo, Waterloo, Ont., Canada, 1977. ROUSSEL, P. PROLOG: Manuel de reference et d'utilisation, Groupe d'Intelligence Artificielle, MarseiUe-Luminy, France, September 1975. MICRO-PLANNER reference manual, AI Memo 203,MIT Project Mac, M.I.T., Cambridge, Mass., July 1970. WARREN, D., AND PEREIRA, L. ""PROLOG--The language and its implementation compared with LISP,"" SIGPLAN Notices 12, 8 (Aug. 1977)."
"Factoring larger multivariate polynomialsMemo no. 73, Department of Artificial Intelligence, University of EDINBURGH, Feb. 74. (10) ROUSSEL P., PROLOG: maneul d'utilisation. Rapport interne, G.I.A., UER de LUMINY, Universit d'AIX-REEILLE, Septembre 1975. (11) WARREN D., WARPLAN: a system for generating plans. This session is run on a of c ""Telemecanique Ti 500"" which is a minicomputer with 32 K of 16-bits words. Since the support languge Prolog needs a work space of 64 K words, a disc is used as virtual memory paged in i0 K words zone of central memory."
Solving mechanics problems: PAT - pulleys and thingsTESSA was written in POP2 by Mike Soul at the University of Essex and produces a syntactic parse for a large set of English sentences (see below). The second component, PAT, is written in PROLOG, an experimental programming language based on predicate calculus, and does the semantic analysis. Overview The syntactic parse from TESSA is currently translated by hand into PROLOG clauses, and forms the input to PAT. PAT outputs PROLOG clauses asserted at run time that describe the semantic analysis derived from the parse.
"On reasoning by defaultTHNOTin MICROPLANNER[Hewitt 1972, Sussman et al.1970],.NOT in PROLOG[Roussel 1975]. For example, in MICROPLANNER,the command (THGOAL ) can be viewed as an attempt to prove given a data base of facts and theorems. There is a fair amount of empirical evidence in support of this point of view, primarily based upon the successful use of PROLOG[Roussel 1975] - a pure theorem prover augmented with a ""THNOT"" operator - for such diverse A.I. tasks as problem solving [Warren 1974], symbolic mathematics [Kanoui 1976], and natural language question-answering [Colmeraurer 1973]. Memo No. 409, M.I.T., Sept. 1977. Roussel, P., (1975). PROLOG, Manuel de Referencest d'Utilisation, Group d'Intelligence Artificielle, U.E.R. de Marseille, France, 1975."
Algorithm = logic + controlRepresentation of data by means of terms is a common feature of Horn clause programs written in PROLOG [12, 33, 38]. Tarnlund [36], in particular, has investigated the use of terms as data structures in Horn clause programs. Several PROLOG programs employ a relational representation of data. It runs efficiently with the sequential execution facilities provided by PROLOG. The alternative formulation, which employs a predicate having one state as argument, is easier to understand but more difficult to execute efficiently.
A short survey on the state of the art in matching and unification problemsVogel, 'Unifikation von Morphismen', Diplomarbeit, forthcoming, 1978 [86] D.H.D. Warren, 'Implementing PROLOG', vol I and vol 2, D.A.I. Research Rep. no. 39, University of Edinburgh, 1977 [87] P.
On compiling embedded languages in LISPFlow analysis of computer programs, Programming Languages Series, Elseviser North-Holland, 1977. (16) Komorowski, H.J. and Ooodwin, J. W. Embedding Prolog in Lisp: An example of a Lisp Craft Tradition, Informatics Laboratory, LinkSping University, Sweden, 1980. (17) Loveman, D.
Group theoretical computations in mathematical crystallographyIndeed, these are basic tools in symbolic manipulations and especially in formal integration. We present here a system written in Prolog, an implementation of Ist order logic developed at the Artificial Intelligence Group of Marseille.
Control structure of a pattern-directed search systemWhen a subproblern is fully solved, as described in Section 3.4, the entry on the OPLIST is placed on CLOSED. The predicate calculus programming language PROLOG [23], incorporates a slash (/) operator which denotes that if a subproblem has been solved no other clauses may be entered even if they resolve with the subproblern represented as a literal.
Prolog in ‘C’
Spelling verification in prolog
Performance characteristics of microcomputer Prolog implementations
RT Prolog: a real time Prolog written in Ada
Limiting a resolution set in a large Prolog database using special hardware
Implemention of parallel Prolog on tree machinesIMPLEMENTATIONOF PARALLEL PROLOGON TREE MACHINES Hajime MIURA* Masaharu IMAI** Masafumi YAMASHITA*** Toshihide IBARAKI**** * Fujitsu Limited, Kawasaki, Kanagawa, 211 Japan ** Toyohashi Univ. of Technology, Dept. of Information and Computer Sciences, Toyohashi, 440 Japan *** Hiroshima University, Dept. of Electrical Engineering, Higashi Hiroshima, 724 Japan **** Kyoto University, Dept. of Applied Mathematics and Physics, Kyoto, 606 Japan In this paper, parallel algorithms to control the execution of Prolog programs on tree machines are proposed, and their efficiencies are compared through simulation experiments. While a better utilization of processing elements and a better load balancing are future research problems, tree sachines are found to be suitable for parallel implementation of Prolog. mm: Prolog, knowledge-based problems, tree machines, logic programming, multiprocessor systems, parallel algorithms. Logic programming is one of the best methods to formalize and solve knowledge-based problems C~li~801. Prolog IS a logic programming language based on first order logic [Kowa79], where knowledge is represented by a set of facts and a set of inference rules.
Topologies for the parallel backtracking Prolog engineSome multicomputer networks for the implementation of the PBPE, a Parallel Backtracking Prolog Engine designed at the University of Bari, Italy, are considered. Two main subsystems, one for the management of clauses and another for interpretation of Prolog, each having its own topology, have to be connected together.Topologies for the Parallel Backtracking Prolog Engine L. Campanale(`), M. De Blasic2),A. Gentilec2),F. Amendola, 173 - 70126 Bari - Italy Somemulticomputer networks for the implementation of the PBPE, aParallel Backtracking Prolog Engine designedat the University of Bari, Italy, are considered.Two main subsystems,onefor the managementof clauses and another for interpretation of Prolog, eachhaving its own topology, haveto be connectedtogether. An experimental application using a variable number of transputers, linked in someof the topologies examined, is being developed. kieywords: Backup Or-Parallelism, Coprocessors, Distributed Systems, Multicomputer Networks, Occam, Prolog Machines, Topologies, Transputers. 1. Introduction The objective of the PBPE (Parallel Backtracking Prolog Engine) project [l] is to realize a machine for the interpretation of Prolog programs.
Pitfalls in PROLOG programmingAccordingly, none of the contemporaryprogramming languages can be said to be ideal. Prolog is no exception. However, it is usually emphasized that programming in Prolog is very easy, even a beginner can handle it within a few hours of learning. The rationale behind this conception is that Prolog clauses are actually some logical statements, and logic is the basis of every rational subject. The problem arises in that Prolog programming is not equivalent to logic programming.Pitfa|ls -75- in PROLOG Programming W. /Vg+ WY Me DepenLrnenLoF CompuLenScience The ChineseUn/verMLyorHong Kong Shafin N.T. Prolog still shares the effectof the influence of the fundamental Yon Neumann computer architectureon conventional programming languages. Ifa user wants to write a Prolog program just according to his logicalreasoning,he will probably fallintoan unexpected trap of the language.
Modeling in PrologIn this paper, the characteristics and programming methodology of PROLOG are developed through a sequence of logic-oriented problems of increasing complexity.UODELING IN PROLOG John Najar ian Department of Computer Science William Paterson College of New Jersey Wayne, New Jersey 07470 Logic prcgratmning languages require careful, incremental presentation inorderto 2 understcodby students of the standardvonNeumann PrQZaJUDing languages. At W.P.C., our A.I. course consist6 of: 25% LISP (functional prograBn&?g, list-Prcc.) 25% PROLOG(theorem proving, natural law. proc.) 50%Classical Applications Presenting the languages first provides the taols and Qental framework conducive to the understanding how classical applications (eg. They should include: Factorial, Primes, Member, Append, Reverse, Sort Fkaee 3 deals with the design of PROLOG programs to solve Icgic problems. At each example, new features of PRG~'slc@c engine can be demonstrated.
Vectorization techniques for prologSeveral techniques for running Prolog programs on pipelined vector processors, such as the Hitachi S-820 or the Cray-2, are developed. This paper presents an automatic program transformation (vectorization) method of Prolog, which enables a type of or-parallel execution of Prolog programs using vector operations. This result confirms the effectiveness of vectorization techniques and applicability of vector processors to Prolog execution and to symbol processing applications.Vectorization Techniques for Prolog Yasusi Kanada, Keiji Kojima, and Masahiro Sugaya Central Research Laboratory, Hitachi Ltd. Kokubunji, Tokyo 185, Japan. Several techniques for running Prolog programs on pipelined vector processors, such as the Hitachi S-820 or the Cray-2, are developed. This paper presents an automatic program transformation (vectorization) method of Prolog, which enables a type of or-parallel execution of Prolog programs using vector operations.
"Puzzles, PROLOG and logicPuzzles have been and continue to be very effective agents for the presentation of logic. Recently, PROLOG has been suggested as the tool of choice for approaching ""virtually all"" logic problems. One of Smullyan's puzzles is used to demonstrate this thesis. We question this rush to PROLOG and its associated procedural interpretation of logic. We give a simple puzzle (definitely not of the Lewis Carroll or Smullyan caliber) and our PROLOG solutions. Our problems in applying PROLOG to this puzzle in turn lead us to try to discover the logic roots of PROLOG.Abssct -63-Puzzles, PROLOGand Logi© Thomas W.Jerardi Johns HopkinsUniversity Applied PhysicsLaboratory' Puzzles have been and continue to be very effective agents for the presentation of logic.Recently, PROLOG has been suggested as the tool of choice for approaching ""virtuallyall""logicproblems. One of Smullyan's puzzles is used to demonstrate this thesis.We question this rush to PROLOG and its associated procedural interpretation of logic.We give a simple puzzle (definitelynot of the Lewis Carrollor Smullyan caliber) and our PROLOG solutions.Our problems in applying PROLOG to this puzzle in turn lead us to try to discover the logicroots of PROLOG. Recently a Smullyan puzzle has been used to suggest the efficacyof the PROLOG language in solving logicproblems [I I].The language of PROLOG seems to make use of the same constructs ( and, o not,implies etc.)as classicallogicand thus would appear to be a natural choice for solving logicproblems."
A prolog space benchmark suite: a new tool to compare prolog implementationsIn p a r t i c u l a r , f o r the programmming language Prolog t h e r e i s a l o t of benchmark s u i t e s i s a c r i t i c a l s i z e f o r t h i s (e.g. [ 1 ] , [ 2 ] ) because e f f i c i e n c y language. The lack of t h e values obtained by t h e space benchmark programs i s a disadvantage s i n c e f o r Prolog a p p l i c a t i o n s c r i t i c a l s i z e than time such t h a t space i s o f t e n a more the assessment of the space q u a l i t y of a Prolog system i s a v i r t u a l i n t e r e s t of users. Our ACM SIGPLAN Notices, Vol. 25, No. 12, Dec. 1990 space benchmark s u i t e i s a c o l l e c t i o n of about 40 s i n g l e programs d i r e c t e d t o both the Prolog user and the Prolog system d e s i g n e r . By means of these programs i t i s p o s s i b l e f o r a Prolog user - t o f i n d out t h e s i z e of - t o reveal t h e i n c l u s i o n d i f f e r e n t i n t e r n a l workspace areas, of space o p t i m i z a t i o n s t r a t e g i e s , i . e . how well the workspace i s - t o t e s t the q u a l i t y of e x p l o i t e d , e r r o r r e c o v e r y i n case of workspace e r r o r s ( i . e . proper e r r o r retlJrn t o Prolog top l e v e l ) .
Efficient interpretation of Prolog programsThe paper focuses on three ideas for solving problems with writing interpreters for the logic programming language Prolog in Prolog and how to combine these ideas to an interpreter for Prolog which is both simple and efficient. The resulting interpreter system can be incorporated into a Prolog based on Warren's Abstract Machine and built mostly from existing parts of it. The interpreter has been implemented and is used in a Prolog system developed at Uppsala University.Efficient Interpretation of Prolog Programs Jonas Barklun d UPMAIL, Computing Science Dept ., Uppsala Universit y P.O . Box 520, S-751 20 Uppsala, Sweden The paper focuses on three ideas for solving problem s with writing interpreters for the logic programmin g language Prolog in Prolog and how to combine thes e ideas to an interpreter for Prolog which is both simple and efficient . The resulting interpreter system ca n be incorporated into a Prolog based on Warren's Abstract Machine and built mostly from existing parts o f it .
Parsing and compiling using PrologThis paper presents the material needed for exposing the reader to the advantages of using Prolog as a language for describing succinctly most of the algorithms needed in prototyping and implementing compilers or producing tools that facilitate this task. The available published material on the subject describes one particular approach in implementing compilers using Prolog. It consists of coupling actions to recursive descent parsers to produce syntax-trees which are subsequently utilized in guiding the generation of assembly language code. Although this remains a worthwhile approach, there is a host of possibilities for Prolog usage in compiler construction. The primary aim of this paper is to demonstrate the use of Prolog in parsing and compiling.HICKEY Brandeis University This paper presents the material needed for exposing the reader to the advantages of using Prolog as a language for describing succinctly most of the algorithms needed in prototyping and implementing compilers or producing tools that facilitate this task. Although this remains a worthwhile approach, there is a host of possibilities for Prolog usage in compiler construction. The primary aim of this paper is to demonstrate the use of Prolog in parsing and compiling. A second, but equally important, goal of this paper is to show that Prolog is a labor-saving tool in prototyping and implementing many nonnumerical algorithms which arise in compiling, and whose description using Prolog is not available in the literature.
"Teaching recursion using fractals in PrologRecursion has traditionally been a difficult concept for students to understand, both as a control structure and as an analytical tool. This paper explores recursion using Prolog (whose predominate control structure is recursion) and through fractals which possess a visually recursive form. We discuss several simple Turbo Prolog programs which demonstrate recursion graphically and whose resultant figures are fractals whose recursive nature is particularly easy to analyze in the Turbo Prolog environment.TEACHING RECUPSIO~~USING FXACTALS IN PROLOG Bruce S. Elenbogen Martha R. O'Kennon Department of Mathematics and Statistics Nathematics Department University of Michigan, Dearborn Albion College Dearborn, Michigan 48128 Albion, Michigan 49224 Recursion has traditionally been a difficult concept for students to understand, both as a control structure and as an analytical tool. We discuss several simple Turbo Prolog programs which demonstrate recursion graphically and whose resultant figures are fractals whose recursive nature is particularly easy to analyze in the Turbo Prolog environment. Although most true Prologs-have the property that any predicate can occur in multin'le arities"", and use any type (strixl.g, integer, list, structure, etc.) as argumnt, Turbo Prdioglequiresthe user to declare all types and predicates up-front."
MS-DOS Prolog implementations revisitedIn an earlier article [11] we proposed a taxonomy for classification of PROLOG implementations. This analysis has been used by ourselves [1], [3], [11] and others [6] in evaluation of current microcomputer-based products. However, it has become out of date for several reasons. First, PROLOG has matured to the point where the language kernels have become comparable in functionality. Thus, we offer a revision which is more in keeping with the current PROLOG offerings.MS-DOS PROLOG IMPLEMENTATIONS REVISITE D Hal Berghel Richard Ranki n Department of Computer Scienc e University of Arkansas Fayetteville, AR 7270 1 In an earlier article [11] we proposed a taxonomy for classification of PROLOG implementations . This analysis has been used by ourselves [1], [3], [11] and others [6] in evaluatio n of current microcomputer-based products . however, it has become out of date for several reasons . First, PROLOG has matured to the point where the language kernels have become comparable in functionality . Thus , we offer a revision which is more in keeping with the curren t PROLOG offerings . Introductio n Despite several initiatives, no formal language standard yet exist s for PROLOG .
Commonsense reasoning in PrologConsequently, it is convenient and effective for Prolog to implement commonsense reasoning.Commonsense Reasoning in Prolog Wei Si Jiang and William G. Wee Dept. of Electrical and Computer Engineering University of Cincinnati Cincinnati, Ohio 45221 Commonsense reasoning with incomplete knowledge plays an important role in problem solving. Consequently, it is convenient and effective for Prolog to implement corm-nonsense reasoning. I. Introduction First order logic (FOL) is a powerful formalism for knowledge representation and problem solving. This subset is powerful enough for many applications of problem solving. Prolog is the Horn clause subset of FOL with negation as failure, but Prolog also has some features that extend beyond FOL.
An introduction to Prolog IIIThe Prolog III programming language extends Prolog by redefining the fundamental process at its heart: unification.Some of these limitations have been overcome as a result of increasingly efficient implementations and ever richer environments. The fact remains, however, that the core of Prolog, namely, Alan Robinson's unification algorithm [22], h as not changed fundamentally since the time of the first Prolog implementations. Their evocation requires that certain parameters be completely known, and this is not in line with the general Prolog philosophy that it should be possible anywhere and at any time to talk about an unknown object x. The research work on Prolog III is not an isolated effort, other research has resulted in languages whose designs share features with Prolog III.
A denotational semantics for PrologConventional control sequencing is assumed for Prolog's execution. The semantics is nonstandard, and goal continuations are used to explicate the sequencing.Conventional control sequencing is assumed for Prolog's ex ?cution. The semantics is nonstandard, and goal continuations are used to explicate Categories and Subject Descriptors: the sequencing. INTRODUCTION Languag,es]: Language Classifiations-Prolog, Semantics of Programming Languages-denotutiorzal Formal Languages]: Mathematical Logic--logic semantics, logic programming The language Prolog is different in philosophy from procedural languages of the ALGOL family. Prolog allows a more declarative essentially logic + control [4].
CLARE—a Prolog database machineThe CLAuse Retrieval Engine (CLARE) is a coprocessor system which based on two-stage filtering, for handling large sets of disc resident clauses in Prolog database applications. The overall architecture and the timing measurements of the first stage CLARE hardware are reported.CLARE - A Prolog Database Machine Kam-Fai Wong ECRC GmbH, Arabellastrasse 17, DSOOOMtinchen 81, West Germany. 44.Howard Williams Department of Computer Science,Heriot-Watt University, 79 Grassmarket,Edinburgh EHl 2HJ, Scotland. The CLAuse Retrieval Engine (CLARE) is a coprocessorsystem which based on two-stage filtering, for handling large sets of disc resident clauses in Prolog database applications. The overall architecture and the timing measurementsof the first stage CLARE hardware are reported. Introduction The semantics of Prolog has been shown to bc suitable for implementing various aspectsof databases.
Pascal's emulation of a Prolog programThis paper describes a Turbo Pascal program that explicitly emulates a Turbo Prolog program. The intended purpose of the Pascal program is to relate important implementation details of Prolog to concepts in a conventional programming language.PASCAL'S EMULATION OF A PROLOG PROGRAM Howard Lambert Department of Mathematical Science5 Eastern New Mexico University Portales, New Mexico 88130 This paper describes a Turbo Pascal program that explicitely emulates a Turbo Prolog program. The intended purpose of the Pascal program is to relate important implementation details of Prolog to concepts in a conventional programming language. INTRODUCTION Learning the Prolog programming language can be a difficult task for many students.
Arrays and assignment in prologThis note describes a very simple modification to Prolog's Definite Clause Grammar1 (DCG) formalism which allows a menu system with the flavor of Texas Instruments' NLMenus2 to be easily implemented.It is as such a valuable record. ARTICLES ARRAYS AND ASSIGNMENT IN PROLOG William G. Wong Logic Fusion Inc. 1333 Moon Drive Yardley, PA 19067 (215) 736-2463 Conventional Prolog implementions support dynamic update of the data base using assert and retract. Louis, MO 63130 sbc@wucsl.UUCP note describes a very simple modification to Prolog's Definite Clause Grammar I (DCG) formalism which throughout various parts of a program. The idea is identical to infinite streams in Concurrent Prolog except that the stream can only be accessed as a variable or its latest value.
Storage management in a Prolog compilerWith the current intense interest in new computing paradigms based on logic, the efficient implementation of Prolog has become an issue of prime importance. Compiling Prolog involves some unique and difficult problems relating to storage management: in particular, the somewhat conflicting requirements of backtracking, and cut and tail recursion processing. The usual solution is to use garbage collection, an expensive process in small computers with limited storage. We describe a Prolog compiler which maintains the heap as lists of free records, to which records are released at the time they are deallocated, thus avoiding garbage collection.Chang P.T.Cox Technical University of Nova Scotia Halifax,Canada Abstract: With the current intense interest in new computing paradigms based on logic, the efficient implementation of Prolog has become an issue of prime importance. Compiling Prolog involves some unique and difficultproblems relating to storage management: in particular,the somewhat conflictingrequirements of backtracking, and cut and tail recursion processing. The usual solution is to use garbage collection, an expensive process in small computers with limited storage. We describe a Prolog compiler which maintains the heap as lists of free records, to which records are released at the time they are deaUocated, thus avoiding garbage collection. Introduction Because of the current interest in new computing paradigms based on logic, implementation of Prolog, an issue previously of academic interest, is now of prime importance.
"Normalization of relations and PROLOGA program for the normalization of relations that is written in Prolog has several advantages relative to programs written in conventional programming languages: notably, conciseness and clarity.Sibley Panel Editor A program for the normalization of relations that is written in Prolog has several advantages relative to programs written in conventional programming languages: notably, conciseness and clarity. The program presented here implements several normalization algorithms and is suitable for the interactive design of small database applications and as a teaching aid. IVORMALIZATION OF RELATIONS AND PROLOG S. CERI and G. GOTTLOB Database design is the art and science of deciding the structures of database relations that are most suited to represent a small portion of the world called the ""universe of discourse."" Moreover, the Prolog code is quite compact. (The core of the system is listed in the Appendix, and we encourage the reader with a Prolog interpreter to experiment with the algorithms.)"
"Towards functional programming in PrologThe integration of functional and logic programming is attempted, using the strategy to add a functional component to Prolog. The component takes the form of extended computable expressions, allowing user-defined functions and operators as well as a number of functional forms.TOWARDS FUNCTIONAL PROGRAMMING IN PROLOG Antonio L. Furtado* Rio Scientific Center "" IBM Brasil Estrada da Canoa, 3520 22.610, Rio de Janeiro, RJ ABSTRACT The integration of functional and logic programming is attempted, using the strategy to add a functional component to Prolog. The other significant orientation is logic programming, exemplified by Prolog. Predicates are the driving mathematical concept in logic programming. Some Prolog dialects offer a limited functional capability."
"Real-time reasoning with PROLOGIn this paper, we present a description of a Prolog implementation of a system (RTR) for ""real-time reasoning"", similar to those discussed by Perlis (see [3] and [6]).Real-Time Reasoning with Prolog Chunsik Yi and Steven Graham University of Missouri-Kansas City Computer Science and Telecommunications Program 5100 Rockhill Road. Kansas City, Missouri 64110 In this paper, we present a description of a Prolog implementation of a system (RTR) for ""real-time reasoning"", similar to those discussed by Perlis (see [3] and [6]). The efficient database structures provided with Prolog make this a reasonable III~~~I:I~~~III even as the size of LTM grows."
Implementation of a Prolog-INGRES interfaceThis report describes a working prototype of a Prolog-INGRES interface based on external semantic query simplification. In addition to data, rules are stored in the database as well and are retrieved automatically if the Prolog program references them but they are not defined in the Prolog rulebase.Implementation of a Prolog-INGRES Interface S. Ghosh, C.C. Lin and T. Sellist Department of Computer Science University of Maryland College Park, MD 20742 ABSTRACT This report describes a working prototype of a Prolog-INGRES interface based on external semantic query simplification. In addition to data, rules are stored in the database as well and are retrieved automatically if the Prolog program References them but they are not defined in the Prolog rulebase. ? Prolog alone cannot meet the requirement of supporting large databases.
"On prolog and the occur check problemIt is well-known that omission of the occur check in unification leads to unsound Prolog systems. Nevertheless, most Prolog systems omit the occur check because this makes unification much faster and unsoundness allegedly seldom manifests itself. Firstly, ""unification without the occur check"" is ambiguous, and in practice, Prolog systems vary markedly in their reaction to programs having occur check problems. Secondly, even very simple program transformations are unsafe for pure Prolog when the occur check is omitted. We conclude that the occur check problem is important, and in particular, that the current efforts to standardize Prolog should address it.ON PROLOG AND THE OCCUR Kim Marriottt and Harald S0ndergaardt: t""Departmentof Computer Science Universityof Melbourne Parkville 3052 Vic., Australia CHECK PROBLEM : DIKU,Universityof Copenhagen Universitetsparken 1 2100 KObenhavn, Denmark Abstract. It is well-known that omission of the occur check in unification leads to unsound Prolog systems. Nevertheless, most Prolog systems omit the occur check because this makes unification much faster and unsoundness allegedly seldom manifests itself. Secondly, even very simple program transformations are unsafe for pure Prolog when the occur check is omitted. We conclude that the occur check problem is important, and in particular, that the current efforts to standardize Prolog should address it. 1."
High performance integrated Prolog processor IPPTo realize the highest performance possible for a sequential processor, and to realize utilization of a large amount of existing software, an integrated Prolog processor (IPP) and its optimized compiler are now being developed. A tagged architecture under constraints of a general purpose computer and a memory management strategy to achieve a high performance are discussed and then an IPP architecture is presented. Based on the Prolog instruction set, which is an extension of Warren's, the Prolog compiler introduces new functions such as indexing by the optimal argument and global register assignment across determinate built-in predicates.ABSTRACT HIGH PERFORMANCE INTEGRATED PROLOG PROCESSOR IPP S. Abe T. Bandoh S. Yamaguchi K. Kiriyama Hitachi Research Laboratory, Hitachi, Ltd. 4026, Kuji, Hitachi, Japan requirement for Prolog. To overcne (i) and (2), we are developing a 'Ib realize the highest performance for a sequential processor, and to utilization of a large amount of possible Prolog processor based on Warren's instruction realize set, which is integrated into a general purpose existing computer. In the following, the high performance software, an integrated Prolog processor (IPP) and its optimized compiler are now being developed.
Danish field grammar in typed prologThis paper describes a field grammar for Danish and its implementations in a Prolog version with predeclared types. In comparison to the ususal S -> NP VP schema, this kind of grammar, where the first rule is S -> CNF FF NF CF enhances analysis effeciency because the fields specify constituents and syntactic function at the same time. The field grammar tradition is outlinedand an overview of the major rules of the Prolog program, which implements the grammar, is given.DANISH FIELD GRAMMAR IN TYPED PROLOG Henrik Rue UNI-C, Danish Computing Center for Research and Education Vermundsgade 5, DK 2100 @, Copenhagen, Denmark ABSTRACT This paper describes a field grammar for Danish and its implementations in a Prolog version with predeclared types. The field grammar tradition is outlinedand an overview of the major rules of the Prolog program, which implements the grammar, is given. Prolog Dialect The Prolog dialect used is the Danish prototype of Borland's TurboProlog.
A comparative feature-analysis of microcomputer prolog implementationsIn recent years, no programming language has received the international attention of PROLOG. Currently the Japanese Fifth Generation computing Systems Project (ICOT) is attempting to build an entire series of computers around this language in order to implement a new generation of computers based on symbolic inferencing techniques. In the United States and Europe, PROLOG is being used in relational database applications, natural language processing, theorem proving and automated reasoning, and a variety of other artificial intelligence applications.In this article, we compare several of the newer PROLOG interpreters and compilers with regard to their functionality.These, in turn, g a v e r i s e to newer offspring, culminating in the microcomputer-based products now under study. SIGPLAN Notices, V21 #2, February 1986 IIo PROLOG TERMINOLOGY AND THEORY There is a fairly large variance -47- in the terminology associated with PROLOG implementations This is a reflection of the historical differences in the origin of the various PROLOGs There appear to be three de facto standards on which implementations are modeled, implementation [24] (as discussed micro-PROLOG[22], and MPROLOG[21], earlier Marseilles implementation. however. Two of these provide syntactic sugar for the basic syntax covered below. -49-Others provide an interactive trace facility and a context editor. Micro-Prolog was one of the f i r s t PROLOGs available on microcomputers. Although not available in the PC/DOS version reviewed for t h i s a r t i c l e , module support is scheduled for later PC/DOS versions. MPROLOG is apparently rooted in versions of PROLOG developed in Hungary, and thus employs a s l i g h t l y d i f f e r e n t vocabulary from PROLOGS derived from DEC 10 PROLOG.
A direct execution architecture for Prolog?This paper describes work in progress on the development of a direct execution Prolog processor.A Direct ExecutionArchitecturefor Prolog? Michael Brady Department of Computer Science University of Dublin Trinity College Dublin Ireland This paper describes work in progress on the development of a direct execution Prolog processor. INTRODUCTION Prolog [Clocksin & Mellish 19811 [Bowen et al 19821 is a computer language based on a variant of first-order predicate calculus called Horn Clause Logic. It might be said, roughly, that the relationship of Prolog to logic is the same as that of LISP to the Lambda Calculus.
A note on the speed of PrologBased on an experiment in compiler writing methods, we discuss the speed of Prolog programs of modest size when compared with operationally equivalent Pascal programs. We have produced three versions of a compiler for the programming language Edison using three different tools: Pascal, Prolog, and a compiler writing system (GAG). The Prolog and Pascal programs analyzed in this case are the semantic analysis and the code transformation phases of the Edison compiler. Our analysis shows that it is possible to write Prolog programs that are able to compete in speed with the corresponding programs written in Pascal.Abstract A note on the speed of Prolog Jukka Paakki I GMD Forschungsstelle an der Universitit Karlsruhe (German National Research Center for Computer Science) Haid-und-Neu-Str. 7 D-7500 Karlsruhe 1 Federal Republic of Germany Based on an experiment in compiler writing methods, we discuss the speed of Prolog programs of modest size when compared with operationally equivalent Pascal programs. We have produced three versions of a compiler for the programming language Edison using three different tools: Pascal, Prolog, and a compiler writing system (GAG). The Prolog and Pascal programs analyzed in this case are the semantic analysis and the code transformation phases of the Edison compiler. Our analysis shows that it is possible to write Prolog programs that are able to compete in speed with the corresponding programs written in Pascal.
"Prolog puzzlesBox 90153 5000LE Tilburg, The Netherlands R974CASI@HTIKUB5.BITNET The title of a recent paper promised an exposition on Puzzle-solving in Prolog [3]. Actually, the title was used only as a starting point for some highly abstract thoughts on logic, but it may have suggested to some readers that puzzles, such as those conceived by Smullyan, are not easily programmed in Prolog. It is the intention of this paper to show that puzzles are quite appropriate as exercises for introductory Prolog courses. For a start we present a simple puzzle on the lines of the ""snow puzzle"" in [3], which might be part of a game of ""Trivial Pursuit"": ""What is the capital of Holland ?"". This simple example exposes a problem with Turbo-Prolog, as it does not support the parenthesized expression in the capital clause."
An interactive source commenter for Prolog programsProlog meta-circular interpreters, i.e., interpreters for Prolog written in Prolog, perform at least two operations on an object program - they parse it and execute its instructions. The value of such a parser is that it provides an elegant means to modify Prolog source code. As the object program is parsed, new information in the form of additional instructions, comments, etc., can be selectively inserted. The Prolog source code commenter we describe is a meta-circular parser with facilities added to allow a user to interactively enter comments.An Interactive Source Code Commenter for Prolog Programs tDavid Roach, tHa1 Berghel, SJohn Talburt Center for Artificial Intelligence and Expert Systems t131 Biomass Research Center University of Arkansas Fayetteville, AR 72701 $2801 S. University University of Arkansas at Little Rock Little Rock, AR 72204 Abstract Meta-Circular Parsing Prolog meta-circular interpreters, i.e., interpreters for Prolog written in Prolog, perform at least two operations on an object program - they parse it and execute its instructions. The Prolog source code commenter we describe is a metacircular parser with facilities added to allow a user to interactively enter comments.
Using Prolog to present abstract machinesThis paper demonstrates that a neat and useful way of presenting these automata is to use a logic programming language such as Prolog, making the approach useful from a teaching point of view. Not only does a Prolog specification provide a precise definition of an automoton's behaviour, but it also gives an immediately-executable simulator. The reversible execution property of Prolog programs can make these simulators inherently more powerful than traditional simulators.USING PROLOG TO PRESENT ABSTRACT MACHINE S D Crooke s Department of Computer Scienc e The Queen's University of Belfas t BELFAST BT7 1NN, Northern Irelan d Introductory courses in Theory of Computatio n usually include a study of abstract machine s such as finite state machines and Turin g machines . This paper demonstrates that a nea t and useful way of presenting these automata i s to use a logic programming language such a s Prolog, making the approach useful from a teaching point of view . Not only does a Prolo g specification provide a precise definition of a n automoton's behaviour, but it also gives a n immediately-executable simulator . Th e reversible execution property of Prolog program s can make these simulators inherently mor e powerful than traditional simulators .
The lion and the unicorn met PROLOGA recent paper published in the Journal of Automated Reasoning, No. 1, 1985, described ways to apply automatic theorem-proving techniques to a logic puzzle. The PROLOG programming language pertains to automatic theorem-proving. That paper did not mention PROLOG, but we use PROLOG to slove the logic puzzle that paper discussed.ABSTRACT -62-The Lion and the Unicorn Meet PROLOG Bruce D. Ramsey IBM Corporation, General Products Division Tucson, Arizona 85744 A recent paper published in the Journal of Automated Reasoning, No. 1, 1985, described ways to apply automatic theorem-proving techniques to a logic puzzle. The PROLOG programming language pertains to automatic theorem-proving. That paper did not mention PROLOG, but we use PROLOG to solve the logic puzzle that paper discussed.
"Data buffer performance for sequential Prolog architecturesSeveral local data buffers are proposed and measurements are presented for variations of the Warren Abstract Machine (WAM) architecture for Prolog. Choice point buffers, stack buffers, split-stack buffers, multiple register sets, copyback caches, and ""smart"" caches are examined. The data memory performance results are equally valid for native code and reduced instruction set implementations of Prolog.DATA BUFFER PERFORMANCE FOR SEQUENTIAL PROLOG ARCHITECTURES* Evan Tick Computer Systems Laboratory Stanford University Stanford, CA 94305 Several local data buffers are proposed and measurementsare presented for variations of the Warren Abstract Machine (WAM) architecture for Prolog. The data memory performance results are equally valid for native code and reduced instruction set implementations of Prolog. 1 Introduction The goal of this paper is to show that efficient memory designs are even more critical for symbolic processor performance than for numeric processors. Evaluation of Prolog performance is approached from the vantage point of memory design."
Garbarge collection for Prolog based on WAMThe Warren abstract machine (WAM) has become a generally accepted standard Prolog implementation technique. Garbage collection is an important aspect in the implementation of any Prolog system.RESEARCHCONTRh3UTIONS AYtifiCiUl Intelligence and Language Processing Garbage Collection for Prolog Jacques Cohen Editor Based on WAM KAREN APPLEBY, MATS CARLSSON, SEIF HARIDI, and DAN SAHLIN The Warren abstract machine (WAM) has become a generally accepted standard Prolog implementation technique. Garbage collection is an important aspect in the implementation of any Prolog system. A synopsis of the WAM is presented and then marking and compaction algorithms are shown that take advantage of WAM's unique use of the data areas. The rest of the article is organized as follows: First a synopsis of Warren's Prolog implementation, the Warren abstract machine (WAM), is given.
Fast Prolog with an extended general purpose architectureMost Prolog machines have been based on specialized architectures. Our goal is to start with a general purpose architecture and determine a minimal set of extensions for high performance Prolog execution. We have developed both the architecture and optimizing compiler simultaneously, drawing on results of previous implementations. We find that most Prolog specific operations can be done satisfactorily in software, however, there is a crucial set of features that the architecture must support to achieve the best Prolog performance.Fast Prolog with an Extended General Purpose Architecture Bruce K. Pendleton Harvest VLSI Design Center, Inc. Most Prolog machineshave been basedon specialized atchitecturns. We hnd that most Prolog specific operations can bc done satisfactorily in software: however, there is a crucial set of features that the architecturc must support to achieve the best Prolog performance.
An augmented Prolog programming environment for tutoring applicationsThis paper focuses on the design of an Augmented Prolog Programming Environment (APPE) for learning Prolog. In general, language compilers and interpreters can only detect syntax errors and can hardly diagnose semantic errors. It is conceived that a Prolog system can be enhanced considerably with the inclusion of an intelligent diagnoser and facilities for doing problem acquisition from the teacher and administering problems to the student. Unlike traditional CAI programs which support mainly teacher-centered tutorials, APPE facilitates the discovery mode of learning since it can cope with individual student programs. The design enables the diagnoser to classify Prolog program bugs into five categories: incorrect solutions, uncovered solutions, redundant solutions, nontermination, and invalid parameters.An Augmented Prolog Programming Environment for Tutoring Applications Moon-c huen Lee Dept of Computer Science, The ChineseUniversity of Hong Kong Shatin, Hong Kong This paperfocuseson the designof anAugmented Prolog Programming Environment (APPE) for learning Prolog. In general, language compilers and interpreters can only detect syntax errors and can hardly diagnose semantic errors. It is conceived that a Prolog system can be enhancedconsiderably with the inclusion of an intelligent diagnoser and facilities for doing problem acquisition from the teacher and administering problems to the student. In consequence, Prolog programming is not purely declarative and more difficult than expected.
School time table scheduling in PrologThe descriptive, logic-based and nondeterministic nature of Prolog language, and its ability to backtrack allows one to easily obtain a deductive data base, mixing the facts, rules, and constraints of the Time-table.SIGART Newsletter, April 1986, Number 96 ARTICLES SCHOOL TIME TABLE SCHEDULING IN PROLOG Professor Angelo Monfroglio OMAR Technical High School Bal. The descriptive, logic-based and nondeterministic nature of Prolog language, and its ability to backtrack allows one to easily obtain a deductive data base, mixing the facts, rules, and constraints of the Timetable. It is unlikely that a polynomial algorithm exists for solving the general Constraint Satisfaction Problem, since some CSP are NP-complete. NOTE. The research uses a prolog implementation (micro-PROLOG by LPA) for microcomputers available for most personal and microcomputers (PC-IBM, Apple, AT&T-Pc, Commodore 64, etc.).
Automata-driven indexing of Prolog clausesIndexing Prolog clauses is an important optimization step that reduces the number of clauses on which unification will be performed and can avoid the pushing of a choice point.Automata-Driven Indexing of Prolog Clauses t R. Ramesh Department of Computer Science University of Texas at Dallas Richardson, TX 75083. Warren Department of Computer Science State University of New York at Stony Brook Stony Brodk, NY 11794. Indexing Prolog clauses is an important optimization step that reduces the number of clauses on which unification will be performed and can avoid the pushing of a choice point. I Introduction The fundamental computational step in execution of Prolog programs is the selection and unification of clause-heads with goal.
Prolog dialects: a deja vu of BASICsThe evolution of Prolog is reminiscent of the kind of dialect formation that BASIC and LISP went through, only worse. Prolog appears to be spawning divergent mutants that differ from one another in syntax, grammar and symmantics. Given that both LISP and Prolog are used for artificial intelligence, Prolog has been quite slow to catch on commercially, in large part due to a lack of this standardization, and its future is unclear.Abstract -39-Prolog Dialects: a deja vu of BASICs Raymond A. Sosnowski Sanders Associates, Inc. MER24-1283, C.S. 2034 Nashua, N.H. 03061-2034 The evolution of Prolog is reminiscent of the kind of dialectformation that BASIC and LISP went through, only worse. Prolog appears to be spawning divergent mutants that differfrom one another in syntax, grammar and symmantics.
Architecture of high performance integrated Prolog processor IPPThis paper describes a high speed integrated Prolog processor (IPP) which integrates the extended Warren's Prolog instructions, and its acceleration hardware into a 32-bit super-minicomputer. Tagged data format and instruction format under constraints of a general purpose machine architecture, and aspects of the hardware architecture of the IPP which includes some special hardware for an accelerating Prolog instruction execution are described. The IPP is implemented by high speed ECL(emitter coupled logic) gate arrays and its inference performance is 1 MLIPS for the deterministic concatenate program. It is easy for the IPP to link Prolog programs and existing procedural programs. And it can share its hardware resource with a base machine.ARCHITECTURE OF HIGH PERFORMANCE INTEGRATED PROLOG PROCESSORIPP S. Yamaguchi T. Bandoh K. Kurosawa M. Morioka Hitachi ResearchLaboratory, Hitachi, Ltd 4026, Kuji, Hitachi, Japan This paper describes a high speed integrated Prolog processor (IPP) which integrates the extended Warren's Prolog instructions, and its acceleration hardware into a 32-bit super-minicomputer. Tagged data format and instruction format under constraints of a general purpose machine architecture, and aspects of the hardware architecture of the IPP which includes some special hardware for an accelerating Prolog instruction execution are described. The IPP is implemented by high speed ECUemitter coupled logic) gate arrays and its inference performance is 1 MLIPS for the deterministic concatenate program, It is easy for the IPP to link Prolog programs and existing procedural programs.
The implementation of Prolog via VAX 8600 microcodeWe have implemented a high performance Prolog engine by directly executing in microcode the constructs of Warren's Abstract Machine. In our system, each of the Warren Abstract Machine instructions is implemented as a VAX 8600 machine level instruction. Other Prolog built-ins are either implemented directly in microcode or executed by the general VAX instruction set. Initial results indicate that our system is the fastest implementation of Prolog on a commercially available general purpose processor.The Implementation of Prolog via VAX 8600 Microcode Jeff Gee,StephenW.Melvin, YaleN. Patt Computer Science Division University of California Berkeley, CA 94720 We have implemented a high performance Prolog engine by directly executing in microcode the constructs of Warren's Abstract Machine. Initial results indicate that. our systemis the fastestimplementation of Prolog on acommercrally available general purpose processor. 1.
A lexical functional grammar system in PROLOGThis paper describes a system in PROLOG for the automatic transformation of a grammar, written in LFG formalism, into a DCG-based parser.Abstract A Lexical Functional Grammar System in Prolog Andreas Eisele and Jochen DOrre Department of Linguistics University of Stuttgart West Germany grammar implementors in two respects: i) Using DCGs for parsing (and overcoming the prohibition of This paper describes a system in PROLOG for the automatic transforination of a grammar, written in LFG formalism, into a DCG-based parser. At the University of Stuttgart such a system has been implemented in PROLOG, which uses tile formalism of Lexical-Functional Grammar [Kaplan/Bresuan 82] as its description language. In this point we had to find a good compromise between speed of parsing and speed of grammar modification. - Using as much of PROLOG as possible We wanted to profit from the facilities PROLOG offers for left recursion) ii)Profiting from PROLOG's unification mechanism to implement LFG-Unification.
The physiology of PROLOG expert system inference engineThe current literature on expert systems development in Prolog is replete with sample inference engines. However, the available models tend to be fragmentary and simplistic. Therefore, we present and describe a more realistic Prolog expert system inference engine. The inference engine is an enhanced version of a standard model. We give special consideration to the relationship that the inference engine bears to the underlying Prolog engine. The role of unification and SLD resolution in the life of a Prolog expert system inference engine is also discussed.The Physiology of a Prolog Expert SystemInference Engine David Roach, Hal Berghel University of Arkansas National Center for Toxicological Research The current with samuleliteratureonexpertsystemsdevelopmentinPrologisreplete inference engines. Therefore, we present and describe a more realistic Prolog expert system inference engine. The inference engine is an enhanced version of a standard modeL It includes features and employs techniques that are non-existent in current models. We give special consideration to the relationshi that the inference engine bears to the underlying Prolog engine. TEe mle of unification and SLD resolution in the life of a Prolog exuert system Introduction There seemsto be general agreement on the way to write a rule oriented, backward-chaining expelt system inference engine in Prolog [1.2,3,8,11,12].
A PROLOG implementation of Government-Binding TheoryA parser which is founded on Chomsky's Government-Binding Theory and implemented in PROLOG is described. By focussing on systems of constraints as proposed by this theory, the system is capable of parsing without an elaborate rule set and subcategorization features on lexical items.Abstrae_t A parser which is founded on Chomskyts Government-Binding Theory and implemented in PROLOG is described. By focussing on systems of constraints as proposed by this theory, the system is capable of parsing without an elaborate rule set and subcategorization features on lexical items. We also attempt to show that logic programming (specifically, PROLOG (Clark and Tarnlund (1982), Clocksin and Mellish (1984), Hogger (1984), and Kowalski (1979))) makes perspicuous the principles and constraints which underlie this parser. 2. Overview of Government-Binding Theory GB-Theory (Chomsky (1981)) has shifted the emphasis of grammar from a system of rules to a system of modules which include: X-bar Theta Case Bounding Trace Control Binding Government 546 A PROLOG Implementation of Government-Binding Theory Robert J.
A common-LISP implementation of an extended Prolog systemThis paper presents an extended Common LISP implementation of a PROLOG interpreter named CL-Prolog, giving a detailed description of the major problems met and the principal data structures and algorithms used for their solution.A sort of PROLOG virtual processor has been implemented whose instructions are defined using LISP as microcode, particular attention is payed to the the Memory Management Unit and the basic Control Mechanism.The reader is supposed to be accustomed with PROLOG Programming and the evaluation of the first order Logic Predicates.The main characteristics of CL-Prolog are:- Clean separation from the host language.- Tail recursion handling and binding mechanism optimization.- Portability, flexibility, and extendibility of basic model.- Interaction between PROLOG code and host LISP interpreter.Interpreter's core is separated in three big modules in order to cut off the different issues :- the reader, the evaluator, and the resources manager -Finally the introduction of a double-stack recursion management has sped up the Backtracking mechanism, the resulting overall performances of this interpreter are really comparable to other commercial one even when they are implemented using procedural languages, supposed faster, confirming the possibility of using very high level languages as effective tools for real implementations.A Common-LiSP Implementation of an Extended PROLOG Systemtll Giuseppe CATTANEO 1,2,Vincenzo LOIA 2,3 1Diparfimento di Informatica ed Applicazioni Universith di SALERNO 1-84100. 21stituto di Cibemetica C.N.R. 1-80072 Arco Felice (NAPOLI). 3 Laboratoire d' Informatique Universit de Rouen Mont Saint Aignan F-76134. ABSTRACT This paper presents an extended Common LISP implementation of a PROLOG interpreter named CL-Prolog, giving a detailed description of the major problems met and the principal data structures and algorithms used for their solution. The reader is supposed to be accustomed with PROLOG Programming and the evaluation of the first order Logic Predicates.
The `Hamming' in PrologThe 'Hamming Problem' in Prolog David Hemmendinger Department of ComputerScience and Engineering Wright State University Dayton, Ohio 45435 csnet: dhemm@CS.wright.edu Dijkstra [1] attributes to Hamming the problem of generating the set {2i3/5 k I i,j,k >_0} in increasing order. Kahn and MacQueen [4] showed how to solve the problem with a stream-processing program that could be implemented with concurrent processes, and since then it has often been cited as an example of a problem whose concurrent solutions are simpler than sequential ones. In fact, however, the solution in Prolog is scarcely more complex than the concurrent ones. If we replace a breadth-first interpreter by an appropriate set of queues as data structures, then we can write a sequential Prolog solution. Queues may be implemented in Prolog as difference lists, which are structures of the form Front\Rear that represent the contents of a list as the initial elements that are the difference between the two lists, Front and Rear.
Implementation of a high-speed Prolog interpreterThis paper describes the implementation of a high speed Prolog interpreter on a standard microprocessor (50 KLIPS on a 16 MHz MC68020).This paper describes the implementation of Implementation of a High-Speed Prolog Interprete r Andreas Kral l Institut fur Praktische Informati k Technische Universitt Wie n Argentinerstr . 8 A-1040 Wie n Europe Application Syste m a high speed Prolog interpreter on a standar d microprocessor (50 KLIPS on a 16 MH z MC68020) . The second part compares the implementation, the runtime and th e storage requirements with that of a compiler . Keywords : Prolog interpreter, Prolog compiler , direct threaded code 1 Introductio n Today most Prolog interpreters and compiler s do not meet the requirements for developin g large application programs . A prolog interpreter is a program, which proof s horn clauses .
Performance studies of a parallel Prolog architectureWe present the most comprehensive experimental results available to date on combined AND-parallelism, OR-parallelism, and intelligent backtracking in Prolog programs. Simulation results indicate that most Prolog programs in use today cannot effectively make use of multiprocessing.PERFORMANCE STUDIES OF A PARALLEL PROLOG ARCHITECTURE Barry S. Fagin Alvin M. Despain Computer Science Division University of California Berkeley, CA 94720 ABSTRACT This paper presents a new multiprocessor architecture for the parallel execution of logic programs, developed as part of the Aquarius Project. We present the most comprehensive experimental results available to date on combined ANDparallelism, OR-parallelism, and intelligent backtracking in Prolog programs. Simulation results indicate that most Prolog programs in use today cannot effectively make use of multiprocessing. 1. First, we briefly discuss techniques for improving Prolog performance, and discuss a rrew execution model for Prolog: the PPP model (for Parallel Prolog Processor).
A Chare kernel implementation of a parallel Prolog compilerWe have designed and implemented a compiler for the parallel execution of Prolog programs as a machine independent application on top of a run time environment for parallel programming called the Chare Kernel. The compiler is based on the Reduce-OR process model for the AND and OR parallel execution of Prolog programs and hence exploits both OR and independent AND parallelism found in Prolog programs. We describe the salient features of the parallel Prolog compiler from the viewpoint of its implementation as a Chare Kernel application.A Chare Kernel Implementation of a Parallel Prolog Compiler Balkrishna Ramkumar and Laxmikant V. Kalk Dept. of Computer Science, University Of Illinois at Urbana-Champaign, Urbana, Illinois 61801 We have designed and implemented a compiler for the parallel execution of Prolog programs as a machine independent application on top of a run time environment for parallel programming called the Chare Kernel. The compiler is based on the Reduce-OR process model for the AND and OR parallel execution of Prolog programs and hence exploits both OR and independent AND parallelism found in Prolog programs. We describe the salient features of the parallel Prolog compiler from the viewpoint of its implementation as a Chare Kernel application.
Ada tasking model and Prolog predicationThis paper is a comparative analysis of the semantics of the Ada tasking model and the Prolog predication. The features analyzed are communication and synchronization, matching and unification, error handling, procedure dependencies, shared variables, logical inferences and concurrency.
Survey and comparison of PARLOG and Concurrent PrologThis paper surveys and compares the two most significant concurrent programming languages, PARLOG and Concurrent Prolog. For both languages the main features are presented and discussed.Survey and Comparison of PARLOG and Concurrent Prolog Domenico Talia CRAI Localit S. Stcfano, 87036 Rende (CS), Italy Abstract The integration of logic programming and concurrent programming has created a new class of languages, concurrent logic languages. This paper surveys and compares the two most significant concurrent programming languages, PARLOG and Concurrent Prolog. For both languages the main features are presented and discussed. 1. Bn is the set of procedure calls which constitute the procedure body. Logic programming languages, whose PROLOG [15] is the primary and the most widespread, were born from this kind of interpretation.
"A PROLOG-based expert system for tuning MVS/XATo understand the components of an Expert System and their functions, PROLOG on an IBM PC (Turbo-PROLOG from Borland International) was chosen as the development environment. The paper will begin by defining the key concepts about Expert Systems, Knowledge Engineering, and Knowledge Acquisition. The reader will be given a brief overview of PROLOG, from which we can explain how an inference mechanism was developed.A PROLOG-based Expert System for Tuning MVS/XA Dr. Bernard Domanski ""Fhe College of Staten Island / CUNY *** ABSTRACT This paper will discuss some of the issues involved in building an Expert System that embodies tmling rules for It 3M's MVS/XA operating system. To understand the components of an Expert System and their functions, PROLOG on an IBM PC (Turbo-PROLOG from Borland International) was chosen as the development environment. The paper will begin by defining the key concepts about Expert Systems, Knowledge Engineering, and Knowledge Acquisition. The reader will be given a brief overview of PROLOG, from which we can explain how an inference mechanism was developed."
Evaluation of memory system for integrated Prolog processor IPPThis paper discusses an optimal memory system to realize a high performance integrated Prolog processor, the IPP. First, the memory access characteristics of Prolog are analyzed by a simulator, which simulates the execution of a Prolog program at a micro instruction level. The main findings from this analysis are that: the write access ratio of Prolog is larger than that of procedural languages, and performance improvement requires the memory system to process concentrated, large write accesses effectively. Then the Prolog acceleration strategies for conventional cache memories are discussed.EVALUATION OF MEMORY SYSTEM FOR INTEGRATED PROLOG PROCESSOR IPP M. Morioka S. Yamaguchi T. Bandoh Hitachi Research Laboratory, Hitachi, Ltd. 4026 Kuji, Hitachi, Japan This paper discusses an optimal memory system to realize a high performance integrated Prolog processor, the IPP. First, the memory access characteristics of Prolog are analyzed by a simulator, which simulates the execution of a Prolog program at a micro instruction level. Then the Prolog acceleration strategies for conventional cache memories are discussed.
A Prolog system for case-based classification (abstract)It is becoming apparent from the research of Kolodner, Schank, and others that case-based reasoning is an important tool for artificial intelligence. We have implemented a case-based system in Prolog that classifies objects described by attribute-value pairs. It uses Prolog's facilities to manage a case database and to encode features.A drawback to many implementations of ID3 is that the resulting decision tree is not in a readily usable form, say for an expert system. We have written Prolog routines that implement ID3 and that write executable Prolog rules. CSC '90 Poster Session Abstract A Prolog System for Case-Based Classification William W. It uses Prolog's facilities to manage a case database and to encode features.
Process programming with PrologPROCESS PROGRAMMING WITH PROLOG Atsuo Ohki, Koichiro Ochimizu Department of Computer Science, Shizuoka University Hamamatsu, Japan 1. They also make their consensus through discussions. is represented naturally by Prolog backtracking with some enhancement. We have enhanced Prolog control structures to accommodate (2). We have found that our enhanced Prolog is useful for tool invocations. We could represent well-known or routine activities in software design activities in Prolog.
Microprogram control of a Prolog machineA Prolog machine design and its control are described. The machine features two-stage pipelining, a triple bus interconnection data path and support for concurrent control of micro-operations. The objective of this design is to improve execution of a Prolog processor by simultaneously performing multiple micro-operations. Capabilities of concurrent operation support are described in detail and demonstrated using some example Prolog functions. Two-stage pipeline technique as applied to non-deterministic control of Prolog program execution will be presented.
A plea for a readable Prolog programming styleProlog is not like most computer languages. In Prolog a particular action can bring forth many results. It is from this that both the power and danger of Prolog come.I will attempt to discuss ways in which Prolog programs can be written to improve maintenance and debugging.Robert McLaughlin PRA, Inc. 827 Leesburg Pike, Suite 7 Vienna VA 22182 A Plea For a Readable Prolog Programming Style 1. Abstract Prolog is not like most computer languages. In Prolog a particular action can bring forth many results. be taken when writing code. It is from this that both the power and danger of Prolog come. I w i l l attempt to discuss ways in which Prolog programs can be w r i t t e n to improve maintenance and debugging.
On typing in prolog-28 ON TYPING IN PROLOG Daniel Brand IBM Thomas J. Watson Research Center P.O. Socrates is human. Bundle is a dog. Is Bundle mortal? A Prolog representation would be Human($x) -> Mortal($x) Human(Socrates) Dog(Bundle) -, Mortal(Bundle) Our convention is to indicate a variable by a $ sign. The reader can probably appreciate that in a larger example each such failure means a lot of wasted CPU time. For this and similar reasons some Prolog interpreters allow a Cut operator. However, it is generally recognized that a Cut operator is undesirable because it is error-prone and it changes the semantics of Prolog.
Interfacing Prolog to PascalINTERFACING PROLOGTO PASCAL KENNETH MAGEL NORTH DAKOTA STATE UNIVERSITY This paper presents the implementation of a mechanism for linking an existing Prolog interpreter with Pascal programs so that each may call the other and so that each may share data with the other. Prolog includes a naive automatic backtracking mechanism as well as a pattern matching-triggered application of rules. Even in these areas, however, Prolog does not provide all of the features which would make implementation as convenient as possible, In some situations where the Prolog implementation is easily constructed, the implementation will be inefficient.
Implementing a Prolog machine with multiple functional unitsThis paper describes the microarchitecture of the PLUM, a high performance Prolog machine. Multiple specialized functional units, each with a port to memory, operate in parallel using data driven control.Implementing a Prolog Machine with Multiple Functional Units Ashok Singhal Yale N. Patt Computer Science Division University of California, Berkeley This paper describes the microarchitecture of the PLUM, a high performance Prolog machine. Multiple specialized functional units, each with a port to memory, operate in parallel using data driven control. Introduction In order to achieve high performance execution of Prolog programs, parallelism at all levels in the programs must be exploited.
An expert system for bibliographic retrieval using PrologPROBIB-2 is a prototype expert system for online bibliographic retrieval that provides enhanced retrieval capabilities through the application of logic programming. Implemented in Prolog, this system attempts to integrate the capabilities of a human search intermediary into a retrieval system that provides a deductive reasoning capability. User profiles may be used to establish a query environment to enable the system to determine the information need of the user. A concern with using Prolog to perform an online search of a large database is that the response time would be unacceptable. This set of predicates may then be used to resolve the user query in the normal Prolog manner.An Expert System for Bibliographic Retrieval Using Prolog C.R. Hatters and M.A. Shepherd Dept. of Mathematics, Statistics, and Computing Science Dalhousie University, Halifax, N.S., Canada B3H 355 LI. Jee School of Computer Science Technical University of Nova Scotia Halifax, Nova Scotia, Canada 835 2X4 PROBIL-2 is a prototype expert system for online bibliographic retrieval that provides enhanced retrieval capabilities through the application of logic programming. Implemented in Prolog, this system attempts to integrate the capabilities of a human search intermediary into a retrieval system that provides a deductive reasoning capability. User profiles may be used to establish a query environment to enable the system to determine the information need of the user. A concern with using Prolog to perform an online search of a large database is that the response time would be unacceptable.
RISCs vs. CISCs for Prolog: a case studyThis paper compares the performance of executing compiled Prolog code on two different architectures under development at U. The compiled code for SPUR was obtained by simple macro-expansion of PLM code generated by the PLM Prolog compiler. The two implementations are compared with regard to static and dynamic program size, execution speed, and memory system performance. Optimizations of the macro-expanded code and minor architectural changes to SPUR would increase this ratio to 0.53, or 0.60 for the largest benchmarks. Thus a tagged RISC architecture can execute Prolog at least half as fast as a special-purpose CISC architecture for Prolog.RISCs vs. CISCs for Prolog: A Case Study Gaetano Borriello Andrew R. Cherenson Peter B. Nelson Computer Science Division Department of Electrical Engineering and Computer Sciences University of California Berkeley, California 94720 Abstract This paper compares the performance of executing compiled Prolog code on two different architectures under development at U.C. Optimizations of the macro-expanded code and minor architectural changes to SPUR would increase this ratio to 0.53, or 0.60 for the largest benchmarks. Thus a tagged RISC architecture can execute Prolog at least half as fast as a special-purpose CISC architecture for Prolog.
Towards an expert system for bibliographical retrieval: a Prolog prototypeA prototype Prolog system has been developed for online bibliographic retrieval. An expert system for online bibliographic retrieval, developed in Prolog, would provide enhanced retrieval capabilities through the application of deductive reasoning. In order to overcome this drawback two alternatives are examined: a special-purpose hardware device and an extended Prolog capability.Robertson School of Computer Science Technical University of Nova Scotia Halifax, rlova Scotia, Canada B3J 2X4 Traditional online bibliographic systems tend to be based on either the Boolean or the A prototype Prolog system has been developed for online bibliographic retrieval. An expert system for online bibliographic retrieval, developed in Prolog, would provide enhanced retrieval capabilities through the application of deductive reasoning. In order to overcome this drawback two alternatives are examined: a special-purpose hardware device and an extended Prolog capability. I. INTRODUCTION A project has been undertaken to develop a bibliographic retrieval system based on predicate calculus using Prolog as both programming language and data language.
PROLOG applications for database design with the information center
Design and distributed implementation of the parallel logic language shared PrologThe parallel logic language Shared Prolog embeds Prolog as its sequential component. A program is Shared Prolog is composed of a set of logic agents, i.e. Prolog programs, that communicate associatively via a shared workspace called blackboard. The distinct features that characterize Shared Prolog with respect to other parallel (logic) languages are: scheduling of agents and granularity of parallelism explicitly controlled, Prolog embedded in the language, intrinsic modularity, associative send/receive of messages among agents with a simple operational semantics in terms of assert/retract of clauses.Design and Distributed Implementation of the Parallel Logic Language Shared Prolog VAmbriola*+, P.Ciancarini*, MDanelutto* * Dipartimento di Informatica - Universith di Pisa + Dipartimento di Matematica eInformatica - Universitci di Udine Italy The parallel logic language SharedProlog embedsProlog as its sequential component. A program in SharedProlog is composed of a set of logic agents, i.e. Prolog programs, that communicate associatively via a shared workspacecalled blackboard. INTRODUCTION Stream-based parallel logic languages like Flat Concurrent Prolog (FCP), Flat Guarded Horn Clauses (FGHC), and Parlog are not extensions of Prolog.
The “Hamming problem” in PrologThe 'Hamming Problem' in Prolog David Hemmendinger Department of Computer Science and Engineering Wright State University Dayton, Ohio 45435 csnet: dhemm@CS.wright.edu Dijkstra [1] attributes to Hamming the problem of generating the set {213)5 k [ i,j,k >_0} in increasing order. Kahn and MacQueen [4] showed how to solve the problem with a stream-processing program that could be implemented with concurrent processes, and since then it has often been cited as an example of a problem whose concurrent solutions are simpler than sequential ones. In fact, however, the solution in Prolog is scarcely more complex than the concurrent ones. A concurrent solution The program in Shapiro's report on Concurrent Prolog [5] is a good example. It is complete except for the definition of the output routine outstream, which writes elements of a stream as they become available.
An experimental VLSI Prolog interpreter: preliminary measurements and resultsThis work presents the preliminary results of a project oriented to the design and VLSI implementation of a Prolog interpreter. Even if the interpretative approach is being considered an inefficient way to execute high level languages when compared to that of compilation, declarative languages with embedded extralogical instructions would require the use of direct execution.AN EXPERIMENTAL VLSI PROLOG INTERPRETER: PRELIMINARY MEASUREMENTS AND RESULTS P.L.Civera, F.Maddaleno, G.L.Piccinini, M.Zamboni Dip.di Elettronlca, Politecnico di Torino 1-10129 TORINO (ITALY) for this case: a solution is the recompilation of the whole ABSTRACT This work presents the preliminary results of a project oriented to the design and VLSI implementation of a Prolog interpreter. INTRODUCTION The increasing use of Artificial Intelligence techniques and Expert Systems using declarative languages such as Prolog 1, requires more specialized machines for the execution of these languages. This reason led us to implement a VLSI system for Prolog execution. The first basic decision to be taken is the choice of the execution technique, i.e., compiled execution versus interpreted execution.
A prolog simulation for a Delphi-based problem solverA solution integration approach and a model integration approach are discussed. A Prolog simulation of the Delphi problem solver demonstrates these concepts.A Prolog Simulation for a Delphi-Based Problem Solver Adel S. A solution integration approach and a model integration approach are discussed. A Prolog simulation of the Delphi problem solver demonstrates these concepts. The resulting software demonstrates some differences from the Prolog implementation mainly due to the support of frames in addition to rules.
A hybrid scheme for detecting AND-parallelism in prolog programsIn this paper, we present a hybrid scheme for detecting AND-parallelism in Prolog programs, in which data dependency analysis is conducted partly at runtime and partly at compile time. In addition, the hybrid scheme greatly supports the combining exploitation of AND- and OR-parallelism of Prolog.A Hybrid Scheme For Detecting AND-Parallelism In Prolog Programs Hong Xia and Wolfgang K. Giloi GMD-TUB Research Center for Innovative Computer Systems and Technology Nardenbergplatz 2, 1000 Berlin 12, West Germany In this paper, we present a hybrid scheme for detecting AND-parallelism in Prolog programs, in which data dependency analysis is conducted partly at runtime and partly at compile time. In addition, the hybrid scheme greatly supports the combining exploitation of AND- and OR-parallelism of Prolog. 1. Introduction In the declarative semantics of Prolog, no sequentiality is specified with regard to the execution of subgoals in a clause. In general, there are two main ways to deal with data dependencies in Prolog programs: (1) Data dependencies can be described by users through introducing extra syntactical constructs to Prolog. (2) Data dependencies can be automatically detected by a compiler or a Prolog machine.
"An extension of PROLOG for object-oriented programming in logicIn this paper, we attempt extending Logic Programming ""smoothly"" in order to allow object-orientation in a PROLOG-like environment. We call our extension ""PROLoop"" (Yet another PROLOG-based Language for Object-Oriented Programming). PROLoop is the essential component of a PROLOG-based environment (""PROViro"") to develop knowledge and rule-based expert systems.An Extension of PROLOG for Object-Oriented Programming in Logic k Schmidt, F. Belli The University of Paderborn, Federal Republic of Germany In this paper, we attempt extending Logic Programming ""smoothly"" in order to allow object-orientation in a PROLOG-like environment. We call our extension ""PROLoop"" (Yet another PROLOG-based Language for Object-Oriented Programming). PROLoop is the essentialcomponent of a PROLOG-based environment (""PROViro"") to develop knowledge and rule-based expert systems."
Pipelined OR-parallelism architecture for parallel execution of PrologThis paper describes a parallel architecture to implement PROLOG. The architecture considered here takes advantage of the OR-parallelism inherent in the language.Pipelined OR-Parallelism Architecture for Parallel Execution of Prolog D. Sarma c. P. wu Department of Electrical & Computer Engineering Rhodes Hall, ML #30 University of Cincinnati Cincinnati, OH 45221 This paper describes a parallel architecture to implement PROLOG. To copy otherwise, or to republish, requires a fee and/or specific permission. guage. Examples of such languages are Parlog,Dado Prolog,Concurrent Prolog,etc.[l3]. Another approach is to exploit the inherent parallelism in the standard Pro log language. The simulation results gives an idea of the optimum numbers of processors to meet the cost performance requirements. 2 Standard Prolog Concept Computer programs in Prolog are rather like hypothesis about the object involved and their relationships.
Transformational programming: the derivation of a Prolog interpretation algorithmThe problem we intend to study is the construction of an interpreter for the logic programming language Prolog. We will start from a formal algebraic semantic definition of Prolog, through a series of transformations, step by step, reach a compact and efficient implementation written in programming language Ada.Transformational Programming: The Derivation of A Prolog Interpretation Algorithm MingYuan Zhu Beijing Institute of Systems Engineering P.O. The problem we intend to study is the constru s ction of an interpreter ming language Prolog. formal algebraic for the logic program-We will start from a semantic definition of Prolog, through a series of transformations, step by step, reach a compact and implementation written in programming efficient language Ada. Roussel implementation was built in Marseille. basic algorithm have been published. Prolog programs was in 1972 when the first Since then a number of Some of these contain expositions of structure sharing with copying ([6]). ([5]), other treat memory management The purpose of this paper is to present and to justify a simple algorithm for interpreting Prolog programs.
A set-oriented parallel execution model for PrologVarious parallel execution models have been proposed for Prolog. Static data dependency analysis and different forms of intelligent backtracking have been used in many of the parallel Prolog models developed in the last few years.
A high performance Prolog processor with multiple function unitsWe describe the Parallel Unification Machine (PLUM), a Prolog processor that exploits fine grain parallelism using multiple function units executing in parallel. These results show that PLUM with 3 Unification Units achieves an average speedup of approximately 3.4 over the Berkeley VLSI-PLM, which is usually regarded as the current highest performance special purpose, pipelined Prolog processor. Measurements that show the effects of multiple Unification Units and memory access time on performance are also presented.A High Performance Prolog Processor with Multiple Function Units Ashok Singhal Computer Science Division University of California Berkeley, CA 94720 Yale N. Patt Department of Electrical Engineering and Computer Science University of Michigan Ann Arbor, MI 48109-2110 We describe the Parallel Unification Machine (PLUM), a Prolog processor that exploits fine grain parallelism using multiple function units executing in parallel. Introduction The growing interest in logic programming and Prolog, has resulted in substantial research towards t.he design of high performance Prolog systems by taking advantage of parallel hardware.
Conditionals and counterfactuals in PROLOGWe concluded our paper with the announcement of a treatment of counteffactuals in terms of dialogical failure and of an implemented theorernprover for conditionals and counteffactuals based on our theoretical developments.In this note we will briefly describe the considerations: leading to our treatment of counteffactuals and introduce the implementation of a theoremprover for conditionals as a subsystem of PROLOG. For a more detailed description of the formal properties of the system we refer to (ttli.91).
An SQL interface to a prolog-based DBMSIn previous work, we have developed PROREL, a Prolog-based system for relational algebra and database [Beuerman, Proc.
A piggy-back compiler for PrologA Piggy-back Compiler For Prolog J. L. Weiner S. Ramakrishnan Computer Science Department University of New Hampshire March 18, 1988 1 Introduction In this paper, we describe' the design and impienieutation of an optimizing Prolog compiler. Our approach is novel both for the breadth of techniques employed and the performance we achieve as a resuit of using those techniques. Furthermore, we know of no other compiler for Prolog that utilizes the same techniques and achieves comparable performance. h addition to efficiency, the design goals were portah'lity and simplicity. Written entirely iu Prolog, the DEC 10 Prolog compiler introduced many optimization techniques for Prolog.
"Generating the minimal model in PrologIn algebra, one first obtain s the elements as formal expressions according to their length, or some othe r complexity measure, and then one makes the necessary identifications . Consequences for a program written in Prolog are generated via queries o r ""Goals"" according to its built-in operational calculus in a deterministi c fashion which, unfortunately, causes Prolog to frequently become entangle d in infinite loops . That is, there are programs which are syntactically sound but for which Prolog cannot find certain logical consequences . A standard example is provided by a :-b . b :-a . b . Given the goal"" b "" , Prolog runs into a loop : In order to satisfy "" b "" , i t uses the second clause and then wants to satisfy first clause which can be satisfied only by "" a "" , which leads it to th e "" b "" etc ."
Feature analysis of Turbo PrologAnalyses of microcomputer Prolo g of six major feature areas an d capabilities of built-in predicates are extenaed to Turbo Prolog . Turbo Prolog differs from other implementations in use of stati c type declarations and checking . In an earlier features of six article, Weeks and Berghel (1) compare d microcomputer Prolog implementation s (Arity/Prolog, micro-Prolog, Prolog), together with MProlog, Prolog-2, Prolog - 86, VM L CProlog for VAX machines . This paper extends the survey by Weeks and Berghel to cove r Turbo Prolog, which was not available at the time of thei r survey .
Deriving contingencies among diagnostic tests with Prolog by code examinationThis paper reports the results of a cursory effort to automatically extract contingencies among these tests by direct examination of their source. PROLOG is used to describe tests and define contingencies.Deriving Contingencies Among Diagnostic Tests with PROLOG by Code Examination Richard Denney Schlumberger Well Systems Austin System Center P.O. This paper reports the results of a cursory effort to automatically extract contingencies among these tests by direct examination of their source. PROLOG is used to describe tests and define contingencies. A SNOBOL program was written that read in an SSD diagnostic test written in C and wrote out a first order logic description, implemented in PROLOG (for information about PROLOG see [5]), of the test in terms of calls to, and the checking of values returned from, the low level hardware interface routines.
A Prolog model of the income tax act of CanadaFinally, I describe the implementation of a partial tax analysis system which I have programmed in Prolog, and review its deficiencies and the extensions which would be required to make it a useful planning tool for tax practitioners.Finally, I describe the implementation of a partial tax analysis system which I have programmed in Prolog, and review. its deficiencies and the extensions which would be required to make it a useful planning tooI for tax practitioners. The implementation has been valuable for the issues it has raised, forcing certain rules and concepts into Prolog has necessitated rethinking their formulation. The implementaFion undertaken works for a given database of facts, which are expressed as Prolog statements. The user interface available is that of C-Prolog.
Universal closure operator for prolog-61-UNIVERSAL CLOSURE OPERATOR FOR PROLOG Thomas Vasak Department of Computer Science, University of New South Wales, P.O. Despite the presence of numerous metaand extra-logical features in most common PROLOG implementations, the language is still often too restrictive to allow certain algorithms to be expressed in a concise, efficient and yet reasonably clear manner. It is also interesting to compare it with the wait declarations of MU-PROLOG [1] and, in particular, delay masks proposed by Vasak [2].
Book review: Prolog for Programmers by Feliks Kluzniak and Stanislaw Szpakowicz (Academic Press)Prolog for Programmers (PP) delivers what it promises by introducing Prolog to programmers from other languages, I know of no better introduction for this audience. (The dialect used is a slight variant of DEC-10 Prolog.) Yet even the experienced Prolog programmer can gain from PP's first-rate treatment of data structures, control, programming techniques, and implementation. PP also addresses broader issues such as language extensibility with a chapter on definite-clause grammars, database with a case study of relational databases in Prolog, planning with an analysis of a STRIPS problem in WARPLAN, and implementation and optimization with a discussion of the authors' own Prolog interpreter.As such I cannot recommend this book as it stands for student use, either for independent use or for use in the classroom. Prolog for Programmers Feliks Kluzniak and Stanislaw Szpakowicz ISBN-0-12-416520-4 Academic Press, 308 pps. $24.95 Reviewed by: Marty Kalin Department of Computer Science De Paul University Chicago, IL 60604 Prolog for Programmers (PP) delivers what it promises by introducing Prolog to programmers from other languages, I know of no better introduction for this audience. (The dialect used is a slight variant of DEC-10 Prolog.) Yet even the experienced Prolog programmer can gain from PP's first-rate treatment of data structures, control, programming techniques, and implementation. The focus is on representing the parsing problem in Prolog, and the chapter illustrates rather than explains Prolog programming.
Increasing the efficiency of Prolog Lexical databases with N-gram Boolean cubesPROLOG has been shown to be an effective tool for expressing the logic of many problems dealing with parsing, natural language processing, and spelling verification [1,7,8,9,12]. As a class, these problems deal with the manipulation of lexical databases as Horn clauses. Since PROLOG does not generally differentiate between program clauses and data clauses, the internal representation and manipulation of data may not be optimal for a particular application.INCREASING THE EFFICIENCY OF PROLOG LEXICAL DATABASES WITH N-GRAM BOOLEAN CUBES Richard Rankin Department of Computer Science University of Arkansas PROLOG has been shown to be an effective tool for expressing the logic of many problems dealing with parsing, natural language processing, and spelling verification [1,7,8,9,12]. As a class, these problems deal with the manipulation of lexical databases as Horn clauses. Since PROLOG does not generally differentiate between program clauses and data clauses, the internal representation and manipulation of data may not be optimal for a particular application. Due to the nature of current PROLOG products designed for sequential machines, certain database organizations are imposed.
A built-in test language for PROLOG to validate knowledge-based systemsOur present work concentrates on the implementation of a uniform, white-box test environment PROTest (PROLOG Test Environment). PROTest supports the development of object-oriented, rule and knowledge-based expert systems which will be implemented in PROLOG.A Built-In Test Language for PROLOG to Validate Knowledge-Based Systems F. Belli, L Camara, A Schmidt The University of Paderborn, Federal Republic of Germany This paper refines and compIetes the results of our previous work represented in /3/. Our present work concentrates on the implementation of a uniform, white-box test environment PROTest (PROLOG Tat Environment). PROTest supports the development of object-oriented, rule and knowledge-based expert. systems which will be implemented in PROLOG. Although formal aspects of knowledge based systems constitute a well-researched area, prag matic aspects of their development are still somehow underdeveloped, e.g. the methods and tools to sys tematically test PROLOG-based expert systems are mostly limited to low level debugging facilities to trace run-time errors (Testing in the Small).
Prototyping analysis, structured analysis, Prolog and prototypesPRUTUTYPING ANALYSTS. STRUCTURED RNULYSIS, PROLOG RNU PROTOTYPES RITA A. RIBEIRO RALPH E. BUNKER DEPARTAMENTO INFORMATICA DEP. The prototyping analyst is able to use the excellent knowledge capabilities of Prolog and is spared much of the complexity of navigating through that knowledge. A Prolog program is a collection of facts and rules. An example of a Prolog fact is loves(mary, john).
The efficiency of the equation interpreter compared with the UNH Prolog interpreterIn this note the Equation Interpreter (a rewrite rule interpreter) and the University of New Hampshire Prolog interpreter are viewed as target systems for executing prototypes.technical contributions -18-The efficlency of the Equation Interpreter compared with the UNH Prolog interpreter (extended abstrac 0 J. Heering P. Klint Centre for Mathematics and Computer Science P.O. In this note the Equation Interpreter (a rewrite rule interpreter) and the University of New Hampshire Prolog interpreter are viewed as target systems for executing prototypes. Measement method The efficiency of the Equation Interpreter and Prolog have been compared by executing a series of simple examples using both systems.
Bagof/3 to ZF expression: an example prolog application manually translated to MirandaA manual technique is given for translating an example Prolog procedure, append/3, used by the predicate bagof/3, to a functionally equivalent program expressed in the functional programming language Miranda which uses a ZF (Zermelo Frankel) expression.bagof/3 to ZF expression: an example Prolog application manually translated to Miranda Peter Greenfield School of Computer Science The University of Birmingham Edgbaston, Birmingham, England Tel: + 44 21 414 4772 Email: GreenfieldPG@CS.BHAM.AC.UK Abstract There is sometimes the requiremcnt in logic programming applications to collect all the solutions of a non-deterministic program and associated goal. A manual technique is given for translating an example Prolog procedure, append/3, used by the predicate bagof/3, to a functionally equivalent program expressed in the functional programming language Miranda which uses a ZF (Zermelo Frankel) expression. Prolog (see for example [Clocksin and Mellish 1987]) systems typically provide the built-in predicate bagof/3 1 which can be used to supply this requiremer_t.
An alternative prolog search strategy
A pedagogic expert system shell in PrologA Pedagogic Expert System Shell in Prolog Victor Schneider Computer Science Department Framingham State College Framingham, HA 01701 Introduction to Artificial Intelligence: Take-Home Final Examination Instructions: Attached is a copy of a Prolog expert system, adapted from the Sterling and Shapiro book and complete with an explanation engine, that will run on the Cogent/Prolog demonstration interpreter. Then, make sure that the program really does what you expect i t to do by running the corrected algorithm on Cogent/Prolog and inserting (and later removing) trace code where needed. Sterling, L. and Shapiro, E. The Art of Prolog. M,I.T. Press, 1986. Tanimoto, S.L. The Elements of Artificial Intelligence.
"Knowledge-based optimization in Prolog compilerKnowledge-Based Optimization in Prolog Compiler Naoyuki Tamura Science Institute, IBM Japan, Ltd. 5-19 Sanban-cho, Chiyoda-ku, Tokyo 102 JAPAN This paper describes an optimization technique used in a Prolog compiler. We stress on knowledge-based approach for optimization. Prolog programs are compiled into intermediate code and the code is translated into a graph for optimization. Figure 1 shows the outline of the compiler [7]. In phase-l, Prolog programs are compiled into intermediate code. The intermediate language is based on David Warren's ""Abstract Prolog Instruction Set"" (51, but some instructions are decomposed into lower level instructions."
Experiences in Prolog-based DFT rule checkingEXPERIENCES IN PROLOG-BASED DFT Gianpiero CABODI Paolo CAMURATI RULE CHECKING Paolo PRINETTO Dipartimento di Automatica e Informatica Politecnico di Torino Corso Duca degli Abruzzi 24, I-10129 Torino Italy the same problems of synthesis and silicon compilation. In the sequel, we shall cover the following topics: predicative representation of hardware, DFT rules in Prolog form, the use of the Prolog reasoning mechanism to verify designs, and a frame- and rule-based expert system kernel implemented in Prolog. A very popular form of knowledge representation uses rules and Born clauses [14], [15], (161 since they are Prolog-like and Prolog provides a simple, yet effective inference mechanism.
Specifying and automatically generating Ada tasks in PrologSpecifying and Automatically Generating Ada Tasks in Prolog John P. Van Tassel Computing Laboratory, University of Cambridge Cambridge CB2 3QG, England David Hemmendinger Department of Electrical Engineering and Computer Science Union College, Schenectady, NY 12308 Many concurrent programs may be specified by formal grammars that define the sequences of events that may occur in the program. We outline the use of Prolog definite clause grammars to specify and model the behavior of Ada server tasks in particular. We describe Prolog programs that translate Ada tasks into the grammars that specify them and that translate from specifying grammars into good-quality Ada code.
A type driven hardware engine for Prolog clause retrieval over a large knowledge baseWhereas existing Prolog systems are very effective at handling small knowledge bases, they are not very efficient at and often incapable of handling large sets of clauses. Various approaches have been put forward for handling the problem, most of which involve coupled systems (loosely or tightly coupled). A Prolog data/knowledge based system which provides an integrated solution to the problem is being developed.A vpe Drlven Hardware Engine for Prolog Clause Retrieval over a Large Knowledge Base Kam-Fai Wongt and M. Howard Williamstt t Software Engineering Department, Unisys Ltd., Livingston, EH54 7AZ, Scotland. tt Dept. of Computer Science, Heriot-Watt University, Edinburgh EHl2HJ, Scotland. Whereas existing Prolog systems are very effective at handling small knowledge bases,they are not very efficient at and often incapable of handling large setsof clauses. Introduction One of the important application areas of Prolog is knowledge base implementation. Most existing systems for handling large knowledge bases [3,4] are constructed by coupling[l] a Prolog translator to a relational database manager.
Design of a high-speed Prolog machine (HPM)
Prolog in the automation of the semantic componentPROLOG IN THE AUTOMATION OF THE SEMANTIC COMPONENT* Gregers Koch DIKU Institute of Datalogy Copenhagen University Universitetsparken 1 DK 2100 Copenhagen Keywords: Computational semantics, Logical translation,semantic analysis, logico-semantic representation, first order logic, Montague's intensional logic. 1. This may be done using well-known techniques by translating the syntactic description into Prolog such that The predicates are the names of the syntactic categories. EUROTRA Seminar, Copenhagen, 1987. [10] Clocksin, W. & Mellish, C.: Programming in Prolog, Springer-Verlag 1981. 329
Emulating Prolog in an IBM PC APL environmentEmula%ing Prolog in an IBM PC APL Environment Maria J. Tobar and M. Alfonseca Introduction Since PROLOG is a highly used language in Artificial Intelligence applications, it has been our aim to test the APL capabilities to emulate it, in this way combining the properties of both languages in a single system, where APL would provide its number-crunching and file handling facilities, while PROLOG-like APL functions would make it possible to perform logical inferences in a non-procedural environment. All the work took place in a Personal Computer, using IBM PC APL as the basis syst,em. PROLOG operates with the so-called Horn's clauses formed by u conjunction of affirmative propositions.
Book review: Prolog: A Relational Language and Its Applications by John Malpas (Prentice-Hall,Inc., 1987)This year we are seeing the fruits of these editors' recruiting efforts, a fresh crop of textbooks, tutorials, primers and programmer's guides for Prolog. One of the best of these new book is Prolog: A Relational Language and Its Applications by John Malpas.It is considerably more distant from programming, and were one to integrate a programming component while using this book in a course, Prolog rather than Lisp would be the obvious language. This year we are seeing the fruits of these editors' recruiting efforts, a fresh crop of textbooks, tutorials, primers and programmer's guides for Prolog. One of the best of these new books is Prolog: A Relational Language and Its Applications by John Malpas. Europeans often complain about the style in which Americans program in Prolog. This book encourages the new Prolog programmer to take full advantage of this new and flexible way of programming.
An experience with a Prolog-based object-oriented languageAbstract An Experience with a Prolog-based Object-Oriented Language Koichi Fukunaga Shin-ichi Hirose Science Institute, IBM Japan, Ltd. 5-19 Sanbancho, Chiyoda-ku Tokyo 102, Japan interest. SPOOL is based on Prolog in the sense that Flavors [12] is based on Lisp. From the viewpoint of Prolog, the language supplies Prolog with the facilities for modularizing program database.
A new design of prolog-based bottom-up parsing system with Government-Binding theoryThis paper addresses the problems of movement transformation in Prolog-based bottom-up parsing system. Three principles of Government-Binding theory are employed to deal with these problems.A NEW DESIGN OF PROLOG-BASED BOTTOM-UP PARSING SYSTEM WITH GOVERNMENT.BINDING THEORY Hsin-Hsi Chen*,**, I-Peng Lin* and Chien-Ping Wu** * Department of Computer Science and Information Engineering National Taiwan University, Taipei, Taiwan, R.O.C. ** Graduate Institute of Electrical Engineering National Taiwan University, Taipei, Taiwan, R.O.C. The Government-Binding (GB) theory [1] provides abstract This paper addresses the problems of movement transformation in Prolog-based bottom-up parsing system. Three principles of Government-Binding theory are employed to deal with these problems. Conclusion This paper addresses the problems of movement transformation in Prolog-based bottom-up parser. Three principles of Government-Binding theory are considered to deal with these problems.
A useful extension to Prolog's definite clause grammar notation1. Introduction A Useful Extension to Prolog's Definite Clause Grammar Notation Peter Van Roy vanroy@bellatrix.berkeley.edu Computer Science Division University of California Berkeley, CA 94720 Programming in a purely applicative style implies that all information is passed in arguments. Both of these techniques are commordy used in imperative languages such as C, but neither is a satisfying way to program in Prolog: • Because Prolog is a single-assignment language, modifying encapsulated information requires a time-consuming copy of the entire structure. The extended Prolog is translated into standard Prolog by a preprocessor.
Architectural support for the management of tightly-coupled fine-grain goals in flat concurrent PrologWe propose architectural support for goal management as part of a special-purpose processor architecture for the efficient execution of Flat Concurrent Prolog. Goal management operations: halt, spawn, suspend and commit are decoupled from goal reduction, and overlapped in the Goal Management Unit.Architectural Support for the Management of Tightly-Coupled Fine-Grain Goals in Flat Concurrent Prolog Leon Alkalaj Tomb Lang and MiloS Ercegovac Jet Propulsion Lab., MS 198-231 Computer ScienceDepartment Caltech, Pasadena,CA 91109 University of California Los Angeles, CA 90024 We propose architectural support for goal management as part of a special-purpose processor architecture for the efficient execution of Flat Concurrent Prolog. Higher speedups are obtained for workloads that exhibit greater goal management complexity, 1 Introduction Flat Concurrent Prolog (FCP) is a high-level, parallel programming language [lo] whose syntax and semantics is characteristic of a group of flui commitled-choice logic programming languages [5], [7], [16], [ll]. I CH2887-8/90/0000/0292$01.00@ 1990 IEEE 293 294 295 2% 297 298 299 300 for a Flat Concurrent Prolog Processor, In Pro
A very fast prolog compiler on multiple architecturesA Very Fast Prolog Compiler on Multiple Architectures Toshiaki Kurokawa Naoyuki Tamura Hideaki Komatsu Yasuo Asakawa Science Institute, IBM Japan, Ltd. 5-19 Sanban-cho, Chiyoda-ku, Tokyo 102, JAPAN Abstract 2 Prolog Language Extensions In this paper, we report on our experiment on Prolog compiler technology. One of the speciality of the compiler is in the intermediate Viiual Prolog Machine Code, which enhanced efficiency and portability. We introduce some declarative extensions to the Prolog language, which is compatible with the language and is powerful enough to produce efficient code. 1 Our Goals and Approaches The goals of our optimizing Prolog compiler technology development were the following: Development of the technology to produce one of the world's fastest Prolog compiler.
"A view of the origins and development of PrologA VIEW OF THE ORIGINS AND DEVELOPMENT OF PROLOG Dealing with failure is easy: Work hard to improve. Work hard to improve. (UNIX ""fortune"" message aptly describing Prolog's sequential search mechanism in finding all solutions to ,aquery) JACQUES COHEN The birth of logic programming can be viewed as the confluence of two different research endeavors: one in artificial or natural language processing, and the other in automatic theorem proving. (See [26] and the following article.) This paper explores the origins of Prolog based on views rising mainly from the language processing perspective."
LCD-reification: a formal method for developing Prolog programsLCD-Reification: A Formal Method for Developing Prolog Programs* Fuyau Lin Fkances E. Hunt Computer Engineering and Science Case Western Reserve University Cleveland, Ohio 44106 The logic programming paradigm has emerged as an alternative to the traditional imperative style of software development. The notion of data reification is also intro duccd This paper describes our design methodology to develop Prolog programs by reifying logical specifications. We will look at Prolog as a design lasguage. An operational specification gives primitives and rules of composition and describes effective ways to calculate relations and objects. Prolog is a logic language that has both declarative and procedural meanings.
A Prolog-based connectivity verification tool
AUTOMATIC FORMAL VERIFICATION OF DIGITAL SYSTEMS USING PROLOGA hardware design methodology based on this framework entails: a) writing a specification of required design, b) designing a circuit intended to implement it, c) proving mathematically that the design meets its specification. Prolog is used both as a representational language for describing the design specification and implementation and also as an inference mechanism for proving its functional correctness. To become a real design tool, its knowledge base should be enlarged. The decision for Prolog as a descriptional and an implementational language seems to be correct. Pattern matching and backtracking in Prolog are very powerful tools in the verification process.
"Simple parser for an HPSG-style grammar implemented in prologThe SIMPLE PARSER FOR AN HPSG-STYLE GRAMMAR IMPLEMENTED IN PROLOG Karel oliva* Lingustic Modelling Laboratory, Coordination Centre for Computer Science and Computer Technology, Bulgarian Academy of Sciences, acad. Repreeantation of Categories in the Parser AS follows from the examples, the notation adopt Z ed for categories in rules is the one describing them as (Prolog) lists of features. Keeping such kind of representation also in the underlying mechanism of the parser would be, however, quite unfelicitous a decision. This identity of ""frozen"" categories (represented as ""usual"" Prolog lists) is checked by the predicate ""identical_categories""."
Book Review: Symbolic Computing with Lisp and Prolog by Robert A Mueller and Rex L. Page (John Wiley and Sons)The main thrust of the authors is to contrast and compare the two major tools for symbolic computing, viz. Lisp and Prolog. For this purpose, the book has been sub-divided into the following four major sections:Section I: Lisp,Section II: Prolog,Section III: Lisp vs Prolog, andSection IV: Applications.Each of these sections is further sub-divided into several chapters covering different aspects of the topic. Every chapter contains a variety of examples, solved respectively in Lisp or Prolog in the first two sections and in both the languages in the last two sections.Book Reviews Symbolic Computing with Lisp and Prolog by Robert A Mueller and Rex L. Page Co|orado State University Published by John Wiley and Sons 605 Third Ave New York, N.Y. 10158 Reviewed by Faisel Saeed Department of Computer Science OMahoma State University Stillwater, OK 74078 Phone (405)-744-5668 This book covers the major portions of symbolic computing and denotational (declarative)programming. The main thrust of the authors is to contrast and compare the two major tools for symbolic computing, viz. Lisp and Prolog. For this purpose, the book has been sub-divided into the following four major sections: Section I: Lisp, Section II: Prolog, Section III: Lisp vs Prolog, and Section IV: Applications. Every chapter contains a variety of examples, solved respectively in Lisp or Prolog in the first two sections and in both the languages in the last two sections.
Book review: The Art of Prolog Advanced Programming Techniques by L. Sterling and E. Shapiro (The MIT Press)PROLOG, logic programming based languages, became very popular in the eighties, taking a circuitous route to the United States, from Europe to Japan to mainstream American computer science.The Art of Prolog Advanced Programming Techniques by L. Sterling and E. Shapiro The MIT Press ISBN 0-262-19250-0 Reviewed by: Witkor Marek marek@ms.uky.edu PROLOG, logic programming based languages, became very popular in the eighties, taking a circuitous route to the United States, from Europe to Japan to mainstream American computer science. The second part, the most important if you want to use it as a textbook, presents PROLOG. This part covers all content of PROLOG, explains its dependency on rule order, introduces arithmetic as available in standard PROLOGs, structures (i.e.
A computer with low-level parallelism QA-2: its applications to 3-D graphics and Prolog/Lisp machinesThis paper describes the architectural benefits and limitations of low-level parallelism in performing 3-D color image generation and interpreting Prolog/Lisp programs. The hardware organization with four ALUs, which are actually implemented in the QA-2, is verified to be adequate. As compared with the IBM 370 architecture, the QA-2 can generate 3-D color images in 1/5 of dynamic instruction steps. The compiler version of Prolog machine on the QA-2 is as fast (45K LIPS) as the ICOT's PSI.A Computer with Low-Level Parallelism QA-2 - Its Applications to 3-D Graphics and Prolog / Lisp Machines - Shinji Tomita, Kiyoshi Shibayama, Toshiyuki NakataL Shinji Yuasa tt and Hiroshi Hagiwara Department of Information Science Kyoto University, Kyoto 606, JAPAN ABSTRACT We proposed a computer with low-level parallelism as one of the basic computer architectures and built a large scale experimental system called QA-2. This paper describes the architectural benefits and limitations of low-level parallelism in performing 3-D color image generation and interpreting Prolog/Lisp programs. The hardware organization with four ALUs, which are actually implemented in the QA-2, is verified to be adequate. As compared with the IBM 370 architecture, the QA-2 can generate 3-D color images in I/5 of dynamic instruction steps. The compiler version of Prolog machine on the QA-2 is as fast (45K LIPS) as the ICOT's PSI.
Argus/V: a system for verification of Prolog programsARGUS/V : A SYSTEM FOR VERIFICATION OF PROLOG PROGRAMS Tadashi KANAMORI t, Hiroshi FUJITAt, Hirohisa SEKI#, Kenji HORIUCH~, Machi MAEJH t Mitsubishi Electric Corporation 8 ICOT Research Center Central Research Laboratory Institute for New Generation Computer Technology Amagaaaki, Hyogo, JAPAN 661 Mita l-4-28, Minato-ku, Tokyo, JAPAN 108 The verification system Argus/V for proving properties of Prolog programs is outlined by contrasting verification with testing in logic programming. Testing of Prolog Programs 3. Logic Programming Paradigm Revisited 4. Verification of Prolog Programs 4.1. Specification of Prolog Programs 4.2.
"Review of ""Knowledge systems and prolog: a logical approach to expert systems and natural language processing"" by Adrian Walker, Michael McCord, John F. Sowa, and Walter G. Wilson. Addison-Wesley 1987.Book Reviews Knowledge Systems and Prolog: A Logical Approach to Expert Systems and Natural Language Processing with SWESIL?) Every opportunity is taken to demonstrate in concise terms the relationship of Prolog with logic. Too many Prolog textbooks fail to point out connections with classical logic where possible. They approach Prolog as a conventional programming language. An important and obvious aspect of Prolog is thus missed: that Prolog, since it is based on logic, permits relatively easy translation from logical form to program."
"Review of ""Prolog and natural-language analysis: CSLI lecture notes 10"" by Fernando C. N. Pereira and Stuart M. Shieber. Center for the Study of Language and Information 1987.Book Reviews PROLOG AND NATURAL-LANGUAGEANALYSIS (CSLI LECTURENOTES 10) Fernando C. Distributed by the University of Chicago Press ISBN 0-937073-17-2, $28.95 (hb), ISBN 0-937073-18-0, $13.95 (sb) Reviewed by Patrick Saint-Dizier IRISA-INRIA I have often met linguists and computational linguists willing to read a short, simple, and well-documented textbook about the use of Prolog for natural-language understanding. I feel that this well-written book mainly devoted to Prolog and logic grammars to a large extent meets the challenge. The presentation is simple and classical. Section 2.3, about the logic of Prolog, is probably the best presentation of the topic I have ever seen, apart from the excellent book The Art of Prolog (Sterling and Shapiro 1986)."
Design of LMT: a prolog-based machine translation systemLMT uses a syntax transfer method for translation, although the English syntactic analysis trees contain some results of semantic choices and show deep grammatical relations. Semantic type checking with Prolog inference is done during analysis and transfer. After transfer, the German syntactic generation component produces a surface structure tree by application of a system of tree transformations. These transformations use an augmentation of Prolog pattern matching. LMT has a single lexicon, containing both source and transfer information, as well as some idiosyncratic target morphological information.DESIGN OF LMT: A PROLOG-BASED MACHINE TRANSLATION SYSTEM Michael C. McCord IBM Thomas J. LMT uses a syntax-to-syntax transfer method for translation, although the English syntactic analysis trees contain some results of semantic choices and show deep grammatical relations. Semantic type checking with Prolog inference is done during analysis and transfer. After transfer, the German syntactic generation component produces a surface structure tree by application of a system of tree transformations. These transformations use an augmentation of Prolog pattern matching. LMT has a single lexicon, containing both source and transfer information, as well as some idiosyncratic target morphological information.
DCKR: knowledge representation in prolog and its application to natural language processingTherefore in what form Frames or Objects are expressed is a key issue for natural language processing. A method of the object representation in Prolog called DCKR will be introduced. It will be seen that if part of general knowledge and a dictionary are described in DCKR, part of context processing and the greater part of semantic processing can be left to the functions built in Prolog.Therefore in what form Frames or Objects expressed is a key issue for natural of sem(B,birthYear:Y,_), of X is 1986 Y. or i0) sem(face,P,S) :- are hasa(eye,P,[facelS]), language hasa(nose,P,[facelS]), processing. A method of the Object representation Prolog called DCKR will be introduced. It will seen that if part of general knowledge and dictionary are described in DCKR, part of contextprocessing and the greater part of semantic processing can be left to the functions built in Prolog. 1. ,) higher level prototypes than elephant#1 is obtained ttlr'ough tire unification mechanism of Prolog. [a in be at other' words, inileri lance of knowledge is carried automatically by tile functions b u i l t in Prolog. As for syntactic processing, grammar rules described in DCG [Pereira automatically converted into a Prolog program, the 802 and parsing can be replaced by Prolog program execution.
PROREL: a Prolog-based system for relational algebra and data baseIn PROREL, the relational nature of Prolog is exploited, together with the database and list processing aspects.PROREL: A PROLOG-BASED SYSTEM FOR RELATIONAL ALGEBRA AND DATA BASE DAVID R. BEUERMAN, S.U.N.Y., ONEONTA In PROREL, the relational nature of Prolog is exploited, together with the database and list processing aspects.
Using a logic grammar to learn a lexiconVarious problems arising with a from implementation and complexity factors are considered, and examples are shown to support the claim that the method shows potential as a practical tool for automatic lexicon acquisition. Keywords: Logic programming, Prolog, logic grammar, learning, lexicon. Topic Area: Theoretical issues 1. Each sentence now constrains the possible values of these entries to be ones. which allow it to be parsed, the hope is that a conjunction of a suitably large number of such constraints will be enough to determine the lexicon uniquely. In concrete Prolog programming terms, what this means is the following. It is to be noted that all this of course requires a Prolog constraint mechanism which is both efficient and logically complete, something that has only recently become possible [4].
"Review of ""Natural language processing in LISP: an introduction to computational linguistics"", ""Natural language processing in POP-11: an introduction to computational linguistics"", and ""Natural language processing in PROLOG: an introduction to computational linguistics"" by Geral Gazdar and Chris Mellish. Addison-Wesley 1989.Hardbound, ISBN 0-201-17825-7, £ 17.95 Pop-11 volume: XV + 524 pp. Hardbound, ISBN 0-201-17448-0, £ 17.95 Prolog volume: XV + 504 pp. Hardbound, ISBN 0-201-18053-7, £ 17.95 Reviewed by Kwee TjoeLiong University of Amsterdam This is a very interesting and intriguing array of textbooks to read, to compare, and to review. It also has been a rather 116 NaturalLanguageProcessingin LISP, POP-11, and PROLOG hard job for me to do so. The last paragraphs try to explain why. Therefore, one of the titles is treated here as prototypical (to wit, the Prolog volume). Whenever they differ, the other two are, subjex,tively, considered as derivative."
Using the same system for analyzing and synthesizing sentencesPRINCIPLES OF ANALYSIS-SYNTHI,SIS The potential reversibility of certain programs written in Prolog is well known. So, in order to facilitate the implementation of a granmar rmming txth in malysis and in synthesis, we have decided to program Leader in this language. CONCLUSION Partial synthesis is an interesting challenge when one decides to use the same system for analysing and synthesizing sentences. If Prolog seems u) be a fairly technical solution, fundamental problems must be solved like writing sizable non ambiguous grannnar with natural phenomena like trroforms (pronouns, ellipsis, etc.), or mastering the control of partial synthesis for avoiding arty future dead end.
A formalism for views in a logic data baseKEYWORDS: First Order Predicate Logic, Logic Data Base, Query-By-Example, Data Base View, Group, PROLOG. 1. Introduction A data base of facts and general logic rules relating facts and other rules is a pre-requisite for natural language understanding, plan generation, and expert systems applications where an (often large) knowledge base is required. This formalism offers a predicate logic based specification and a practical language, PROLOG (Roussel (2), Warren (3)), for expert systems and data base design. Query-By-Example (QBE, Zloof (4)) is a language developed for querying relational data bases (Codd (5)). The similarity between QBE syntax and PROLOG goals has been noted in the literature (Neves et al (6)}.
Montagovian Definite Clause GrammarKeqwords Compositional Semantics, D e f i n i t e Clause Oamma, Friedman Warren Algorithm, I n t e n s i o n a l Logic, Mont•gue Orammmar, Natural Language Processing, PROLOG. I Introductop Consideration is given by Landsbergen (20] to the global algorithmic structure of a top down parser demonstrably equivalent to a compositional grammar such as that of PTG [223. The postorder traverse in (ii) of a preorder ere•tiDe involves a duplication which may be •voided by •dopting the PROLOG Definite Clause grammar (DCg) formalism, (C28] of. [3], £4], C5], [21]), which, as has been observed [32] virtually forces the methodology of syntax directed translation coupled with compositional semantics. The clauses of • DC may be d i r e c t l u executed by a PROLOG interpreter, hence if combined CFg+analytical-M rules are presented in the form of D e f i n i t e Clauses, the problem of mapping a l g o r i t h m to implementation does not arise: the algorithm and program are one and the s•me.
JPSG parser on constraint logic programmingThis paper presents a constraint logic programming language cu-Prolog and introduces a simple Japanese parser based on Japanese Phrase Structure Grammar (JPSG) as a suitable application of cu-Prolog.cu-Prolog adopts constraint unification instead of the normal Prolog unification. In cu-Prolog, constraints in terms of user defined predicates can be directly added to the program clauses. For natural language processing, such constraints are more important than those on numerical or boolean objects. In comparison with normal Prolog, cu-Prolog has more descriptive power, and is more declarative.JPSG Parser on Constraint Logic Programming TUDA, Hirosi * Department of information science Faculty of science University of Tokyo 7-3-1 Hongo, Bunkyo-ku Tokyo, 113 Japan e-maih a30728%tansei.cc.u-tokyo.junet@relay.cs.net HASIDA, Kbiti Institute for New Generation Computer Technology (ICOT) 1-4-28 Mita, Minato-ku Tokyo, 108 Japan e-mail: hasida@icot.jp@relay.cs.net SIRAI, Hidetosi Tamagawa University 6-1-1 Tamagawa gakuen, Machida-shi Tokyo, 194 Japan e-mail: a88868%tansei.cc.u-tokyo.junet@relay.cs.net Abstract This paper presents a constraint logic programming language cu-Prologand introduces a simple Japanese parser based on Japanese Phrase Structure Grammar (JPSG) as a suitable application of cu-Prolog. cu-Prolog adopts constraint unification instead of the normal Prolog unification. In cu-Prolog, constraints in terms of user defined predicates can be directly added to the program clauses. For natural language processing, such constraints are more important than those on numerical or boolean objects. In comparison with normal Prolog, cu-Prolog has more descriptive power, and is more declarative.
Logic and inheritanceAn elaboration of the Prolog language is described in which the notion of first-order term is replaced by a more general one. This extended form of terms allows the integration of inheritance---an IS-A taxonomy---directly into the unification process rather than indirectly through the resolution-based inference mechanism of Prolog. This results in more efficient computations and enhanced language expressiveness. The language thus obtained, called LOGIN, subsumes Prolog, in the sense that conventional Prolog programs are equally well executed by LOGIN.1 Abstract Logic and Inheritance Hassan A-Xaei Roger Nar MieroeleeSronis and Gomput,r Tschnetogy Corporation 9,30 Research Boulevard Austin TX 78759 lengthening proofswbut rather, as a means to accelerate, or focus, a deduction process--thus shortening proofs. An elaboration of the Prolog language is described in which the notion of first-orderterm is replaced by a more general one. This extended form of terms allows the integration of inherltance--an IS-A taxonomydirectly into the unification process rather than indirectly through the resolution-based inference mechanism of Prolog, This results in more efficient computations and enhanced fan= guage expressiveness. The language thus obtained, called LOGIN, subsumes Prolog, in the sense that conventional Prolog programs are equally well executed by LOGIN.
"Equational logic programming: an extension to equational programmingThe paradigm of equational programming potentially possesses all the features provided by Prolog-like languages. In addition, the ability to reason about equations, which is not provided by Prolog, can be accommodated by equational languages. The extended language is a powerful logic programming language in the sense of Prolog and thus enjoys the programming features that Prolog possesses.Associated with the language possesses all the features provided by Prolog-like languages. In addition, the ability to reason about equations, which is not provided by Prolog, can be accommodated by equational languages, In this paper, we propose an extended equational programming paradigm, and describe an equational logic programming language which is an extension of the equational language defined in [Hoff 82]. The extended language is u powerful logic programming language in the sense of Prolog and thus enjoys the programming features that Prolog possesses. All these features contribute to a key characteristic of Prolog that makes it different from other programruing paradigms: it generates solutions by reasoning (or ""solving for variables"") rather than direct computing."
KC expert—the development of an ICAI system for chemistryThe first objective of the project was to convert the chemical database from a Pascal compatible format to a Prolog compatible format. The next objective was to put a Natural Language Interface (NLI) onto the database, so the user could query the system. The teaching model will pose problems for the student, observe and evaluate the students progress in solving the problem (the student model) and give hints to the student. The first Prolog system used was Turbo Prolog from Borland International. The output of the parser was a query of the chemical database. Problems soon arose with using Turbo Prolog. It is a completely compiled Prolog which means that every minor change means a program recompilation.The first objective of the project was to convert the chemical database from a Pascal compatible format to a Prolog compatible format. The next objective was to put a Natural Language Interface (NLI) onto the database, so the user could query the system. The teaching model will pose problems for the student, observe and evaluate the students progress in solving the problem (the student model) and give hints to the student. The first Prolog system used was Turbo Prolog from Borland International. The output of the parser was a query of the chemical database. Problems soon arose with using Turbo Prolog. It is a completely compiled Prolog which means that every minor change means a program recompilation.
KCM: a knowledge crunching machineKCM (Knowledge Crunching Machine) is a high-performance back-end processor which, coupled to a UNIX* desk-top workstation, provides a powerful and user-friendly Prolog environment catering for both development and execution of significant Prolog applications. They show that KCM, which runs at a peak speed of 833 Klips on list concatenation, compares favorably with other dedicated Prolog machines and available commercial systems running on fast general purpose processors.Watzfawik ECRC, Arabellastr. 17,800O Muenchen 81, West Germany E-mail: (hans, jacques, jclaude)@ecrcvax.uucp KCM (Knowledge Crunching Machine) is a highperformance back-end processor which, coupled to a UNIX' desk-top workstatrbn, provides a powerful and user-friendfy Prolog environment catering for both development and exewtbn of sbnificant Prolog applications. They show that KCM, which runs at a peak speed of 833 Klips on fist concatenation, compares favorably with other dedicated Prolog machines and available commercial systems nmning on fast general purpose plOC8SSOrS. Keywords: Prolog engine, tagged architecture, memory system 1 Introduction KCM (Knowledge Crunching Machine) is intended to be a single user, single task high-performance back-end processor which, coupled to a UNIX' desk-top workstation, provides a powerful and user-friendly Prolog environment catering for both development and execution of significant Prolog applications.
"QPATR and constraint threadingQPATR is an MS-DOS Arity/PROLOG implementation of the PATR-II formalism for unification grammar. The formalism has been extended to include the constraints of LFG as well as negation and disjunction, which are implemented with the disjunction and negation-as-failure of PROLOG itself. A technique of constraint threading is employed to collect negative and constraining conditions in PROLOG difference lists.Thus, QPATR can also be used in instruction QPATR is an MS-DOS Arity/PROLOG implementation of the PATR-II formalism for unification grammar. The fbnnalism has been extended to include the constraints of LFG as well as negation and disjunction, which are implemented with the disjunction and negation-as-failure of PROLOG itself. A technique of constraint threading is employed to collect negative and constraining conditions in PROLOG difference lists. I Introduction QPATR (""Quick PATR"") is an MS -DOS Arity/PROLOG implementation of the PATR-II formalism (of Shieber et al. 1983, Shieber 1986) with certain logical extensions."
Performance and architectural evaluation of the PSI machineWe evaluated a Prolog machine PSI (Personal Sequential Inference machine) for the purpose of improving and redesigning it. In this evaluation, we measured the execution speed and the dynamic characteristics of cache memory, register file, and branching hardware introduced for high-speed execution of Prolog programs.Execution speed of the PSI firmware interpreter was found to be comparable to that of the DEC-10 Prolog compiled code on the DEC-2060. It was also found that PSI was faster than DEC for executing programs containing much unification and backtracking that require runtime processing.With the cache memory, the hit ratio for application programs was found higher than 96%, this demonstrates that the Prolog execution has much memory access locality. The memory access frequency and the appearance ratio between Read and Write command were also investigated.Concerning the register file, use rate of each dedicated access mode was measured and effect of each mode was discussed.PERFORMANCE AND ARCHITECTURAL EVALUATION OF THE PSI MACHINE Kazuo Taki Katsuto Nakajima ICOT* Abstract We evaluated a Prolog machine PSI (PersonM Sequential hlference machine) for the purpose of improving and redesigning it. In this evaluation, we measured the execution speed and the dynamic characteristics of cache menmry, register file, and branching hardware introduced for high-speed execution of Prolog programs. Execution speed of the PSI firmware interpreter was found to be comparable to that of the DEC-10 Prolog compiled code on the DEC-2060. With the cache memory, the hit ratio for application programs was found higher than 96%, this demonstrates that the Prolog execution has much memory access locality. The memory access frequency and the appearance ratio between Read and Write command were also investigated.
Optimization on networksThe project is to use PROLOG to solve an optimization problem on a network. An implementation of the painted network algorithm in PROLOG is given.Optimization on Networks David Binger University of Illinois, Urbana-Champaign ABSTRACT The project is to use PROLOG to solve an optimization problem on a network. An implementation of the painted network algorithm in PROLOG is given. Project-No.: 003-031 Title: Optimization on Networks Subject: Combinatoncs Programs: UNSW PROLOG Typesetting: mltroff[1] Version: 06/23/87 54 The Mathematical Laboratory 1. The Painted Network Algorithm Optimization on Networks a, I The goal of this project is to use PROLOG to solve a problem in optimization on networks.
Logic programming in APL2The most popular vehicles for logic programming are LISP and PROLOG. APL2 has the important features of these languages and more. On one hand, APL2 has all the expressive power of LISP and implementation of PROLOG in APL2 is not difficult. On the other hand, APL2 includes facilities for full screen management, menus, graphics, access to relational databases, and powerful computational primitives. This includes Unification, Resolution, and a logic programming environment like PROLOG. A discussion of the pertinent APL2 notation, detailed discussion of the algorithms and commented programs appear in (Br1).Box 50020 San Jose, Calif. 95150 USA The most popular vehicles for logic programming are LISP and PROLOG. APL2 has the important features of these languages and more. APL2 has all the expressive power of LISP and implementation of PROLOG in APL2 is not difficult. On the other hand, APL2 includes facilities for full screen management, menus, graphics. access to relational databases, and powerful computational primitives. This includes Unification, Resolution. and a logic programming environment like PROLOG. A discussion of the pertinent APL2 notation, detailed discussion of the algorithms and commented programs appear in (Brl).
Automatic menu generationThis note describes a very simple modification to Prolog's Definite Clause Grammar1 (DCG) formalism which allows a menu system with the flavor of TexasIt is as such a valuable record. ARTICLES ARRAYS AND ASSIGNMENT IN PROLOG William G. Wong Logic Fusion Inc. 1333 Moon Drive Yardley, PA 19067 (215) 736-2463 Conventional Prolog implementions support dynamic update of the data base using assert and retract. Louis, MO 63130 sbc@wucsl.UUCP note describes a very simple modification to Prolog's Definite Clause Grammar I (DCG) formalism which throughout various parts of a program. The idea is identical to infinite streams in Concurrent Prolog except that the stream can only be accessed as a variable or its latest value.
Constructing three-dimensional geometric objects defined by constraintsThe geometric constraints are first evaluated symbolically by an algorithm written in Prolog. The symbolic solution is then numerically evaluated by procedures linked to Prolog.The geometric constraints are first evaluated symbolically by an algorithm written in Prolog. The symbolic solution is then numerically evaluated by procedures linked to Prolog. Our Prolog implementation [8] provides calls to the procedural programming language Modula-2 [ 131 which is compiled. OCTOBER 23-24.1986 115 $h986WORKSHOPON %,/ ?- go. 6 Edit PROLOG Define Constraints Graphic Side ?- go. alternative solution?
"Deductive parsing with multiple levels of representationPAD2 uses an inference control strategy based on the 'freeze' predicate of Prolog-II, while PAD3 -- 5 utilize the Unfold-Fold transformation to transform the original axiomatization into a form that functions as a recursive descent Prolog parser for the fragment.PAD2 uses an inference control strategy based on the ""freeze"" predicate of Prolog-II, while PAD3 - 5 utilize the Unfold-Fold transformation to transform the original axiomatization into a form that functions as a recursive descent Prolog parser for the fragment. The clause defining the 'parse"" relation given in Figure 4 as part of the axiomatization of GB theory is the actual Prolog definition of 'parse' used in the PAD1 and PAD2 parsers. Cohen, J. and T. Hickey. (1987) Parsing and Compiling Using Prolog. ACM Trans. Programming Languages and Systems. 9:2, p. 125-163."
Objects in concurrent logic programming languagesConcurrent Prolog supports object-oriented programming with a clean semantics and additional programming constructs such as incomplete messages, unification, direct broadcasting, and concurrency synchronization [Shapiro 1983a].Bobrow Knowledge Systems Area Intelligent System Laboratory Xerox Palo Alto Research Center Abstract Concurrent Prolog supports object-oriented programming with a clean semantics and additional programming constructs such as incomplete messages, unification, direct broadcasting, and concurrency synchronization [Shapiro 1983a]. Most of the ideas presented apply equally well to other concurrent logic programming languages. Concurrent Prolog As in Prolog, a program in Concurrent Prolog is a collection of Horn clauses. Correct CP implementations are sound but incomplete OOPSLA'86 ProceedinGs 243 theorem provers (as are conventional Prologs), An implementation of CP can be based upon fine-grained parallelism.
Delay reduction using simulated annealingA simulated annealing algorithm is used in conjunction with a timing analyzer, both written in Prolog. A screening function takes advantage of the symbolic equations provided by the timing analyzer to reject clearly inappropriate choices, so full timing analysis is performed less frequently. Despite running in an interpreted Prolog, performance gains of over 50% versus an unsized circuit can be attained in less than 10 CPU minutes.A simulated annealing algorithm is used in conjunction with a timing analyzer, both written in Prolog. A screening function takes advantage of the symbolic equations provided by the timing analyzer to reject clearly inappropriate choices, so full timing analysis is performed less frequently. Despite running in an interpreted Prolog, performance gains of over 50% versus an unsized circuit can be attained in less than 10 cpu minutes. MOST (Method for Ordering and Sizing Transistors) is a Prolog program which makes use of a simulated annealing algorithm and the information supplied by PTA (the Prolog Timing Analyzer) to assign sizes to the transistors.
A dedicated small computer for artificial intelligenceIt is commonly recognized that AI Languages, such as Common Lisp or Prolog, require a workstation. This is mainly due to the fact that both languages need large amounts of memory space and disk storage space. In this paper we describe the design objectives of a small computer for artificial intelligence applications and a small operating system which supports Common Lisp and Prolog.A Dedicated Small Computer for Artificial Intelligence Hiromitsu Shirakawa Hitoshi Ogawa Masayuki Fujiwara Ritsumeikan University Department of Computer Science and SystemsEngineering Kita-Ku, Kyoto, 603 Japan It is commonly recognized that AI Languages,such as Common Lisp or Prolog, require a workstation. This is mainly due to the fact that both languages need large amounts of memory space and disk storage space. SLIM hasthesecharacteristics: (1) It supports Common Lisp and Prolog. (2) These languagesare built into ROM for fast startup. (3) It has an open operating system, any part of which is reprogrammableby users. Common Lisp was chosen as it has become the de facto standard. Prolog was also chosen as it is well suited for artificial intelligence.
"Expert systems and ICAI in tax law: killing two birds with one AI stoneThey are: A computer-assisted instruction (CAI) course for teaching income tax, programmed using conventional CAI techniques, A ""document modeling"" computer program for generating the documentation for a tax-based transaction and advising the lawyer-user as to what decisions should be made and what the tax effects will be, programmed in a conventional language, A prototype expert system for determining the income tax effects of transactions and tax-defined relationships, based on a PROLOG representation of the rules of the Income Tax Act, An intelligent CAI (ICAI) system for generating infinite numbers of randomized quiz questions for students, computing the answers, and matching wrong answers to particular student errors, based on a PROLOG representation of the rules of the Income Tax Act, and A Hypercard stack for providing information about income tax, enabling both education and practical research to follow the user's needs path. Their primary disadvantage is the massive rewriting required when the tax law changes. AI approaches based on PROLOG, on the other hand, are harder to develop to a practical level but will be easier to audit and maintain.A prototype expert system for determining the income tax effects of transactions and tax-defined relationships, based on a PROLOG representation of the rules of the Income Tax Act, 4. An intelligent CAI (ICAI) system for generating infinite numbers of randomized quiz questions for students, computing the answers, and matching wrong answers to particular student errors, based on a PROLOG representation of the rules of the Income Tax Act, and 5. The author shows that non-AI approaches are a way to produce packages quickly and efficiently Their primary disadvantage is the massive rewriting required when the tax law chances. AI auuroaches based on PROLOG. on the other hand: are hard, to develop to a practical level but will be easier to audit and maintain."
"RELFUN: A relational/functional integration with valued clausesFunctional nestings are flattened to relational conjunctions, using a purified version of PROLOG's is-primitive. RELFUN functions may have non-ground arguments, like relations, and/or return non-ground values, their input and output arguments can be inverted like those of relations.Functional nestings 3unctions, using a purified version FUN functions may have non-ground are flattened to relational conof PROLOG's is-primitive. RELarguments, like relations, and/or return non-ground values, their input and output arguments can be inverted like those of relations. definable as (function-)valued Higher-order functions are clauses, with funarg problems being avoided by the standard renaming operational semantics is of clause variables. The various proposals for combining logic (relational) and applicative (functional) languages they merge the two original components. present LISP/PROLOG combinations, differ in the degree to which For instance, many of the tabulated from HCPRVR to LISPLOG in [Boley & Kammermeier et al. dent LISP and PROLOG parts. 1985], consist of largely indepen-The separate identities of a functional and a relational component LISP/PROLOG-oriented proposals, RF-Maple [Voda & Yu 1984]. are also found in some less though not often as easily as in Other, more theoretically motivated approaches focus, however, on a unifying in Eqlog [Goguen & Meseguer 1984], concept, such as equations in an attempt to closely unite the functional and relational styles. To illustrate, with g=likes, (likes '(fatherof x) mary) h=fatherof, and bmary, the request asks whether some individual denoted by ""{fatherof x), a description likes mary (fatherof acts of the father of any individual x, as a function in the predicate-calculus sense), if the database contains monolithic fact, this request On the other hand, the request whether some individual ((likes (fatherof sue) mary)) as a returns 'true"" and binds x to sue° (likes (fatherof x) mary) asks computed as the value of (fatheof x), an application returning the father of any individual x, likes mary (fatherof acts as a function sense), if the database contains the fact ((likes john mary)), (is I:I (fatherof x)) (likes in a generalized lambda-calculus the rule ((fatherof sue) john) and this request, via flattening to 1:1 mary), internally binds 1:1 to john and again returns ""true"" and binds x to sue. -91-Besides such dynamic flattening equivalent but more efficient (at run time'), a semantically st_tic flattening (at 'compile time') ±s also supported by our RELFUN implementation. RELFUNs is-terms can be viewed version of PROLOGs is-primitive version of the single-asslgnment languageso They may be generated fatherof example) or may be directly part±al results (cf. the fac as a generalized and purified or as a ""consistent-assignment' statements in functional during term flattening (cf. the written by the user to name example)."
An implementation of ID3 that creates executable rules (abstract)A drawback to many implementations of ID3 is that the resulting decision tree is not in a readily usable form, say for an expert system. We have written Prolog routines that implement ID3 and that write executable Prolog rules. The attribute-value descriptions of examples are stored as standard Prolog predicates. This system allows the direct use of one of the most robust machine learning techniques in a programming environment that is widely used for artificial intelligence applications.A drawback to many implementations of ID3 is that the resulting decision tree is not in a readily usable form, say for an expert system. We have written Prolog routines that implement ID3 and that write executable Prolog rules. CSC '90 Poster Session Abstract A Prolog System for Case-Based Classification William W. It uses Prolog's facilities to manage a case database and to encode features.
A NATURAL LANGUAGE SHELLThe system is developed under Unix using a combination of Prolog and C code. The natural language processing part is being implemented in UNSW Prolog with extensions to facilitate efficient processing of dictionaries and frame hierarchies.The system is developed under Unix using a combination of Prolog and C code . The natural language processing part is being implemented in UNSW Prolog with extensions to facilitate efficient processing of dictionaries and frame hierarchies .
A heuristic chip-level test generation algorithmArtificial intelligence techniques of goal trees and rule databases are use to implement the algorithm in ProLog. The goal types and solving strategies are outlined. The current, partial ProLog implementation is discussed.Artificial intelligence techniques of goal trees and rule databases are used to implement the algorithm in ProLog. The goal types and solving strategies are outlined. The current, partial ProLog implementation is discussed. INTRODUCTION Chip-level simulation with hardware description languages (HDLs) is replacing gate-level simulation as increasing VLSI densities make gate-level simulation computationally impractical. The algorithm has been partially implemented' in ProLog. Work continues on more complete solving of the goal types, adding remaining necessary VHDL constructs, and limiting and otherwise optimizing the solving phase.
Declarative expression of deductive database updatesSoundness and completeness is proved by showing that an update procedure can be mapped into a semantically equivalent Pure Prolog program. This means that the semantic and proof-theoretic results of Pure Prolog can be mapped into similar results for the Datalog extension.In particular, we show that an update.program can be simply mappedto a Pure Prolog programthat storesthe databasestateasa term, andwhose semanticsandproof theory can be mappedback to extendedDatalog. This allows us to transform the results aboutthe model theory and proof theory of Pure Prolog into very similar results for our Datalog extension. 1.1 RelatedWork A modaloperatorfor replacing Prolog's assert operatorandsolving someof its problems was first &scribed in lWar84]. which also gave a Kripke semantics[Kri63] for the operator. They do not addressthe problem of expressing proceduralupdates. Meta-Prolog [BK82Bac88] is a very general languagethat incorporatestheories and proofs asobjects.
TIMELOG-an intelligent spreadsheet for school timetablingThe process of manipulating data within the constraints of a set of rules is a task for which the programming language PROLOG is ideally suited. This paper outlines an attempt to combine the rule based approach of PROLOG with the interactive power of the spreadsheet to produce an intelligent design aid for a school timetabler.The process of manipulating data within the constraints of a set of rules is a task for which the programming language PROLOG is ideally suited. This paper outlines an attempt to combine the rule based approach of PROLOG with the interactive power of the spreadsheet to produce an intelligent design aid for a school timetabler. Based on a concept outlined by Kriwaczek [2], it is written in micro-PROLOG [3] and implemented on a 6502-based ACORN BBC MASTER [4], a system in common use in UK schools. When the cursor reaches the edge of the screen the whole screen window moves in the normal way and there is a G(oto) command which allows the user to move directly to a different part of the sheet. PROLOG The spreadsheet is written in PROLOG so that it has been possible to build into the system a set of rules by which teacher clashes, room clashes and class clashes are defined and all manipulation of data must conform to these rules.
Automated inversion of logic grammars for generationWe describe a system of reversible grammar in which, given a logic-grammar specification of a natural language, two efficient PROLOG programs are derived by an off-line compilation process: a parser and a generator for this language. The centerpiece of the system is the inversion algorithm designed to compute the generator code from the parser's PROLOG code, using the collection of minimal sets of essential arguments (MSEA) for predicates.The centerpiece of the system is the inversion algorithm designed to compute the generator code from the parser's PROLOG code, using the collection of minimal sets of essential arguments (MSEA)for predicates. The interpreter first transforms a DCG grammar into equivalent PROLOG code, which is subsequently inverted into a generator. Cambridge University Press. Naish, Lee. 1986. Negation and Control in PROLOG. Lecture Notes in Computer Science, 238, Springer.
Centaur: the systemCENTAUR is essentially written in Lisp (Le_Lisp). The logical engine is Prolog (Mu-Prolog). The man-machine interface is built on top of the virtual graphics facility of Le_Lisp, itself primarily implemented on top of X-Windows.CENTAUR is essentially written in Lisp (Le-Lisp). The logical engine is Prolog (Mu-Prolog). The man-machine interface is built on top of the virtual graphics facility of Le-Lisp, itself primarily implemented on top of X-Windows. 1. They are connected through an interface that contains two classes of primitives: - control primitives to call Prolog from within the Virtual Tree Processor and to call the Virtual Tree Processor from within Prolog, - transformation primitives to perform coercions between Virtual Tree Processor trees and Prolog terms. 1.3. This has already proven useful in switching from a first Prolog interpreter, C-Prolog of Edinburgh University [23], to a more powerful Prolog system, the Mu-Prolog of Melbourne University [21].
Objects with logicThis paper describes an approach to the integration of logic and object programming where predicates, logic expressions, and a generalized search protocol that support Prolog-like reasoning are implemented as an integral part of an object-oriented language. This logic programming facility provides 1) domain-based reasoning, 2) functional arguments, 3) support of the abstraction power of object-oriented languages, and 4) matching of complex object patterns, none of which are available in Prolog. The integration does not require logic facts to be local predicates in the environment, instead, facts are represented as objects in the application model.., Auburn Hills, MI 48057 This paper describes an approach to the integration of logic and object programming where predicates, logic expressions, and a generalized search protocol that support Prolog-like reasoning are implemented as an integral part of an object-oriented language. This logic programming facility provides 1) domain-based reasoning, 2) functional arguments, 3) support of the abstraction power of object-oriented languages, and 4) matching of complex object patterns, none of which are available in Prolog. The integration does not require logic facts to be local predicates in the environment, instead, facts are represented as objects in the application model. The form of logic expressions in KSL/Logic is more general than in Prolog. For example, while the arguments of predicate expressions in Prolog can only be variables or structures, in KSL they can be executable expressions, i.e., functions, in KSL/Logic.
An interpreter for large knowledge basesBenchmarks comparing the proposed interpretation scheme with other Prolog systems are presented and show a strong improvement in the performance.To copy otherwise, or to republish, requires a fee and/or specfic permission. © 1989 ACM 0-89791-299-3/89/0002/0087 $1.50 87 Prologs control strategy uses depth first search with backtracking. A large bandwidth - that is limited when secondary memory is used - is thereby required. Prologs execution strategy is distinguished by a topdown execution approach t. This causes a redundant search, and the halting condition cannot be guaranteed. An alternative to Prologs top-down approach, for logic programs, is the bottom-up approach 2, which has been the classical alternative taken in deductive databases [GaMiNi 84, Mi 88].
Intelligent computer-based instructionMuch of the enthusiasm stems from the adoption of PROLOG as the core programming language by the Japanese Fifth Generation Project. An intelligent computer-based instruction system, based upon an expert system approach and comprised of an expert system shell and a number of subject dependent knowledge bases, is introduced in this paper. The system, being implemented in PROLOG, would provide powerful question-answering and reasoning capabilities.An intelligent computer-based instruction system, based upon an expert system approach and comprised of an expert system shell and a number of subject dependent knowledge bases, is introduced in this paper.' The system, being implemented in PROLOG, would provide powerful question-answering and reasoning capabilities. Now, the course material can be transformed into micro-PROLOG representation as shown in Figure 1. Clause (Cl) is a general rule indicating that a metal and an acid would undergo chemical reaction to give hydrogen. [G] Zichol J., Dean J. and Driggs J. Teachers Encounter PROLOG. Journal of Computer Assisted Learning, Blackwell Scientific Publications, Oxford, Vol. 2, No. 2 pp. 74-82. (1986) 9 Sergot M.
"Automated theorem proving: mapping logic into AIThe ATP field, via resolution, has even provided the foundation for an exciting AI and database programming language, PROLOG. We conclude with a new method for extending the PROLOG system to work with non-Horn clause sets within a positive logic format, particularly simple for ""slightly non-Horn"" clause sets.The ATP field, via resolution, has even provided the foundation for an exciting AI and database programming language, PROLOG. We conclude with a new method for extending the PROLOG system to work with non-Horn clause sets within a positive logic format, particularly simple for ""slightly non-Horn"" clause sets. KEYWORDS: automated theorem proving, mechanisms for automated provers, PROLOG, slightly non-Horn clause set. Introduction. Logic and automated theorem proving (ATP) have enjoyed a special place in the artificial intelligence (AI) world from the beginning of AI. Also the boundary is fuzzy because one might include or exclude PROLOG systems. PROLOG descended (some might say ""ascended"") 217 from a linear resolution theorem prover but is distinct in many ways, including not being sound (it can lie!)."
Socrates: a project integrating human science with computer scienceHowever, using algorithmic tools to solve a problem that is answerable only through heuristics renders those tools less useful. The system, implemented in PROLOG, was constructed from complex functional representations of data. Naturally, a project of this complexity involves the programmers very deeply in the implementation environment. PROLOG was studied as an applicative programming language, and yet it was discovered that it is possible to force procedurality onto PROLOG. Here the emphasis is not on specialized programming techniques, but on the programmer's ability to reason inside the problem domain and to communicate that reasoning through the language at hand, be it LFD's actual PROLOG code, or the code of some other computer language.However, using algorithmic tools to solve a problem that is answerable only through heuristics renders those tools less useful. The system, implemented in PROLOG, was constructed from complex functional representations of data. Naturally, a project of this complexity involves the programmers very deeply in the implementation environment. PROLOG was studied as an applicative programming language, and yet it was discovered that it is possible to force procedurality onto PROLOG. Two methods to program any looping problem were generalized, one a procedural implementation coded as required by PROLOG syntax and the other, pure PROLOG. The procedural method is used to circumvent PROLOG's stack manipulation: a dummy variable is carried all the way down to the boundary condition and only then is it instantiated.
"Implementing knowledge bases on secondary storage (abstract only)We are currently investigating partitioning schemes with hashed partitions, where each partition contains ""homogeneous"" facts and/or rules and uses traditional AI KR schemes, e.g., frame-like knowledge structures, such as PROLOG structures, and tuples in PROLOG relations. Furthermore, the implementation language has a bearing on some of these issues. For example, with PROLOG there must be an explicit accommodation of the default backtracking technique, whereas with LISP the programmer is free to tailor the backtracking algorithm to the knowledge structures from the outset. As another example, consider the default indexing techniques used with PROLOG. Some PROLOG implementations index on the first component of a relation only [2].Essentially, there are four approaches: (1) develop a simple interface between an AI development system, such as PROLOG, and a database system, such as INGRES, i.e., a loose-coupling, (2) extend a database system to accommodate AI tasks, e.g., add inferencing capabilities, (3) extend an AI development system by adding database capabilities, and (4) develop a tightly-coupled system with its own AI and database capabilities, Although these four approaches to incorporating secondary storage residency into knowledge systems are very important ones, there is also much potential for incorporating specialized, file processing techniques, i.e., developing systems for applications that do not demand full database-level capabilities--a simplified approach to (4) above. We are currently investigating partitioning schemes with hashed partitions, where each partition contains ""homogeneous"" facts and/or rules and uses traditional AI KR schemes, e.g., frame-like knowledge structures, such as PROLOG structures, and tuples in PROLOG relations. Another related issue is partition size, i.e., knowledge-partition resolution and granularity. As another example, consider the default indexing techniques used with PROLOG. Some PROLOGimplementations index on the first component of a relation only [Z]."
"Please: a language combining imperative and logic programmingPLEASE differs from ANNA by restricting the logic used in annotations to Horn clauses, therefore, PLEASE specifications can also be transformed into prototypes which use Prolog to ""execute"" pre- and post-conditions. We believe the early production of executable prototypes will enhance the development process. In this paper we give an overview of PLEASE, present an example specification, describe the translation of PLEASE specifications into Prolog procedures, and discuss some of the techniques used to obtain acceptable efficiency in the resultant prototypes.PLEASE differs from ANNA by restiicting the logic used in annotations to Horn clauses, therefore, PLEASE specifications can also be transformed into prototypes which use Prolog to ""execute"" pre- and post-conditions. We believe the early production of executable prototypes will enhance the development process. In this paper we give an overview of PLEASE, present an example specification, describe the translation of PLEASE specifications into Prolog procedures, and discuss some of the techniques used to obtain acceptable efficiency in the resultant prototypes. 1. Prolog is much more efficient than general purpose theorem provers, to achieve this, several concessions were made."
Automatic design and implementation of language data typesAlthough compiler construction has long been aided by parser generators and other tools, interpreters and runtime systems have been neglected, even though they constitute a large component of languages like Lisp, Prolog, and Smalltalk. Of the several parts of a runtime system, the primitive datatype definitions present some of the most difficult decisions for the implementor.Although compiler construction has long been aide d by parser generators and other tools, interpreters an d runtime systems have been neglected, even thoug h they constitute a large component of languages lik e Lisp, Prolog, and Smalltalk . Of the several parts of a runtime system, the primitive datatype definition s present some of the most difficult decisions for the im - plementor . Cost evaluation on machine code derived fro m those designs yields performance formulas, which ar e then used to estimate the designs' effect on bench - mark programs . 1 Introduction In recent years there has been a move towards higher - level languages such as Lisp, Prolog, Smalltalk, APL , SETL, Snobol, Icon, and others . (struct predicat e (head term ) (body (seq XX ter m (struct ter m (functor atom ) (args (seq yy ato m (union ato m (intp (range ints (- (expt 2 28) ) (expt 2 28)) ) (floatp floats) , complicate d (symp symbols) ) Detailed internal descriptions of Prologs are still rare . C-Prolog uses a combination of tagging and spaces .
"Use of instruction set simulators to evaluate the LOW RISCThe LOW RISC has been proposed as an HLL architecture for Prolog. This paper describes the development and use of software simulators for evaluation of the LOW RISC instruction set.Short Department of Computer Science Arizona State University Tempe, AZ 85287 Abstract The LOW RISC has been proposed This paper describes the as an HLL architecture for Prolog. development and use of software simulators for evaluation of the LOW i. Reducing the calls has been a large factor in the design of RISC architectures. 2. RISC as an rrJ. Architecture for Prolog. The applicability of RISC concepts to non-procedural languages, like Prolog [C184], has not been widely for Prolog in use today are based on machine. One such abstract Machine (WAM), serves as the basis for a number of implementations support for Prolog through [Wa 83, Ga 84]. Architectural the use of ""microcoded WAM-engines"" has received considerable attention [Ti 84, Do 84, Do 85]. 63 The LOW RISC (logic programming oriented windowed reduced instruction set computer) hardware interpretation of Berkeley RISC II [Ka 85], [Mi 86] provides an alternative to compiled Prolog code."
"On the evaluation strategy of EDUCEIt was constructed by fully integrating the logic programming language Prolog and the relational data base management system Ingres. The other strategy, known as one-tuple-at-a time, evaluates queries by imitating the evaluation strategy of the programming language Prolog. In earlier versions of Educe, users selected the strategy by using two different query languages.On the Evaluation Strategy of EDUCE Jorge BOCLB ECRC Arabellastr 17 D-8000 Muenchen 81 West Germany Educe 1s a logic programmmg system for handhng large knowledae bases It was constructed by fully mtegratmg the Iogle pr&qamm,ng language Prolog and the re!atmnal data base management system Ingres Educe uses a hybnd strategy for the evaluation of querws TIus strategy 1s bawd on two contrastmg strategws The strategy known as sets retraeval, transforms recur~we and non-recurswe queries Into a form swtable for evaluation by a relatIona data base management system The other strategy, known as one-tuple-at-o ttme, evaluates quervzs by umtatmg the evaluation strategy of the programnung language Prolog In earher ver~lons of Educe, users selected the strategy by usmg two different query languages In order to remove this responsibdity from the user, algorahms to map expresslons from ather of the languages Into the other were unplemented and added to Educe Tlus paper brIefly rewews the nnplementatlon of both evaluators and the mappmgs compares the baac strategies of evaluallon, and then proceeds to explam Educe's own strategy 1 Introduction This paper discusses the design and nnplementat,on of Educe a logic programmmg system capable of handhng large knowlpdge bases Educe uses B hqbrld strategy for the evaluation of quenes Tlus strategy 1s based on two rontrastmg ctrategles The strategy known as sets retrtevaltransforms recur~we and non-recurswe querws Into a form sull able for ebaluatlon b) a relational data base management system (RDBMS) The other strategy, known as one tuple-at (I t,me e\aluates querws bk mutang the evaluatton strategy of the programmmg language Prolog prolog A number of alternatwes for couplmg/mtegratmg Prolog and a relatJona1 DBMS are presented and dwuswd lkb9, Stong5, Vass84, Venk85, cpdb, Zamolo, SaWarr/ Ed"": was constructed bv the couphng/mtegratlon of a deductwe component and an external data base (EDB) component jkb9j The programmmg language Prolog 1s at the centre of the deductl\e component, and the relational DBMS Ingres lmgres was used for the EDB component [G&35] PermIssIon to copy wlthout fee all or part of this matenal IS granted provided that the copies are not made or dlstrlbuted for direct commercral advantage, the ACM copyrIght notlce and the title of the pubhcatlon and its date appear, and notlce 1sgiven that copying IS by perm~s~on of the Assoclatlon for Computmg Machmery To copy otherwise, or to repubhsh, reqmres a fee and/or speck permtsslon At the top level, Educe offers users two different languages one following the non-procedural style of data mampulat~on language (DML) for RDBMSs, and one with a style close to Prolog We refer to these languages as loose DML and close DML, respectwely Expressions m these languages CM be freely muted m Educe programs In terms of Implementation, there IS a close correlation between these languages and the evaluation strategxs outhned ,n the prewous paragraph It seems natural to use the sets retrieval strategy for the loose DML and the one tuple-at-a ttme strategy for the close DML Imtmlly, Educe used a couphng between a Prolog Interpreter and a relatIona DBMS for the lmplementatlon of the loose DML Because of the problems that the evaluation of recurswe queruzs causes [Boa 851 m a coupled system, the close DML was xnplemented b\ mtegratmg the low level access mechamsm of the DBMS mto the Prolog mterpreter Although, these two approaches rmght be thought antagomstx to each other, ,n Educe they co-exw and co-operate More recently algorithm\ to map expresslonc from ather of the languages mto the other have been Implemented Tlus allows Educe to decide for Itself whvzh IS the (hkely) best strategy for evaluation of a gnen quer, The motwatlons for the two languages 1x1 Educe and thew partwdar syntax are &cussed m detad m lBocca 851 Th,s paper first presents a short rwlew of the arclutecture of Educe, then describes as Implementatlon and finally chscusses issues of performance The paper IS dwlded into fi\e sections SectIon 1 1s tlus mtroductlon In wrtlon 2 an outhne of the architecture of Educe IS g,\en %ctmn 3 dwusses the wnplementatlon of the loose and the close languages, the handhng of those rules stored m the EDB and the mappmg algorahms An exammatlon of the efficwncv of Educe's partvxiar lmplementatlon 1s undertaken HI se&Ion 4 Fmallt HI sectlon 5 conclusions are presented and future worh dwussed 2 Architecture In thl5 secllon an ourlmr of the chosen arctutecture for Educe and the motl\atwn< behmd ,t BPC presented A detalled dlscuswon of powblr alterna~wc architectures for Educe can be found 1"" Boccd 851 From the pomt of \wn of thp implementor loose couphng presents ltwlf a~ an ob\xrus method for wnplementatlon Prowded that ~CCUPSI~II ,< IIOI allowed a smlplr W&V to construct a Itmwh cmplrd s,scen, 1s by settmg up `wo processes ant Ior thr deductlxe rwnpon~~t and one for the EDB compurwnt 1 hew tno process= rxchange messages, 1 e querws and r+e> through a channel of communaca~~on Educe foHors thl< approach for loosr rouplmg, settmg up one process fix Pr&g a= the dtducll\e component, and one process ior Ingres a< tllP E1)H *o,,,,`""""ent Commumcst~on between the Prolog and the Ingrcs prur~acz 1% by mean of two pipes [umx 831, one for queries and one for rephes ,Flg 1) 0 1986 ACM 0-89791-191-1/86/0500/0368 $00.75 Rep1 yes 4 Prolog 1 DBMS Puer I es * I c -- ( Data Base ) Figure 1 mk ----.,., ---.-1.---.-----.-- -------- *, , Figure 2 Unfortunately, the two processes m loose coupb~,e: would be very lneffiaent for a"" lmplementatlon of the close DML m Educe This IS apparent m systems that have adopted this as n solution [frog 85, Nash 831 Because of this, we chose to Integrate the deductwe and the EDB components mto one monobthlc umt to handle the close DML Fol this, the acce6a methods module of the DBMS was detached from It and attached to Prolog [Fig 21 This allowed the multiple process ConfiguratIon of loose couphng Fig l] to be merged wth the close mtegratlon ConfiguratIon Fig 21 m a particularly coherent way To explam this, let us start by consldermg two concurrent processes, each of which runs the DBMS on a common data base [Fig 31 When this configuratIon [Fig 31 1s merged wth the two previous ones [Flgs 1 and 2] produces Educe's arhltecturc [Fig 41 In the configuration depicted by Fig 3, one of the occurences of the DBMS 1s replaced by the Prolog+AM configuration IFig 21 This 1s possible, Smce the Access Methods module of the Prolog+AM and the DBMS are ldentxal repbcas In other words, Educe appears as two concurrent DBMS's sharmg access to a common data base It IS Important to note that this architecture does not Impose any restrxtions on recur~lo"" On the contrary, It prowdes an &went mechamsm for the evaluation of multiple and recur~we querres m ather of the two languages, close and loose Recurswe defimtlons which Include expresslons m loose form are evaluated by a hybrid strategy A"" evaluator has bee"" implemented for this purpose The evaluator uses loose coupling for the non-recursl\e part oi the defmltron, and then, for the recurslvc part, IL uses the route prowded by close mtegration for retlxvals from the mtermedmte results Recently, a module which performs mappmgs from expressions m loose form mto close form and rre bersa, has been bwlt This module allows Educe to select a route, either couphng or integration, entrely on the basis of expected performance 3 Implementation The descrlptlo"" of the Implement&on of Educe here presented follolrs the hlstorlcal development of thP <\Ftem In order to a\oid dwa""tlmg thr deductwe- and the EDB components loose couphng was rnplemented 1"" the fnyt Instance The mtegratlon phase was postponed until we had gathered sufficient detail of the constructlo"" of these components Rule storage and the transformatlo"" of rxprewons can be see"" as mIportar,t extensrons of the baw capatnbtles of Educe 3 1 Loose Coupling Let us begm with the discusqlon of a relatlxelg ample part of the lmplementatlon the JXLrt that deal? wth loose couphng wthout recu~slon This part of Educe uas m~plemented d\ tao related processes /Fig 11 One process actmg as B master runs the Prolog mterpreter wtnle the second process the wrver pun\ the DBMS The Prolog Interpreter used 1s a derwed product of the Mu-Prolog mterpreter ji%sh 83] The lngres DBMS [Stonebraker 76j N~F chosen as the EDB component Thus, m this set up, whenever the evaluation of a goal reqwres access to the EDB, all expressions reqwlng some form of s) ntactx analysis are parsed, and code 1s generated for them by the Prolog mterpreter The code generated IS the equwalent QUEL ~XJIlYSSlOll This QUEL expression the query, 1s sent wa a p'pe to Ingres lngrw m turn evaluates the query and produces a reply Tins reply 1s pIped back to Prolog winch further processes It to bmd \armbles to their respectwe values In this part of the Implementation, the control of processes and commumcatlon between them was written m C, while the parsmg of queries and code generation was all done III Prolog r?' , L------------b Data Base \I Figure 3 Rep1 #es 4 Prolog b DBMS Duet- I es pL-pzj * 1, Data Base ) Figure 4 This scheme permlts a more refined and efficient cwtrol of synchronuatron and communlcatmn between the processes The predicate helpdb 1s perhaps the sxnplest example of the theory of operatmn described above This predicate 1s defined by the Prolog clause helpdb - query( ' help `) The predicate query(anlngresQuery) takes the atom anlngresQuery and sends the strmg of characters formmg the name of the atom down a p'pe to Ingres Then It waits for the evaluatmn of the query by Ingres and on completmn returns true Thus, by means of this mechamsm, any arbitrary Ingres query can be sent to the server for evaluatmn The predicate query was wntten m C and has been Integrated mto the Prolog mterpreter A more complex sltuatmn develops when the mode of opcratmn of Prolog differs from the mode of operatmn of the FDB Take the ease of retrteve retrleve( Atts, Boolean ) - send-query( Rels, Atts, Boolean ), repeat, rel( p ), ( P = E, ( E = contniue, t f611 1 ,= [ ( OutAtts] , value( Atts, OutAtts ) ) FolloHmg the parsmg of Atts, a query 1s sent to lngres wa send- query T>plcally, Ingres produces a whole relatmn as a,, answer to the query Smce Prolog reqlures only one tup1e at a time, some adjustments have to be made Basically, Ingres pipes the result relatmn to Prolog while Prolog takes one tuple each tme from the pipe In other words the p,pe acts as a queue To take one tuple from the pipe rel(Pj IS called P 1s compared agamst the atom contmue to check for the pnd of rep11 from Ingres If It 1s not the end of reply (rontznue),then the tuple P 1s passed ,n swtable form to value ahlch bmds \anablrs to attnbute values It should also be mentmncd that the svntax of retneLe allo\r~ unmsLantmted >armbles III the condltwns (Boolean) argument Because of this, it 1s desirable to delay evaluatmn of the retrteue until the search crlterla have been clearly estabhshed, $0 avoldmg retneval of unnecessary data 3 2 Close Integratuxl It 1s not only for syntactic convenience that vanables are necessary in the condltmn part of retrreves WIthout them, It would be nnposslble to express recursmn Take for example the relatzon pm@, Y), defined by psrcnt( x, Y) - ( ""m-(X) ) v*??"
Iteration for applicative languagesThe elements of the construct are explained as well as its evaluation. A prototype Prolog implementation is included to illustrate the discussion.INTRODUCTION Fhe control component of of function exponentiation is used to construct suitable to applicative the construct are explained as well as Prolog implementation is included to applicative languages should naturally be congenial to the mathematical languages, generally functions (as Prolog). Both LISP and Pro]og composition in LISP roughly concepts that underly such in LISP) or predicates (as in support recursion, function corresponds to the conjunction of literals in Prolog. The procedural languages have functional of LISP. The difference is even more that is true under more than striking in Prolog. A predicate p one conjunction of conditions must be expressed by an equal number notation, with disjunction and a single unit.
Recovering implicit informationThis paper describes the SDC PUNDIT, (Prolog UNDerstands Integrated Text), system for processing natural language messages. PUNDIT, written in Prolog, is a highly modular system consisting of distinct syntactic, semantic and pragmatics components.Schiffman, Lynette Hirschman, Marcia Linebarger, and John Dowding Research and Development Division SDC -- A Burroughs Company P.O Box 517 Paoli, PA 19301 USA ABSTRACT This paper describes the SDC PUNDIT, (Prolog UNDerstands Integrated Text), system for processing natural language messages. 1 PUNDIT , written in Prolog, is a highly modular system consisting of distinct syntactic, semantic and pragmatics components. Introduction Reeoverlng Implicit Information This paper describes tile SDC PUNDIT 2 system for processing natural language messages. PUNDIT, written in Prolog, is a highly modular system consisting of distinct syntactic, semantic and pragmatics components. The restrictions enforce context-sensitive wellformedness constraints and, in some cases, apply optimization strategies to prevent unnecessary structure-building. further below. . . . . . . . . . . . . . . . . . . . . . . . . 2 Prolog UNDderstands Integrated Text 97 Each of these three parts is described 2.1.
"A generative grammar approach for the morphologic and morphosyntactic analysis of ItalianA morphologic and morphosyntactic analyzer for the Italian language has been implemented in VM/Prolog |3| at the IBM Rome Scientific Center as part of a project on text understanding.Aim of this project is the development of a prototype which analyzes short narrative texts (press agency news) and gives a formal representation of their ""meaning"" as a set of first order logic expressions. Question answering features are also provided.The morphologic analyzer processes every word by means of a context free grammar, in order to obtain its morphologic and syntactic characteristics.It also performs a morphosyntactic analysis to recognize fixed and variable sequences of words such as idioms, date expressions, compound tenses of verbs and comparative and superlative forms of adjectives.The lexicon is stored in a relational data base under the control of SQL/DS [2], while the endings of the grammar are stored in the workspace as Prolog facts.A friendly interface written in GDDM [1] allows the user to introduce on line the missing lemmata, in order to directly update the dictionary.A GENERATIVE GRAMMAR APPROACH FOR THE MORPHOLOGIC AND MORPHOSYNTACTIC ANALYSIS OF ITALIAN Marina Russo IBM Rome Scientific Center via del Giorgione, 129 00147 Rome Italy lemmata, structured in a table of a relational data base under the ABSTRACT A morphologic and morphosyntactic analyzer for the Italian language has been implemented in VM/Prolog 131 at the IBM Romc Scientific Center as part of a project on text understanding. The disadvantage is a performance degradation when the size of data increases, since Prolog is not provided with efficient search algorithms. The advantage is that this system is directly accessible from VM/Prolog (the string containing the query is processed by SQI., which returns the answer as a Prolog list)."
"Crossing coreference in Discourse Representation TheoryAn intriguing parallel with certain properties of Prolog suggests a modification to Discourse Representation Theory which allows a simple and coherent explanation of these, and related, sentences.Annotated variables on the other hand are ""multiplied out"" in the relational spirit of Prolog, i.e. instead of""predicate(X,Y(Y=Z))"" we write ""(predieate(X,Y), Y=Z)"". And then a proof of tim setof-expression treats these pre-established Iindings as constraints to be satisfied. This is the Prolog way to implement the cataphoric pronoun in Bach-Peters-sentences, In this, last, respect the setofoperator in Prolog is treated as just another predicate, and its being second order is irrelevant. And in this the Prolog setof-operator differs fundamentally form the iota-operator as used in First Order Logic."
Recovering implicit informationThis paper describes the SDC PUNDIT, (Prolog UNDerstands Integrated Text), system for processing natural language messages. PUNDIT, written in Prolog, is a highly modular system consisting of distinct syntactic, semantic and pragmatics components.Schiffman, Lynette Hirschlnan, Marcia Linebarger, and John Dowding Research and Development Division SDC -- A Burroughs Company P.O Box 517 Paoli, PA 19301 USA ABSTRACT This paper describes the SDC PUNDIT, (Prolog UNDerstands Integrated Text), system for processing natural language messages. 1 PUNDIT, written in Prolog, is a highly modular system consisting of distinct syntactic, semantic and pragmatics components. Introduction This paper describes the SDC PUNDIT 2 system for processing natural language messages. PUNDIT, written in Prolog, is a highly modular system consisting of distinct syntactic, semantic and pragmatics components. APPROVED FOR PUBLIC RELEASE, DISTRIBUTION UNLIMITED. 2 Prolog UNDderstands Integrated Text work in natural language understanding for the Strategic Computing Battle Management Program.
"The success of failure: the concept of failure in dialogue logics and its relevance for NL-semanticsIn this paper we present a new interpretation of failure, a concept to which a lot of attention is being paid in the field of artificial intelligence research, especially due to the rise of the programming language PROLOG that treats negation as procedural failure. Our interpretation of failure, however, does not originate from research in the foundations of PROLOG.UUCP Abstract preoccupation with ""assertions"", being the linguistic counterparts In this paper we present a new interpretation of failure, a concept to which a lot of attention is being paid in the field of artificial intelligence research, especially due to the rise of the programming language PROLOG that treats negation as procedural failure. Our interpretation of failure, however, does not originate from research in the foundations of PROLOG. Failure in dialogue tableaux Nowadays, because of the success of prolog, people are greatly interested in the logical properties of negation interpreted as procedural failure. We want to make it clear from the outset, that this new interpre tation of failure is not an interpretation for negation, as is the case in prolog. We will apply dialogical failure together with standal'd (classical, intuitionistic) negation."
Graphical interface for logic programmingMuch of the power of PROLOG language and logic programming is due to the unification process between variables and the matching between patterns.LAMARMORA 12 28100 NOVARA, Italy Private address: via Beldi' 19 28068 ROMENTINO, Italy INTRODUCTION Much of the power of PROLOG language and logic programming is due to the unification process between variables and the matching between patterns. reasoning and theorem proving is easily Moreover achievable through the logic and the backtracking mechanism of the language. Unfortunately the PROLOG language has no similar feature for graphics. It is easy to obtain intelligent systems in PROLOG, but it has a very poor graphical interface. Often solving a problem by logic programming we commit the solution in some way to the PROLOG system. Now let us commit image processing to a graphical intelligence.
A definite clause version of Categorial GrammarThis modification is needed to account for the types of higher-order functions and, as a consequence, standard Prolog-like Horn logic theorem proving is not powerful enough. We tackle this problem by adopting an intuitionistic treatment of implication, which has already been proposed elsewhere as an extension of Prolog for implementing hypothetical reasoning and modular logic programming.This modification is needed to account for the types of higher-order functions and, as a consequence, standard Prolog-like Horn logic theorem proving is not powerful enough. Thus, proof rules (I)-(V) provide the abstract specification of a first-order theorem prover which can then be implemented in terms of depth-first search, backtracking and unification like a Prolog interpreter. (An example of such an implementation, as a metainterpreter on top of Lambda-Prolog, is given in [9].) Carnegie-Mellon University. [3] Gabbay, D. M., and U. Reyle. 1984. N-Prolog: An Extension of Prolog with lIypothetical Implications.
Déduction automatique et systèmes transformationnelsLes systèmes transformationnels utilisent des processus déductifa d'une approche différente des systèmes utilisés en intelligence artificielle. A travers une comparison du langage prolog et du langage Sygmart, il est montré comment réaliser dans les systèmes transformationnels des applications utilisant des raisonnements et des bases de connaissances.RESUME : Les systmes transformatiounels utilisent des processus deduetifs d'une approche diff 6rente des systmes utilis 6s en intelligence artificielle. A travers une comparaison du langage Prolog et du langage Sygmart, il est montr comment raliser dans les systmes transformationnels des applications utilisant des raisonnements et des bases de connaissances. Le but de cet article est de montrer travers quelques exemples simples la transposition transformationnelle des principales fonctions dductives des systmes bases sur l'inf 6rence logique. Les exemples utiliss sont ceux definis dans PROLOG [ 3 ] pour l'approche logique et sont traduits dans SYGMART 2 ] pour l'approche transformationnelle. 2. Evidemment comme il est prScis plus haut, la prise en compte dans PROLOG de tous ces renseignements suppose une structure beaucoup plus complexe. 3.
Knowledge and tools in building GRANDJUR 1.1We are experimenting with two implementations of the programs described here. We built the first prototype using a Prolog language, but have now begun to experiment with a hypertext tool. Tools and routines are available to replicate, in Prolog, many of the screen handling advantages of hypertext media. The Prolog version of the GRANDJUR program occupies much less space in memory, and operates much faster.This Prolog representation required additional coding to make a pleasant presentation, but allowed a quick and easy development of a prototype without fancy screen handling.The use of Prolog predicates to identify types of knowledge, with an argument to identify the associated concept seemed rational and natural to us, and facilitates easy search and change. Tools and routines are available to replicate, in Prolog, many of the screen handling advantages of hypertext media. The Prolog version of the GRANDJUR program occupies much less space in memory, and operates much faster.
The effectiveness of error seedingThe lessons learned from experiments in using it on selected Pascal and Prolog systems are summarised, and suggestions for further research are offered.The lessons learned from experiments in using it on selected Pascal and Prolog systems are summarised, and suggestions for further research are offered. 1. The technique was devised and developed in the early stages of the project and initially tried out on Pascal processors, subsequently it was used, somewhat differently, with Prolog processors. This paper is concerned not with what was revealed about the error handling capabilities of the processors, but what was discovered about the effectiveness of error seeding as an evaluation tool. The tests reported here covered the languages Pascal and Prolog. 5.1 Pascal The Pascal tests [2, 3] were the first to be carried out.
Implementation of predicate logic in APL2A first prototype is now ready, which can be used for PROLOG-like functions in connection with image processing functions.A first prototype is now ready, which can be usedfor PROLOG-like functions in connection with image processingfunctions. 1. Very popular are predicate logic (implemented in PROLOG), production rules (more powerful than PROLOG) and semantic networks. They also use their own programming languages, like LISP or PROLOG and have specialized workstations for their languagesand tools.
"CRITAC: a Japanese text proofreading systemIt detects mistypes, Kana-to-Kanji misconversions, and stylistic errors. This system combines Prolog-coded heuristic knowledge with conventional Japanese text processing techniques which involve heavy computation and access to large language databases.It detects mistypes, Kana-to-Kanji misconversions, and stylistic errors. This system combines Prolog-coded heuristic knowledge with conventional Japanese text processing techniques which involve heavy computation and access to large language databases. 1. Because of this high-level representation, human proofreading knowledge can be easily mapped into Prolog rules. Two user-friendly representations of text, called ""source"" and ""KWlC"" (Key-Word-In-Context) views, are derived from the structured text. The proofreading knowledge base currently consists of about 30 Prolog proofreading rides for the structured text. The user interface handles two external views and facilitates the SQL/DS online dictionary server and text compiler."
"A parametric NL translatorA ""universal grammar"" is defined, together with parameters of variation for specific languages. The system, written in Prolog, parses, generates, and translates between English and Spanish (both directions).A ""universal grammar"" is defined, together with pal-ameters of variation for specific languages. The system, written in Prolog, parses, generates, and translates between English and Spanish (both directions). i. A general knowledge of GB is assumed in the following, as is a familiarity with Prolog, the language in which the GBT is implemented. (since the irt is assumed to be tical, it is not tested for well-formedness. ) The highlevel Prolog program for this stage is given below: (7) tragformation(L, Dstruchure, Sstrdcture) :- transform (L,matrix (+),Dstructure, Sstructure), dbl_CCP_filter (L, Sstructure), wh filter(L, Sstructure), case filter(L, Sstructure), b conditions (L, Sstructure), ecp(L, Sstructure)."
Design and performance measurements of a parallel machine for the unification algorithmUnification is known to be the most repeated operation in logic programming and PROLOG interpreters. To speed up the execution of logic programs, the performance of unification must be improved.Unification is known to be the most repeated operation in logic programming and PROLOG interpreters. To speed up the execution of logic programs, the performance of unification must be improved. PROLOG's statements in the form of logic propositions, its argument match capability, and nondeterministic and database management features make it very suitable for AI and expert system applications. To copy otherwise, or to republish, requires a fee and/or specific permission. 0 1990 ACM 089791-324-8/90/OW3/0021$1.50 ing post that PROLOG has achieved in the fifth generation, and marks the beginning of an era in which PROLOG is accepted world-wide.
VALKYRIE: a validation subsystem of a version server for computer-aided design dataWe present a mechanism for assisting designers in adhering to their methodology, specified as Prolog rules that must match a verification event log.We present a mechanism for assisting designers in adhering to their methodology, specified as Prolog rules that must match a verification event log. Implementation of the Valkyrie Validation Subsystem 5.1 Using Prolog Prolog was chosen as the language for implementing Valkyrie because of its rule-based structure. A Prolog program consists of rules, facts, and queries.
Constraint logic programming languagesConstraint Logic Programming (CLP) is an extension of Logic Programming aimed at replacing the pattern matching mechanism of unification, as used in Prolog, by a more general operation called constraint satisfaction.This article is directed toward users, implementors and designers of LP languages, a basic knowledge of Prolog is assumed. T\NOof the the main CLP representatives will be emphasized and described: Prolog III and CLP (R). The first has been proposed by Colmerauer, the originator of Prolog, and the head of the Groupe d'lntelligence Artilicielle in Marseille, France, the second was developed by a logic programming team at IBM Yorktown Heights. It is the author's opinion that the embryonic attempts to introduce constraints in Prolog are due to Colmerauer with his design and implementation of Prolog II [14].
Programming techniques for efficiently exploiting parallelism in logic programming languagesGranularity collecting (e.g., in OR-parallel Prolog) and removal of synchronization points (e.g., in AND-parallel committed-choice languages), are in general useful techniques for speeding up parallel logic programs.Ichiyoshi - ICOT+ Granularity collecting (e.g., in OR-parallel Prolog) and removal of synchronization points (e.g., in ANDparallel committed-choice languages), are in general useful techniques for speeding up parallel logic programs. This data structure is analogous in form and performance to the 2-3 tree used in the Prolog algorithms presented. As with any engineering discipline, the techniques and performance measurements are subject to countless caveats. The better choice among structure and list is dependent, on the Prolog system, but, both are close. We show the list version here.
Discourse, anaphora and parsingThe model has been implemented in an extension of PROLOG, and runs on a VAX 11/750 computer.The model has been implemented in an extension of PROLOG, and runs on a 1. Introduction VAX 11/750 computer. Our system thus consists of two parts: a logical specification of DRS theory, written in a language that we have dubbed PrAtt (for Prolog with Attributes), and a simple theorem prover (interpreter) which is capable of deducing the DRSs that correspond to various input sentences using the logical specification of DRS theory. The rules are written in DCG format (Clocksin and Mellish 1984) in a superset of Prolog that we developed in this project. This language, which we have dubbed PrAtt (for Prolog with Attributes), allows an attribute-value notation as well as the standard position-value notation of Prolog.
"Legal reasoning in 3-DThe concept of ""relative weight"" between competing norms is defined, and 3-D is used to formalize two types of legal reasoning (""subsumptive"" and ""means/end""). A general overview is given of a PROLOG program, 3dpr, that implements the 3-D based theory of normative reasoning.The concept of ""relative weight"" between competing norms is defined, and 3-D is used to formalize two types of legal reasoning (""subsumptive"" and ""means/end""). A general overview is given of a PROLOG program, 3dpr. that implements the 3-D based theory of normative reasoning. The goal of this paper is to present a general theory of normative reasoning and to provide a general overview of an implementation of the theory in PROLOG. Such a theory would be useful be useful for the understanding and construction of systems that make decisions based on rules and principles. The 3-D based theory of practical reasoning has been implemented in a PROLOG program (3dpr) that treats the modal operators O(I), U(,) and !"
Are applicative languages inefficient?Side-effects are forbidden in applicative languages like Prolog [3], FP [2], pure Lisp [9], and SISAL [8]. Algorithms can often be reformulated applicatively with no loss of efficiency.Ng Computer Science Division University of California, Berkeley Berkeley, CA. 94720 February 5, 1988 Abstract Side-effects are forbidden in applicative languages like Prolog [3], FP [2], pure Lisp [9], and SISAL [8]. Algorithms can often be reformulated applicatively with no loss of efficiency. The same ideas can be applied to pure Lisp, FP, and Prolog. A simpler model for Prolog is to count the number of steps spent unifying atoms and functors in a top-down left-to-right interpretation of the program. CACM 1:8 (Aug. 1978), 613-641. [3] Clocksin, W.F. and Mellish, C.S. Programming in Prolog. Springer-Verlag, New York (1981). [4] Cohen, S., Multi-Version Structures in Prolog, in: Proe.
A logic programming model of the game of sproutsThis paper describes a representation scheme which simplifies much of the geometry of the game. Using this representation, we develop a Prolog program which will play Sprouts. It is hoped that the program will prove to be a useful research tool in finding the key to a winning strategy for Sprouts and that the representation will serve as a useful model for studying planar graphs.This paper describes a repre-sentation scheme which simplifies much of the geometry of the game. Using this representation we develop a Prolog program which will play Sprouts. It is hoped that the program will prove to be a useful research tool in finding the key to a winning strategy for Sprouts and that the representation will serve as a useful model for studying planar graphs. 1. The original proof that the 2nd player has a forced win in the 6-point game was forty seven pages long [l,p 5681. 2. LIST MODEL OF SPROUTS Before discussing the Prolog representation of Sprouts, our list model of Sprouts and a description of the legal moves based on this model must be presented in some detail. The code to implement these functions requires approximately 700 lines of Prolog. The code to maintain the representation without the deletion option is roughly half of the total.
Book review: Partiality, Truth and Persistence by Tore Langholm (Lecture Notes 15 Ctr. for the Study of Lang. and Information. University of Chicago Press)The remainder in the sixteen-title series deal with both topics, such as Pereira and Shieber's Prolog and Natural Language Analysis (Lecture Notes 10).The remainder in the sixteen-title series deal with both topics, such as Pereira and Shieber's Prolog and Natural Language Analysis (Lecture Notes 10). However, for an efficient implementation, a structured programming language could be considered. good reference on implementing logic systems, For a see Implementations of PROLOG, edited by J. A. Campbell, which contains the one-page PROLOG interpreter M. The application of partial model theory would be reasoningbased systems in general, although I believe the easiest implementations would be PROLOG-based systems. References: [1] LA. Campbell, Implementations o__fpROLOG, Ellis Horwood Publishers, distributed by Halsted Press: a division of John Wiley and sons, 1984.
FCP: a summary of performance resultsFlat Concurrent Prolog is a simple concurrent programming language which has been used for a variety of non-trivial applications.FCP: A Summary of Performance Results Stephen Taylor, Rony Shapiro and Ehud Shapiro Department of Computer Science Weizmann Institute of Science Rehovot 76100, Israel. Flat Concurrent Prolog is a simple concurrent programming language which has been used for a variety of non-trivial applications. The latter programs are abstractions of common parallel programming techniques and serve to quantify the cost of communication in the language. 1 Introduction Flat Concurrent Prolog (FCP) [5] is a simple, process oriented, concurrent programming language. Five parallel applications, Merge Sort, Matrix Multiply, FCPic, Triangle and Or-Parallel Prolog, were used to compare uniprocessor and Hypercube performance.
Solutions to logic problems in APL2The solutions are contrasted with solutions to the same problems in PROLOG. Thus, it is shown that APL has logic programming capabilities in addition to its well known computational abilities.The solutions are contrasted with solutions to the same problems in PROLOG. Thus. it is shown that APL has logic programming capabilities in addition to it6 well known computational abilities. We can ask ourselves what is new about PROLOG, that make6 it different to other, more traditional, programming languages. This question is easy to answer: PROLOG is non-procedural. meaning that PROLOG instructions (see cl11 do not need to be given in any pre-established order.
Evaluation of the FACOM ALPHA Lisp machineThe FACOM ALPHA is the first and only commercially dedicated processor for Lisp and Prolog manufactured in Japan. This paper discusses the evaluation of the FACOM ALPHA for Lisp execution when compared with a general-purpose computer.EVALUATION OF THE FACOM ALPHA LISP MACHINE Masanobu YUHARA Aikira HATTORI Masashi NIWA Mitsuhiro KISHIMOT0 Hiromu HAYASHI Artificial Intelligence Laboratory FUJITSU LABORATORIES LTD. 1015 Kamikodanaka Nakahara-ku Kawasaki 211 JAPAN ABSTRACT The PACOM ALPHA is the first and only commercially dedicated processor for Lisp and Prolog manufactured in Japan. This paper discusses the evaluation of the FACOM ALPHA for Lisp execution when compared with a general-purpose computer. Most of AI application programs are written in Lisp or Prolog, and their execution frequently requires vast amounts of memory and CPU time. Besides supporting a Lisp interpreter and compiler, the ALPHA also supports a Prolog interpreter and compiler [2]. In this paper, however, we will focus on Lisp.
Annotations for distributed programming in logicIt has been recognised that languages like Concurrent Prolog and Parlog which use committed choice non-determinism have departed from the original concept of logic programming, but no new paradigm has been suggested.Logical variables and unification provide a powerful means of communication, and annotations can provide a synchronization mechanism that complements them. 1o Introduction Horn Clause logic programming [1, 2] has aroused a great deat of interest in the past decade because of its declarative semantics and potential for parallel execution. Languages like Prolog [3] and IC-Prolog [4] have tried m realize the Horn Clause paradigm, as advocated by Kowalski [1], by retaining the declarative semantics and giving the programmer some control over the execution. In Section 2 we look at variable annotations in Concurrent Prolog, Parlog, a proposal by Saraswat [8] and Guarded Horn Clauses [9]. We begin by examining Concurrent Pmlog d then discuss Saraswat's annotation, Parlog and Guarded Horn Clauses. Concmrent Prolog has been the subject of extensive discussions in the Prolog Digest (a network mailing group).
Restricting logic grammars with government-binding theoryIn spite of these restrictions, this formalism allows for relatively elegant characterizations of natural languages that can be translated into efficient prolog parsers.In spite of these restrictions, this formalism allows for relatively elegant characterizations of natural languages that can be translated into efficient prolog parsers. 1 INTRODUCTION The best-known parser formalisms for logic programming systems have typically aimed to be expressive and efficient rather than restrictive. DCGs are similar to standard context free grammars (CFGs), but they are augmented with certain special features. These grammars are compiled into prolog clauses that (in their most straightforward use) define a top-down, backtracking recognizer or parser in prolog. 2. The DCG notation is very powerful. The fact that arbitrary prolog tests are allowed makes the notation as powerful as prolog is: a DCG can effectively parse or recognize exactly the class of effectively parsable or recognizable languages, respectively.
The Parallel Expert Parser (PEP): a thoroughly revised descendant of the word Expert Parser (WEP)A prototype of PEP is implemented in Flat Concurrent Prolog and runs in a Logix environment.A prototype of PEP is implemented in Flat Concurrent Prolog ar{d runs in a Logix environment. Io Introduction Work on parallel natural language understanding (NLU) is only starting to emerge. A potentially parallel NLU system (the Word Expert Parser, Small 1980) has been drastically revised so as to allow a truly parallel implementation (viz. in Flat ConCurrent Prolog, using the Logix environment (Silverman et al. 1986)), we call the resulting system the Parallel Expert Parser (PEP, Devos 1987). 2. This suspension takes place during unification of the Flat Concurrent Prolog (FCP) predicate (see below), into which expert routines are compiled.
An object-oriented modelling enviornmentThis system has been prototyped in an object-oriented extension to Prolog. The impact that these two paradigms, logic and objects, have had on the design is discussed.This system has been prototyped in an objectoriented extension to Prolog. The impact that these two paradigms, logic and objects, have had on the design is discussed. `While our jmplementatjon js based on our own addition of a modules facility to the Warren Abstract Machine[WARR83], the 0-OP interpreter may be quickly adapted for any Prolog with a basic modules facility. 3.2 The Object-Oriented Prolog Lan le!Fw Object-oriented Prolog is a super-set of standard Prolog. The infix predicate send/2 may be freely embedded in a pr0gra.m.
How to invert a natural language parser into an efficient generator: an algorithm for logic grammarsIn this paper we present an algorithm for automated inversion of a PROLOG-coded unification parser into an efficient unification generator, using the collections of minimal sets of essential arguments (MSEA) for predicates.In this paper we present an algorithm for automated inversion of a PROLOG-coded unification parser into an efficient unification generator, using the collections of minimal sets of essential arguments (MSEA) for predicates. The starting point of the experiment was a string parser for English (Grishman, 1986), which is used in an English-Japanese MT project. The PROLOG version of this parser was inverted, using the method described here, into an efficient PROLOG generator working from regularized parse forms to English sentences. To obtain a PROLOG parser (or any PROLOG program) working in the reverse, requires some manipulation of the clauses, especially the ordering of the literals on their right-hand side, as noted by Dymetman and Isabelle (1988).
Sentential semantics for propositional attitudesThe grammar is implemented using the standard implementation of definite clause grammars in Prolog.The grammar is implemented using the standard implementation of definite clause grammars in Prolog. 1 LOGICALFORMS FOR PROPOSITIONAL ATTITUDES The sentential theory of propositional attitudes claims that propositions are sentences of a thought language. Second, we do not allow any of the nonlogical operations of Prolog, such as checking whether a variable is bound or free, negation as failure, and the rest. Since the grammar is a set of definite clauses, our notation is like Prolog's. The variables of the target language are u, v, w, x, y, z, etc.
Automatic programming of AGVS simulation modelsThe modeling support program is an automatic programming system, written in Turbo-Prolog which generates the computer code for the required model and experiment in the SIMAN simulation language.The modeling support program is an automatic programming system, written in Turbo-Prolog which generates the computer code for the required model and experiment in the SIMAN simulation language. Method of Operation - SIMTOOL uses expert, rule-based knowledge about AGV system modeling using Prolog first order predicate calculus (horn-clause format). 'CHARACTERII,TIGS: ._-- SINTOOL is an interaotive simulation tool written in Borland's Turbo Prolog for the IBM PC and compatibles. It consists of approximately 6,000 lines of co&e containing 752 rules.
A model for preferenceAn experimental implementation is described, which uses Prolog-like preference statements.An experimental implementation is described, which uses Prolog-like preference statements. 1. Introduction In this paper we address the problem of choosing the best solution(s) from a set of interpretations of the same text segment (For the sake of brevity, throughout this text we use the term interpretation, where in fact we should write representation of an interpretation). This formalism is very much inspired by the programming language Prolog: a preference rule is analogous to a three argument predicate (two interpretations and the resulting relationship), a simple rule to an assertion, and a composite rule to a clause with sub-goals. 4.2. Future directions The implementation of this preference model has been written in Prolog. facilitate experimentation, a mechanism provided for tracing the preference To is rules application to observe their behaviour.
Equations, disequations and unsolvable subsets (abstract)Colmerauer [Col 84], motivated by the introduction of inequations in Prolog-II, was the first to propose an algorithm to extend his unification algorithm for handling disequations. This unification graph is formally detailed in [Cod 88], and a simplified version of our algorithm has been implemented as the basis of intelligent backtracking in a Prolog compiler. This system has a low overhead (30%) w.r.t. standard Prolog unification and gives substantial speedups (from 2 to 20) on non-deterministic programs, see once more [Cod 88].Colmerauer [Co1 841, motivated by the introduction of inequations in Prolog-II, was the first to propose an algorithm to extend his unification algorithm for handling disequations. This unification graph is formally detailled in [Cod 881, and a simplified version of our algorithm has been implemented as the basis of intelligent backtracking in a Prolog compiler. This system has a low overhead (30%) w.r.t. standard Prolog unification and gives substantial speedups (from 2 to 20) on non-deterministic programs, see once more [Cod 881.
"Commentary on: solving symbolic equations with PRESSThe paper ""Solving Symbolic Equations with PRESS"", by Sterling, Bundy, Byrd, O'Keefe and Silver [Sterling et al 82], describes a program PRESS (PROLOG Equation Solving System) which solves some symbolic, transcendental, non-differential equations.Commentary on: Solving Symbolic Equations with PRESS Richard Fateman, Alan Bundy, Richard O'Keefe and Leon Sterling 1 Review by Fateman The paper ""Solving Symbolic Equations with PRESS"", by Sterling, Bundy, Byrd, O'Keefe and Silver [Sterling et al 82], describes a program PRESS (PROLOG Equation Solving System) which solves some symbolic, transcendental, nondifferential equations. It is not 35 without significance that Leon Sterling has a version of PRESS in Flat Concurrent PROLOG [Sterling 86], a system with no provision for backtracking at all... SIGSAM Bulletin, (17):21-24, 1983. L. Sterling. Pressing for parallelism: a prolog program made concurrent. Journal of Logic Programming, 3(1):75-92, April 1986."
"The process allocation in parallel interpretation of logic programs (abstract only)The AND/OR Process Model in Conery's dissertation [1] and Concurrent Prolog by Shapiro [2] are two famous pioneering efforts in this area. A logic program could be modified at run-time, which is semantically understood as knowledge base maintenance. The assert/retract ""predicates"" in Prolog are simple but typical examples of knowledge base maintenance. A prototype system which simulates this static process allocation model for parallel interpretation of subset Prolog programs is being implemented in Ada. This prototype system may be used for further studying different schemes of program partitioning, allocation and the resulting influences on machine learning and system performance.The AND/OR Process Model in Conery's dissertation 111 and Concurrent Prolog by Shapiro (21 are two famous pioneering efforts in this area. A logic program could be modified at run-time, which is semantically understood as knowledge base maintenance. The assert/retract ""predicates"" in Prolog are simple but typical examples of knowledge base maintenance. Conery, ""The AND/OR Process Model for Parallel Interpretation of Logic Programs,"" PhD thesis, Dept. of Information and Computer Science, Univ. of California, Irvine (1983). [21 E. Shapiro, ""Concurrent Prolog: A Progress Report,"" IEEE Computer, 44-58, August 1986."
A course on “expert systems” for electrical engineering studentsWe have demonstrated that bright engineering students can get to grips with practical issues in applied artificial intelligence through a short, intensive, course - starting from ground level. PROLOG was found invaluable as a pedagogical tool, as was the highly-structured engineering-style laboratory.We have demonstrated that bright engineering students can get to grips with practical issues in applied artificial intelligence through a short, intensive, course -- starting from ground level. PROLOG Was found invaluable as a pedagogical tool, as was the highly-structured engineering-style laboratory. Following that we review the material that is covered and the approach taken. Heavy use is made of PROLOG tO exemplify the concepts taught, and the rationale for this is discussed next. After much discussion and reflection on LisP vs PROLOG, the latter was chosen for the following reasons -- many of which are subjective and controversial. • PROLOG is a smaller language and therefore less daunting to students. • Toy expert systems can be built directly in it more easily than in raw LISP. • Although the LiSP-based OPS-5 package was available, PROLOG allows a greater variety of techniques to be exemplified. • Good programming environments were available for neither, but this impacts PROLOG less seriously than LISP. • Although PROLOG is an unusual language, our previous experience in introducing it to Engineering students at Calgary indicated that they may find it easier to grasp than do Computer Science students who are hampered by their wider exoerience of more conventional programming languages.
Building a backtracking facility in smalltalk without kernel supportLanguages like Snobol, Prolog, and Icon were designed with backtracking facilities from the outset and these facilities are deeply intertwined with the implementation.LaLonde and Mark Van Gulik School of Computer Science Carleton University Ottawa, Ontario, Canada KlS 5B6 Abstract Languages like Snobol, Prolog, and Icon were designedwith backtracking facilities from the outset and these facilities are deeply intertwined with the implementation. It has existed for some time in languages like Snob01[4], Icon [3], and Prolog [I]. In eachof thesescases,the facility is integral to the language and as a consequence deeply intertwined with the implementation.There hasneverbeena successfulretrofit of backtracking in a languagethat was not designedfor it. Backtracking is a facility that permits computations with multiple solutions and multiple solution techniques. Coupled with unification in Prolog, it leadsto a powerful symbolic processing capability.
"Generating English paraphrases from formal relational calculus expressionsTwo examples are included. The system was developed and implemented in Prolog at the University of Essex under a grant from ICL.Two examples are included. The system was developed and implemented in Prolog at the University of Essex under a grant from ICL. SPARCK JONES,""A Natural Language Front End to Databases with Evaluative Feedback"", in GARANDIN and GELENBE (eds), New Applications of Databases, Academic Press, London, 1984. [2] W.F.CLOCKSIN and C.S.MELLISH, Programming in Prolog, Springer Verlag, Berlin, 1981. [3] E.F. CODD, ""A Database Sublanguage founded on the ReJational Calculus"", in Proceedings of the ACM SIGFIDET Workshop on Data Description, Access and Control, 1971. [4] E.F. WEST, ""QPROC: A Natural Language Database Enquiry System Inplemented in Prolog"", in ICL Technical Journal, November 1983. 583"
A message driven OR-parallel machineWe present first the multiple binding mechanism for the OR-parallel Prolog architecture and the corresponding OR-parallel abstract machine is described.We present fist the multiple binding mechanism for the OR-parallel Prolog architecture and the correspondiig OR-parallel abstract machine is described. A number of groups have been working on OR-parallelism in Prolog ( (Lusk et al, 1988), (Hausman et al, 1987). (Reynolds et al, 1987), (Baron et al, 1988)), their findings indicate that the exploitation of OR-parallelism can lead to independent computation with low communication overhead. To illustrate the problem, we have the following Prolog program (Fig. 1). Assuming that the code is executed in parallel (each processor taking one different branch).
Knowledge-based support for system verification during requirements analysisThis paper proposes a Petri Net representation of an information system and the use of a PROLOG-based knowledge base to test its representational accuracy.This paper proposes a Petri Net representation of an information system and the use of a PROLOG-based knowledge base to test its representational accuracy. The third section will discuss the basic features of Petri Nets as they are used to model the information system and how this modelling can be represented as factual knowledge in PROLOG. The fourth section will use the analytical properties of Petri Nets to define rules in the knowledge base and their use in the verification process. If each of these has to be fired immediately upon receipt of the appropriate inputs, then only one of these two transitions can be fired at any given point of time. These conflicts can be identitied in PROLOG using the following rule: conflict (TRl, TR2) :- input(TRl,X), input(TR2,Y), diff(TRl,TR2), shares(X,Y). h'ote that the predicate 'diff' ensures that the system does not pick the same transitions for conflict evaluation.
A reconfigurable software style expert system (abstract only)This system does not deal with how a program is formatted, that is, the system does not deal with concerns such as blank lines, comment contents and indentation of code. The system is being implemented in Prolog because of its use as a language for creating expert systems and its ability to allow the creation and use of generic data structures. The source language preprocessor parses the source program creating a database of Prolog facts and possibly rules that will be used by the rule database. I chose this scheme because it was in keeping with the basic structure of Prolog as a language. The second approach involved an explicit graph scheme.This system does not deal with how a program is formatted, that is, the system doesnot deal with concerns such as blank lines, comment contents and indentation of code. The system is being implemented in Prolog becauseof its use as a language for creating expert systems and its ability to allow the creation and use of generic data structures, The systern has two distinct components. The source language preprocessor parses the source program creating a database of Prolog facts and possibly rules that will be used by the rule database. I chosethis schemebecauseit was in keeping with the basic structure of Prolog as a language. The second approach involved an explicit graph scheme.
"An early report on encompassIn ENCOMPASS, software can be specified using PLEASE, an Ada-based executable specification language which can be automatically translated into Prolog. A prototype implementation of ENCOMPASS has been constructed.In ENCOMPASS, software can be specified using PLEASE, an Ada-based executable specification Ianguage which can be automatically translated into Prolog. A prototype implementation of ENCOMPASS has been constructed. At present, predicates are specified using Horn clauses: a subset of predicate logic which is also the basis for Prolog. I'* 22This approach allows a simple translation from predicate definitions into Prolog procedures. ** In PLEASE, as in Prolog, the empty list is denotedby [ 1, and a list literal is denotedby [I] , where 1is a commaseparatedlist of elements. Although many implementations show significant deviations, 76 a ""pure"" Prolog interpreter can he viewed as a resolution theorem prover. 19122In order to dramatically increase Prolog's efficiency, several concessions were made."
Expert-VSim (abstract only): an expert simulation environmentThis expert system is rule-based implemented in Prolog. The presence of such an expert system is of significant importance in the modeling and simulation process. It provides database and inference capabilities that assist the user in: the selection of probability distributions for input variables using common heuristics and procedures [2] to choose from the known theoretical distributions and estimate their parameters (with or without that availability of data), or to allow the user to fit a distribution to experimental data, the analysis of the simulation results, the construction of confidence intervals for the observed variables, and the comparison of simulation runs, the construction of the model itself by providing an on-line database containing the descriptions of the standard and user-defined node types together with the ability to traverse and inspect the multi-level structure of the model, the extension of the expert system itself by allowing the user to add to the set of rules and facts through the Prolog interface, the independent use of the statistical analysis functions and procedures available to analyze and process data, and the management of experimental and simulation data through the database capabilities of the system.This expert system is rule-based implemented in Prolog. The presence of such an expert system is of significant importance in the modeling and simulation process. It provides database and inference capabilities that assist the user in: 1. the selection of probability distributions for input variables using common heuristics and procedures (21 to choose from the known theoretical distributions and estimate their parameters (with or without tha availability of data), or to allow the user to fit a distribution to experimental data, 2. the analysis of the simulation results, the construction of confidence intervals for the observed variables, and the comparison of simulation runs, 3. the construction of the model itself by providing an on-line database containing the descriptions of the standard and user-defined node types together with the ability to traverse and inspect the multi-level structure of the model, 4. the extension of the expert system itself by allowing the user to add to the set of rules and facts through the Prolog interface, 5. the independent use of the statistical analysis functions and procedures available to analyze and process data, 6. and the management of experimental and simulation data through the database capabilities of the system. / I (INFERENCE ENGINEISTATISTICS ANALYSIS FUNCTIONS, +-----+T 1 RANDOM VARIATE GENERATOR 'II I ]SCHEDULER~DISPATCHER~STATISTICS COLLECTORl PARAMETER ESTIMATORS1 I I I NETWORK DATA STRUCTURES AND OPERATORS I PROLOG BATA BASE MANAGEMENT SYSTEM FIGURE. Expert-VSim Layers.
Expert systems for user serviceOver the last few years, expert systems have moved from very expensive LISP or PROLOG based computers to easy-to-use software packages for the PC.Expert Systems for User Service Regina Trimm DeWitt, User Servlco Consultant Seebeck Computor Center The University of Alabama Box 870346 Tuscaloosa, Alabama 35487-0346 (205) 348-3973 RDEWllT at UAlVM Institutional Profile: Between 16,000 and 17,000 Undergraduate & Graduate students Approximately 800 faculty and 1200 staff members Computer Center employs approximately 75 people including 9 consuftants in User Service Over the last few years, expert systems have moved from very expensive LISP or PROLOG based computers to easy-to-use software packages for the PC. Most of the first expert systems created were developed using high level computer languages such as LISP and PROLOG. Both these languages are considered traditional AI languages due to their capabilities for symbolic processing. Now many traditional mainframe provide the capability to run LISP and PROLOG. While these symbolic languages may not run as efficiently on these mainframes, expert systems are becoming more common on these machines.
Structure of a LOTOS interpreterThe interpreter was implemented in YACC/LEX, C, and Prolog. The discussion includes the following topics: syntax and static semantics analysis, translation from LOTOS external format to internal representation, evaluation of Abstract Data Type value expressions and CCS* clauses.The interpreter was implemented in yAcTJ/LEX, C, and Prolog. The discussion includes the follcx~- inq topics: svntax and static semantics analvsis, translation from LWCS external format to internal representation: evaluation of Abstract Data Tvpe value expressions and CCS* clauses. 1-2 Introduction The theory and practice of specification lanquaqes Eor data ccxmnunications protocols and services (often called Formal Description Techniques or F'M's for short) has been the object oE much interest in recent vears. Clocksin, W-F, and Mellish, C.S. Prcqramrninq in Prolog. Spr inqer-Verlaq, Rerlln, L'WA. F,hriq, H. and Yahr, B. Executable Description of the OS1Transport Service in Prolog. In: Y. Yemini, R. Strom, and S. Yemini (eds.1, Protocol Specification, __- Testinq and Verification N, North-Holland, ?
Module test case generationTechniques for test case generation in C and in Prolog are presented and illustrated in detail.Techniques for test case generation in C and in Prolog are presented and illustrated in detail. 1 INTRODUCTION The fundamental goal of our research is to improve system quality and reduce maintenance costs through systematic module regression testing. To generate cases with significant variations, we have found Prolog more effective than C. (Some familiarity with Prolog is necessary to understand this chapter.) Prolog Code We base test case generation on three Prolog predicates.
Book review: The Logical Foundations of Artificial Intelligence. by Michael R. Genesereth and Nils Nilsson (Morgan Kaufmann 1987)At the theory level, the author discusses syntax, semantics, and control strategies for logic programming and Prolog. For the operation level, the author presents his AND/OR Process Model and an updated survey of related work.At the theory level, the author discusses syntax, semantics, and control strategies for logic programming and Prolog. For the operation level, the author presents his AND/OR Process Model and an updated survey of related work. The author also makes it very clear that the model is an abstract parallel interpreter for parallel execution of logic programs, not a model for parallel execution of Prolog. Chapter 2 is an introduction to logic programming and Prolog. It describes some differences between logic programming and Prolog. It also discusses control strategies in a logic program and illustrates some of the control techniques used in parallel systems.
"Design and performance of a coherent cache for parallel logic programming architecturesThe cache optimizations also improve the performance of non-committed-choice languages, such as OR-parallel Prolog. A version of the cache design described here is currently being implemented for ICOT's Parallel Inference Machine (PIM).Parallel logic programming languages, many based on Prolog, are high-level in the sense that destructive assignment is forbidden and programs often appear as many small recursive procedures instead of fewer, large iterative &es. In addition, some languages retain Prolog's nondeterminacy, resulting in backtracking over assignment. Gi are guards, ""I"" is the commit, and Bj are the body go&. In FGHC, as in Prolog, procedures are composed of sets of clauses with the same name and arity. lJnlike Prolog. there are no nondeterminate procedures."
A rule-based approach for simulation errors in discrete sequential processesSuch an approach combines recognition and simulation of sequences and is particularly useful when test patterns are needed for a complex recognition system. This paper presents a Prolog-based simulation system wherein the productions of a stochastic grammar are expressed in an English-like IF-THEN format so they can easily be edited to simulate parsing errors leading to incorrect sequences.Such an approach combines recognition and simulation of sequences and is particularly useful when test patterns are needed for a complex recognition system. This paper presents a Prolog-based simulation system wherein the productions of a stochastic grammar are expressed in an English-like IF-THEN format so they can easily be edited to simulate parsing errors leading to incorrect sequences. Although this can be accomplished in several computer languages, the natural if-then structure and top-down organization of a Prolog data base make this language an appropriate vehicle for designing such a system. BACKGROUNDAND APPROACH The system to simulate errors in a DSP reported on here involves several interactive modules that input string representations of sequences and their relative frequencies and output a number of Prolog rules that generate the sequences stochastically.
"Oblog-2: A hybrid knowledge representation system for defeasible reasoningOblog-2 is a hybrid knowledge representation system comparable to Krypton and KL-TWO. It combines a terminological reasoner with a Prolog-like inference mechanism. The terminological component supports the description of type and attribute taxonomies.Gordon* German R.esearch Institute for Mathematics and Data Processing Pos tfach 1240 5205 Sankt Augustin 1 West Germany April 8, 1987 Oblog-2 is a hybrid knowledge representation system comparable lo Krypton and KL-TWO. It combines a terminological reasoner with a Prolog-like inference mechanism. The terming logical component supports the description of type and attribute taxonomies. From a franlr language perspective, attributes are similar to slots. Oblog rules are sets of Prolog-like definite clause procedures for compnting attribute values. Thus it is left open whether or not there are other sets of suflicient ronditions. Prolog's use of negation as failure, however, is c.orrect only for the conrp[elion of a Prolog program [4], which asserts the ""only if' halves of the definitions of predicates."
"Task-oriented parsing - a diagnostic method to be used adaptive systemsExisting methods for the representation of tasks in HCI are insufficient for this purpose as they do not support task-oriented parsing (i.e. analysing the input stream in terms of higher level task units). This paper presents a Prolog implementation of a task-oriented parser (+ generator) based on a grammar notation called LEXITAS.Existing methods for the representation of tasks in HCI are insufficient for this purpose as they do not support tusk-oriented parsing (i.e. analysing the input stream in terms of higher level task units). This paper presents a Prolog implementation of a task-oriented parser (+ generator) based on a grammar notation called LEXITAS. The technical details of the task representation will be further elaborated when the Prolog implementation of a ""task-oriented parser"" is describeld in the next section. -a Fig. 2: The modular structure of TOPIG TOP/G - A TASK-ORIENTED PARSER AND GENERATOR TOP/G is a task-oriented parser and generator realizing the principles described above. It is entirely written in Prolog, i.e. everything is represented as facts or rules in a Prolog database."
Development of a blackboard system for robot programmingThe blackboard architecture is a system architecture which provides a structured way of coordinating different sub-systems in such a way that they can work together to solve problems. A blackboard system was implemented in Prolog and it has been applied successfully for the automatic generation of control code for a robot to perform the task of block assembly in an environment with an obstacle.The blackboard architecture is a system architecture which provides a structured way of coordinating different sub-systems in such a way that they can WOIL together to solve problems. A blackboard system was implemented in Prolog and it has been applied successfully for the automatic generation of control code for a robot to perform the task of block assembly in an environment with an obstacle. On each level, the data are stored in units, and these units can be implemented az structures in Prolog. The number of sub-blackboards used must be defined by the application programmer. The generation of AML code is carried out by the Robot Task Translation Module ( Fig. 1 ). It is a Prolog program which provides a series of routines for converting the robot motion commands from Prolog into a program suitable for execution on an IBM 7565 robot, under the control of an IBM Series 1 computer.
Sherlock—a system for diagnosing power distribution ring network faultsThe system consists of a fault diagnosis subsystem implemented using Prolog and a user interface subsystem developed in the SmallTalk environment.The system consists of a fault diagnosis subsystem implemented using Prolog and a user interface subsystem developed in the SmallTalk environment. In any feeder circuit in the ring network, there are several feeders connected in series and is expressed by a Prolog term of the form u+...+v. Parallel feeders in the network are represented by multiple Prolog facts with each fact specifying one sequentially connected leg of the network. The legs in the arguments of the above network facts are in the form of Prolog terms and these terms are not evaluated by Prolog.
Computer-generated design of electric circuitsGiven the requirements of the circuit to be designed, a program using this approach can generate a set of candidate circuits, evaluate them according to the specified requirements, and recommend the most suitable circuit(s). A PROLOG program (called VMD) implementing this approach has been developed for the design of voltage multiplier circuits.Given the requirements of the circuit to be designed, a program using this approach can generate a set of candidate circuits, evaluate them according to the specified requirements, and recommend the most suitable circuit(s). A PROLOG program (called VMD) implementing this approach has been developed for the design of voltage multiplier circuits. COMPUTER-GENERATED DESIGN OF VOLTAGE MULTIPLIERS As a preliminary experiment to verify the basic ideas of the proposed approach, a PROLOG program called VMD (an acronym for Voltage Multiplier Designer) has been developed for the automated design of voltage multiplier circuits.
The network control assistant (NCA), a real-time prototype expert system for network managementThis system, called the Network Control Assistant (NCA), was mostly written in Prolog on an IBM PC/AT. The human interface for NCA consists of an efficiently designed hierarchy of color enhanced screens with user selected options.This system, called the Network Control Assistant (NCA), was mostly written in Prolog on an IBM PC/AT. The human interface for NCA consists of an efficiently designed hierarchy of color enhanced screens with user selected options. About 10,000 lines of Prolog code were designed and implemented for NCA in 4 months by 2 full time professionals and 1 halftime student. Prolog code for the example shown in Figure 3 is offered in Figure 4.
"GUMS: a general user modeling systemWe describe a prototype general user modeling system (hereafter called GUMS 1) which we have implemented in Prolog. This system satisfies some of the desirable characteristics we discuss.We describe a prototype general user modeling system (hereafter called GUMSI) which we have implemented in Prolog. This system satisfies some of'the "" desirable characteristics we discuss. That is, the failure to be able to prove a proposition is not taken as evidence that it is not tree. Many logic programming languages, such a prolog, encourage the interpretation of unprovability as logical negation. We believe that this Idnd of system will prove useful to a wide range of applications. We have Implemented an initial version in Prolog and are planning to use it to support the modeling needs of se,eral • pmjecls."
Project management expert system (abstract only)These project monitoring capabilities are realized using diagnostic and dealing heuristics. PROMX is implemented in ESP [4], which is a Prolog-based object-oriented programming language. Various kinds of knowledge in the project domain are represented using the object-oriented feature and the logic programming feature of ESP. The knowledge of the constituent relationships between the activities and the precedence constraints between the activities is represented in the form of a Prolog Horn clause. The knowledge of diagnostic heuristics and dealing heuristics is also represented as a Horn clause.These project monitoring capabilities are realized using diagnostic and dealing heuristics. PROMXis implemented in ESP [4], which is a Prolog-based object-oriented programming language. Various kinds of knowledge in the project domain are represented using the object-oriented feature and the logic programming feature of ESP. The knowledge of the constituent relationships between the activities and the precedence constraints between the activities is represented in the form of a Prolog Horn clause. The knowledge of diagnostic heuristics and dealing heuristics is also represented as a Horn clause.
"Constraint-driven generation of model structuresTwo knowledge representations, the system entity structure and the production rule formalism are incorporated into an automatic procedure for generating model configurations. The procedure is implemented in the Turbo Prolog environment. A simple case study based on a local area network (LAN) modelling problem is discussed to illustrate the conceptual framework.Two know ledge representations, the system entity structure and the production rule formal ism are incorporated into an automatic procedure for generating model configurations. The procedure is implemented in the Turbo Prolog environment. A simple case study based on a local area network (LAN) model I ing problem Is discussed to I I I ustrate the conceptual f ramewoi-k. The template rule syntax has the following form: if object-attribute-l = val ue-1 and/or object-attribute-2 = val ue-2 and/or ..I . . . object-attribute-n = vat ue-n then concl usiokl = value-l (cfl) and conclusion-2 = val ue-2 (cf2) and where cf 1 ,cf2,..., are certainty factors whose values range from 0 which stands for no recommendation, to 1 which denotes a strong recommendation. loferencoEnaineDesian The system's shel I has been implemented in Turbo Prolog and runs on IBM PC compatl ble machines. The inference engine uses the strategy of""generate and test"", I.e., it takes the initial data from the user and the hypothesis generated by the knowledge base to prune the search space tree."
Parallel execution of logic programs in the framework of OR-ForestAll the algorithms and schemes discussed in this paper have been implemented in PROLOG and their correctness and feasibility have been proved by testing a number of benchmark programs.All the algorithms and schemes discuessed in this paper have been implemented in PROLOG and their correctness and feasibility have been proved by testing a number of benchmark programs. Softwore Simulation and Preliminary Experirents All the algorithms and scheres designed in top levels have been specified in PROLOG [18,191. Based on this specification, we have developed a Simulation and Experiment System for Parallel Inference Machine (SES-PIM) on VAX-11/780 118,191. The whole system consists of about 8000 lines of PROLOG programs. The main purposes of developing SES-PIM are to verify our research results in the top levels and to develop a tool for studying parallel inference machines and parallel/concurrent logic programming languages.
Compilers and staging transformationsWe illustrate the techniques by deriving fragments of simple compilers from interpreters, including an example of Prolog compilation, but the techniques are applicable in a broad range of circumstances.Compitatlon of other languages Besides the simple functional language specified above, we have also developed a compiler for Prolog using the meta transformation approach. Prolog is of particular interest because of its unusual semantics and because of tim many opportunities it provides for optimization. DIKU Report 85/t, University of Copenhagen, 1985. Kahn, K. and M. Carlsson, The eornpgation of prolog programs without the use of a prolog corn° plier. Nillson, J. F., Formal viennadc.finition-.method models of prolog. In: Implementations of Prolog. Campbell, J..A. ed, Ellis Horwood, 1984 Paulson, L., A emanties..directed compiler ten.. orator.
Using object-orientation to implement logic programmingWe present an implementation of the logic programming language Prolog which uses object-orientation, and could therefore provide a basis for logic programming on object-oriented hardware.We present an implementation of the logic programming language Prolog which uses object-orientation, and could therefore provide a basis for logic programming on objectoriented hardware. The problem of implementing Prolog has this property, since the primary activity in executing a Prolog program is solving goals, which may be of many different types, such as user-defined, primitive, special purpose system goals, controls (such as cut), variables, or goals with variable predicate symbols. Persistents are not used here. 3.1 Representation of Prolog programs The input representation of a Prolog program for our implementation is a list of clauses represented in Lisp syntax, as in Microprolog [S].
Static evaluation of functional programsThis analysis leads to a revised notion of basic block, appropriate as an intermediate representation for a normal order functional language. An implementation of the analysis technique in Prolog is sketched, as well as an effort currently underway to apply the technique to the generation of optimized G-machine code.This analysis leads to a revised notion of basic block, appropriate as an intermediate representation for a normal order functional language. An implementation of the analysis technique in Prolog is sketched, as well as an effort currently underway to apply the technique to generation of optimized G-machine code. We show how to exploit coherence within conditional expressions (i.e. observing that in cond(p, t, e), we know p holds within L, and -p within e) to produce stronger strictness results. e. An implementation in Prolog is outlined for our strictness analysis method. That is, the accumulation of demand propagation constraints on a value in D is modeled by successive unifications on a Prolog term representing approximations to that value. f.
PARLOG: parallel programming in logicPARLOG is a logic programming language in the sense that nearly every definition and query can be read as a sentence of predicate logic. It differs from PROLOG in incorporating parallel modes of evaluation.KEITH CLARK AND STEVE GREGORY Imperial College, London PARLOG is a logic programming language in the sense that nearly every definition and query can be read as a sentence of predicate logic. It differs from PROLOG in incorporating parallel modes of evaluation. PARLOG also has many features in common with the languages Concurrent PROLOG (CP) [47] and Guarded Horn Clauses (GHC) [52], which are both derivatives of the Relational Language. The PARLOG mode declarations express constraints on the unification between call and clause head similar to the mode constraints of DEC-10 PROLOG [11.The difference is that in DEC-10 PROLOG the attempt to use a clause when a mode constraint is not satisfied is always considered an error.
"Optimizing existential datalog queriesThis, in effect, automatically captures some aspects of Prolog's cut operator that are appropriate to the bottom-up model of computation 2) We eliminate argument positions in recursive rules by ""pushing projections"" 3) We observe that ""pushing projections"" in rules also has the effect of making some rules (even recursive rules) redundant and try to (identify and) discard themI) Ravr Krrshnamurthg (g) The problem of pushmg proJections m recursive rules has received little attention The obJectwe of this paper is to motivate this problem and present some (partial) solutions We consider programs with function-free rules, also known as Datalog programa After formally defining existential subquenes, we present a syntactic cntenon for detectmg them and then consider optimization m three areas 1) We identify the existential subquenes and make them explicit by rewntmg the rules This, m effect, automatically captures some aspects of Prolog's cut operator that are appropriate to the bottom-up model of computation 2) We ehmmate argument positions m recursive rules by `pushing proJections"" 3) We observe that ""pushing proJections"" m rules also has the effect of makmg some rules (even recursive rules) redundant and try to (Identify and) discard them 1. Given some tuple m c , 1e some W such that c(W) holds, the set of tuples m q rs independent of the Then, we rewrite the rules using a simple transformatron whose only role II to make the exrstentral subquenes exphcrt by creatmg rules defining them Even rf no further optumration is possible, thus allows us to optimree at run trme by not computr mg multrple solutions when we are only Interested m the existence of some solutron Thus, m effect, captures some aspects of Prolog's cut operator that are appropriate to the bottom-up model of computatron (and rs automatrcally introduced by the compiler)t. whether there exrsts some tuple for e set of tuples m e Thus, in order to compute q, We call we need not compute c , beyond determmmg are ehminated, improvmg the performance of the The second phase consistrpof `pushing proJectron', m which some of the exrstentml argument posrtrons c(W) an czrstenkrl query (to be formally defined later) Further, suppose we are only mterested 111 values for the first argument of q Thus IS rmphclt rf the query 1sdefined by the followmg rule wvQ - q&Y) resultmg executron The thud phase in our approach cons&s of deletmg some rules from the adorned program at comprle time by takmg advantage of the exrstentml nature of subquenes (whrch is reflected m the In the termmology of relational algebra, the second argument of q 1s projected out in computmg the set of answers If we consrder the rule defining q , It 1s easy to see that not all values in the second argument of q are requued. Adorning Existential Propame The defimtion of an existential argument (and query) uses the notion of program equivalence Two IDBs, IDBl and IDB2 are said to be query cqurualcnt wrth respect to a query Q if for all states of the extensional database, EDB, the answer for Q IS the same for the two programs (Q,IDBl,EDB) and (QJDBOEDB) One of the objectives of this paper is to identify the notrons of exrstentml arguments and projec t Note that our oblechve differs from that motlvatmg Mendelzon's mtroductlon of cuts (usmg functIonal dependencres) mto Prolog programs [Mendehon 851 Whle both arm at ehmmatmg redundant computation, we are workmg mth a bottom-up execution model, wheress Mendelzon wss optlmrzmg Prolog's backtrackmg trons m 8s general terms as possible We now present 8 defimtlon of exrstentml arguments which seems to capture the intuitron Unfortunately, detectmg exrstential arguments under this defimtron turns out to be 8n undecidable problem."
A symmetrical approach to parsing and generationThe parsing and generation programs are seen as two dual non-left-recursive versions of the original grammar, and are implemented through a standard top-down Prolog interpreter. Formal criteria for termination are given as conditions on lexical entries: during parsing as well as during generation the processing of a lexical entry consumes some amount of a guide, the guide used for parsing is a list of words remaining to be analyzed, while the guide for generation is a list of the semantics of constituents waiting to be generated.The parsing and generation programs ale seen as two dual non-left-recursive versions of the original grammar, and are implemented through a standard top-down Prolog interpreter. Formal criteria for termination are given as conditions on lexical entries: during parsing as well as during generation the processing of a lexical entry constimes some amount of a guide, the guide used for parsing is a list of words remaining to be analyzed, while the guide for generation is a list of the semantics of constituents waiting to be generated. Several parsing techniques can be applied to this problem, we will be concerned here with a top-down parsing approach directly implementable through a standard Prolog interpreter. This approach relies on a lefi-reclr,sioll-climination trans/brmation for a certain class of definite clause programs (see section 33. Yasukawa, 1983. BUP: a bottom-up parser embedded in Prolog. New Generation Computing 1:2, 145-158. [PWS0] Pereira, Fernando C.
Conceptual graphs as a visual language for knowledge acquisition in architectural expert systemsThe EKSPRO expert system on PC/AT is based on a 3-D CAD system (Scribe modeller), linked to a solar irradiation calculation package (Sun Code), to PASCAL material and equipment data bases, and to a Prolog II based inference engine. It allows architects to revise office room shapes, materials, lighting sources, thermal control devices, window locations and sizes.Skafte Nielsen Electromagnetics Institute - Bldg. 348 Technical University of Denmark DK 2800 Lyngby, Denmark Passive solar energy/thermal control in office buildings The EKSPRO expert system on PC/AT is based on a 3-D CAD system (Scribe modeller), linked to a solar irradiation calculation package (Sun Code), to PASCAL material and equipment data bases, and to a Prolog 1/ based inference engine. It allows architects to revise office room shapes, materials, lighting sources, thermal control devices, window locations and sizes. This editor performs also syntax control, facilitates proper symbol alignment, and offers field to enter any of (i) - (iii) above. 3. Prolog knowledge base generation The visual language stores the conceptual graph and its attributes as facts in a Prolog fact base, through binary data base relation conversion.
The family of concurrent logic programming languagesIn addition, the paper reports on techniques for sequential and parallel implementation of languages in this family, mentions their applications to date, and relates these languages to the abstract logic programming model, to the programming language PROLOG, and to other concurrent computational models and programming languages.To copy otherwise, or to republish, requires a fee and/or specific permission. 0 1989 ACM 0360-0300/89/0900-0413 $00.75 CONTENTS INTRODUCTION 1. LOGIC PROGRAMMING, PROLOG, AND THE POWER OF THE LOGICAL VARIABLE 1.1 Syntax and Informal Semantics of Logic Programs 1.2 Examples of Logic Programs and Their Computations 1.3 Operational View of the Logical Variable Unification 1.4 Semantics of Logic Programs 1.5 PROLOG 2. CONCURRENT LOGIC PROGRAMMING 3.1 Language Comparison and 3.2 Semantics of Concurrent Logic Programming 3.3 Flat GHC: A Language with Nonatomic Unification 3.4 Flat PARLOG: FGHC Extended with Sequential-Or and Sequential-And 3.5 P-PROLOG,: Synchronizing Deterministic Logic Programs 3.6 ALPS: An Integration of P-PROLOG, FGHC 3.7 FCP( :): FCP( 1) Extended with Atomic Unification 3.8 FCP(?) It defines pure PROLOG and relates it to the logic programming model.
Languages for expert system building: a comparisonSix relatively standard high level languages are studied, which include FORTRAN, Modula-2, Ada**, Pascal, LISP and Prolog. Some of the newly developed expert system building languages are also studied.Six relatively standard high level languages are studied, which include FORTRAN, Modula-2, Ada*', Pascal, LISP and Prolog. Some of the newly developed expert system building languages are also studied. However, we found many cases in which expert systems were not written in LISP or were originally written in LISP and later translated to another language. Prolog is another popular symbolic processing language but it has not found great favor for expert system building. We examined six languages for use as an expert system building language. They were LISP, Prolog, FORTRAN, Pascal, Modula-2, and Ada. They were evaluated on 15 separate features, culminating in an informal rating.
The concept of a supercompilerIt is argued that the language Refal serves the needs of supercompilation best. Refal is formally defined and compared with Prolog and other languages. Examples are given of the operation of a Refal supercompiler implemented at CCNY on an IBM/370.It is argued that the language Refal serves the needs of supercompilation with Prolog and other languages. Examples best. Refal is formally defined and compared are given of the operation of a Refal supercompiler implemented at CCNY on an IBM/370. In many cases,a Prolog program will resemble the corresponding Refal program. In our view, however, Prolog is not at its best when used to define algorithms proper.
An expert systems based methodology for solving resource allocation problemsThese problems were solved well in few minutes of run time by Prolog-based systems that implemented the proposed paradigm.These problems were solved well in few minutes of run time by Prolog-based systems that implemented the proposed paradigm. The case studies are described in the paper, an overall evaluation of the methodology is given, and an outline of the Expert System Shell is presented. keywords: resource allocation, expert systems, scheduling, backtracking strategy, Prolog, rule-based systems. 1 Introduction Some version of the generic resource allocation problem exists in almost any organization. Also, its entire control strategy as well as its backtracking strategy is hard-coded in the Prolog (Parlog) program. Section 2 describes our methodology for solv ing resource allocation problems.
Recording the reasons for design decisionsThe example development has been represented in hypertext and as a Prolog database, the two representations being shown to complement each other.The example development has been represented in hypertext and as a Prolog database, the two representations being shown to complement each other. We have represented Liskov and Guttag's design process as a hypertext network and as a Prolog database. We discuss this experiment and the extensions needed to provide method-specific tools to represent deliberation and artifacts. Currently, however, Planetext does not have a Prolog interface, so changes to the network are not automatically reflected in the Prolog version.
Efficient tests for top-down termination of logical rulesConsidered is the question of whether top-down (Prolog-like) evaluation of a set of logical rules can be guaranteed to terminate.Considered is the question of whether top-down (Prolog-like) evaluation of a set of logical rules can be guaranteed to terminate. Definitions and Problem Statement We shall assume rules are Horn clausesin the Prolog style introduced in Example 1below. A logic program, or program for short, is simply a collection of such rules. The idea is to evaluate subgoals of a rule in a certain order, using bindings of early evaluations to limit the scope of later ones. Prolog accepts the order in which subgoals of a rule body are written, working on the subgoals in left-to-right order.
"An approach to natural language processing in the rule-based expert systemFinally, a way of transforming the symbolic expressions into PROLOG rules is introduced.After transforming the knowledge into the symbolic form, each symbol representing the same element of knowledge, e.g. the same word, appearing in many rules, will be stored only in one memory location, It is shown that on the basis of the presented form of knowledge, the computer can derive PROLOG-rules to make plausible inferences. Below, we shall briefly explain a method of solving the above mentioned problems. 2. A structure of the KB On the basis the proposed knowledge representation, the computer is able to derive the PROLOG rules. For instance, the PROLOGrule derived by computer for the rule 2 has the form f2* all V""12 (a >:-a 6(alta7>t a8(a,,ag) (12) 4."
"Decidability and expressiveness aspects of logic queriesThe containment and equivalence problems addressed here extend the work of Aho, Sagiv and Ullman on relational queries [1] and Papadimitrious on Prolog [10]. As corollaries we show that determining safety and literal redundancy are both undecidable problems.Israel 32~00 Ths paper addresses some basic problems regardmg logic pre grammmg based quer~s over relational databases We re-examme the query classes H and YE+ defined by Chandra and Hare1 [2] We define H+ and YE++ which &ffer from H and YE+ m that the use of equahty (=) and mequahty (#) IS prohibIted We show that, H+ IS more expressive than YE++ and that any H+ program can be transformed into an eqmvalent H+ program contammg a smgle recurs~e predicate wllhout usmg the equahty or mequality opera tors As a corollary we obtam a fixpomt formula characterlzatlon of H+ queries IVe consider the problems of determmrng contamment, equlxalence, and satrsfiablhty of logic based queries The contam ment and equl\alence problems addressed here extend the \\ork of Aho, Saglv and Ullman on relational queries [l] and Papachrmtnou on Prolog [lo] As corollaries we show that deternunmg safety and hteral redundancy are both undecrdable problems # Parts of the work were conducted at the IBM Thomas J Watson Research Center Yorktown Heights, NY 10598 Permlsslon to copy wthout fee all or part of this materm ISgrantedprovided that the copsesare not madeor dlstnbuted for dmxt commercmladvantage,the ACM copyrrght notice and the ode of the pubhcatlon and Ifs date appear, and notxe IS gwen that copymg ISby permwon of the Assouatlon for Computing Machmery To copy otherwse, or to repubhsh, requues a fee and/or specific permlsslon 0 1987 ACM 0-89791-223-3/87/ooO3/0237 759 1 INTRODUCTION Recently, there has been a growmg Interest m logic program ming based query languages and thez rela? xIJx2) If the MPCP mstance has a solution, this query returns an mfimte number of tuples whose List component contains terms of the form 7 CONCLUSIONS Chandra and Hare1 have defined two query classes, H and YE+, and proved that these classes are Identlcal [2] We have defined H+ and YE++ to be those classes with the exceptron that the use of equality (=) and inequality (#) 1sprohibited We have showed that H+ IS more expressive than YE++ Without usmg equality or mequahty we have shown that any query m H+ can be converted mto an equivalent one m which at most one predicate 1s recurslve As a corollary we obtamed a fixpomt query characterlza tlon of H+ queries We have proved that the problem of determmmg contamment or eqmvalence of logic queries IS recursively unsolvable Our con tainment and equivalence results extend to H Lihewiae, satlsfiablhty of logic queries contammg function symbols IS undecld able When function symbols are not allowed, satlsfiablhty 1sdecld- able The complexity of decldmg contamment or equnalence over YE++ quenes remams an open problem Another open problem 1s that of characterlemg the queries which can be expressed as a func tion of allowed predicate anty ACKNOWLEDGMENT I had stlmulatmg discussIons with K R Apt, C Been, A K Chandra, N Frances, A Itm, A Walker and R Y Pmter I would especially like to thank N France2 for readmg and commentmg on early versions of thrs paper I would hke to thank C Beer1 for pomtmg out the safety Corollary and an incorrect proof None of those mentIoned above 1sm any way responsible for the content of this paper PI Aho, A V, Y Saglv, and J D Ullman, ""Eqmvalence Among Relational Expressions,"" SIAM J Computing 8(2) 218-246, May 1979 PI Chandra, A K , and D Harel, ""Horn Clauses Queries and Generahzatlons"", J Logic Programming 1985 1 1 15 131 Harrison, M A, Introduction to Formal Language Theory (Addison-Wesley, 1978) 141 Jarke, M , J Clifford, and Y Vasslhou, ""An Optlmlzmg PROLOG FrontEnd to a Relational Query System"", m Proc ACM SIGMOD '84 Conference, 296-306, Boston, MA, June 1884 SIGMOD Record 14,2 151 [()I 171 PI PI WI Pll W4 [131 I141 (3) (4) (5) (6) klllllfllJl, S , and II lohot&,""l'lolog and Relatlonsl Databawzs fat Fifth Generstlon Computer Systems"", lrch Rep No 111002,ICOl', lohyo, Jzpan, October 1982 Lloyd, J W , Foundntwna of Logw Programnung (Sprmger-Vellag, 1'181) Mmker, J , ""An Experlmcnt 11Relatlonnl Data Base Sys-Len* B 15,ti on Logicn, 1"" 11 Gallure xnd J Mlnker (tda ), Logic and 1) \tl Bwz> (Plenum Press, New Yolk, 1978) Moschovah~~, k N , Elernenfory Induclton OR Abslract Sfructures, (North-Holland, 1974) Nlcolas, J hl and K Yazdaman, ""An outlme of BDGEN A Deductive DBMS', m Proc of IFIP congress 83 (North-Holland, 1983) Papadlmltrlou, C H , ""A Note On The Expresswe Power of Prolog"", m Bull&n EATCS, June 1985 Saglv, Y , ""Optlmlzmg Datalog Programs"", m Proc Sixth ACM SIGACT-SIGMODSIGART Symp on Prmclples of Database Systems, San Diego, CA, March 1987 Shmueh, 0, S Tsur, H Zfira and R Ever-Hadam, ""Dynamic Rule Support m Prolog"", m J V Woods (ed ), IFIP TC-10 Working Conference on Fifth Generation Computer Architecture, UMIST, Manchester, UK , July 1985 (North-Holland, to appear) Ullman, JD ,""Implementation of LogIcal Query Languages for Databases"", ACM Trans on Database Syst , 10,3, ?89-321, Sept 1985 Warren, D H D , Efficient Processing of Interactwe Relattonal Database Queries Expressed m Prolog, Prm 7'th VLDB Conl , Cannes, France (1981) 272-282 Appendrx EXAMPLE OF CONSTRUCTION Consider the followmg program P Pl(y,Y)+-P*(X,Y) P,w,w-P3w,y) p:(X,Y)+r*(X,Y) P,(X,Ykr."
A simple expert systemExpert systems are one field of artificial intelligence (AI) that has received considerable recent attention. These systems generally are written in Lisp or Prolog -- languages that are interpretive, have flexible data accessing mechanisms, and use powerful string manipulation tools.Expert systems are one field of artificial intelligence (AI) that has received considerable recent attention. These systems generally are written in Lisp or Prolog -- languages that are interpretive, have flexible data accessing mechanisms, and use powerful string manipulation tools.
"Knowledge-based assistant for colonscopyAn initial prototype has been implemented using a parallel architecture with transputers and a PC. The expert system is implemented in Prolog and it communicates with the feature extraction programs running in a ""transputer pyramid"" by transforming the vision features into symbolic predicates for logical inference.An initial prototype has been implemented using a pamlIe1 architecture with transputers and a PC. The expert system is implemented in Prolog and it communicates with the feature extraction programs running in a ""transputer pyramid"" by transforming the vision features into symbolic predicates for logical inference. Although we could use Prolog's search mechanism, rh 4 l l * `I Image ,,* `., Shared PC 1 . .. Jones, Expert Systems: Knowledge, Uncertainty and Decision, Chapman and Hall, 1988. P. Hammond, APES: a Prolog Expert System Shell, Department of Computing, Imperial College, London."
Version control in families of large programsThe configuration algorithm has been implemented in Prolog, and this prototype implementation has been used for some examples.The configuration algorithm has been implemented in Prolog, and this prototype implementation has been used for some examples. It would then be possible to build a program variant for debugging purposes: BUILD Main VERS = 1 :{Kind = BaseLine, Debug = Yes}, 5.5 Implementation using Prolog The configuration algorithm indicated in sect. 5.3 has been implemented in Prolog. A prototype of the configuration builder has been implemented in Prolog. The CONFIG parts are represented as Prolog lists and terms.
A two-tier memory architecture for high-performance multiprocessor systemsThe two tier memory system has been evaluated by analyzing the memory behavior of the simulated parallel execution of Prolog programs. Initial results indicate that the two tier memory system potentially reduces memory interference and speeds up synchronization.The two tier memory system has been evaluated by analyzing the memory behavior of the simulated parallel execution of Prolog programs. Initial results indicate that rhe two tier memory system potentially reduces memory intetference and speeds up synchronization. The reasons for selecting Prolog and the parallel execution model for Prolog are given in Section 4. Some examples are: Id [2,26], Common Lisp 1401, Prolog[B], and Concurrent Prolog[36]. 2.2. Intermediate Level All multiprocessor systems require some form of synchronization primitives to support mutual exclusion and communication protocols for parallel processes.
Software process enactment in OikosIn the paper, an example taken from a real project (the specification of a small language and the implementation of its compiler) shows how Oikos and ESP are effective for software process enactment. As it is, ESP embeds Prolog as its sequential component, and combines it smoothly to the blackboard approach to deal with concurrency and distribution.In the paper, an example taken from a real project (the specification of a small language and the implementation of its compiler) shows how Oikos and ESP are effective for software processenactment. As it is, ESP embeds Prolog as its sequential component, and combines it smoothly to the blackboard approach to deal with concurrency and distribution. In fact, ESP is an extension of the distribu.tcd logic language Shared Prolog 163,and as such it embeds Prolog as its sequential component. Shared Prolog itself has been implemented using a commercial Prolog compiler (BIM Prolog).
Cooperating knowledge-based assistants for the officeWe also describe an experimental system, written in PROLOG, that incorporates the above design principles.We also describe an experimental design principles. with a frame and rule-based knowledge representation system, written in PROLOG, that incorporates the above Categories and Subject Descriptors: C.2.4 [Computer-Communication Networks]: Distributed Systems-distributed applications,H.4 [Information 1.2.1 [Artificial Intelligence]: Applications Systems Applications]: Office Automation, and Expert Systems-office autonation General Terms: Design, Experimentation, Theory Additional Key Words and Phrases: Collaborative cooperating expert systems, distributed systems, computer-supported cooperative work, systems, expert systems, knowledge-based systems 1. Each frame is identified the frames are specified as shown by a unique name and consists of a set of slot descriptions, in which each description is a 3-tuple of slot name, facet name, and slot value. Slot values may be PROLOG strings, numbers, lists, or structures, for example, in Figure 5, the slot value of employee's ako slot is the string office-object, and the slot value of roger's that contains a single element, a PROLOG works-on slot is a list [ . . . ] structure project l-designengineer in dyadic operator form. We plan to use the proof path recording mechanism as the basis for an explanation facility. (The PROLOG code representing the salient features of the rule interpreter is provided in Appendix A.)
Matching, unification and complexityPattern matching and unification are two key primitive operations used in many inference based systems including theorem provers, term rewriting systems, computer algebra systems, deductive data bases, Prolog, logic programming systems, functional language systems, systems for analysis of specifications and program synthesis, and program verification systems.Matching, Unification and - A Preliminary Note - Complexity Deepak Kapur and Paliath Narendran Computer Science Branch General Electric Company Corporate Research and Development Schenectady, NY 12345 Pattern matching and unification are two key primitive operations used in many inference based systems including theorem provers, term rewriting systems, computer algebra systems, deductive data bases, Prolog, logic programming systems, functional language systems, systems for analysis of specifications and program synthesis, and program verification systems.
"A binding rule for Government-binding parsingThe fragment of the attribute grammar shown here is part of an English grammar and parser being developed in the Prolog and PLNLP languages.The fragment of the attribute grammar shown here is part of an English grammar and parser being developed in tile Prolog and PLNLP languages. Introduction Binding is a component subtheory of Governmentbinding which applies in the derivation of the logical form of utterances from their surface rcpresentation. Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, New York. Kuhns, Robert, 1986. ""A PROLOG Implementation of Government-binding Theory."" l'roceedings of the 1986 Annual Conference of the European Chapter of the Association for Computational Linguistics, Kuno, Susumu, 1987."
A frame-based approach to hardware verification (abstract only)Using the built-in preprocessor, the system will translate the register frame into the following Prolog clauses: reg(isa, value, primitive). reg(input, value, In). reg(output, value, Out). reg(state, value, S). reg(state, next, S1). reg(equal, reg(output, value, X), reg(state, value, X)). reg(equal,reg(state, next, X), reg(input, value, X)). Our system was built using our expert system shell PAIS-I which is written in Prolog and C and supports frame-based knowledge representation.Using the built-in preprocessor, the system will translate the register frame into the following Prolog clauses: reg(isa,value,primitiue). reg(input, value, In). reg(output,value,Out). reg(state, due, S). reg(state, nezt, Sl). reg(equal,reg(output,ualue,X),reg(stute,uulue,X)). reg(equal, reg(stute, nezt, X), reg(input, value, X)). Our system was built using our expert system shell PAIS-I which is written in Prolog and C and supports frame-based knowledge representation.
"BUILDRS: an implementation of DR theory and LFGThis paper examines a particular PROLOG implementation of Discourse Representation theory (DR theory) constructed at the University of Texas.BUILDRS: AN IMPLEMENTATION OF DR THEORY AND LFG Hajime Wada Nicholas Asher Department of Linguistics The University of Texas at Austin This paper examines a particular PROLOG implementation of Discourse Representation theory (DR theory) constructed at the University of Texas. Kamp (1985) ""Distributive and Collective Plurals"", Talk Presented at Universily of Texas Conference on Syntax and Semantics, March 1985. Frey, W., and U. Reyle, (1983) ""A PROLOG Implementation of Lexical Functional Grammar as a Base for a Natural Language Processing System."" in Proceedings of the First Meeting of the ACE Europe."
Actors as a special case of concurrent constraint (logic) programmingThis very impoverished concurrent constraint language is a syntactic subset of Janus, a concurrent constraint language which closely resembles concurrent logic programming languages such as Guarded Horn Clauses [21], Strand [5], Parlog [2] and Flat Concurrent Prolog [13]. By identifying the subset of Janus which is an actor language, we elucidate the relationship between actors and concurrent logic programming (and its generalization as concurrent constraint programming).This very impoverished concurrent constraint language is a syntactic subset of Janus, a concurrent constraint language which closely resembles concurrent logic programming languages such as Guarded Horn Clauses [al], Strand [5], Parlog [2] and Flat Concurrent Prolog [13]. By identifying the subset of Janus which is an actor language, we elucidate the relationship between actors and concurrent logic programming (and its generalization as concurrent constraint programming). Hand compilations of simple programs indicate that Janus will run faster than Prolog and Strand. We hope to obtain speeds comparable to C. Takeuchi. Object oriented programming in concurrent prolog. New Generation Computing, 1:25-48, 1983. Chris Tomlinson and Vineet Singh.
ASSYST - computer support for guideline sentencingIn a related paper, Sergot et al. [4] have discussed the formalization of the British Nationality Act in Prolog. In their article, Sergot et al. demonstrated how the language of the statute could be translated into definite Horn clauses which form the basic logic structure of Prolog's programming language.In a related paper, Sergot et al. [4] have discussedthe formalization of the British Nationality Act in Prolog. In their article, Sergot et al. demonstrated how the language of the statute could be translated into definite Horn clauses which form the basic logic structure of Prolog's programming language. Although the process of developing ASSYST helped to improve the coherency and consistency of guidelines, a more rigorous AI approach might have been employed. Using a more formal Al language such as PROLOG may have helped in uncovering some of the inconsistency. Further development may benefit by a shift to, or a combination of the menuing features already developed, supplemented by a PROLOG inference engine. A major factor in getting ASSYST off the drawing board and into end-users' computers is that ASSYST is not a full blown AI legal reasoning expert system.
"Anaphora resolution in slot grammarThese algorithms operate on the output of a Slot Grammar parser, and, like the parser, they run in Prolog. The VP anaphora algorithm implements an S-structure analysis of VP ellipsis that we argue provides a more unified and empirically motivated treatment of VP anaphora resolution than analyses that attempt to interpret elliptical VPs at a level of logical form.These algorithms operate on the output of a Slot Grammar parser, and, like the parser, they run in Prolog. The VP anaphora algorithm implements an S-structure analysis of VP ellipsis that we argue provides a more unified and empirically motivated treatment of VP anaphora resolution than analyses that attempt to interpret elliptical VPs at a level of logical form. The parser and the algorithms constituting the anaphora resolution component run in Prolog. In Section 2 we present a brief overview of Slot Grammar and the parser that implements it. McCord, M. C. (1987). ""Natural language processing in prolog."" In Compltational Linguistics Volume 16, Number 4, December 1990 Shalom Lappin and Michael McCord Knowledge Systems and Prolog: .4 Logical Approach to Expert Systems and Natural Language Processing, edited by A."
Moded type systems for logic programmingIn contrast, for reasons of efficiency, most logic programming languages are built around incomplete procedures. This difference is rooted in Prolog, which evaluates resolvent trees in a depth-first rather than a breadth-first order.In contrast, for reasons of efficiency, most logic programming languages are built around incomplete procedures. This difference is rooted in Prolog, which evaluates resolvent trees in a depth-first rather than a breadthfirst order. Mode annotations were first introduced to aid the Edinburgh Prolog compiler in producing more efficient object code [War7'7]. A number of languages designed as successors to Prolog, including Epilog [Por82] and Nu-Prolog [TZ86], have incorporated mode annotations.
Manhattanville College expert academic advisor—preliminary report (abstract only)We felt that the Arity Expert System Development Package c and Arity Prolog Compiler c provided a powerful shell to do the initial development as well as the flexibility to enhance the system by including code written directly in Prolog.We felt that the Arity Expert System Development Package c and Arity Prolog Compiler c provided a powerful shell to do the initial development as well as the flexibility to enhance the system by including code written directly in Prolog. l.Balkovich, E., Lerman, S., and Par-melee, R.P.
Concurrent algorithmic debuggingAlgorithmic Debugging is applied, in this work, to reactive systems, in particular to programs written in Flat Concurrent Prolog (FCP). Debugging reactive systems is known to be more difficult than the debugging of functional systems.Algorithmic Debugging is applied, in this work, to reactive systems, in particular to programs written in Flat Concurrent Prolog (FCP). Debugging reactive systems is known to be more difficult than the debugging of functional systems. The framework is defined in terms of a particular concurrent logic language, Flat Concurrent Prolog (FCP) [15]. FCP pro grams are also used as an experimental tool to check the validity and usefulness of the suggested framework. An implementation of the algorithm is described briefly, and examples of debugging sessions are provided. 4. FCP Flat Concurrent Prolog (FCP) is a concurrent logic programming language.
Quantifier scoping in the SRI core language engineBecause experimental data on human quantifier-scoping preferences are still fragmentary, we chose to design a system in which the set of preference rules could be easily modified and expanded.The algorithm described has been implemented in Prolog as part of a larger natural language processing system.The algorithm described has been implemented in Prolog as part of a larger natural language processing system. As qterms are collected, they are inserted into the store in inverse order of preferencc c.g., the qterm that has narrowest-scope preference appears at the front of the list representing the forest. In implementing this algorithm in Prolog, we found that it was considerably easier to generate the scopings by working from the narrowest to the widest scope, rather than rice versa.
Towards a compiler for a constraint languageFor this purpose, CONSAT was incorporated into the hybrid knowledge representation system BABYLON in order to use constraints together with rules, frames, and Prolog [Guesgen et al. 1987].For this purpose, CONSAT was incorporated into the hybrid knowledge representation system BABYLON in order to use constraints together with rules, frames, and Prolog [Guesgen et al. 1987]. *The author was previously working at the Gesellschaft fuer Mathematik und Datenverarbeitung, Schloss Birlinghoven, 5205 Sankt Augustin, F.R.G. This shows at least that more effort must be put into a Prolog program than into a CONSAT program in order to obtain an efficient modeling. 6 USERINTERFACE It is beyond the scope of this paper to discuss all aspects of CONSAT's user interface. CONSAT was incorporated into the hybrid knowledge representation system BABYLON in order to use constraints together with rules, frames, and Prolog [Guesgen et al. 1987]. In this environment, it is used in several applications, for example, in a system for process diagnosis [Voss 1988], where constraints are applied to maintain functional relationships in physical units.
Object oriented programming, tutorialThis order can usually be deduced by visual inspection of the program. A non-procedural program (written in PROLOG, for instance) contains a certain number of instructions that will not be executed in a predefined order. There are still people, for instance, that call Artificial Intelligence to any program that is written in Prolog or Lisp. In the same way, there are those who maintain that any program written in Smalltalk, C++ or Objective C is OOP.This order can usually be deduced by visual inspection of the program. A non-procedural program (written in PROLOG, for instance) contains a certain number of instructions that will not be executed in a predefined order. There are still people, for instance, that call Artificial Intelligence to any program that is written in Prolog or Lisp. In the same way, there are those who maintain that any program written in Smalltalk, C + + or Objective C is OOP.
Efficient generation of lexically proper palindromesThe method reported provides substantial pruning of a Prolog search tree by calculating the number of success nodes along certain search paths instead of visiting them, indexing words to improve database performance, and continuous analysis of current states to eliminate non-productive search paths.Efficiency measuresinvolve the storage and retriev 3 system developed to minimize the searchsace. tin e of the design goals of the project was to efficiently generate palindromes on a microcan uter. s The program was implemented using A&y Prolog version .O, and timed on an IBM AT clone, running at 1OmHz. with 512k of primary memory, PC-DOS 3.2, and a 20 megabyte ftTed disk. SearchMethod Imorovements: In general, the highest cost of generating palindromes derives from the characteristics of Prolog and its search tree mechanism. At the highest level, the palimimme generation process may be considered as a tree traversal.
"Pasta-3: a graphical direct manipulation interface for knowledge base management systemsThese tasks can be freely mixed, combined, and switched Pasta-3 interfaces to the KB2 knowledge base system, implemented in Prolog and built over the EDUCE system which provides a tight coupling to a relational DBMS KB2 uses the Entity-Relationship data model, extended with inheritance and deduction rules. Queries can be recursive and involve logical variables, quantification, and subqueries. Expressions mixing both KB2 statements and Prolog predicates can also be formulated. The video shows Pasta-3 actually being used, in real time and under normal conditions.Pasta-3:A Graphical Direct Manipulation Interface for KnowledgeBaseManagementSystems Mlchel Kuntz ECRC, Arabellastmsse17,800OMumch 81, WestGermany Phone (89) 926 99 125 emal kuntz%ecrcde@pyramldcorn Pasta-31san end-userinterface for D/KBMSs basedon the graphlcal Dwect Mampulatlon (DM) mteractlon paradigm, which rehes on a bit-mapped, multi-wmdow screen and a mouse to unplement chckable icons as the main representattonof information This style of mteraction enables end users to learn quickly and remember easily how the systemworks Pasta-3gives complete access to the D/KBMS, smce its users can carry out all mampulatlon tasks through it schemadefmmon, schema and databrowsing, query formulanon, and updatmg These tasks can be freely mixed, combmed, and swltched Pasta-3interfaces to the KB2 knowledge basesystem,lmplemented m Prolog and built over the EDUCE system which provides a tight couplmg to a relauonal DBMS KB2 uses the Entity-RelationshIp data model, extended with mherltanceand deduction rules KB2 was developed by the KB Group at ECRC Pasta-3usesDirect Mampulatton m the strong senseof the term DM of the actual graphical representauonsof the application data and not Just DM of commandsoperatmg on that data Besidesthe high degreeof mtegratlon m the overall design, major mnovations with respect to earher work include enhanced schema browsing with active functlonalmes to facilitate correct userunderstandmgof the KB structure, ""synchronized"" data browsing that exploits the underlymg semantic data model to make browsmg more powerful, and a graphical query languageprovldmg full expressive power (mcludmg certam recursive queries, nestedsubqueries,quanuflcauon) Pasta-3provides interactive design support that hasslgmflcant ergonomic advantagesover the usual approachto this problem In Pasta-3different types of schemamformanon -- the basic E-R diagram, the mhentance lattices, the propertiesof eachE-R item -- aredisplayedm separate windows, which makes accurate reading of such mformatlon much less &fficult than m the usual casewhere all these layers are thrown together m a single graph, which makesmlsmterpretationhard to avold For schemaand data browsmg, Pasta-3offers faclhtles that bmld more semantics into the browsing processes One type of schemabrowsmg tool 1sa subgraphcomputation capability which automatically finds and displays the paths that connect arbntrary E-R Items This helps end users to correctly perceive the schema structure Data browsing mcludes""synchromsed""browsmg,a functlonahty which showssimultaneously data from several Enhhes all sharmg the sameRelationship and mdlcates which values from eachEnhty are associatedwith given values from the others Pasta-3'sDM query language replacesthe textual language without loss of expressive power it offers a new, sophlstlcated DM edmng capablhty for the same formal constructs Query specification takes place m a window contammgicons representmgthe componentsof the query expression which c?"
Optimizing datalog programsDatalog programs, i.e., Prolog programs without function symbols, are considered It is assumed that a variable appearing in the head of a rule must also appear in the body of the rule.OPTIMIZING DATALOG PROGRAMS (Extended Abstract) Yehoshua Sagrv Department of Computer Science Hebrew Umverslty Chat Ram 91904 Jerusalem, Israel Dstalog programs, 1e, Prolog programs without function symbols, are considered It 1s assumed that a varrable appearing in the head of a rule must also appear m the body of the rule The input of a program 1s a set of ground atoms (which are given m addition to the program's rules) and, therefore, can be viewed as an assignment of relations to some of the program's predicates Two programs are equivalent d they produce the same result for all possible assignments of ~elatlons to the extensional predicates ( the predicates that do not appear arsebeads of rules) Two programs are uniformly cqulvalent if they produce the \run(~ rc+ult for all possible assignments of nntlcll rclatlons to all the predicates (1 e , both extensional and mtentlonal) The eqmvalence problem for Datalog programs 1s known to be undecidable It 1s shown that uniform equivalence IS decidable, and an slgorlthm 1s given for mmrmrzmg a Datalog This work was done while the author WBS vlsltmg Stanford Umverslty and was supported by a grant of AT&T Foundation, a grant of IBM Corp , and an NSF grant IST-84-12791 program under umform equivalence A technique for removing parts of a program that are redundant under equivalence (but not under uniform equivalence) 1sdeveloped A procedure for testing uniform equrvalence 1s also developed for the case m which the database satisfies some constrzunts I. \ ttw Init I,11 OIIC our algorithm determines that the atom A(w, y) IS redundant and, consequently, the rule can be replaced with G(~,Y,~-+,w, 4, +-v), Ah4, 42,Y) To fully appreciate the Impol tance of the algorithm, one should reahze that optlmlzatlon under uniform equivalence 1s the only on(' thProlog programs, but has not given any algorithm for testing uniform eqluvalcrice or ~imliiumig under uniform c*qluv alence Naughton [1986] hC~lstlevelopt>tl n method for optmuzmg Dntdog progl cun'r 1)~ moving atoms from a lecurblve rule to nonrecursive rules (the method may create new nonrecurslve rules) This method applies to linear rules II.
Application of a self tuner using fuzzy control techniqueThe inference engine used is the backward chaining process of the Prolog language. To implement the self-tuning property, the membership curve of the controller output has been changed according to an error based performance index.The inference engine used is the backward chaining process of the Prolog language. To implement the self-tuning property, the membership curve of the controller output has been changed according to an error based performance index.
"Abstracting controlFor example, two conversions yield an abstraction of Prolog-style backtracking. A number of other constructs can likewise be expressed in this framework, each is defined independently of the others, but all are arranged in a hierarchy making any interactions between them explicit.This ensures an automatic consistency between the two methods of language definition. 3 An Application: Nondeterministic Programming It is well-known that continuation passing-style can be used to simulate backtracking in, e.g., Prolog programs [Mellish & Hardy 841. In this""downward success"" model of nondeterministic execution, alternatives at choice points are considered in sequence. Sometimes, however, we want to collect all the results in a list (cf. the begof predicate found in many Prolog systems). A possible way to obtain this would be to update a list of solutions imperatively. Mazurkiewicz: Proving Algo rithms by Tail Functions, Information and Control Vol. 18 pp 220-226 (1971) [Mellish & Hardy 841 Ch ris Mellish, Steve Hardy: Integrat ing Prolog in the POPLOG Environment, in Implementations of PROLOG, John A."
An undergraduate curriculum in expert systems design or knowledge engineeringWe purchased copies of Golden Common Lisp and Turbo Prolog as well as using an Altos with Xenix and C to get us started. We have developed a course that concentrates on Lisp and then follow it with a course in Prolog. I would like to have added several other of the artificial intelligence languages including Ops5, and Flavors but decided to wait until we obtained the artificial intelligence workstations in order to keep our software costs down to manageable levels. It was clear from the industry experts that we talked to that in many cases the expert systems are rewritten in C after first being developed in either Lisp or Prolog. Having built a reasonably firm foundation, the students are then moved into the Expert systems design course where they undertake more ambitious projects of their own under directed supervision.We have developed a course that concentrates on Lisp and then follow it with a course in Prolog. I would like to have added several other of the artificial intelligence languages including Ops5, and Flavors but decided to wait until we obtained the artificial intelligence workstations in order to keep our software costs down to manageable levels. A constant theme running through these courses is the concept that there is no one problem solving technique but rather that each type of problem specialised iiowledge is needed and in addition we need to have rules of thumb or heuristics to guide us when more than one option is available. In the Prolog course students begin working with developing several systems. small expert We build a diagnostic system using the bicycle repair one as a model. It was clear from the industry experts that we talked to that in many cases the expert systems are rewritten in C after first being developed in either Lisp or Prolog. Having built a reasonably firm foundation, the students are then moved into the Expert systems design course where they undertake more ambitious projects of their own under directed supervision.
Memory allocation and higher-order functionsIt has been seen to reduce the 80% garbage collection overhead to less than 5% on average.The algorithm has been built into a virtual machine to efficiently implement at the assembly level the Actor language PLASMA, an Actor-oriented version of PROLOG and a variant of SCHEME, currently in use on 8086, 68000 and Vax.The rationale to use the heap memory is that continuations are available via a single pointer in a unified memory and can be shared optimally when recurrently captured, which is simply impossible using a strategy based on stack recopy.The algorithm has been built into a virtual machine to efficiently implement at the assembly level the Actor language PLASMA, an Actor-oriented version of PROLOG and a variant of SCHEME, currently in use on 8086 , 68000 and Vax .
A parallel inference engine (PIE) (abstract only)It uses the inherent generic structure of ADA to help implement many features that would be difficult in languages such as Lisp and Prolog. Using the tasking structure in ADA and the ADA rendezvous, the problem of distributing knowledge over multiple bases is accomplished.t would be difficult in languages such as Lisp and Prolog. Using the tasking structure in ADA and the ADA rendezvous , the problem of distributing knowledge over multiple bases is accomplished.
Generating a requirements specifications knowledge-baseThe second phase converts this structured parse into a set of Prolog-based facts and rules that encapsulate the knowledge within the initial document.The second phase converts this structured parse into a set of Prolog-based facts and rules that encapsulate the knowledge within the initial document.
Expert systems in insurance underwriting: model development and applicationRuleMaster is a modular system as opposed to the inference network approach used in M1, which more closely resembles LISP or PROLOG in structure. With the modular structure, knowledge and rule base building and modifications proved much easier from a programming standpoint.RuleMaster is a modular system as opposed to the inference network approach used in Ml, which more closely resembles LISP or PROLOG in structure. With the modular structure, knowledge and rule base building and modifications proved much easier from a programming standpoint. While artificial intelligence languages such as LISP or PROLOG have been used in many instances for expert system creation, they require dedicated computer systems and specialized programmrng skills.
Object oriented performance models with knowledge-based diagnosticsObject oriented languages allow hierarchical and graphical definition of system architecture, and languages such as PROLOG facilitate the development of knowledge-based systems. We will show how the combination of an object oriented language (Smalltalk) and PROLOG can be used to develop a tool containing hierarchical system description, graphical system entry, performance prediction algorithms, and knowledge-based diagnostic capabilities at an order of magnitude reduction in development costs over standard high order languages such as PASCAL.
Making abduction more efficientThe TACITUS system uses a cost-based abduction scheme for finding and choosing among possible interpretations for natural language texts. Ordinary Prolog-style, backchaining deduction is augmented with the capability of making assumptions and of factoring two goal literals that are unifiable (see Hobbs et al., 1988).
On expert database systems (abstract)For example, the basic relational algebra operations union, intersection, join, selection, projection and hence relational DML can be implemented in PROLOG ([2]). Unfortunately, other aspects of a DBMS, like DDL, concurrency, sophisticated indexing, security, data integrity and query optimization are very difficult to implement in a logic programming environment like PROLOG.
A unification processor based on a uniformly structured cellular hardwareIn this paper, an implementation of unification using a systolic-like method is presented for a VLSI-oriented Prolog machine. Not pointers but a line of symbols and the arity of each symbol are used to express the structure of terms on a uniformly structured cellular hardware.
Intelligent information retrieval with proto-GnosisThis paper describes first experiences with the language proto-GNOSIS, a hybrid of MUMPS and PROLOG. The objective of the GNOSIS project is to create a GNOSIS shell, specified as a superset of X/OPEN capabilities.
An expert autonomous vacuum cleaner robotThis paper describes the design of a Prolog-based expert system for real-time control of an autonomous vacuum cleaner robot.
"Facilitating process prototyping by controlling the impact of changeOther researchers have implemented and used tools and techniques for controlling the impact of change in prototyping situations. Examples include innumerable users of LISP or PROLOG, as well as such software engineering efforts as GANDALF [3], Infuse [4], the Cornell Synthesizer Generator [5], ""smart recompilation"" [8] and others.Other researchers have implemented and used tools and techniques for controlling the impact of change in prototyping situat,ions. Examples include innumerable users of LISP or PROLOG, as well as such software engineering efforts as GANDALF [3], Infuse [4], the Cornell Synthesizer Generator 1% ""smart recompilation"" [8] and others."
The qualitative problem solving system PHYSYSSince the system can not solve differential equations it generates only qualitative predictions. We chose Prolog as the implementation language primarily because of its inherent ability to do backward chaining and its promise of shortened development time for such problems. A prototype version of PHYSYS has been implemented in Turbo Prolog.
An interactive test sequence generatorA logic specification is a collection of Horn clauses coded in Prolog describing the externally observable behaviour of a system.
EXAPL (Expert System Based on APL) and its application to chemical analysisConsequently, the system nucleus is quite small in contrast with that of LISP or PROLOG. EXAPL is shown to be potent and practical in application to a chemical analytical data system, ARTHUR, and our plans to develop further a simple APL-based version, EASYARTHUR, for use by novices, are outlined.
Extensions to functional programming in SchemeThese features bring us closer to executable specifications of programs and are therefore relevant for automatic program generation. We discuss extensions to Prolog-style languages that might enable them to approximate the same expressive power.
Feature logic with disjunctive unificationContext-unique feature descriptions can be easily implemented in environments that support ordinary unification (such as PROLOG).
Rule based programming in CMuch of the functionality of an 'OPS--like' language, and all of the features of a Prolog-like language can be generated in this manner.
"A grammar rule notation translatorThe output of the translator is a Prolog program that should run on most Prologs (the output is not designed to be run on Turbo Prolog or any Prolog requiring type declarations). The Turbo code (see Listing) for the translator is easily converted to other Prologs. The Grammar Rule Notation I refer the reader to Clocksin and Mellish [i] for a complete explanation of the Grammar Rule Notation. After each rule, comments describe the features being demonstrated. determiner --> [the]. determiner --> [""a""]. fruit --> [a + banana]. fruit --> [a] + [banana]. /*Literals, as in C&M*/ /*Some Prologs use strings*/ /*Use of the '+' separator*/ /*Identical to rule above*/ sentence : singular --> noun_phrase : singular + verb : singular."
Parlog86 and the dining logiciansThis misconception stems from a confusion between the two. Prolog is a manifestation of logic programming, not the embodiment of it. As Prolog is better known than its theoretical foundation, logic programming, it is more appropriate to introduce Parlog from Prolog than from their common parent. In Concurrent Prolog the logic variable is almost reinstated to its glory in Prolog by the use of multiple environment orparallelism (the approach taken by parallel Prologs).
Objects in concurrent logic programming languagesBobrow Knowledge Systems Area Intelligent System Laboratory Xerox Palo Alto Research Center Concurrent Prolog supports object-oriented programming with a clean semantics and additional programming constructs such as incomplete messages, unification, direct broadcasting, and concurrency synchronization [Shapiro 1983al. Most of the ideas presented apply equally well to other concurrent logic programming languages. Concurrent Prolog As in Prolog, a program in Concurrent Prolog is a collection of Horn clauses. Correct CP implementations are sound but incomplete theorem provers (as are conventional Prologs). An implementation of CP can be based upon fine-grained parallelism.
Computerizing a machine readable dictionaryLABEL) or a mini transition network (e.g. CONJUGATIONS). Prologizing the dictionary The parser's prim ary purpose is to convert the relative Tree-form MRD into a structured computerized dictionary, which can be used by natural language processing applications. A similar approach has been adopted in this project, except that Prolog was chosen as a target language. A Prolog program consists of facts and rules, the latter being Horn clauses with a single consequent followed by a list of antecedents. Some of the information in the MRD is turned into Prolog rules, primarily to avoid duplicating unnecessary information.
A bottom-up generation for principle-based grammars using constraint propagationThis paper describes the solution to these problems and the issues concerning implementation of the algorithm using a constraint logic programming language, cu-PROLOG. First, the problems of bottom-up generation are shown. This gives it more de:,criptive power and more deelarativeness than norreal prologs. The clause of cu-PROLOG is represented as, p,r(cat(P, F, [], [], Sc, Sere), h ,--- bl,b2,... The author also wishes to express his indebtness to Tuda ttirosi, and Hasida Koiti of ICOT for permitting him to use the cu-PROLOG. Thanks are also due to Dr. Terashima, Mr. Sakama, Mr. tfigashida, Mr.
The concurrent logic programming language CP: Definition and operational semanticsTo a 6rst approximation, the sequential analogue of these languages + a Prolog in which every clause has a cut. In this paper we present the notion of (parallel) don't know commit(`&`), which simulates non-determinism by parallelism. For instance, FCP(&) is the language of pure Horn clauses (purely declarative-no control over the search), CP(J, I) is (a cleaned-up version of) Concurrent PrologS, CP(&&, , , , , ) (without AND- and OR-paraUelism) is the well-known programming language Prolog, CP(&&, I, , , , , ) (without AND-and OR-parallelism) is Prolog with cut and CP(l, I,&, ,] supports the paradigm of coneutrent, controllable constraint eystems. In (121 Lev i and Paltiidessi present a formal treatment for a communication primitive related to Concurrent Prolog's `1'. In [3], Beckmann attempts to give a semantics for Concurrent Prolog via a translation to CCS.
"Implementing a graph-colouring algorithm in ParlogThey have tended to suffer though, from being seen as ""parallel Prologs"", and thus considered suitable mainly for those applications where Prolog has been found particularly suitable. Conf. on Fifth Generation Computer Systems, Tokyo, ppA58-471. [Shapiro 86]. E.Shapiro. Concurrent Prolog: a progress report. IEEE Computer, 19, 8 pp.44-58. E.Shapiro and A.Takeuchi. Object oriented programming in Concurrent Prolog. New Generation Computing 1, 1 pp.25-48. [Wood 69]."
An algorithm for generating quantifier scopingsShieber An Algorithmfor GeneratingQuantifierScopings APPENDIXA. PROLOG IMPLEMENTATION OF THE ALGORITHM The following is the core of a Prolog implementation of the nondeterministic algorithm which includes all but the lowest level of routines. The syntax is that of Edinburgh Prologs, e.g., DEC-20 Prolog. Prolog Implementation of Scope Generation Algorithm / • . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A constant term is represented is represented as the Prolog term is the encoding of the by the homonymous Prolog constant.
ARMS: arbitrary robot modelling system (abstract only)The differential speed control matrix tells how fast each joint must move so that all the joints start and stop moving at the same time. An expert system approach was used in a PROLOG prototype of the system. However, developing the prototype resulted in an algorithm for the process.
Resourceful systems for fault tolerance, reliability, and safetyCategories and Subject Descriptors: rich architecture and an explicit goal D.2.m [Software Engineering]: Miscellaneoussoftware fault tolerance General Terms: Fault Tolerance, Software Fault Tolerance, Reliability, Software Reliability, Safety, Software Safety Additional Key Words and Phrases: Logic programming, object-oriented programming, planning, N-version programming, prolog, recovery blocks, resourceful systems 1. BACKGROUND ISSUES System failures can have costly and sometimes disastrous consequences. For a complete explanation of logic programming and Prolog, consult, for example, Sterling [19861. One can pull oneself up one level and develop a general RB framework in Prolog. The predicate findall/3, used in nvp/3, is built into most Prologs. It backtracks through all executions of the term given as its second parameter.
Display development system: a successful Ada application., inputs, outputs) are documented in a commentary prolog with no guarantee that the actual code implementation matches the documentation. The compiler ensures that the specification parameters match those in the package body. In DDS the package prologs were quite small and code reviews accepted the package specification as sufficient documentation for interface definition. Figure 4 contains an example of a DDS package prolog. The actual specification is shown in Figure 9.
A deductive database architecture based on partial evaluationSystems having such features are called Knowledge Base Management Systems (KBMS). Using logic programming (Prolog-like languages) as an implementation tool seems a promising way for realizing such systems /KUNI-82/. However, to be efficient, these systems need to use sophisticated techniques such as parallelism between processors /CERI-85/, syntactic and semantic query simplifications from Prolog to data manipulation languages IVASS-841JARK-841 or logic programs' compiling in order to minimize data flow between Prolog and DBMS. To cope with such a technique, a control of Prolog's inference process is needed and can be achieved by using metaprogramming/KOWA-79/.
Abstracts of current literatureliterature give intuitively incorrect answers when applied to ABSTRACTS OF CURRENTLITERATURE The following research reports are available on request from: Advanced Computational Methods Center Computer Services Annex Building University of Georgia Athens, Georgia 30602 NEW REPORTS AND MEMOS 01-0004 A Programming Solution to Certain Problems with Loops in Prolog Nute, D. 01-0006 A Further Note on Looping in Prolog Covington, M. 01-0007 A Non-Monotonic Logic Based on Conditional Logic Nute, D. 01-0009 Could Non-monotonic Inference Ever Be Deductively Valid? Rankin, T. 214 Representing transitive relations in the obvious way in Prolog results in unwanted loops. A programming solution to this problem is provided and limitations and possible extension of this solution to other looping problems is discussed. In an earlier paper (01-0001) I proposed that looping in Prolog should be prevented by blocking all derivations in which the current goal matches a higher goal.
"New directions in logic programming., Bowen Logic Programming Research Group School of Computer & Information Science Syracuse University Syracuse, NY, 13210 USA CSNET: kabowensyr Abstract Prolog has established itself as a highly successful example of the logic programming paradigm. Today there are a number of vigorous research streams exploring methods of extending the capabilities and capacities achieved by Prolog. These include treatment of concurrency, inclusion of functional programming capabilities, and incorporation of metalevel reasoning techniques. The basic methodology lies in the adaptation of theorem-provers for logical systems to create abstract machines which ""execute"" formulas of the logical system. Prolog is a highly successful example of this approach."
Strategies for deductive databasesWe will discuss how PROLOG can be used to achieve a homogeneous system. PROLOG is a powerful programming language based on logic, specifically on theorem proving unification and resolution operations. In this section, we will look at PROLOG only from a deductive database point of view. Most of the oilier features of PROLOG can be found in [12]. The use of PROLOG in achieving a homogeneous deductive DBMS can be pursued in two levels [19,20]: (i) improving PROLOG with a belter data management and (ii) enhancing PROLOG with DBMS facilities.
A coment on “A hardware unification unit: design and analysis,”But consider the - There are versions of the C Prolog interpreter (l.5a.edai and later) which attain 2k LIPS on a VAX 780. I no longer have a version of UNSW Prolog to run benchmarks on, but my understanding is that it is about twice as slow. UNSW Prolog and C Prolog are both coded in C. - The general unifier in C Prolog takes roughly 20% of the total time (according to the UNIX profiler).
Book review: The Elements of Artificial Intelligence An Introduction Using LISP by Steven L. Tanimoto (Computer Science Press)While the book title does not mention it, the book also features a discussion of Prolog, including a Prolog in LISP interpretor and explanations with implementations of the Prolog unification algorithms. Wi{h a solid Prolog book as companion, such as I. 8ratko's Prolog and AI text, this book gives a sound programming introduction to the major areas of AI. The focus is on representing the parsing problem in Prolog, and the chapter illustrates rather than explains Prolog programming.
Generators and the replicator control structure in the parallel environment of ALLOYWhile full backtracking is very powerful, it is often inefficient [SDDS86], as are full continuations. In Prolog, a language where side effects are severely restricted', backtracking is efficient. As with Ultra Prolog [Mit88a] there is a lot of research on the identification of language subsets which can have full or-parallelism. SIGPLAN Conference on Lisp programming, pages 9-16, 1984. Seif Haridi and Per Brand. Andorra Prolog-an integration of prolog and commited chaise languages.
"An application of knowledge-base technology in education: a geometry theorem proverOn the other hand, the development of computer based logic programming languages, such as Prolog, makes an experimental environment for geometry worthy of exploration. This paper describes our attempt to organize the contents of a whole high school geometry book as a ""knowledge base"" and to implement it in Prolog. Section 2 states the special requirements that one has to obey when implementing such a system for a high school environment and compares our attempt with related work. The availability of an implementation of Prolog for our target machines (micro-PROLOG) completes the argument to choose Prolog for the basis of our implementation."
"Book review: Automatic Natural Language Parsing. Edited by Karen Sparck Jones and Yorick Wilks (Ellis Horwood and John Wiley and Sons 1983)A sketch of selected papers follows. Colmerauer's ""Theoretical Model of Prolog 11"" starts off the collection. Although he covers the same ground elsewhere, notably in Prolog II Manual and Theoretical Model and in a paper from the Clark-Tarnlund volume, Colmerauer provides an extract worth reading. The rest of the paper clarifies key notions such as ""assertion,"" emphasizing throughout a way of looking at Prolog. The paper is inferreal, with examples rather than proofs, clear and even witty, it makes a good introduction to Prolog II. The first is Shapiro's ""Systems Programming in Concurrent Prolog,"" the second Suzuki's ""Experience with Specification and Verification of a Complex Computer Using Concurrent Prolog."""
"The purpose and promise of logic programmingFurthermore, Prolog contains several non-logical constructs (out of implementational necessity). Thus Prolog is a compromise between a ""contraption"" language and a ""logic programming"" language. The advantages of thinking and writing directly about the problem are apparent to Prolog programmers. Prolog programs consist of what are often called ""facts"" and ""rules."""
AquariusWe are currently focusing on an experimental multiprocessor architecture (Aquarius II) for the high performance execution of Prolog that will contain 12 processors specialized for Prolog and others for a total of 16 processors. 1.2. We have written large application programs in Prolog specifically design tools to aid in construction of our experimental engines. 1.4. In section 2, we discuss our current efforts in the completion of a VLSI single chip Prolog processor. In section 3, we describe the extension of that chip to handle parallel processing of Prolog by replication of the basic Prolog processor.
Coming to grips with a RISC: a report of the progress of the LOW RISC design groupEvolution of the LOW RISC Architecture The SLP '86 LOW RISC was a minimal pure Prolog machine, depending heavily on a host processor for arithmetic and operating system support. Fruitful discussions were held with Kevin Buettner, the author of the ALS Prolog compiler. The first outcome was a method to provide hardware support for garbage collection at the cost of a dedicated bit that could be used either as a mark or reverse bit. Expressing this procedure in Prolog is not difficult. The desigr hides the real-time activity from the Prolog programmer.
Nondeterminism and unification in LogScheme: integrating logic and functional programmingUsing these primitives, we can write programs in the style of Scheme, Icon, Prolog, or any mixture thereof. We have found that a style of programming that uses both logical and functional techniques can be more powerful than the use of either technique alone. To copy otherwise, or to republish, requires a fee and /or specific permission. 0 1989 ACM O-89791-328-0/89/0009/0327 $1.50 94305-4070 power beyond that provided by Prolog and other systems that do not allow logic variables to be denoted by identifiers outside of the scope of a single clause. In subsections 3 and 4 we investigate the merge of Scheme and Prolog, then show how relations can be abstracted. 3.1 Pure Prolog Consider the Prolog relation append.
"Search direction by goal failure in goal-oriented programmingThe language to be described in this paper is goal directed in the defined sense, whereas PROLOG and the PLANNER-type is, their search procedures are initially languages are only partially so. `The ""standard version"" of PROLOG Mellish [Z]. is usually regarded as that described by Clocksin and A PROLOG program is ""run"" by giving it a problem to be solved in the form of one or more queries or goals to be tested, as, for example, ? Recent efforts to improve PROLOG's compilers rather than interpreters is discussed in more detail in Section of standard PROLOG and with that software and hardware, such as writing and building superfast PROLOG machines to enable PROLOG to perform ever more ""logical inferences per second,"" also do not make the language any more goal directed, sequential computers does not eliminate just as building ever faster the ""von Neumann bottleneck"" inherent in sequential machines."
"A logic programming approach to frame-based language designIn this paper, we will propose a logic programming approach to design a frame-based language. The relationship among frame, logic and Prolog is our basic design issue. Frame is considered as a collection of slot-relations, and frame reference/inference procedure can be specified in logic form. Prolog is used to represent all of these concepts. Frame is encoded with Prolog facts and rules. Because ""predicate logic as a programming language"" is the basic idea behind Prolog fsl, Prolog inherits many interesting features from logic fi4t."
SLD: a folk acronym?For example, in most logic programming text books [e.g. Bratko 1986, preface] the acronym PROLOG is said to stand for Programming in Logic. This is said to come from the French, Programation en Logique [Kowalski, 1988]. It is interesting to note, though not directly relevant to this present discussion, that Prolog was not the first implementation of Logic programming, Absys was [Elcock 1988]. A slightly less trivial example is the choice of the word atom for non-numeric constants in Prolog. The word atom had a well-defined meaning in logic before its use in Prolog.
Knowledge based systems and Ada: an overview of the issuesLogi c programming gained acceptance as a popular AI technique since the introduction of PROLOG and it s selection as language of choice by japan Fifth Generation Computers Project . Further developments are expected from the efforts of PROLOG's creators at the Universite de Marseille on their PROLOG II project. A PROLOG application is composed of an enumeration of fact s and rules .
Guarded horn clauses and experiences with parallel logic programmingA lot of work has been devoted to the Or-parallel execution of Prolog programs. We consider that this approach may be useful for uncontrolled all-solution-search problems. We decided to compile GHC programs to DEC-10 Prolog programs since we already have a DEC-10 Prolog compiler which translate8 a Prolog program to the machine language. The body of a clause is evaluated only after that clause is selected. (3) Since they are both implemented on top of Pro log, there exists an interface to Prolog. The goal prolog calls X as a Prolog goal. The differences between the two can be summarized as follows: (a) Ueda's Compilers.
The early years of logic programmingTHE EARLY YEARS OF LOGIC PROGRAMMING This firsthand recollection of those early days of logic programming traces the shared influences and inspirations that connected Edinburgh, Scotland, and Marseilles, France. ROBERT A. KOWALSKI The name Prolog is ambiguous. It was originally intended as the name for the programming language developed by Alain Colmerauer and Phillipe Roussel in the summer of 1972. It is a confusing notion, as claims made for the general concept of logic programming do not always hold for the programming language, Prolog, and vice versa. In an attempt to minimize such confusion, I shall reserve the term Prolog to refer to the programming language alone. It is because of this work that 1971 is sometimes given as the year Prolog was born. My short visit was very productive, and we planned to continue our collaboration.
New BooksPage 17 Contents: (provisional) Informal introduction, Lists, Prefixed terms: N-tuplets, The ()redefined rules of Prolog II, Applications, Solutions to exercises, Apendix A: the syntax of Prolog II, Appendix B: the principal predefined rules of Prolog II, Appendix C: comparisons between Prolog II and micro-Prolog, Appendix D: Comparison Prolog II and Edinburgh Prolog. The author introduces Prolog as an efficient language for non-numeric programming. Contents: An overview of Prolog, Syntax and meaning of Prolog programs, Lists, Operators, arithmetic.
An approach to intelligent assistance for the specification of ASIC design using objects and rulesIF/Prolog includes a bidirectional interface to C that allows the integration of PROLOG programs in a C environment. We hope to further improve the performance by transforming major parts from PROLOG to C and to restrict the use of PROLOG to the rule system. Although, PROLOG proved to be a valuable prototyping tool. 1. 2.
Survey on special purpose computer architectures for AIExamples of these architectures are the dataflow machines[39,40], object-oriented architectures[41,42], Lisp machines[18,22], and Prolog-like machines, such as the Fifth Generation Computer System[14]. Some new languages, such as Loglisp[61] and QUTE[105], which amalgamate Prolog and Lisp in natural ways, have been developed. On the other hand, to explore parallelism, the parallel versions of Prolog and Lisp, such as Parlog[106], Concurrent Prolog[107,108], and Concurrent Lisp[109,110], have been proposed.
Towards empirical studies of programming in new paradigmsTypical paradigms for programming include: - imperative (as in Fortran, Algol and their descendants) - object-oriented (as in Smalltalk) - logic programming or rules-oriented (as in Prolog) - functional (as in pure Lisp or Backus' FP). We have begun collecting experimental data to address these issues for learners of Prolog who have already learned to program in a procedural language (in most cases, Pascal). The students experienced real difficulty with the use of arguments. Some of this was a problem with Prolog syntax. Some was the style of Prolog programs, which use complicated arguments as a shorthand notation.
Toward integration of the imperative and logic programming paradigms: Horn-clause programming in the Pascal environmentAN EXAMPLE PROBLEM to a relatively large audience of The following simple Horn-clause program 81]: is_student (John). likes (Mary, Pascal). likes (Mary, Prolog). likes (John, Prolog). likes (John, x) :- likes (x, Prolog). is a modification of a well-known example [KiMe, may_study (x, y) :- is student (x), Obviously, the query ? The following type declaration is used in the example: 26 type object = (Any John Mary Prolog Pascal), The enumeration value Any is further used to model free variables. The predicate likes is determined by means of Four clauses, a split statement is used for its implementation: function likes (var x y: object): Boolean, vat Prolog_var: object, begin Prolog_var := Prolog, s p l i t likes := is (x Mary) and is (y Pascal), likes := is (x, Mary) and is (y Prolog), likes := is (x Oohn) and is (y Prolog), likes := is (x John) and likes end { s p l i t } , end {likes}, (y Prolog var), Note that the Prolog_var is needed because the enumeration constant Prolog can not substitute the variable formal parameter y in the call of likes above.
Designing a high performance parallel logic programming systemKeywords: LOGIC PROGRAMMING, PARALLEL PROCESSING, RESTRICTED AND-PARALLELISM, WAM, PROLOG 1 Introduction The sequential performance of logic programs [12] has been greatly improved since the advent of the first Prolog interpreters by the development of evaluation and compilation techniques such as those portrayed by the Warren Abstract Machine (WAM)[21]. Shapiro. A subset of Concurrent Prolog and its interpreter. Technical Report TR-003, ICOT, January, 1983. Warren. OR-Parallel Execution Models of Prolog. In Proceedings of TAPSOTT '87. Springer-Verlag, 1987. 52
Extending APL to logic programmingOn the other hand, we have the rapidly growing field of Art&&l Intelligence, specially as applied to Expert Systems, where a programming approach somewhat different from classic programming is being attempted, either in the form of symbolic manipulation of complicated character dructu.rcs (as in the case of the LISP language) or through the direct use of first-order predicate logic (as in PROLOG). However, while LISP is one of the oldest computer languages, and has progressed in the last twenty five years to become relatively standard and implemented in complete stand-alone systems, PROLOG is comparatively young (about tit&n years) and a standard complete definition does not exist. In fact, the probability of a PROLOG application not being able to run on a different implementation t? There is a certain tendency, however, to recognize that, in the long run, neither LISP nor PROLOG may be perfectly suitable as *the optimal pro gramming languages' for Artificial Intelligence.
Unification: a multidisciplinary surveyUNIFICATION AND LOGIC PROGRAMMING 5.1 Example of Unification in Prolog 5.2 Research 6. UNIFICATION AND HIGHER ORDER LOGIC 6.1 Example of Second-Order Unification 6.2 Research 7. Warren et al. [1977] presented an accessible early description of Prolog. Through its use of resolution, Prolog inherited unification as a central operation. I will first give an example of how unification is used in Prolog, then I will review the literature on unification and Prolog, finishing with a discussion of the logic programming languages Concurrent Prolog, LOGIN, and CIL. 5.1 Example of Unification in Prolog I turn now to unification as it is used in Prolog.
The architecture and preliminary evaluation results of the experimental parallel inference machine PIM-D. - support of two types of logic programming languages: The machine can support two types of logic programming languages, OR-parallel and AND-parallel Prolog, in a uniform manner, inter-process communication is * N. AND-parallel Prolog provides an inter-process communication facility by sharing logical variables among AND (goals), while OR-parallel Prolog processes provides independent solution search among OR processes. GHC is one of AND-parallel Prolog, such as Concurrent Prolog [15] or PARLOG [6], and was chosen as the basic language of fifth generation computers in IOOT because it has clearer semantics and provides more efficient implementation than Concurrent Prolog and because it has more powerful descriptive power than PARLOG [16].
"A parts selection expert system to increase manufacturabilityThis ability to pass control very simply between Prolog, LISP, and C allowed the expert system designer to take advantage of all the necessary tools (database, LAN, etc.). l Lastly, a small toolset in Prolog simplified the construction of the expert system. (See the Appendix, listing 2, for an example of the Hans Kleine Buening and Stefan Schmitgen . "" Prolog: Grundlagen und Anwendungen"" B.G . Teubner ( Stuttgart , 1986 ). "" HP Prolog for HP 9000 Series 300 Computers "" Hewlett-Packard. III return rains - 334.34844 LISTING 2: S-EXPRESSION PROLOG SYNTAX AND EXPERT SYSTEM TOOLSET The HP Prolog product supports both the popular C-Prolog syntax and a ""LISP-like"" S-expression syntax."
"Burnside's theoremIL Author: RP The file simp-pl contains a small ""expert keeping with the idea behind PROLOG this system"" for formal arithmetic. In program consists basically of a number of rules for simplifying expressions existing content. which may be augmented while keeping the Problems: (1) Acquaint yourself with the necessary basics of PROLOG. for instance by learning to mderstand the program simp-pl. Debugging in FROLOG Formal Power Series Examples WHAT IS PROLOG?[ To start with,PROLOC is a programming language and thus this problem is a programming problem. Writing programs as logical formulas, more precisely, as socalled Horn formulas in predicate logic, is what the language PROLOG is all about. Executing a PROLOG program consists in attempting to satisfy this collection of formulas."
Default reasoning in natural language processingHowever, this behavior cannot be be captured by PROLOG-based parsers* [Dah 177,PereiraS0] for two reasons: (a) representation: all linguistic rules ate viewed as equal citizens, (b) computation: PROLOG backtracking can search for any solution, yet it cannot retract partial solutions. Context: What is the purpose of the act: selling Mary's house to potential buyers, or making sure she arrives safely home? *We allude here to PROLOG as a parsing mechanism and not to the programming language PROLOG which is computationally universal. 80] A parser is required to negotiate this set of conflicting/cooperating clues and to deposit in a database a hypothesis about the meaning of the utterance. (c) PROLOG itself does not facilitate default reasoning which can resolve lexical gaps.
An extended frame languageOUR FRAME SEMANTICS Our frame system is implemented in C-Prolog [CLOCSl]. Prolog was chosen as the implementation vehicle for this system because of its expressive power and late binding properties. Although basic familiarity with Prolog is assumed, the concepts discussed are independent of the use of Prolog. 3.1 FRAMES A frame is identified by an atom and consists of a set of slots. Defining a slot whose name is a Prolog term including variables effectively defines a set of similar slots whose attributes may be shared.
BABEL: a base for an experimental library[Goldberg SO] [Stefik 833 Ait-Kaci and Nasr [Ait-Kaci 86a] have proposed a new programming language, LOGIN, combining the idea of inheritance with logic programming. LOGIN replaces Prolog's firstorder terms with v-terms which generalize first-or&r terms by allowing partially ordered constructors. LOGIN uses the standard Prolog operational semantics---a computation mechanism which implements natural deduction---with a VT-term unification algorithm rather than an ordinary unification algorithm. Since ordinary first-order terms in Prolog can be represented as v-terms, LOGIN is more expressive than Prolog, and subsumes it.
The future of computer languages: implications for educationThese new Ianguages -- or newly popular languages -- 3re not merely abstruse systems used by a few cognoscenti in B handful of universities or research Iaboratorics. At least a dozen of these languages (like PROLOG and micro-PROLOG, LISP and Smalltalk, FORTH and C, and of course Ada and Modula-2) are beginning to appear on microcomputers and in a scattering of computer science classrooms. Notably absent arc languages developed (or populnrizcd) in the last fifteen years, including PROLOG, Smalltalk, and FORTH. and. even within the ALGOL family. Languages among these five types (which include LISP, Lono. Smalltalk. FORTH. PROLOG. micro-PROLOG, QBE, and Intellect) has experienced considerable growth, especially in the last fifteen years.
"Book review: Combinatorics, Set Systems, Hypergraphs, Families of Vectors and Combinatorial Probability by B. Bollobas (Cambridge University Press)Logic programs are nondirectional, which makes them more expressive but harder to understand, for example, a single relation, such as PROLOG's append relation, cab be used in several different ""modes."" The authors argue that the functional component should be deterministic and based on pattern matching rather than unfication. Cohen's article describes a LISP/PROLOG hybrid, written and embedded in PROLOG. His APPLOG interpreter provides an integrated environment that includes the best features of both languages. Maher take up the question of whether the different approaches for adding functional features to PROLOG preserve the unique semantic properties of logic programming."
Investigation into the efficiency of using APL for the programming of an inference machineThis system was now implcmcnted using PASCAL, APL of the first and the second generation and PROLOG.`) (Another PROLOG-version was published by Yazdani jYa841.) Fcurer and Mr. Abrccht. the PROLOG-version was devclappcd by Prof. Klcinc-RUhning. However PROLOG shows other difficulties in solving different problems.
Book reivew: ARTIFICIAL INTELLIGENCE IN ECONOMICS AND MANAGEMENT. Edited by L. P. Pau (North-Holland 1986)Miller supplies a Prolog model of a double-auction market such as a stock market. It is apparently implemented in LISP. MacRae describes a Prolog implementation of a federal income tax law problem-solving system, where the user helps guide the search. It is as such a valuable record. ARTICLES ARRAYS AND ASSIGNMENT IN PROLOG William G. Wong Logic Fusion Inc. 1333 Moon Drive Yardley, PA 19067 (215) 736-2463 Conventional Prolog implementions support dynamic update of the data base using assert and retract.
"An integration of logic and object-oriented programmingALF, the Alltalk Logic Facility, provides the programmer with a Prolog-like model for logic programming . Since ALF is implemented in the Alltalk system, ALF also provides permanence for its objects, i .e ., rules, facts and queries . 1 . Integration Goal s In designing ALF we wished to achieve a "" natural "" integration between Smalltalk and Prolog . Our design goals were : 1. ALF and Smalltalk should manipulate the same data . Th e execution model for ALF should be expressible in terms of classes, methods, instances, and message sending . The main ideas in Prolog (logic variables, unification, and resolution) should b e given object-oriented interpretations . 3."
Logic programmable natural language processor of a knowledge-base management systemIt follows the logic programming paradigm by allowing the embedding of Prolog statements. Conceptual schema are defined by specifying a semantic context for each word. This system is said to be a strongly coupled knowledge-base and database system. KWB Core is an enhanced Prolog environment comprised of a Prolog compiler/interpreter, an external knowledge-base manager, an external database interface, and other programming tools. 1 Introduction The Knowledge WorkBench (KWB) is the first commercial software product to provide an integrated view of knowledge- and databases [1][2]. It is also possible to break to the Prolog level at any time and write Prolog procedures.
"Review of ""Communicating with databases in natural language"" by Mark Wallace. Ellis Horwood 1984.ISBN 0-85312-639-9, $29.95 [Also distributed by Halsted Press/Jolin Wiley & Sons as ISBN 0-470-20105-3] As a programming language for computational linguistics, Prolog is a relative newcomer. Mark Wallace, however, demonstrates very clearly in this timely book the value of this important tool, especially as it relates to the building of natural language front ends and interfaces to database systems. D&Qs is based on predicate calculus, suitably restricted to provide an adequate relational query language. Queries in D&Qs can either be cast into Prolog (as in his ""pilot"" version) or converted by Prolog to an underlying query language. In the Prolog version, each simple qualifier is handled through facts, each relation maps into a predicate, and each tuple of the relation ends up as a Prolog clause for that predicate."
The role of the computer architecture simulator in the laboratoryIn the light of these considerations , it is opportune to reexamine the effectiv e role of the computer architectur e simulator in laboratory activities . on the Prolog functional language [S] i s currently under development at th e University of Bari . In a previous work, an instruction - level processor simulator in Prolog [28 ] has been described . That paper, however , given its indicative nature, is to b e considered an introduction to the use o f Prolog in this field . Computer, Vol . 18, no . 2 , 67-76, 1985 . [28] A . Pashtan . A Prolog implementatio n of an instruction-level processo r simulator .
"PLEASE:Predictable Logic based ExecutAble SpeCificationsPLEASE specifications may be used in proofs of correctness, and may also be transformed into prototypes which use Prolog to ""execute"" pre- and post-conditions. The early production of executable prototypes for experimentation and evaluation may enhance the development process. 1. PLEASE specifications may be used in proofs of correctness, they also may be transfornled into prototypes which use Prolog[9] to ""execute"" pre- and post conditions, and may interact with other modules written in conventional languages. There are Prolog procedures for the predicates permutation and sort, as well as for the program pre- and post-conditions and the program as a whole."
"BooksThe book includes: * an introduction to PROLOG, * programming techniques in PROLOG, * the principles of implementing PROLOG systems, *a description of a PROLOG interpreter for small computers (written in PASCAL and PROLOG) with complete listings, * two case studies in PROLOG applications (a planning program by D.H.D. Warren and an implementation of Sequel-like database query languages) with complete listings, * a short overview of some important PROLOG dialects by Janusz S. Bien'. CONTENTS: An Introduction to PROLOG, PROLOG and Logic, Metamorphosis Grammars: A Powerful Extension, Simple Programming Techniques, Summary of Syntax and Built-in Procedures, Principles of PROLOG Implementation, Toy: An Exercise in Implementation, Two Case Studies, PROLOG Dialects, Selected Bibliography, Index. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Ken Kahn, ""Uniform-a language based upon unification which unifies (much of) Lisp, Prolog, and Act t"". Bill Kornfeld, ""Equality for Prolog""."
Trees and networks using APL2YES OUIfANOS IS-IdOTHER-OF H•PERI'ON GAVE ME THE A21SWER: NO AND BESIDES OURANOS IS-FATHER-OF HYPERION GAVE ME THE ANSWER YES Conclusion As described before, the system is now complete and performs logic inferences according to expectations. The syntax is more compact than PROLOG's, and the number of rules and axioms for a given system is somewhat smaller. This is obviously, an open field of implementation. The speed, as compared to non-emulated PROLOG interpreters, is, of course, slower by about one order of magnitude. Logic Programming Associates Ltd., London (1982). 141 McCabe, FG. and Clark, K.L., Simple PROLOG and MICRO extensions. Logic Programming Associates Ltd., London (1983).
RASP: a resource allocator for software projectsThe reader is assumed to have some very basic knowledge of Prolog. 1 The Rasp philosophy The goal of Rasp is to aid the manager of a software project to distribute the available and suitable resources (mainly human resources) onto the project. There are two remarkable design choices inherited by Logiform: a spreadsheet-like .interface and Prolog as implementation language. There is a unifying concept between these two worlds: both are a natural way to manipulate nary relationships. Each axis is Figure 1: graduated with the set of the possible values which the corresponding choosen component can assume. On the other side Prolog is a Relational Language and its basic objects are n-ary relations.
LangLAB: a natural language analysis systemThe gratmraat* r!es writtmt it I)CG at:ealso trnslatted irate a Prolog progratm, a.nd the Prolog in.terpreter works as at top° (iowx a)d dopth-4ist paser itterleatving syntax axtrdysis. nd sex**atie aaalysis. lf.IE stratetltred dieti¢mary respectively by tra.nslatm's. 3)ranslated results are c0nsMted by the Prolog system and the Prolog interp:eter works as parset. Figure 3 shows results of the translation. These BUP clauses are then translated into a Prolog program (Figure 4) by the DCG translator wl,ich is embedded in the Prolog system.
Constraint logic programmingThe framework herein, we call it CLP(X), is aschemein the sensethat when one instantiates X with a suitable domain of discourse,one obtains a programminglanguagewith severalimportant features. PROLOG, PROLOG-II, PROLOG-III and the CLP system,for example,areinstancesof the scheme.This schememayalso provide formal semanticsfor other languagessuch as the recently proposedGIL [ 151and LOGIN [ 11. Motivation and Background Much of the present researchin Logic Programming concentrateson extensions to Prolog. An important issue is the integration of the essentialconceptsof functional and logic programming. Now insteadof establishing one by one the various semanticresults for a given extension to PROLOG, one can use the schemeto obtain them all in one move.
"New BooksThe remainder in the sixteen-title series deal with both topics, such as Pereira and Shieber's Prolog and Natural Language Analysis (Lecture Notes 10). However, for an efficient implementation, a structured programming language could be considered. good reference on implementing logic systems, For a see Implementations of PROLOG, edited by J. A. Campbell, which contains the one-page PROLOG interpreter M. Its step-by-step introduction begins with a simple interpreter for Prolog and proceeds Page 23 to the ""state of the art"" in Prolog compilation techniques."
VLSI and rule-based systemsIn languages stressing production rules, such as OPS, data is pattern matched against the if part until all literals are satisfied, the then part then indicates how the database should be changed. In more deductive languages like Prolog, the match is between a goal literal whose truth is unknown, and the then part of a rule. More complex operations such as list equality are possible by comparing the leaves of one list (with tags included) one at a time against the CAM entries. SUPPORT FOR PROLOG Figure 3(a) diagrams a typical view of how a Prolog program operates. CAM, on the other hand, continues to handle such cases nicely. The only problem with CAM and Prolog is Prolog's need for larger stack spaces in the near future than may be economicallyviable with CAM.
An expert database for material and production planning(OF course going on more easier ways to in A[ which is based on the First to integrate prolog and RDBMS as anything that can be represented in the Relational Algebra (RA) can For Example, the expression c(X,Y):- a(X,P,Z), b(P,Y) in be represented in Prolog and vice versa. [3] prolog 533 can be viewed in Relational and Projection of X, Y. Also prolog mechanism. With this in mind let us see Grouping data and using them [5]. We can add a few files which facts to impart knowledge invoked these files will be contain the data, which prolog views as to the system. When the Expert Shell is read and retrieved into the core.
New booksIt also offers you a multiprocessor implementation of PROLOG as a solution to many multiprocessor machine design problems. PROLOG MULTIPROCESSORS concludes with extensive literature surveys of other PROLOG multiprocessor implementations. Parallel Computation and the Data-Flow Alternative 2. Informal Introduction to Prolog 3. Data-Flow Problems and a Prolog Solution 4.
Rules for implementing very large knowledge base systemsIn theory at least, the integration of programming languages based in the logic paradigm, e.g. Prolog, and relational DBMSs appears as one of the most. promising technologies to be used for constructing Knowledge Base Systems. However, in terms of SIGMOD RECORD, Vol. 18, No. 3, September 1989 29 implementing the integration of a relational system to a programming language such as Prolog, some significant performance problems appear. This emulator is derived from the Warren Abstract Machine (WAM), the most popular emulator for compiled Prolog programs [War 83]. This is the most efficient and powerful model used nowadays for the construction of Prolog compilers.
AGENT: active logical objectsThe efficiency of the solution to a problem can be improved without any change in the solution itself. The programming language Prolog (PROgramming in LOGic) [3] utilizing one of many possible evaluation (control) strategies, is an example of a successful logic programming language used today. Some of them, instead of developing parallel control strategics for Prolog-like languages concentrated on designing parallel logic programming languages with different syntax and semantics. A traditional logic programming language such as Prolog incorporates the notion of a logical variable.
Functional computations in logic programsCategories and Subject Descriptors: D.3 [Software]: ming Languages]: Language Classifications-nonprocedural guages]: Processors-compilers, optimization, Programming Languages, D.3.2 [Program languages, D.3.4 [Programming Lan I.2 [Computing Methodologies]: Artificial Intelligence, 1.2.3 [Artificial Intelligence]: Deduction General Terms: Languages, Performance Additional Key Words and Phrases: Dataflow PROLOG 1. INTRODUCTION and Theorem Proving--2ogic programming analysis, determinancy, functional dependency, In recent years there has been a great deal of interest in logic programming languages, the best known of these being PROLOG. This, understand and reason about declaratively cut as a low-level primitive of spa:e on the run-time stack, and to PROLOG's search has been through however, makes programs harder to [21, 231. It can be extended in a straightforward way to take other kinds of connectives, such as PROLOG's if-then-else construct, into account. PROPOSITION 3.4.
Logic programming in LISP with controlled search (abstract only)LOGIC PROGRAMMING IN LISP WITH CONTROLLED SEARCH R.B.Abhyankar and N.Baharam Department of Mathematics and Computer Science Indiana State University, Terre Haute, IN 47809 INTRODUCTION: We have implemented a system, PROLISP, that combines LISP and PROLOG-style programming but optionally allows the user to place a depth bound on the depth first search. APPLICATIONS: EXAMPLE 1: It has been observed C21 that given the data base p(a,bl. p(c,bl. p(x,z):-p(xIY),p(Y,z). p(X,Y1:-P(Y,Xl. PROLOG generates a `stack overflow' error when presented with the goal ? CNS is analogous to CONS in LISP and IS is analogous to the PROLOG `is' operator. By controlling the depth bound,a different number of initial integers can be generated, thus yielding a form of `controlled lazy evaluation'.
Automatic insertion of BIST hardware using VHDLFor this purpose, we use a Prolog description of the hardware since we need a representation which can be processed by a rule-based system. There are severat methods for describing hardware using Prolog [II]. From these, we decided to use the extensional method [6]. These examples give an idea of the contents and format of the Prolog description that can be extracted from the VHDL description.
A bibliography on partial evaluationKahn, K. M. and M. Carlsson. FEC The compilation of Prolog programs without the use of a Prolog compiler. Komorowski, H.J. LET A Specification of an Abstract Prolog Machine and Its Application to Partial Evaluation. North-Holland, 1986. 26 Takeuchi, A° and K. Furukawa. LEM Partial evaluation of Prolog programs and its application to meta programming.
Programming languages for distributed computing systemsThe languages we describe are CSP, Occam, NIL, Ada,' Concurrent C, Distributed Processes, SR, Emerald, Argus, Aeolus, ParAlfl, Concurrent PROLOG, PARLOG, Linda, and Orca. Finally, we present our conclusions and give an extensive bibliography. 1. Since a distributed sys-Ada, Concurrent C, Linda, NIL Emerald, ConcurrentSmalltalk Occam ParAlfl, FX-87 Concurrent PROLOG, PARLOG Occam, StarMod Concurrent PROLOG, ParAlfl Emerald CSP, Occam, NIL Ada, Concurrent C DP, Concurrent CLU, LYNX BSP, StarMod Linda, Orca Concurrent PROLOG, PARLOG CSP, Occam, Ada, Concurrent C, SR Concurrent PROLOG, PARLOG Ada, SR Argus, Aeolus, Avalon NIL tem has by definition more than one processor, it is possible to have more than one part of a program running at the same time. Concurrent PROLOG. Concurrent PROLOG was designed by Ehud Shapiro of the Weizmann Institute of Science in Rehovot, Israel [Shapiro 1983, 1986, 19871.
Expert DB: an assistant database design systemIn section 4, we present the simplification, normalization and transformation rules used in implementing ExpertDB using Prolog. Finally we present our conclusion and future directions in section 5. 2. The clause `assert' adds the necessary facts into the design database while `retract' deletes the necessary facts. 4. Implementation Using Prolog In this section, we present the Prolog predicate rules used in implementing ExpertDB. Conclusion and Future Directions ExpcrtDB was implemented in Turbo Prolog. This language was chosen for several reasons: (a) The construct used in ER modeling can easily he represented in Prolog [pARS83].
"Efficient dataflow analysis of logic programsIn this paper, we will adhere to the syntax of Edin burgh Prolog and write a definite clause as P :- 91, 92' * * *, 9,. read declaratively as ""q, and q, and. . . and q, implies p"". To simplify the discussion in the remainder of the paper, we will assume Prolog's control strategy, with its textual ordering of clauses and literals. However, the techniques discussed here do not depend on Prolog's con trol strategy `in any fundamental way, and can be adapted to other control strategies in a straightforward manner."
A survey of adaptable grammarsThe notation used will be my own generative clause grammars which are adaptable versions of Prolog's definite clause grammars. The formal definitionis given in appendix A, appendix B shows some examples. Here there is a one-to-one correspondence between a grammar rule and its compilation into a Prolog clause such that each rule can be compiled one at a time.' Neither GCG nor any other adaptive grammars are sufficient at this point. In the implemented version of GcG, a few Prolog hacks can compensate a little. The readers familiar with Prolog will recognize how the following grammar rule disables any previous grammar rule concerned with variables named x. variable(*type) Ix], !
"Logical animationWe arenot restricted to Horn clausesso the deduction techniques of Prolog are not in themselves adequate.An animator based on translation into Prolog is describedin section 5. This issue does not arise in systems, like conventional Prolog, where disjuncts cannot be expressed directly, but correspond syntactically to certain meaningless programs.For disjunctive logic programming see[MIN89]. It hasbecomean effective FORESTTool for validation even though the specifications are subjectto somerestrictions. The Prolog animator uses the Prolog database to record the current state, ie the extension or ""values"" of each function and predicate in a specification."
"Review of ""Word expert semantics: an interlingual knowledge-based approach"" by Bart C. Papegaaij, Victor Sadler, and A. P. M. Toon Witkam. Foris Publications 1986.On the contrary, I found this book to be among the very best Prolog-based descriptions of expert systems, natural language processing, and knowledge systems. Every opportunity is taken to demonstrate in concise terms the relationship of Prolog with logic. Too many Prolog textbooks fail to point out connections with classical logic where possible. They approach Prolog as a conventional programming language. An important and obvious aspect of Prolog is thus missed: that Prolog, since it is based on logic, permits relatively easy translation from logical form to program."
"Review of ""Efficient parsing for natural language: a fast algorithm for practical systems"" by Masaru Tomita. Kluwer Academic Publishers 1986.Book Reviews different from the strategy imposed by Prolog, and partly automating the writing of rules. For example, arguments having a regular and predictable structure (parse tree building, logical form construction, etc.) can be automatically included in grammar rules. Such interpreters are written in Prolog and they transform a Prolog-like program into one that is directly executable. Thus it would have been of particular interest to have guidelines on Prolog techniques useful to such computational-linguistics frameworks."
A Review Of Artificial Intelligence In SimulationA series of papers presented the use of a set of new simulation languages that were based on PROLOG and other logic-programming languages. TS-PROLOG is a PROLOG-based language that was developed as a logic-theoretical basis for rule-oriented simulation. TC-PROLOG was used to solve drug administration problems using simulation (Deutseh, Futo and Papp 1986). To apply PROLOG-based simulation languages to parallel processors, researchers developed Concurrent Prolog for Simulation (T-CP), a simulation language based on Concurrent Prolog (Cleary, Goh and Unger 1985).
Semantic-head-driven generationA variant of our method is used in Van Noord's BUG (Bottom-Up Generator) system, part of MiMo 2, an experimental machine translation system for translating international news items of Teletext, which uses a Prolog version of ComputationalLinguisticsVolume 16, Number 1, March 1990 Shieber et al. For ease of exposition, the encoding will be a bit more cumbersome than is typically found in Prolog DCG interpreters. The standard DCG encoding in Prolog uses the notation (cat o) --> (cat I) ..... We use the functor '--->' to distinguish this node encoding from the standard one. The right-hand-side elements are kept as a Prolog list for easier manipulation by the interpreters we will build.
The procedure to construct a word predictor in a speech understanding system from a task-specific grammar defined in a CFG or a DCGThe rules described in a DCG are directly converted into a set of Pro]og clauses, which works as a parser with an aid of tile powerful pattern matching mechanismof Prolog. Thus syntactic analysis can be done without writing a specia] parser working on the rules of the grammar. We discuss an application of this method to a word predictor, that is, the method for transforming taskspecific linguistic constraint defined in a CFG or a DCG into a Prolog program which acts as a left-toright word predictor. 2. Matsumoto et al.: BUP ---A bottom-up parser embedded in Prolog, New Generation Computing, I-2 (1983). 607
Fast prototyping of a goal-oriented simulation environment sytemThe dis arity in execution times is due to the fact that SES is a Ferolog program that is executing Prolog rules. It is felt that a ten-fold improvement in performance may result from using a compiled Prolog as the base SES code. The prototype was developed on a TI Explorer using an interpreted version of Prolog. Prolog proved to be an effective prototyping tool. System simulation and cooperative problem solving On a Prolog basis. In implementations of Prolog, J. A. Campbell, Ed.
What it's like to be a POPL refereeThe problem is that some of these papers cannot be judged in half an hour . An example of this is a hypothetica l original PROLOG paper submitted to POPL . I've no idea whethe r there was an original PROLOG paper or if a logic programmin g paper was sent to POPL early on or not. My initial reaction, and that of most computer scientist that I've talked to, when originall y confronted with a description of PROLOG is that it is a pile o f . PROLOG has only a few simple ideas, unification an d backtracking, and some other things which look like warts -- cut, add axiom and delete axiom . It is only when you try to solve som e problems using the paradigm that PROLOG suggests that you appreciate that there is something there.
A model for self-adaptation in a robot colonyKEYWORDS: Artificial Inteligence, Inductive-learning, Producer-Consumer problem, 1.INTRODUCTION A robot is a programmable move materials, parts, Prolog, Robot colony. multifunction device designed to tools or specialized devices through variable programmed motions for performing a variety of tasks [i]. In the absence the changes occurring of metalevel, adaptation to in the colony would not be possible. 3.EXAMPLE The metalevel computation procedure and the lowlevel Prolog database. is performed by a learning computations by a distributed The learning procedure observes the execution of the Prolog database and learns by induction. the learning mechanism An impo{tant feature of is its tendency to generalize'. And so, start */ /* from the beginning */ 3.3 Conversion of clauses :We employ the recurrence relations into Prolog the-following Prolog program scheme for low-level computations (in the learned state) fx(l,I,X) :- X is bl(I). <2> fx(I,J,X) :- W is b(J),fx(I-i,W,Z),X is a(Z). 3.3.1.
A “course” for data modellingPrerequisites: completion of undergraduatecoursesin, comparativeanalysisof the run-time behavior of programminglanguages,anda linear algebraor discretestructurescourse. rseOutline: (1) Review/Overview of Formal Logic (A) StatementCalculus (1) prime sentences/ compositesentences (2) prime formulas /composite formulas (3) conjunctive normal form (4) theoremson valid sentences (5) theoremson valid consequences (6) modusponensrule (7) consistent versusinconsistent statements (8) developmentof the indirect proof technique (B) PredicateCalculus (1) (2)operationaldefinitionoffirstorderlogic operational definition of well formed formulas (3) free versusboundvariables (4) evaluation proceduresandassignments for a formula (5) validity theorems (15)conjunctive normal forms (7) prenex conjunctive normal forms (8) Skolemstandardforms (9) theoremson valid consequences (10) rules of universal specification, and universal generalization (11) semantictrees (II) Axiomatic Theories (A) introduction to the conceptof axiomatic theory-- madlematicalproving versuslogical proving (1) review of methodsof proof usedin mathematicalproving (2) formaldeduction (3) operationaldefinition of abduction (B) statementcalculus asa formal axiomatic theory (C) predicatecalculus asa formal axiomatic fi@Jry (JII) Overview of artificial intelligence techniques/ knowledgerepresentation (A) semanticnetworks (B) the ISA hierarchy (C) slot-assertionnotation (D) framenotation (E) lisp implementation (F) PROLOG environment and logic programming (backtrackingexamplesandHorn clauses) (G) PROLOG andrelational databases (H) PROLOG and natural languageprocessing (only if time permits!!) Thesestudentshave tendedto possess strong backgroundsin programminglanguagesand database.The author hasnot assumedthat the studentstaking this coursehavebeenexposedto PROLOG, thereforeintroductory materialon PROLOG is coveredin the coursebeforemaking assignmentson intelligent databases.Normally the enrollment in this coursehasbeensmall, ten or fewer students, so that a strong emphasison student researchefforts along with classroomcritiques can be accomplished. [CLOC 811W. F. Clocksin and C. F. Mellish, Programming in PROLOG , Springer-Verlog, 1981. * An introductory text in PROLOG.
"A comparison of concurrent languages: a class projectWSU on the VAX-11/7$5 (VMS). procedures, and mechanism for Ada is available at Concurrent Prolog, a variant of sequential Prolog, supports concurrent programming and parallel execution. An investigation of Concurrent Prolog could best be performed by a student who already has Prolog or logic programming experience. INM83 INMOS, Occam - Programming Manual, INMOS Limited, 1983. SHA83 Shapiro, E., ""A Subset of Concurrent Prolog and Its Interpreter,"" Revised version of TR-003, Institute for New Generation Computer Technology, Tokyo, Japan, February 1983."
A course in programming languages for computer science majorsThe computer facilities availabl e include (1) VAX 11/780 with VMS operatin g system, which supports LISP, Pascal , Fortran, Cobol, and Ada , (2) PDP 11/3 4 with Unix operating system, which support s Prolog , and (3) a dual IBM 3031 runnin g VM/370, and MVS operating systems, whic h also support Pascal and Fortran . The functional programmin g language viewpoint of Lisp . 4 . The logic programming languag e viewpoint of Prolog . Hence the cours e topics also included Horn Clause, th e relationship of logic to Prolog, and th e notions of topic-down proof procedures , unification, depth-first search , backtracking, and negative fac t representation . The students were occasionall y requested to do exercises from th e textbooks during a tutorial and th e answers were discussed before the end o f the class . During the weeks when Lisp an d Prolog were taught, students were asked t o write Lisp and Prolog programs and t o solve some simple problems .
"An amateur's introduction to recursive query processing strategiesHenschen-Naqvi Henschen-Naqvl 1s a top-down, compiled and Iteratlve method The apphcatlon domam 1s that of linear range restncted rules The method has a compllatlon phase which generates an Iterative program That iterative program 1s then run agamst the data base The general strategy 1s fairly complex to understand, and we shall restnct ourselves to descnbmg It m the ""typical case"" which 1s P(X,Y) - up(XW),p(XQWdown(~,Y) PKY) - WX,Y) query(X) - p(G) Note that the relation names up and down are not to be confused with the notions ""top-down"" or ""bottom-up"", which are charactenstlcs of evaluation strategies Let us introduce some simple notation, which will make reading the algorithm much simpler Smce we are only dealing with binary relations, we can view these as set-tiset mappings Thus, the relation r associates with each set A a set B, conslstmg of all the elements related to A by r We denote Ar the image of A by r, and we have A r = { y 1r(x,y) and x E A} If we view relations as mappings, we can compose them, and we shall denote r s the composltlon of r and s Therefore A (r s) = (A r) s This approach 1ssmular to the formahsm described m [Gardann and Mamdrevdle 861 We shall denote the composltlon of relation r n times with itself r' Finally we shall denote set union by `+' Once this notation 1s mtroduced, It 18 easy to see that the answer to the query s {a} flat + {a} up flat down + {a} up up flat down down + + {a} up' flat down* + The state memonred by the algorithm 1s a couple , where V 1s a the value of a unary relation and E 1s an expression At each step, usmg V and E, we compute some new tuples and compute the new values of V and E The Iteratlve program 1sas follows V ={a), E = X, /* the empty string */ while ""new tuples are generated m V"" do begin /* produce some answer tuples */ answer = answer + V flat E, /* compute the new value */ v =vup, /* compute the new expression */ E = E 1 down, end Note that E 1s an ezpresaton, and 1s augmented each time around the loop by concatenating "" down"" to it through the ""cons"" operator As can be seen from this program, at step 1, the value V represents {a} up' and the expression E represents down' Therefore the produced tuples are {a} up' flat down' This 1s not meant to be a complete descnptlon of the method, but a descnptlon of its behavior m the typical case The Henschen-Naqvl method 1s described m [Henschen and Naqvl 841 The method has been amplemented m the case described here This Implementatlon can be found m [Laskowskl] An equivalent strategy 1s described usmg a different formahsm m [Gardann and Mamdrevllle 861 The performance of the strategy IS compared to Semi-Naive evaluation and another method (not described here) m [Han and Lu 861 3.2.6. Prolog Prolog 1s a top-down, interpreted and recursive method The apphcatlon domain of Prolog 1s dlficult to state precisely (1) It 1s data dependent m the sense that the facts have to be acychc for the interpreter to terminate, and (11) there 1s no simple syntactic charactenzatlon of a termmatmg Prolog program The Job of charactenemg the ""good"" rules 1s left to the programmer We consider its execution model to be well known and wdl not describe It In fact Prolog 1s a programming language and not a general strategy to evaluate Horn clauses We essentially mention Prolog for the sake of completeness and because It 1s interesting to compare Its performance to the other strategies 3.2.7. A summary of the charactenstlcs of each strategy 1spresented m Table 1 Table 1: Summary of Strategy Characteristics Method Nitlve Evaluation Semi-Naive Evaluation Query/Subquery Query/Subquery APEX Prolog Henschen-Naqvl Aho-Ullman Klfer-Lozmskn Counting Magc Sets Applacatron Range Bottom-up Evaluable Bottom-up Evaluable Range Restricted No Arlthmetlc Range RestrIcted No Arlthmetlc Range Restricted No Arlthmetlc Constant Free User responsible Linear Strongly Linear Range Restricted No Arithmetic Strongly Linear Bottom-up evaluable 4. ,,,,i-1) + 4 4 QSQ, Recuratve F,, &sum(&,,h `.p-l) +E,, tw4Lp,h `.p-l) `JJ., 2 f I& 1 F/M + T sp2 trot 1 E/rot Tjwdoa 1 Deiotm 2 dor- EiP wm(E,,h Lp-l) EL + 1-l T up2/1at1 %at T/m.dom 1 Fdotm 2 drrn (E,, &own)* 1-l 4 5 Henschen-Naqvc F,, gsum(Elph `sp-l) + UC, `bp2 /Iat 1 Ffrot + Kp2 flatIE/M %at2 doral Fdom E:p gS'd%on, l-l)) + T up2 /lot 1 Qat T/1.t2dows 1 Fdowm (Es, &non) 4 6 Prolog twm(Fsp,h Lp-1) +F., gsum(F.pJGp-l) Cp2 w 1F/U + `&z/w F /Iat Tfrotz doml i?"
A morphological processor for Modern GreekThe model file consists also of sequences of entries, each in the form of a Prolog term. Each model includes information concerning a. Phonological rules take into account a list of phonemes described as sets of distinctive features. In our system, phonemes are listed as Prolog terms. Phonological rules are listed as Prolog clauses. In our system, the augment rule, listed also as a Prolog clause, is activated by validation rules authorizing the concatenation of a verbal stem and a verbal affix marked for past.
"User models, discourse models, and some othersWell that would be very convenient, but I'm really interested in logic programming itself. $3. Just as well: we don't have anything on Prolog for accountants. Do you want something really noddy? Oh, but I've done a bit of Cobol. $5. There isn't anything on Prolog from a Cobol point of view, I'm afraid. U6. I wouldn't have thought that mattered: Cobol's a good general lead in, isn't it? Again, the discourse model relates the system's belief about the utility of a book on Prolog for a would-be logic programmer with the world model link between Prolog and logic programming, and it relates this book in the world model with the text model entity for ""one pretty basic book""."
An approach to integrating expert system components into production softwareDeclarative programming makes use of newer tools like Prolog l*j 131and OPS5 141. Declarative programming tools have proven themselves as the tools of choice for knowledge-intensive and reasoning-intensive systems like expert systems. It also forces the use of a more complex syntax than a purely declarative language would require, and forces the programmer into flow of control considerations alien to the declarative programming paradigm. This point has been made frequently for Prolog Isl [ial. Forcing a certain flow of control in a Prolog program, usually using the cut operator, often results in unreadable Prolog code I'll. McCabe, micro-Prolog: Programming in Logic, Prentice Hall, Englewood Cliffs, 1984.
Unfold/fold transformations and loop optimization of logic programsWe assume some acquaintance with the fundamentals of logic programming and Prolog. The remainder of this sum mary is organized as follows: Section 2 sketches some basic notions used later in the paper. This is exemplified by the factorial function: fact(x) = if x = 0 then 1 elsex *fact(x-1). In Prolog, this might be coded as fact(0, 1). fact(N, F) :- N > 0, Nl is N-l, fact(N1, Fl), F is N * Fl. H. Nakagawa, Prolog Program Transformations and Tree Manipulation Algorithms, J.
Sensitive parsing: error analysis and explanation in an intelligent language tutoring systemWe will show by giving two examples how such types of errors can be clearly represented in PROLOG. All types of syntactic errors are treated by error rules. The np-ruie treats the error predicate F, which is a PROLOG term, by calling it. II. In German, verb groups in the perfect tense are frequently split up. Again, this description has been simplified in order to make clear how these transformation rules function in PROLOG. freeze is a predefined predicate of PROLOG II [ProloglA]. freeze(X,P) delays the evaluation of P until X: takes a value, compls analyses the verb complements of the sentence.The order of the sentence parts is produced by the equations between them (predicate eq). 3.31Semantic errors.
Book review: EXPERT SYSTEMS 1987 Assessment of Technology and Applications by Terri C. Walker and Richard K. Miller (SEAl Technical Publications)A discussion of the differences between some of the various current dialects of Prolog is also included. The book has a complete and quite up-to-date bibliography. There is no discussion of the various parallel implementations of Prolog. I don't think it would be very difficult to add some discussion about how Prolog syntax could be extended to handle concurrency. The book also seems to skirt the issue of how second-order predicate calculus problems can be addressed in Prolog. But these are ..small complaints. This is not a good book for studying the theoretical aspects of logic programming.
A specialized expert system for judicial decision supportThe expert system itself was designed and implemented almost exclusively by the first author, and is implemented using Turbo Prolog (1.1) and Turbo Pascal (3.0). It has been in use to assist specific decisions by Judge Rippey since the spring of 1987. INTERNAL ORGANIZATION OF JEDA JEDA is written in two parts, a database part in Turbo Pascal and an expert system part in Turbo Prolog. Turbo Pascal was used for its ease of file and screen handling capabilities. Turbo Prolog was used mainly because, at the time of implementation, it was the only inexpensive implementation of Prolog that offered easy editing, debugging, and windowing features.
TALISMAN: a prototype expert system for spelling correctionAs we reported in an earlier article [33, perhaps the greatest single difficulty in using Prolog in approximate string matching is the inefficiency with which it accesses the clause database. This text file was then `corrected by two versions of our Prolog spelling checker against our 9,734-word test lexicon. Having exhaustedthe lexical organization options within Prolog, it was decided that we would explore the possibility of interfacing the Prolog program with a high-level languagewhich would handle the lexical organization.
"A software development environment for law-governed systemsThe law, whose ruling dependson the state of the system at the time a messageis sent, is re means of a restricted Prolog program.gresented by Given a messagesending act send (s , m, t 1, the ruling of the law for that act is defined by the evaluation of the goal ""send ( s , m, t ) "" with respect to this Prolog program. This evaluation is expected to either result in posing a goal of the form deliver (...I exactly once or result in failure (in Prolog sense). The latter is interpreted as symbol f a i 1. Note that law L3 does not either modify or tie reader is assumed to have only a minimal knowledge of Prolog. `Throughout this paper, we use the so called Edinborough syntax [2] of Prolog, where variables ate capitalized and constants are written in lower case."
"Distributed artificial intelligence: an annotated bibliiographySzeredi, ""System Simulation and Cooperative Problem-Solving on a Prolog Basis,"" Implementations ofProlog, ed. Campbell, J. Rokusawa, ""Data-Flow Based Execution Mechanisms of Parrallel and Concurrent Prolog,"" New Generation Computing, vol. 3, pp. 15-41, 1985. This paper describes the use of petri nets as a modelling tool and prolog as a programming environment for predicatetransition nets."
Getting the languages for a programming languages courseFor mor e information on obtaining Standard ML of New Jersey through the mail, write to : David MacQuee n Room 2C-32 2 AT&T Bell Laboratories Murray Hill, NJ 0797 4 5 The Relational Paradig m The relational paradigm is linked to the inception of Prolog, in 1972 . Prolog is still the most widely availabl e language of this kind . In our course we spend approximately a week and a half on Prolog, and devote 2 o r 3 laboratory assignments to this area . There is an implementation of Prolog, called SB-Prolog, that wa s originally developed by David Scott Warren and his group at SUNY, Stony Brook .
A blackboard architecture for the decision support processHowever, the preferred language for logic modeling in current DSP research is Prolog. Binbasioglu and Jarke [1986, 19871 used object-oriented Prolog to identify the problem context, to formulate the problem, and to build a model. While Prolog can be modified to handle most of these problems, this process requires both extensions to Prolog and the inclusion of more control information into the clauses that constitute the definitions. These extensions make the use of Prolog burdensome. Chen and Henschen [1985] offer new constructs and provide a compilation process to overcome these problems in Prolog.
"Japanese honorifics and situation semanticsCIL (Complex Indeterminate Language) can be represented by the following formula. CIL =Prolog + ParameterlzedTypes +Freeze =Prolog + Frame +Freeze. Context))). ,,< 2, denotes the operator "":-"" in Prolog [Bowen 1982]. ""[ta]X],X"" is the DCG parsing mechanism. X is a list like [a,b,c,dl which contains Prolog atmns or terms. Y is a Prolog atom or term. 1) Search list X for Y. 2) If there is a term in X with the same arguments but different term name, fail and return. 3) if Y is not in X, then add Y to list X,succeed and return. 4) IfY is in X, succeed and return."
Proteus and Pundit: research in text understandingThe work by NYU is being done in LISP (primarily in COMMON LISP), as is most of the Strategic Computing research. SDC is doing its development in PROLOG because Prolog provides a powerful framework for writing grammars, it also provides the inference engine necessary for knowledge structuring and reasoning about the discourse structures in text processing. This division will permit us to make some valuable comparisons between the LISP and PROLOG development environments, and between the resulting systems. The context sensitive constraints are expressed in a version of Restriction Language (Sager 1975) which is compiled into LISP. The SDC (PROLOG-based) system uses a topdown left-to-right Prolog implementation of a version of the restriction grammar (Hirschman and Puder 1986). 4.4.
A database design for graphical modelsA prototype of this system is implemented in LPA prolog on a Macintosh n workstation, while better techniques for combining data and knowledge manipulation are topics of our ongoing research. [1] S. Williams,E. Aitchinson, Evaluation of the Effectivehess of Prolog for a CAD Application, IEEE CG&A, vol. 4 (March 1984) [3] S.J. Fut 6, E Darvas, P. Szeredi, The Application of Prolog to the Development of Question Answering and Database Management System, Logic and Databases, Plenum Press (1978) [81 A.
Generality in artificial intelligenceStepping up in generality, one can allow arbitrary constant terms, built from function symbols, constants, and predicate symbols, for example, location(Block1) = top(Block2).Prolog databases allow arbitrary Horn clauses that include free variables, for example, P(x, y) A Q(y, z) > R(x, z), expressing the Prolog rule in standard logical notation. However, a Prolog program incorporating this fragment directly can sterilize a container only by killing each bacterium individually. It appears that most human daily activity involves only such reasoning. In principle, Prolog goes slightly beyond this, because the expressions found as values of variables by Prolog programs can themselves involve free variables.
The symbolic computation laboratory at UIUCThe various software packages, Reduce, Macsyma, SMP, Cayley, Scheme, and Prolog are found under the rootrnenu. Choosing one of them automatically opens a new window and starts the program in the window. The same technique works for all programs, Macsyma, Cayley, Prolog, etc. Other things work in a uniform way, too. If it is running in a Command window, which is scrollable, the question never arises. How do you save a program in Reduce or Prolog? The Sun window menu will automatically make a file out of whatever is in the window.
"Discourse representation theory and the semantics of natural languages: contribution to a panel on ""discourse theory and speech acts""An extension of the original fragment of DRT was first implemented in Prolog in Kolb [1985], this implementation also had the merit of providing a deductive account (restricted to a generalized syllogistic language) for DRSs. 2.2 Implementing DRT in Prolog Prolog lends itsself in a natural way as an implementation language for DRT. (A faithful and at the same time optimal implementation of the fragment in Kamp [1981] takes up about 11/2pages of Prolog code.) Several alternatives to the implementation of DRT (in Prolog) have been investigated (cf. Sabatier An Introduction to Natural Language Processing in Prolog, to appear. Kamp, H. [1981] ""A Theory of Truth and Semantic Representation"", in J."
"A review of automated debugging systems: knowledge, strategies and techniquesAnother er~up is composbd of general purpose debugging systems (Snifled5, Kraut"", "" , Foeusf8' lQ, Fatrsy'). All the other systems are enhanced Prolog tracei= (PWO- 21, Prese122, Opium23* 24). A particular group of enhanced Prolog tracers is ma.de out of the systems following the track opened by Shapiro in Algorithmic Program Debugging (APD in the following)25, (Rational Debugging (RD) 26, Declarative Error Diagnosis (DED)27, Error Diagnorir System (EDS) 2H ). 2. *and we heard that this idea is used in many more Prolog systems. For example, in BIM Prolog and in the Prolog of IBM Tokyo Basic mechanisms are provided in Opium to erlable the implementation of new scenarios. Shibayama, ""PRESET - A Debugging Environment for Prolog"", Logic Programming Conference, Tokyo, 1985, pp. 90-99."
P4: a logic language for process programmingLanguage Overview As mentioned, P4 is based on the logic programming paradigm. While similar to Prolog, it has several differences. 2.1. Data Model ~4 is in fact an object-oriented model. Inputs are data items. Outputs are logical variables (in the Prolog sense)that will have values bound to them if the goal is satisfied. Automatic rules are applied to goals as soon as possible using the typical Prolog unification mechanisms (extended to include type checking).
Towards an efficient management of objects in a distributed environmentHorn Department of Computer Science, Trinity College Dublin, Ireland A prototype of an object oriented system implemented in C-Prolog is described in this paper. Its main objective is to demonstrate system features that would support efficient management of objects and object oriented databases in a persistent and distributed environment. The system is currently operational. Objects in Prolog can be created as instances of Prolog coded implementations (preprocessed form), or database classes. The next step planned is to make use of the monitoring information as well as an expert knowledge and rules, so that the system can be self controlled, regarding the distribution of objects, locality, and objects decomposition and clustering. Using C-Prolog, it was noticed that the concept of clusters, if supported in Prolog implementation, could facilitate providing a support for efficient management of large object oriented databases in Prolog.
Using expert systems to select software the traffic analysisNormally, Al programming is made in the languages LISP and PROLOG. LISP, which stands for LISt Processing, is particularly suited for symbolic and numeric processing for decision analysis. For years, LISP has been preferred by AI engineers in the United States. On the other hand, the PROLOG 1 anguage, representing PROgramming in LOGic, is - preferred in Europe and Japan. Clocksin, W.F. and Melltsh, C.S. (1984). Programming in PROLOG, Second Edition. Springer-Verlag, New York. Chang, E.C. (19B7).
Computer aided concurrent design for printed wiring boardsThis methodology was integrated into our toolset by incorporating a knowledge base, written in PROLOG, and access routines to our data representation, written in LISP. As mentioned earlier, the knowledge base was implemented in PROLOG which represent logical statements based on relationships established by the design engineers. The outcome of this constraint determines whether we have violated this rule. PROLOG also allows for direct manipulation of LISP objects.
"Review of ""Natural language understanding and logic programming, II: proceedings of the second international workshop"" by Veronica Dahl and Patrick Saint-Dizier. North-Holland 1988.The collection shows clearly the fast proliferation of new logic grammars and Prolog dialects, which is perhaps a necessary stage for a relatively new domain. A paper on morphological analysis of Italian is an example of the work where it is fully justified to use Prolog, but its use is of little relevance to the problem under consideration. To summarize, the volume definitely proves the usefulness of the Prolog programming language for a wide range of natural language processing tasks."
"A collection of projects for the mathematical laboratoryTitle 001 ETHZ 001-001 Satz yon Burnside 001-002 Formale StSrungsrechnung 001-003 Phasenportraets 001-004 Unbestimmte Summation 001-005 Automafisches Beweisen 001-006 Public-Key-Verschliisselung 001-007 Zeichnen von Kreisen und Linien 001-008"" Exakte Berechnung von II(x) 001-009 Formale Potenzreihen 001-010"" RShrenoszillator 001-011 Error-Correcting-Codes 001-012 Knuth-Bendix-Algofithmus 001-013 Finite Elemente 001-014 Parametrische Resonanz 001-015 Programmable Logic Arrays 001-016 Flip-Flop Simulation 001-017 Ebene Laplacegleichung 001-018 Rutherford-Streuung 001-019 Beantwortung meteorologischer Fragen 001-020"" Suchalgorithmen auf Graphen 001-021 Die Drehgruppe des Rubik-Wiirfels 001-022"" Boundary-value Problems 001-023"" Hamming Codes 002 RWTH 002-021 Rechnen in It-Math 002-022 Public-Key Verschlfisselung 002-023 Stirungsrechnung bei Differentialgl. 002-031 Elementarteileralgofithmus 002-032 Gekoppelte Differentialgleichungen 002-034 Transformation yon Dgl-systemen 002-041 Vereinfachung algebraischer Terrne 003 UIUC 003-001"" Burnside's Theorem 003-002 Formal Perturbation Theory 003-009* Formal Powersefies 003-021"" Rubik's Cube 003-030* Bell Polynomials Program(s) ref av Comments Cayley Reduce 3 Numlnt Reduce 3 withdrawn TPU, Lisp SAC-2 UCSD-p Prolog Numlnt, Mlab SAC-2 SAC-2 Flowers n/a n/a PLA Spice-2 pascal Ingres Prolog ml Cayley Macsyma 002-023 ml in English Cayley ml g-Math It-Math 001-006 It-Math Maple Maple Maple It-PROLOG Cayley 001-001 ml Reduce 001-002 ml Prolog 001-009 Cayley 001-021 ml Reduce ml 14 The Mathematical Laboratory Nr. Tide Program(s) 003-031"" Optimization on Networks Prolog 004 UMN 004-005"" Automated Theorem Proving Lisp, TPU 004-006* Public Key Encryption SAC-2 004-021 Rubik's Cube Cayley 3.3."
Semantics of CAD objects for generalized databasesOur approach is to integrate these representations within the same formalism. lt uses a specific object-oriented approach. It is implemented in Prolog [ 131. ln the following, a cell is a particular representation of a given circuit. A prototype that inc:ludes the functionalitics described in thi, presentation has been implemented in Prolog on a VAX 11/7X0 running Unix 4.2 BSD. All the information is created. updated and \torcd as a set of Prolog clauses. The characteristics of both the database and Prolog system arc taken for what they arc. This implies the management of deductive informations and conaistcncy controls by Prolog, and the management of the !
Teaching multiple programming paradigms: a proposal for a paradigm general pseudocodeOnly logic programming languages stand in a category by themselves. Even there the most widely used language, Prolog, has had to borrow features from other paradigmsiu order to make implementation practical. Lisp or Scheme), and the third quarter in a logic programming language (usually Prolog). There is a danger using this approach that students will focus on learning the syntax of specific programming languages rather than learning computer science. Sterling and Shapiro [1986l claim that the user can program logically, functionally, or imperatively using Prolog. However, Prolog has many disadvantages, the primary one being the introduction of nonintuitive control mechanisms (such as the cut statement) that compromise Prolog as a pure logic programming language.
Research actvities on natural language processing of the FGCS projectCIL (Complex Indeterminate Language) 2.1 Partially Specified Term CIL is an extension of Prolog which was designed for the system description language of DUALS. CIL has the freeze predicate, which was originally introduced in Prolog-II C51, as a primitive predicate for realizing various lazy evaluation controls. As is easily seen, CIL unification is close to that over infinite trees in Prolog-II. The domain of CIL can be defined formally to be a set of infinite trees. 2.2 Reserved Forms in CIL The current CIL syntax is an extension of the syntax of DEC-10 Prolog.
Integrating logic, object-oriented and procedural paradigms in a fault diagnosis and monitoring systemThis rule-oriented module has been implemented in Prolog and applies an expert system shell developed internally for the specific requirements of our system. The shell uses EMYCIN like rules with certainty factors and backward chaining, enhanced with Prolog specific features like unification and generic rules. It can be easily linked together with both C subroutines and various Prolog systems. • Prolog offers features (backward chaining, unification of variables) which are very useful for reasoning tasks.
"Dictionaries, dictionary grammars and dictionary entry parsingThe system consists of a rule compiler, a parsing nDgBe, a dictionary entry template generator, an loader, and various development facilities, all in a PROLOG shell. User-written PROLOG functions and primitives are easily added to the system. Rule application may be constrained by arbitrary tests (revoked, as Prolog predicates, via a t operator), and a string operator is available for sampling local context. McCord, M (1987} ""Natural Language Processing and Prolog"", m A Walker, MMcCord, J Sowa and W Wilson (Eds) Knowledge Systems and ' Prolog, Addison-Wesley, Waltham, Massachusetts, 291 - 402."
Character recognition of cursive scriptsIn the present paper the inverse problem is studied and the design of a PROLOG based system is described which recognizes the printed cursive script to determin the constituent characters from which the script had been generated. The recognition problem may be described as the inverse of the above, that is, for a given Q we determine P, by a set of inference rules of the type Q - P, that use pattern matching and unification in PROLOG. This approach tends to reduce the search space on the average by five orders of magnitude. In this recognition phase the incidence of blanks or inter-character spaces is used to construct the class components of Q, using pattern matching and unification in PROLOG. An illustrative program is detailed in Section 3.
Experiments on incorporating syntactic processing of user queries into a document retrieval strategyThe syntactic analysis of texts in REALIST is implemented in PROLOG and is used to identify phrases in the text - like noun phrases. The implementation of the noun phrase parser for this work was done in PROLOG. PROLOG as a programming language lends itself to the development of natural language grammars quite well and was thus very suitable for our task. This is because PROLOG has the advantage that it is possible to directly interpret an extension of context-free grammars called Definite Clause Grammars (DC&s) into executable machine code, from within PROLOG.
An overview of parallel processing languagesAND/OR Parallelism in Concurrent Logic Languages Concurrent Prolog. Concurrent Prolog was developed at the Weizmann Institute of Science in Rehovot, Israel by Ehud Shapiro.[8] The language was modified in 1985 to free it from possible side effects. Again, like ParAlfl, Concurrent Prolog overcomes this by providing a means of mapping processes to specific processors. Communication in Concurrent Prolog is done by using data structures similar to the lists employed by functional languages.
Models and artificial intelligenceT-Prolog allows the user to specify multiple model parameters and goals the model is to achieve. TS-PROLOG incorporates facilities similar to those found in conventional simulation languages. Researchers at the Vienna University of Economics and Administration [Adelsberger & Neumann 19851 have developed a simulation system called V-GOSS (Vienna Goal Oriented Simulation Svstem) which is imolemented in several dialects includ?ng, Waterloo PROLbG, York Prolog and micro-PROLOG. The system is a quasi concurrent PROLOG interpreter along the lines of the Hunaarian aDDroach.
A natural language based legal expert system for consultation and tutoring—the LEX projectAspects of problem dcpcndcncc in other components are described below. l The system is truly knowledge based in the sensethat the knowledge can be coded without giving regard to details of the deduction component and that the dcduction component can operate on any knowlcdgc base that adheres to the syntactic convent.ions. This is in contrast to purely Prolog-based solutions such as the earlier implementation LEXO where the structure of the legal rule becomes part of the program, with the consequencethat any change to the domain knowledge has to be checked for procedural conscquencesof the Prolog-Code. 2.0 Implementation of LEXl (Ccmsultation System) Most of the implementation described below is on an IBM 3083 in VM/Prolog. Hence the negation of public can be positively proven. This goes beyond the Prolog concept of negation as failure, which had been used in the prior version LEXO. The Means End Guidance Rules arc at prcxcnt rcprcscnlcd in PROLOG form and can opcratc on Ihc data bases to make decisions as lo which module to procccd lo.
What it's like to be a POPL referee, or how to write an extended abstract so that it is more likely to be acceptedThe problem is that some of these papers cannot be judged in half an hour. An example of this is a hypothetical original PROLOG paper submitted to POPL. I've no idea whether there was an original PROLOG paper or if a logic programming paper was sent to POPL early on or not. My initial reaction, and that of most computer scientist that I've talked to, when originally confronted with a description of PROLOG is that it is a pile of . PROLOG has only a few simple ideas, unification and backtracking, and some other things which look like warts -- cut, add axiom and delete axiom. It is only when you try to solve some problems using the paradigm that PROLOG suggests that you appreciate that there is something there.
A methodology for creating user views in database designUse of the system in a number of organizations subsequent to the end of the formal testing phase continues to identify discussed further in Section 4.3. 4.2 VCS Implementation occasional refinements. This is 4.2.1 Use of PROLOG. The system was implemented in PROLOG. This language was chosen for several reasons: -Many researchers (e.g., [5, 6, 8, 141) have characterized PROLOG as an appropriate language for defining and implementing expert systems. In particular, the constructs used in E-R modeling PROLOG [14]. -PROLOG easily accommodates incremental can be easily represented in additions or deletions [6], which facilitated development of the system in an iterative manner. The View Creation System has since been transferred to a microcomputer environment using Arity PROLOG. Among the reasons for this change were a desire to make the system as portable as possible and a wish to take advantage of a number of additional PROLOG.
DoD-STD-2167 default Ada design and coding standardFor example, sectio n 40 .5 .7 corresponds to chapter 7 of ANSI/MIL-STD-1815A . 40 .5 .1 Introduction . 40 .5 .1 .1 Ada prolog . In order to facilitate automated sourc e code documentation (e .g ., cataloging, indexing, searching , retrieval), a standard prolog for Ada source code shall b e provided with every Ada compilation unit and with every Ad a subprogram, package, or generic unit that exceeds 200 lines o f 40 .5 .1 .1 .1 Every Ada prolog shall consist of three blocks of Ad a comments . These blocks shall provide information about the uni t as a whole as well as about every enclosed Ada subprogram , package, and generic unit that does not contain its own Ad a prolog . The Ada prolog blocks shall be consecutive and formatte d as follows : a. Exception states that cannot b e handled locally shall be suitably recorded (e .g ., flagged , counted, logged, filed) and propagated to the calling unit . Th e Ada prolog shall identify and describe every Ada exception tha t can potentially be propagated . 40 .5 .12 Generic units . 40 .5 .12 .1 Use of generic units .
"RAP: relocation allowance planner, a rule-based expert system with self-defining documentation featuresThe actual coding of the above excerpt into RAP's Prolog rule baseasrule10 is shown in Figure 1 below: _-----------------__----------------------------------------------------------- rule10 => if you will $sign a 12month serviceagreement! Place, ""An Expert System for Managing Toxicological Studies"", Expert Svstems, [in press]. Berghel, H. andD. Roach,""Using Prolog and C to Implement a PC-Based Expert System"", PC/AI, Vol. 4, No. 5 (1990) [in press]. Green, ""RAP: Relocation Allowance Planner"", Technical Report 13 El VI V33 B-1-5-89, National Center for Toxicological Research(May, 1989). Bratko, I., Prolog Programming for Artificial Intelligence, Workingham, England, Addison-WesleyPublishing, 1986."
A concurrent multiple-paradigm list processor TAO/ELISThe comma just before a Lisp form (or term in the Prolog terminology) means that the form is to be evaluated before unification. In addition, the body of a logical assertion (or sequence of literals in the Prolog terminology) may contain any number of Lisp forms. The scope of logical variables is extended from that of Prolog's ones, which is limited in a Horn clause where the variables are established.
Deductive databases: achievements and future directionsSome of the latter,such as OPSS, only support forward-chaining, others, such as Prolog, only support backward-chaining. Some expert system shellssupport both, but the programmer must select the better strategy for the situation at hand, and code it as part of the actual program. Thus deductive databases support well the firsttwo examples, whereas Prolog and other backward-chaining systems would fa/l. In the last example, however, the firstargument, Str, of allunol is bound to the values generated by the predicate alk. Thus a computation, such as Prolog's backward-chaining which recursively propagates these bindings, is significantly more efficientthan forward chaining.
"Meta-interpreters and partial evaluation in ParlogConcurrent Logic Languages Although logic programming is often considered synonymous with Prolog, recently a new type of logic programming language employing committed choice has been receiving attention [TaF86]. Whereas Prolog, given a choice of clauses to evaluate some goal, employs nondeterminism, in which control may backtrack and make an alternative choice, this new type employs indeterminism, in which computation commits to the use of one particular clause. Thus the guard/body separator "":"" behaves similarly to a cut in Prolog. It is mandatory in a Parlog clause, though unwritten in the case where the guard is empty."
Meta-interpreters for expert systems (abstract). © 1986 ACM-0-89791-177-6/86/0002/0484 $00.75 484 This methodology is naturally expressed within logic programming using the language Prolog. Prolog is a very convenient language for building expert systems. Each component is written as simply as possible, in the style of 'flavors' from the LISP machine. The basic framework for using Prolog to build expert systems has been sketched in [2]. This paper describes a partial evaluator which takes a meta-interpreter and a knowledge base and produces an augmented knowledge base where the regular Prolog interpreter will perform with the desired functions.
Technical correspondenceAssert and retract save concurrency and are the major extra-logical operations in Prolog. That is essentially all that Linda is offering, hence, the title of this section. The remaining difference between Linda and the database manipulation component of (sequential) Prolog is concurrency: Linda allows concurrent Tuple Space operations, whereas, by definition, sequential Prolog is sequential. Sumcys. 1989. To be published. Shapiro. E. Cmcurrent Prolog: Collected Papers, Vols. I and Il. MIT Press. 1987.
Temporal logic programming is complete and expressiveRecently, the idea has emerged that one could more easily use the expressive power of temporal logic if it could be made directly executable, for instance as is done with firstorder logic in PROLOG. This has lead to the definition of a number of programming languages based on temporal logic ([FKTMo86], [Mos86], [AM87], [Gab87], [WadSS], [OWSSa], [Sak]). Debray and Prateek Mishra. Denotational and operational semantics for Prolog. Journal of Logic Programming, 5( 1):61-91, March 1988. Luis Fariiias de1 Cerro. Molog: A system that extends Prolog with modal logic. New Generation Computing, 4:35-50, 1986.
"New BooksThe book begins with a complete introduction to Logic Programming, including a description of PROLOG as an example. The subsequent material surveys parallel interpreters, describes in detail the various AND/OR Process Model and provides an in-depth discussion of implementation techniques for an efficient concrete interpreter based on the specification of the AND/OR Process Model. Introduction. 2. Logic Programming Syntax, Semantics, Control, Prolog, Alternate Control Strategies. 3. Parallelism in Logic Programs. Special features of the book are: * Full integration of LISP programming techniques and example programs into the presentation. * All supporting LISP software, including language interpreter, is available on diskette for IBM-PC, XT, AT and compatible systems at nominal cost (under $40). * Laboratory exercises based upon the software, some of which are suitable as starting points for in-depth studies of AI technology. * Up-to-date coverage in a rapidly-changing field. * Treatment of several advanced topics including nonmonotonic reasoning, evidential reasoning, conceptspace exploration. * PROLOG coverage. * Extensive lists of References to the most important * Numerous diagrams. * This book makes it possible for a professional with access to an IBM-PC or compatible to learn the basic principles and programming techniques of AI on his/her own. * Demonstration programs include, among others, ""SHRINK"" -a simulated psychiatrist, ""LINNEUS,"" a programs that demonstrates inference in an ISA hierarchy, ""PROVER,"" a formula verifier based upon Wang's algorithm, ""PROLOG"" -a mock Prolog interpreter in LISP, ""INFNET,"" -a probabilistic inference network in the spirit of PROSPECTOR, SIGART Newsletter, April 198""7, Number 100 Page 20 ""PYTHAGORUS"" -a program that explores a space of concepts in the realm of plane geometry, ""STONE WORLD,"" -which combines a natural- language interface with a simulated microworld."
"Semantic abstraction and anaphoraWe formulate bolh the grammar and the semantic constructors in pure Prolog (exploiting the syntactic sugar of Def-inite Clause Grammar (Pereira and Shieber [121, pp. 70-79)) because it is expressive enough for our purposes and is widely used in work of this kind(sec, inter alia Colmerauer [31, Abramson and Dahl [ll and [11]). This relationship is above, and so are not listed here. assured by the following Prolog clauses: q(String, Analysis) ""- external(S, Analysis), shuffle(t], [], [] ) . s(S, [], String, []) . shuffle([QIQls],Q2s, [QIQ3s]) ""- s(S,Qs) --> np(VP'SI,Qnp), vp(VP,Qvp), shuffle(Qls,Qls,Q3s) . Ablex, New Jersey, 1986. [12]Pereira, F. C. N., and Shieber, S. M. Prolog and Natural Language Analysis, vol. 10 of C.S.L.I."
Automated design software for switched-capacitor IC's with symbolic simulator SCYMBALWe proposed to chose the following solution to cover the above actions. PROLOG language has been retained to cover stage (Pl) and (P3), and a standard procedural language has been used at the stage (PZ). 4. The diagram of the described above procedure is presented in Fig.4 In our opinion, PROLOG language coupled with a symbolic simulator reveals to be a very convenient too1 to treat the problem of exhaustive structures' generation and evaluation. No algorithm had to be developed and the statement of imposed specifications corresponded exactly to the program structure. To compare PROLOG approach with the algorithmic one we have realized a structure generator in FCRTR4N.
Artificial intelligence and simulation: an introductionPROLOG is the principal AI programming language used outside of North America and was chosen as the programming language for the Japanese 5th generation computer development project. It is currently gaining popularity in North America as well. A popular on PROLOG is the book by Clocksin and Mellish (19841. PROLOG is also beginning to see use as a language for the design of simulation models as described by Adelsberger (19841. Clocksin, W.F. and Mellish, C.S. (1984). Prosramminc in PROLOG, 2nd edition, Springer-Verlag Publishing Co. N.Y.
Automatic reasoning about numerical stability of rational expressionsThe control mechanism of the present implementation's inference engine may cause it to visit the nodes of the tree several times, in order to discover properties (e.g. sign) that were not discovered in previous visits to the node. 5 The prototype implementation The implementation as of February, 1989, included both a front-end coded in Maple 4.2 [4], and the analyzer, written in a combination of Maple and Quintus Prolog. Primary control lies with the deduction machinery coded in Prolog, However, since Quintus Prolog lacks built-in exact and extended precision arithmetic, a Maple subprocess is invoked whenever such operations are performed. Mark Mutrie kindly provided me with a copy of his Maple expression parser to use in the frontend of the analyzer. The Quintus Prolog-Maple interface is a modification of a design for a Waterloo Unix Prolog-Maple interface by Sue Kindersley and David E. After loading this file into the stability analyzer, we invoke the analyzer setting the goal that it prove q stable: > stabilityprover Quintus Prolog Release 2.2 (Sun-3, Unix 3.5) I ?- consult('test.out').
"Knowledge-based query processing in object basesOne obvious approach to achieve the above goal is to extend a logic-based programming language, e.g. PROLOG[Wa 77], to support object-oriented programming [Za 84] [Pe 83][Sh 83][Ko 83]. Briefly, the notion objects is implemented by a new infix operator ""with"", that takes as left operand an object and as right operand a list of methods(each of which is an arbitrary PROLOG clause) , and class hierarchy is implemented by a special predicate ""isa"". [W382] Warren, D., ""Higher Order Extensions to Prolog: Are they Needed?"", Machine Intelligence, 8, 1982, pp 441-454."
"System = program + users + lawThe law is a collection of rules, each represented by a Prolog clause. It is enforced, in principle, as follows. which would be represented by the following Prolog goal. ? send(jonss,`set(owner,smith),dictionsry) To satisfy this goal, the system would try to find some rule whose head (i.e., the left side) could be ""matched"" (unijicd, in Prolog terms) with it. Programming in Prolog. Springer-Verlag, 1981. PI Denning, P.J. Fault' tolerant operating systems."
"Version modeling concepts for computer-aided design databasesDynamic Configuration Blnding A version of a composite object is formed from versions of Its components Instances can be bound at the time the composite IS created, or can be left unspeedied until the object I accessed The latter approach, dgmamlc bmdrng, IS most useful during the exploratory phases of design, when alternatIve new verS,ons are being evaluated At some pomt in an object's MetIme, Its con6guratlons must be bound to specdlc versions, usually when It 1s""released "" Layers, first proposed m [GOLDBl], support dynamic configurations The database 1spartItIoned mto layers that correlate verelons among related objects The mltlal layer contamb the orlglnal versions, the second layer contams newly added objects and new versions of existing objects, etc A composite object Identifies its components by referencing their assoelated generic objects At least conceptually, the binding to actual verS,ons takes place by searclung through the design layers for the first encountered version of the desired object s The power of layermg IS that the designer determmes which verS,ons will be bound simply by specrjytng the layer search order The choice of ordering is an environment, and all object accesses are evaluated with respect to one of these There can be many userdefined environments l$gure 3 1 - Example Derrvatlon of a Version Hlstory Imtx+lly, V[O] II the current version After currency movesto VIZ], no further derlvstmna can be made from V[O], vl], q3], or V(4] wIthout repoatmnmgthe currency 0 ml Figure 3 2 - Layers and Envuonments Example The Version I-bster~esare partmoned ,nto layers as shown Layers can be shuffled to make somevers,onsdonun& others For exam ~1% rf layer 1 dommates layer 2, then a reference to the ALU wll be bound to ALU(I] rather than the newer ALU[Z] As an example, consrder tbe creatron of layers as shown m Frgure 3 2 By creatmg envuonments from drfferent sequences of layers, different mstances of the ALU and the Regrster Fde can be bound If the envuonment IS formed from layers 0, 1, 2, and 3, tben the ALU IS bound to Instance 2 and the Regrster Fde IS bound to Instance 2 If the envuonment IS formed from layers 0, 1 and 2, then tbe Instances bound are 2 and I respectrvely If the layers are sequenced as 0 followed by 1, then the ALU Instance 1s1 and the Register Fde Instance 1s also 1 If the envnonment contams Just layer 0, tben the ALU[O] and RFrle[O] are the Instances bound As a final example, an envuonment constructed from layer 0 followed by layer 3 would yreld ALU[O] and Rfile]2] as the bound objects Note that It ISnot possrble to create a context that bmds ALU]01 and RFde[l], because of the groupmg of ALU[l] and RBle[l] m tbe same layer The mecbamsm as presented provrdes a primrtrve way to constram allowable contiguratrons to those that are consrstent, I e , the Interfaces of the components are compatrble m how they are mterconnected to reabze the composrte object A more sopbrstrcated approach would mtroduce compatrbdlty relatronshrps among obIects of the same type, m a manner srmrlar to eqmvalences For example, ALU[OJ rs-eompatrble-wrth Rfile]2], and thus can partrcrpate m the same configuratron of the datapath The approach IS still under mvestlgation a a Validation Part of tbe functron of any database system 1sto keep Its databases consrstent In desrgn databases, consrstency enforcement IS closely tred to the mecbamsms that permrt a desrgn to be released to a user commumty One such mecbamsm, based on object check-m to an archrve, rs descrrbed m the next sectron Conststency IS usually determmed by the successful executron of sequences of vabdatron tools It 1s beyond the scope of the data management system to automatrcally Invoke such sequences, and to determme whetber they are successful However, It can strll assrst desrgners track portrons of the desrgn that must be revabdated after a change The system can log desrgner actrvrty wrth theu assrstance, for example, to record the success or farlure of a slmulatron run Eqmvalence constramts are described by vabdatron scrrpts that must match the actual log of desrgn events to be vabd For example, verrfyrng that a layout and transistor object a-e eqmvalent reqmres the mvocatlon of a clrcult extractor and a schematrc comparrson tool These tools must be appbed to the approprrate versrons eonstramed to be equrvalent We have based a sample Vabdatron Subsystem on PROLOG PROLOG provrdes an elaborate pattern matcher, m whrch the vahdatron scrrpts, specrfied as PROLOG rules, are matched agamst the event log, stored as trme-stamped PROLOG facts, to ""prove"" that the constramt 1sm force (see Frgure 3 3) PROLOG can be used to mfer unvabdated eqmvalence relatronshopsfrom those that have already been vabdated It can also Inform the desrgner about the nature of eqmvalence vrolatrons If there are any, by backtrackmg to the pomt of farlure Suppose that A and B are eqmvalent A desrgner check&out A to create a new versron A' By mberrtance, A' must be shown to be eqmvalent to B before It can be checked back mto the Arcbrve The desrgner can augment the database wrtb a new eqmvalence relatronsbrp among A and A' If tbrs constramt IS shown to be vabd, then the orrgmal constramt IS satrsfied by transrtrvrty A IS eqmvalent to B and A' IS equivalent to A rmpbes that A' rs eqmvalent to B 4. Version Server We are mcorporatmg the data model of Sectron 2 and the operations of Se&on 3 mto a Vetwon Server [KATZ86] It (1) organrses the desrgn mto configuratrons across representatrons, (2) mamtams versron hrstorres, (3) supports workspaces, m whrch desrgners can make private changes, (4) permtts these changes to be shared with other designers through semr-pubbc workspaces, and (5) amplements the careful update of the desrgn arcbrve, by msurmg that objects added to rt have been successfully vabdated and that all eqmvalence relatronsbrp are m force By supportrng the structural relatronsbrps of Sectron 2, wrtbout rmposmg constramts on the mternal formats of the obIects rt manages, the Versron Server should be able to manage mformatron from many desrgn domams The Version Server provrdes access to obIects through checkout/check-m operatrons, wbrcb are nested wrthm desrgn transactrons Versrons are checked-out to prrvate workspaces, where a desrgner can create new derrvatrves These can be shared, wrtbout first vabdatmg them, by cbeckmg them mto a semr-publr workspace assocrated wrtb the design transactron Desrgners checkmg out versrons from these workspaces accept the rusk that such oblects may be mcomplete or mvabd Otberwrse, the objects can be checked back mto tbe arcbrve as new versrons, but only If all constramts, equrvalence and other rules equrvalence (Layout, Transrstor) - extractor (Layout, Tl), comparator(Transrstor, Tl, succeed) jacts extractor (layout- 1, transistor- 1) extractor (layout-2, transrstor-2) comparator (transrstor-3, transrstor-1, succeed) comparator (transrstor-3, transrstor-2, fad) equivalence (layout-l, transistor-3)r ** YES Frgure 3 3 - Check-m Scrrpt and Proof of Consrstency m PROLOG Layouts are shown to be equwalent to tramastor descrlptmns by executmg a wcult extractor and schematlc comparator This sequence of events IS specified m the Prolog rule, where the cap&ahaed parameters are variables The facts mdlcate wblch tool events are assoaated wrth which WXSKGIS(lower case parameters), and whether the mvocstlon succeeded or faded To check that layout-l and tranmstor_3 are eqmvalent, the rule IS matched agamst the facts, and Prolog's mlerence mechamsm can deduce that the rule IS satmied for the specified obJecta wise, can be shown to be vahd These mechamsms are more fully described m [BANC85, KATZ84b, KIM 841 6."
Representation and use of design rules within a technology adaptable CAD systemA general purpose design rule checker, which verifies design rules related to the structural description of a design, has been implemented in Paper30.3 Prolog on the ,3RIONbased on the ideas presented in this section IAUD86bl. As Prolog is an untyped language and has very powerful pattern matching capabilities, the program implementation is greatly simplified. , extra simplification is achieved because 1' a5 DRDL operators are described by structures which are identical to those that describe Prolog functors, no pre-processing of DRDL operators 1.5 necessary for their use in a Prolog environment 6.
A spreadsheet interface for logic programmingIn PERPLEX, programming is as easy as using a spreadsheet Logicprogramming languages(like Prolog) promise to be more problem oriented and easier to learn for the non-programmer than procedural languages. Van Emden et al. [9] also use a matrix display to present answer substitutions of incremental Prolog queries. However, they do not support the definition of new predicates. Campbell: Excel Macro Treasury, Macworld, November 1987, pp 122-125. 7. Alain Colmerauer: Opening the Prolog HI Universe, BYTE, August 1987, pp 177-158. 8.
"Detecting stable properties of networks in concurrent logic programming languagesOne can view this whole question-answer episode as directional ""message-passing"": PI sends the message f (a,Y> on the ""one-shot"" channel X, this message in ' Wherever concrete syntax is used in this paper, we use the Edinburgh Prolog convention: identifiers beginning with an upper-case letter denote variables, other identifiers denote constants. Concurrent Prolog, Volume 1 and 2. MIT Press, December 1987. I<. Hardware description and simulation using Concurrent Prolog. In Proceedings of CHDL '87, pages 9 - 27, Elsevier Science Publishing, 1987."
Book review: THE T PROGRAMMING LANGUAGE A Dialect of LISP by Stephen SladeWhile the book title does not mention it, the book also features a discussion of Prolog, including a Prolog in LISP interpretor and explanations with implementations of the Prolog unification algorithms. Wi{h a solid Prolog book as companion, such as I. 8ratko's Prolog and AI text, this book gives a sound programming introduction to the major areas of AI.
Parallelism in logic programsWe also refer to a vector of terms as a tuple, and denote it by the use of an overbar, e.g., t. Following the syntax of Edinburgh Prolog, definite clauses (rules) are written as p :-Ql,...rqn read declaratively as q1 and q2 and . . . and q,, implies p. This is precisely what committed choice languages such as Parlog [CG86] and Concurrent Prolog [Sh86], the freeze primitive in Nu-Prolog [Na87], and some other proposed methods, e.g. in [Co83], achieve by dynamically suspending and starting goals. , but memoing enables us to recognize that the goal has been generated before, and thereby devise modifications to Prolog that do terminate (e.g., see [ViSS]). In fact, this causes Prolog to be incomplete.
Type declarations as subtype constraints in logic programmingWhite Plains, New York, June 20-22, 1990. erences above, types appear only at compile-time and standard Prolog-like computation mechanisms may be used. In contrast, there are also prescriptive systems where the underlying computation mechanisms are extended to support some form of typed unification [GM86, AKN86, Smo88]. Note that this does not imply that we intend to directly execute type declarations in a Prolog-like manner. Rather, it simply gives us a convenient model for types together with a sound and complete proof system for deriving subtypes. A type sys tem for logic programs. In Ehud Shapiro, editor, Concurrent Prolog Vol. 2. MIT Press, 1987. [Zob87] J. Zobel. Derivation of polymorphic types for prolog programs.
"Critical research directions in programming languagesLisp and Smalltalk systems suffer particularly from this burden, but so will ML and Prolog programs when their prototyping usage matures. The experience was reported of a 10,000 line Pascal program for factory scheduling which was recoded as a 200 line Prolog program. Moreover, the 200 line Prolog program could be maintained and evolved much more readily than could the Pascal program. Here, LP may be challenged: understanding Itorn clause logic does not really tell one how to use Prolog effectively. Prolog is neither sound (without the ""occurs check"") nor complete (due to depth first search)."
Unification-based semantic interpretationSuch constraints are commonly specified using sets of equations. 33 one equation per feature per constituent, but we can indicate constraints that would be expressed in other formalisms using more complex equations by letting the value of a feature contain a variable that appears in more than one equation. The CLE is written in Prolog, to take advantage of the efficiency of Prolog unification in implementing category unification, so our grammar rules are written as Prolog assertions, and we follow Prolog conventions in that constants, such as category and feature names, start with lowercase letters, and variables start with uppercase letters. In this case the rule says that the logical form of a sentence generated by the s_np_vp rule is an applicative expression with the logical form of the verb phrase as the functor and the logical form of the noun phrase as the argument. (The dummy functor apply is introduced because Prolog syntax does not allow variables in functor position.) [The notation Var\Bocly for lambda expressions is borrowed from Lambda Prolog (Miller and Nadathur, 1988).] The logical form for the whole sentence would then be apply(Xklike(X,mary),john), which must be reduced to yield the simplified logical form like(jobn,my).
A qualitative modelling environment for design & diagnosis of automationFigure 2 illustrates the various levels of knowledge and transformations between their representations. 3 Synthesising the Knowledge Base The task of generating a knowledge base is split into the following sub-tasks: • Development of an object-oriented qualitative component model • Simulation of all possible component failures to generate a set of examples • Compression of the examples to generate a diagnostic rule base 193 Causal Model I Qualitative Simulation Operational Knowledge I Rule Induction Compressed Operational Knowledge DEEP LEVEL SHALLOW LEVEL SHALLOW LEVEL Figure 2: Deep and shallow levels of knowledge 3.1 The qualitative component model The model has been constructed using an objectoriented language built on top of prolog, Prolog Object Oriented Language (POOL). POOL was developed at the Turing Institute specifically for the purpose of model simulation, and supports the following features: • Message passing (with arguments) between model components. • Forward chaining production rules as message responses. • Application dependent message sequencing strategies. • Component class hierarchy, allowing device behaviour to be inherited from the class level. • Interface to both prolog and a HyperCard type graphical interface enabling simulations to be animated. Device behaviour is specified in term of message responses written using POOL, while device attributes and faults are represented as prolog facts. An example of message responses is shown from a component definition in the model: 3.1.1 Robotics overhead camera camera response conveyor_look :: (set scan_region to look, forward_to conveyor, send [look_image] to vax as return_look_image). camera response conveyor_pick :: (set scan_region to pick, forward_to conveyor, send [pick_position] to vax as return_pick_position, send [pick_clarity] to vax as return_pick_clarity). camera response return_look_image :: if no_power then set look_image to true elseif narrow_aperture then set look_image to true elseif wide_aperture then set look_image to false else set look_image. camera response return_pick_image :: (if nopo.er then set pick_clarity to black elseif out_of_focus then set pick_clarity to blurred elseif narrow_aperture then set pick_clarity to dark elseif .ide_aperture then set pick_clarity to bright else set pick_clarity to normal, if no_power then set pick_position to inside else set pick_position). This allows for verification of both the diagnostic rules and the fault simulation. 4 Software tools The software has been developed on a Sun 3 workstation using Quintus Prolog and C. Use has been made of an internal development HyperCard type graphical package, which allows simulations to be animated.
Some uses of higher-order logic in computational linguisticsWe also describe a higher-order logic programming language, called Prolog, which represents programs as higher-order definite clauses and interprets them using a depth-first interpreter. As it turns out, most programming languages are poorly suited for an approach such as ours. Prolog, for instance, permits the representation and the examination of the structure of first-order terms, but it is not easy to use such terms to represent first-order formulas which contain quantification. We claim that Prolog has several linguistically meaningful applications.
Improved portability and parsing through interactive acquisition of semantic informationUsing domain knowledge to rule out semantically anomalous parses is especially important when parsing with large, broadcoverage grammars such as ours: Our Prolog implementation of Restriction Grammar -Iirschman 1982,Hirschman 1985] includes about 100 grammar rules and 75 restrictions, and is based on Sager's Linguistic String Grammar [Sager 1981]. We present in Section 2 the methodology we have adopted to collect and use selectional patterns, and then give in Section 3 some examples of the operation of our 1See [Ballard 1986] for a detailed and informative comparison of TELI, TEAM,IRACQ, T(A, and ASK. =PUNDIT (Prolog UNDerstands Integrated Text) is implemented in Quintus Prolog, and has been described in [Hirschman 1985] and [Hirschman 1988b] (syntax), [Palmer 19861 (semantics), [Dah 119861(discourse),and [Passonneau 1988](temporal analysis). 50 module. In Logic Prolog Programming and its Applications, D.I-LD. Warren and M.
A semantic-head-driven generation algorithm for unification-based formalismsA variant of our method is used in Van Noord's BUG (Bottom-Up Generator) system, part of MiMo 2, an experimental machine translation system for translating international news items of Teletext, which uses a Prolog version of PATI-II similar to that of Hirsh (1987). Yuji Matsumoto, Hozumi Tanaka, Hideki Hirakawa, Hideo Miyoshi, and Hideki Yasukawa. 1983. BUP: a bottom-up parser embedded in Prolog. New Generation Computing, 1(2):145-158. Michael Moortgat. 1984. Fernando C.N. Pereira and Stuart M. Shieber. 1985. Prolog and Natural-Language Analysis, Volume 10 of CSLI Lecture Notes.
Bottom-up beats top-down for datalogHowever, this algorithm is easily seen to mimic the search performed by Prolog's SLD resolution strategy, and in fact, it converges to an answer in situations where Prolog would enter an infinite loop and fail to return an answer. However, the correspondence is a bit subtle. Assuming no loops, Prolog will construct stacks of activation records for rules and goals, and each stack will correspond to a path from the root in the rule/goal tree. True rule/goal tree. different activation records, which Prolog constructs at different times. Each tuple of Si for a particular tree node corresponds to the bindings that occur in one or more of these activation records.
Book Review: Artificial Intelligence Applications in Materials Science by Ralph J. Harrison and Lewis D. Roth (The Metallurgical Society, 1987)Prolog is rapidly becoming one of the most popular languages for a variety of AI applications, including expert systems, export databases, and natural-language processing. Prolog by Example cox 3tains a large collection of problems with corresponding programs and comments. Chapters 3-19 serve as a guidebook for software development in Prolog, enhancing the approach of teaching the language by example.
"Task granularity analysis in logic programs&-Prolog is a parallel Prolog system based on strict- and non-strict independence [7] which uses a modified RAP-WAM abstract machine [S], and where annotations for parallelism can be automatic or userprovided. Tl: execution time with granularity control. Table 2: Execution times for benchmarks on &-Prolog with reasonable grain sizes [9], but does not discuss the compile time analysis necessary to estimate the amount of work that may be done by a call. C. S. Mellish, `Some Global Optimizations for a Prolog Compiler ,"" J. Logic Programming 2, 1 (April 1985), pp. 43-66."
An evaluation of MProlog by LogicwareA typical production cycle consists of: 1. develop a Prolog program source file using PDSS 2. apply the first two components of (b) to produce a binary program 3. interpret the binary program using the Interpreter. General impression is that his system offers quite good features for production of larger commercial software in Prolog. This is particularly evident in the modularity aspects catered for in the implementation. Some incorrect examples can be found, as well as erroneous and confusing References. Beginning Prolog programmers beware Modularity. Modularity is one of the redeeming features of this product.
CLP and constraint abstractionThe parameter D denotes a constraint domain which specifies the type of primitive constraints that can be expressed and solved using the language. For example, Prolog is CLP(H) where H is the domain of finite trees subject to equality constraints [STER 861, and Prolog II is CLP(1) where I is the domain of infinite rational trees subject to equality and disequality constraints tThis work was supported by NSF grant CCRg7189g9. In Section 3, we define the language CLP*(D) which is based on the constraint domain d(D), but which employs the program clause notation used in Prolog and CLP(D). The syntax of CLP*(D) is very similar to that of CLP(D) except for two points: 1) The user defines predicates by using Horn clauses to constrain predicate variables. Throughout we will precede an A-constraint (called the query) by the prompt symbol ?- as in Prolog, and the solution to the A-constraint will follow the symbol ==>.
"A version server for computer-aided design dataWe bave implemented a simple Validation Subsystem in PROLOG. Tbe PROLOG system is used as an elaborate pattern matcher, in which the validation scripts, specified as PROLOG rules, are matched against the event log, stored as time-stamped PROLOG facts, to l'ptove"" that the constraint is in force lot the returned objects (see Figure 5.1). We are investigating how to use PROLOG to infer unvalidated equivalence relationships from those that have been validated. This sequence of events is specilied in the Prolog rule, where the capitalized parameters are variables."
“KABU-WAKE” parallel inference mechanism and its evaluationFGCS is attempting to develop an AND-STREAM ,parallel inference machine, which executes the GHC (Guarded Horn Clause) language [7]. From the point of view of GHC, OR parallel Prolog, that is pure Prolog, is a language that is used to describe special types of algorithms such as a search problem. Therefore, when we think of the GHC-oriented machine as a general purpose parallel ~ inference machine, we can regard an OR parallel Prolog-oriented machine as a special-purpose parallel inference machine. As search problems appear in most AI applications, we think the OR parallel Prolog-oriented machine is quite valuable. 6. Acknowledgments The authors would like to thank Mr.
Two-level grammar: data flow English for functional and logic programmingLisp [McCaBZ]) and logic programming languages (e.g. Prolog [Cloc84]) are that they often have awkward syntax, are very cryptic, and usually have no data typing, thus causing programming errors which are more difficult to detect than in strongly typed languages. The list operations head and tail are implicit as in Prolog, the append predicate is referenced explicitly. While the overall structure of this program closely resembles a Prolog equivalent [Cloc84], we claim that this version is more readable because of the natural language vocabulary which is an integral part of the program and thus explains the details of the algorithm.
Introducing object-oriented programming into the computer science curriculumObject-oriented programming systems have become increasingly widespread as implementations of Smalltalk-80 [Goldberg 83,84] became more widely available and as object-oriented dialects of other languages, such as Objective C [Cox 84], C++ [Stroustrup 86], Object-Pascal [Tesler 84], Flavors [Weinreb 80], Common Loops [Bobrow 85], extensions of Prolog [Zaniolo 84, Vaucher 86], and Concurrent Prolog [Shapiro 83], have emerged. The students are already somewhat familiar with imperative programming languages (Pascal, Ada), and are introduced to the unfamiliar models of functional programming through Lisp, logic programming through Prolog, and object-oriented programming through Smalltalk. MIT AI Memo No. 602, Nov. 1980. [22] Zaniolo, C., Object-oriented Programming in Prolog, 1984 International Symposium on Logic Programming, New Jersey, Feb. 1984, p. 265-271. 102
ABSTRACTS: J - S I G S AM Japanese Special Interest Group on Symbolic and Algebraic Computation and Report of the Last Seasonal MeetingA vectorized code has been tested on vector computers VP100 (FACOM) and $810/10 (HITAC), and the CPU time has been reduced by a factor 30 for both machines. Symbolic Formula Manipulation System based on Prolog M. Noro, K. Yokoyama, T. Takeshima Intn'l Inst. for Infomation and Social Fujitsu Limited Sciences ShinKamata, Oota-ku, Tokyo 114, Japan Development of a symbolic formula manipulation tem based on Prolog language is planned contract with ICOT (Institute for Fifth sysunder Generation Computer Technology), We aim at a system which performs integration of elementary function by Risch algorithm. Its implementation involves all functions of formula manipulation and the main sufficiently sophisticated algorithms. Algorithms will be first implemented in Prolog on a VAX machine, then translated into the due language ESP on a PSI machine. Matrix out algorithms and Hensel lift-up procedures are language in order to avoid disadvantage coded in C from the lack of array func.tions of Prolog. C-coded modules for array function will be replaced by ESP-coded modules in the final system on a PSI machine.
"An attribute-grammar implementation of Government-binding theoryThe current version of the attribute grammar is presently being used to implement an English parser written in Prolog. Although the parser is not yet complete, we expect that its breath of coverage of the language will be substantially larger than that of other Government-binding parsers recently reported in the literature (Kashket (1986), Kuhns (1986), Sharp (1985), and Wehrli (1984)). Prentice-Hall, Englewood Cliffs, NJ Arbab, Bijan. 1986. ""Compiling Circular Attribute Grammars into Prolog."" IBM Journal of Research and Development, Vol. 30, No. 3, May 1986 Berwick, Robert and Amy Weinberg. 1984. Linguistic Inquiry, Vol. 9, No. 4. Kuhns, Robert. 1986. ""A PROLOG Implementation of Government-binding Theory."" Proceedinge of the Annual Conference of the European Chapter of the Association for Computational Linguistics, p.546-550."
"Abstracts of current literatureA ""universal grammar"" is defined, together with parameters of variation for specific languages. The system, written in Prolog, parses, generates, and translates between English and Spanish (both directions). The model has been implemented in an extension of Prolog, and runs on a VAX 11/750 computer. Susanne M. The experimental implementation is the appropriate Prolog program derived from that specification. The DLOG implementation relies on an extension to the standard Prolog proof procedure."
Architectural issues in designing symbolic processors in opticsAmong logic languages our focus has been on a parallel logic language, PARLOG [11], which is a derivative of Prolog and Guarded Horn Clauses. However, the essential conclusions for PARLOG apply equally well to PROLOG. We emphasized PARLOG because unlike the more popular PROLOG, the PARLOG computational model was inherently parallel. Concurrent logic programming languages, e.g., Concurrent Prolog, PARLOG [11], and Guarded Horn Clauses, alleviate the problems posed by the sequential semantics of Prolog.
"A logic-programming/object-oriented cocktail(iii) On the contrary, imperative programming languages, from BASIC to SMALLTALK have emphasized update through the concept of assignment but they do not have clean fixpoint semantics. I suggest here to admit this dichotomy (like PROLOG and relational system do) and to have clean queries defined the way suggested above and updates specified using assignments and imperative programming. Katayama Proceedings of the International Conference on Fifth Generation Computer Systems, 1984 [Nakashima 83] ""Data Abstraction in Prolog/KR"" H. Nakashima and N. Suzuki New Generation Computing, 1 (1983) pp 49-62 [Shapiro 83] ""Object Oriented Programming in Concurrent Prolog"" E. Takeushi New Generation Computing, 1 (1983) 25-48 Object Oriented programming and Prolog. [Tokoro 84] ""An Object Oriented Approach to Knowledge Systems"" M."
"Story driven animationThe last module generates actions on a graphics display and records them on video tape, The story understanding module is implemented using Prolog, because Prolog is one of the most suitable languages for natural language processing [3,7]. The if-then-style knowledge representation is suitable for stage directing. Therefore, it is also implemented using Prolog. The action generating module is implemented using Flavors, an object-oriented Lisp package [13]. Masako Ichikawa and Yumiko Koyama have contributed to the programming. [1] Chacola, D.G. and Schrack, G.G., ""Modeling and Animating Three-Dimensional Articulated Figures"", Proceedings of Graphics Interface '86 [2] Charniak, E., ""Towards a Model of Children's Story Comprehension"", A/TR-266, AI Lab., MIT, 1972 [3] Clocksin, W.F. and Mellish, C.S., Programming in Prolog, Springer-Verlag, 1981 CHI + GI 1987 [4] Doyle, J., ""A Glimpse of Cognitive Psychology"", Artificial Intelligence: An MIT Perspective, The MIT Press [5] Drewery, K. and Tsotsos, J., ""Goal Directed Animation using English Motion Commands"", Proceedings of Graphics Interface '86 [6] Marino, G., Morasso, P. and Zaccaria, R., ""Motor Knowledge Representation"", Proceedings of AAAI 1984 [7] Pereira, F. and Warren, D., ""Definite Clause Grammar for Language Analysis -- A Survey of the Formalism and a Comparison with Augmented Transition Networks"", Artificial Intelligence, 13, 1980 [8] Reynolds, C., ""Computer Animation with Scripts and Actors"", ACM Computer Graphics, vol. 16, no. 13, Jul., 1982 [9] Rumelhart, D.E., ""Notes on a Schema for Stories"", In D."
Hierarchically organised formalisationsThe set of logical statements would then be an embodiment of the meaning of the statute, and we might call it a logicof model of the statute [KS]. The exciting thing of course is that, using Prolog, this logical model can become a working model with which a machine can deduce the same consequences automatically. Meta-Level Predicates and Knowledge Representation Problems It would have been surprising had a general purpose tool like Prolog turned out to be perfect for such a specialised application as the formalisation of statutes, and in fact the main lessons to come out of investigations have been in the unearthing of problems of knowledge representation from the law's fertile ground. Consideration of our example knowledge representation problems can provide us with an indication of the kind of definition required. If the definition is in Prolog, it may also serve a `meta-interpreter' (or `inference engine') for the language in which the problems are represented.
PLEXACT: an architecture & design of a knowledge-based system for information systems developmentInference methods: include property inheritance through the IS-A hierarchy and pattern matching by the structures of semantic networks. 3. An example in PROLOG: /* link(node 1, node 2). */ isa(information_system, system). or in a more generic form: /* sn(nodel, link, node 2) */ sn(information_system, isa, system). Recent object-oriented language implementations have included PROLOG as a special object class [Digitalk, 1986]. A PROLOG program which is an instance of the PROLOGclass can be used to represent a rule-based expert system and be attached to a slot of an object. However, currently available PROLOG systems provide little support for object-oriented programming.
A law-based approach to object-oriented programmingThe law is a set of rules represented essentially by means of Prolog clauses. The law is enforced, in principle, as follows. When a message is sent, a gocrl ? send(s,m,t) is presented to a Prolog interpreter for evaluation with respect to the `set of rules comprising the law of the system. `Throughout this paper we use the so called Edinborough syntax [l] of Prolog, where variables are capitalized .and constants are written in lower case.
Reasonably priced compilers an interpreters for the IBM PC and compatible computersi PASCAL TURBO PASCAL UCSD PASCAL PILOT: UTAH PILOT PROLOG: PROLOG V PROLOG V-PLUS $49.95 Norell Data Systems $39.95 Software Toolworks $8O.88 Interface Technologies 3336 Richmond Av.
"A transformational approach to the derivation of hardware algorithms from recurrence equationsSocalled concurrent logic languages such as Guarded Horn Clauses 161and Concurrent Prolog 171meet these requirements. In these languages, a program for a hardware algorithm could be composed of some uniform predicates with different interpretations. As for notation, we basically follow a logic language Prolog 191.A capitalized symbol denotes a variable, and ""[AIL]"" denotes a list, where A and L are its car and cd* parts respectively. Shapiro,E.Y., ""A Subset of Concurrent Prolog and Its Interpreter"", Tech. Report TROOB,ICOT (1983)."
Esplex: A rule and conceptual model for representing statutesStarting off from a model based on propositional logic (3) which proved Inadequate for representing the expressive richness of legislative language, A.I. techniques for knowledge representation were adopted and a first rule-based system (HAAL, Harlani, Tlscornla, 1986) Implemented In Prolog created (4). ESPLEX Is still In the development phase. We also believe that the implicative form of representation is applicable to definitions (type 3). 4.1.2. Prolog as Implementation Language The rules are written with the formalism of Horn clauses and .are Implemented in Prolog. Cf13: the tenancy will not be cancelledl. Translated into rules, In accordance with the Prolog formalism, follows In the knowledge base: the section appears as Rules Permitted (termination, tenant, tenancy):- cond
Synthesizing a large concept hierarchy from French hyperonymsMator(:, Iarousse, Paris 1963) and coding them as a set of Prolog clauses awtilable for the KAI,IPS()S system. Concept type hierarchy and hyperonymy First, we must remind you how the concept type hierarchy is the necessary basis for any use of the Conceptual Graph model. The relation between the current meaning of the word and its hyperonym were encoded as a l'rolog clause (by hand). 4. Ixmps were suppressed by the application of Prolog consistency checking programs that introduced an additional syuonymous relation between concepts. We mean here that when wl < w2 and w2 < wl are found, we declare as a l'rolog clause that SYNONYM(wl,w2). 5. t'rolog programs were applied to the result in order to display it in a suitable way (see appendices A and B), and to have associative access to this data from Prolog. There is a difference between simple hypemnym definitions and compound hyperonym definitions.
GTS: parallelization and vectorization of tight recurrencesFigure 4.b shows the parallel code generated by a compiler for a single-recurrence hamiltonian loop with n statements. In this scheme we can distinguish three parts: prolog, core and epilog. The prolog part includes those statements and iterations extracted from the inner DO loop in order to use the same code for all the tasks in the core part. IF(jZ6) C&Ii] I Au-51 * OIj.51 ENDIF IF(is4) Bfj + 11 = q-31 ENDIF ...* .......... `prolog part . . . . . . . . . . . . . . *core part DOi=l+j,93,9 A[i + 31 = S[i] + 2 C[i+S] = A[i+3]`D[i+3] B[i+9] = C[i+5] ENDO . .._...._................................................ Figure 4.c shows the general vector code generated by the compiler for a general single-recurrence hamiltonian loop. We can distinguish three parts: prolog, core and epilog. The prolog part is the original loop in which each statement sj dbhg the graph (excluding the first one) is included in a conditional statement so that the wlj initial iterations are only executed.
Distributed variable server for atomic unificationThe algorithm has been implemented for the language Flat Concurrent Prolog (FCP) and is incorporated in the distributed version of the Logix system. Examples of languages with atomic unification are Flat Concurrent Prolog (FCP) [ll, 141, FCP(J,]) [13], and FCP(:,?) [8]. PI PI PI [41 PI bl VI PI PI WI [Ill Bar-on, U ., A Distributed Implementation of Flat Concurrent Prolog, M.Sc. Thesis, Weizmann Institute of Science, 1986.
Tool integration in the Pact environmentThe interfaces to these Common Services will be delined for each of the languages supported in Pact (C, Lisp and Prolog). The Common Services are an important mechanism for tool integration support. One part of the Pact project is de-g and implementing language bindings to the Common Services in Common Lisp and Prolog. The original definition is a C language binding. Thii may involve a radical change to the binding. One example is the definition of the Prolog interface to the Data Query and Manipulation Common Service.
"CRITTER: a translation system for agricultural market reportsThis schema is made up J a semantic refit (represented as a [imcto:['with a fixed arity), and a iMicatio of the elatiom,hip of the arguments to Ihe lexica] unit's syntae,i(: dependents. hi each Icxical cnhy, this complex of morphological, syatactie md setnantie :infi)rmation is specified as a feature sttuettue. 'it'fisfeature stuetmg is cucoded as a Prolog term that wc deserxbe indirectly, by means of predicates which access the relevam athibute values. Most of the syntactic rules that we use are, like (4.a), based on the simple context-free skeleton of definite clause grammars, with the same augmentation mechanisms: non-terminals have arguments and additional PROLOG goals (enclosed in braces) can be stated. The non-terminals in our rules are uniformly assigned a single argument, whose content is a feature structure, and the PROLOG goals are used to state mutual constraints between these feature structures. (iii) walk(inv-l: acress(2: X ) ) <-> traverser(2: X', inv-l: $manner(2: apied)). entry(i) is straightforward, entry 0i) expressesan ""argumentconversion"": john misses mary <=> mary manque djohn, entry (iai)expresses a morecomplexcorreslondanee:john walks across the str,n:t <=>john traversela rue d pied This lexicon is compiled into a set of Prolog clauses. The transfer algorithm then performs a simultaneous reeursive root-toleaves travta'sal of source and target semantic structures, making use of these clauses to maintain translational equivalence of the source and target structures."
Manhattanville College expert academic advisor--preliminary reportTo prepare for the project we did much library research. Several of us learned LISP and Prolog. After a survey of the literature, we decided that to try to build the system from scratch would probably have been too daunting a task. We also decided that we wanted a shell that would be reasonably flexible and that had the capability to interact with Prolog. We wanted a system that could eventually run as a stand-alone, turn-key system on an IBM PC or compatible. We are also considering the possibility of writing the entire svstem m Prolog, dispensing with the shell, and running it on our PDP 11/44 rather than on the PC's. 7.
Implementing the generalized word order grammars of Chomsky and DiderichsenThis type of system may be called Generalized Word Order Grammar (GWOG), and this paper deals with ways of implementing such a system on the computer using Definite Clause Grammar (DCG,Clocksin & Mellish, 1981), a formalism available in most Prolog versions. Definite Clause Grammar is a convenient rewriting system with an arrow (-->) familiar to generative linguists. Such restrictions or conditions are written within curly brackets ({ }) in Definite Clause Grammar, and they state which conditions are to hold on the variables specified. (Variables begin with capital letters in Prolog.) Two alternatives are shown with examples. The first alternative occurs if the fundament is an np: np(_,[Fund],[]). Cambridge, Mass: MIT Press W.Clocksin & C. Mellish, 1981. Programming in Prolog. Berlin: Springer P. Diderichsen, 1946 (3:rd ed).
"Review of ""Computational lexicography for natural language processing"" by Bran Boguraev and Ted Briscoe. Longman 1989.It also has been a rather 116 NaturalLanguageProcessingin LISP, POP-11, and PROLOG hard job for me to do so. The last paragraphs try to explain why. First of all, however, an objective and factual summarly of the contents and form of Gazdar and Mellish's NLP in X: An Introduction to CL, where X is instantiated to one of {PROLOG, POP-11, LISP} (reviewer's shorthand). Quotations can be helpful as the shortest way to give you a rapid impression. Therefore, one of the titles is treated here as prototypical (to wit, the Prolog volume). Whenever they differ, the other two are, subjex,tively, considered as derivative."
"Knowledge abstractionAt least two such marriages already exist. The Silogic Prolog [57] allows for calls both ways between Prolog and C, and Modula-Prolog [46] provides for calls both ways between Prolog and Modula. This problem has resulted in, for example, the use of control rules and other devices in expert systems and the ""cut"" and other control mechanisms in Prolog. Besides the need for immediate control over the use of knowledge, there are a number of additional control questions related to the use of knowledge. Reidel, Hingham, Mass., 1973. Muller, C. Modula-Prolog: A software development tool. IEEE Softw. (Nov. 1986],39-45."
AI in engineeringThe version of Prolog used is that offered by Expert Systems, International hosted on a VAX-11/780 under the VMS operating system. The implementation of expert systems and intelligent tutors uses Prolog and Lisp languages. A reduced version is available in basic. This work is generic in nature and is written in Prolog. The shells are used by a large number of people to prototype knowledge bases. 2.
A natural language interface for a flexible assembly cellSince the instruction interpreter is implemented in Prolog, thesentencesarerepresentedwith Prolog clauses.An assembly task for example is transformed into the Prolog clause: assemble{partl(Conc-PI, Actent-Pl, [plarg]), [pa.rQ(Conc-P2,ActentP2, Ip2argl. A parser for the instruction interpreter hasbeenconstructed. This parseris implemented in Prolog, since Prolog is very suitable where unification is concerned.
"A constraint approach to mastermind in logic programmingColmerauer, A., Kanoui, H. and Van Caneghem, M. ""Prolog, bases theoriques et developments actuels."". T.S,I. AI 8, 1 (1977), 99-118.. 8. Naish, L. Negation and Control in Prolog. Ph.D. Th., University of Melbourne, Australia, 1985. 9. Sigart 85 (1983), 28-29. 11. Sterling, L and Shapiro, E. The Art of Prolog: Advanced Programming Techniques. MIT Press, 1986. 12. van Emden, M.H."
"Expert system approach to VLSI cell design (abstract)Logic programming is a good method to mimic human reasoning using a deduction technique, from a set of assertions or facts towards a specified goal [4]. PROLOG is the main logic programming language which was chosen as Japan's Fifth-Generation computer project [5]. Specifically, the objective of this project is to develop a knowledge-based system for VLSI design written in Prolog. The body of knowledge of VLSI consists mainly of judgements and heuristics used by design engineers. Tarnlund (eds.), Logic Programming, New York: Academic Press, 1982. 5. W.F.. Clocksin and C.S. Mellish, Programmingin Prolog, New York: Springer-Verlag, 1981. 6. M.R. Barbacci, ""Instruction set processorecifications for simulation, evaluation and synthesis,""Proc. 16th Design Automation Conference, June 1979. ..... ,-..L.-:-,-...-- ' , a.-, :A:-_2-."
Convergence of sideways query evaluationTo copy otherwise,. or to republish. requires a fee and/or specific permission. 0 1986 ACM-O-89791-179-2/86/0300-0024 $00.75 Prolog interpreters assume a fixed order to subgoals. Since performance of Prolog is highly dependent on the order in which goals are written, we would like to automate the process of selecting the order. This result leads to a faster algorithm than that of Naish [Na] for testing the convergence of his class of Prolog programs. 2. DEFINITIONS DATALOG Queries A relational symbol A has associated with it a set Attr(A) = {.
An approach to control different versions of knowledge in object-oriented systems and its applications in FIREXWe suggest tagging existing objects with method resolution path to commit consistent coexistence of different versions of the graph inheritance hierarchy. FIREX will be implemented in PROLOG and LISP in cooperation with the fire brigade department of the city of Bremerhaven who is also the end user of the system. Besides a series of PROLOG extensions, the ob ject-oriented programming environment of FIREX in cludes an extension of the language Scheme which is a well-known LTSP dialect (/REES&V). FIREX obtains a declarative knowledge basis for these regulations including the exceptions which can be easily maintained. The knowledge basis has been materialized in PROLOG as it had been previously published (/BELLS9/). l Planning and supporting the 6re fighting actions.
Logic programming for large scale applications in law: A formalisation of supplementary benefit legislationFor example, our prototype formalisations are excecuted by APES [6], a PROLOG systemwhich is augmentedto generatedialogues with the user automatically, and to provide proofs of conclusions reached. APES works (like PROLOG) by reasoningbackwardsfrom a conclusion we want to establish, to data we have available. It works in PROLOG, but destroysany declarative reading that the formalisation has.Further, it precludesany possibility of using an alternative execution strategyon the formalisation.
Performance measurements on a commercial multiprocessor running parallel code(All programs are running in double-precision floating-point.) Non numerical programa. PROLOG database interpreter, C parallel compilation, FORTRAN/C mix parallel compilation. Table II shows the execution times for the different compilations. The PROLOG interpreter developed at the Laboratory [14] runs on a database containing the bus and tram network of the city of Zurich (VBZ). Note that the copy-back scheme still provides some reduction in the bus trafficalbeit small-compared with write-through. TABLE III Execution time (s) of PROLOG interpreter running on VBZ database. The S81b system is about 40% faster than the S81a system.
SIGDA travel grantsThe hybrid system incorporates the programming languages C and PROLOG. PROLOG is used to perform transformations from logic specifications to SIGDA newsletter, vol 16, number 1 complementary, domino, and zipper transistor 13 connectivity sets. The trend of programming language used in this direction of research seems to be switched from more procedural language to LISP and PROLOG. However C language still dominates when efficiency algorithms based designs are implemented. is concerned and when With respect to routing, I feel the following most important in the conference. topics are I) The use of channel routing compaction as a postcompaction technique to reduce the effects of large contacts and thus to reduce the channel area. 2) ne use of simulated annealing techniques for channel routing.
Analysis of memory referencing behavior for design of local memoriesThe total number of values in each class, with classes de5ned by a range of lifetime and number,of references, is shown in Table 2 for the prolog trace. The calculated upper bounds on the average number of simultaneously live values for several classes is shown in Table 3. LIFETIME o-1 l-10 10-100 100-l ,000 l,OOO-10,000 10,000-100,000 100.000-00 PROGRAM PROLOG, 2,580,905 REFERENCES, TOTAL OF 315,304 VALUES NUMBER OF REFERENCES O- l- lo- loo- l,ooo- lO,OOO- 1oo,ooo-1 10 100 1,000 10,ooo 100,000 00 94,708 86,033 76,447 309 33,245 2,244 2 4,962 1,142 79 4,642 1,007 35 4,867 4,083 1,241 248 9 1 I TABLE 3. NAME INSTRUCTIONS VALUES REF/VAL REF/INST c2 1,000,000 179,535 3,026,564 16.86 3.03 Gauss 1,ooo.ooo 815,457 4,451.168 5.46 4.45 Ld 813,441 332,935 3,000,768 9.01 3.69 Prolog 1,ooo,ooo 316,119 3,604,851 11.40 3.60 Troff 1,000,ooo 334,290 3.525,344 10.55 3.52 TABLE 7.
A high-speed hardware unit for a subset of logic resolutionAlthough the hardware is useful for other logic applications, we use Prolog examples in this paper, The first sections differentiate this research from other work and discuss the simplifications to the resolution problem. This design's parallelism is distinct from AND/OR parallelism. 4 Simplifying the Resolution Problem Resolution is the formal process of making a logical inference. In the following Prolog program father(X,Y) :- son(Y,X). son(dan, edward). The hardware performs lock resolution, the standard approach used in executing Prolog programs and a method that can theoretically perform all proofs or inferences (i.e., anything that can be proven from a database using logic can be proven using lock resolution).
"A progress report on SPUR: February 1, 1987We have retargeted the SPICE Common Lisp system and can execute sequential benchmark programs on a simulator, a3 For the purpose of supporting ""conventional"" programming, we are also creating a C compiler for SPUR, using the portable C compiler and Graham-Glanville code generation. As part of a class project, the performance of Prolog on SPUR was also estimated using simply expanding the intermediate language code for a popular Prolog interpreter into SPUR code. 34,35 We have designed a set of primitive extensions to Common Lisp for parallel processing and we are in the process of implementing them. Gaetano Borriello, Andrew Cherenson, Peter Danzig, and Michael Nelson, ""Special or General-Purpose Hardware for Prolog: A Comparison,"" Computer Science Division Technical Report UCB/CSD 86/314, University of California, Berkeley, October 1088. 35. Gaetano Borriello, Andrew Cherenson, Peter Danzig, and Michael Nelson, ""RISCs or CISCs for Prolog: A Comparison,"" submitted to ASPLOS II, February 1987. 313."
Automatic programming assistant for network simulation modelsThe system uses an interactive dialogue to define the AGVS. The system is written in Turbo Prolog for the IBM/PC. - Once the AGYS has been defined, the system writes the corresponding SIMAN code. The library of macros is written in GPSS/PC. ANPS contains 1,218 lines of Prolog code and 86 ,,ubroutines. The simulation code generated by ANPS is GPSS/PC (Minuteman 1986). -In: AIAA 5th Aerospace Sciences Meeting, New York, Paper 67-205. Turbo Prolog 2.0 Guide. (1986). Borland International, Scotts Valley, California.
LO and behold! Concurrent structured processesThus, as opposed to sequential logic programming langua.ges like Prolog, which are trunsformational systems, in the sense that given a certain input they will compute a certain output and then terminate, concurrent logic programming languages are ren.ctz%esystems, which continuously interact with the environment 1121. VULCAN: logical concurrent objects. In E. Shapiro, editor, Concurrent Prolog. MIT Press, 1986. H. Lieberman. Concurrent object oriented programming in ACTl. Takeuchi. Object oriented programming in concurrent prolog. New Generation Computing, l(l), 1983. [23] C.
"Typed unification grammarsLIST), lists will be written using the usual abbreviation for lists: the list of words ""John likes Mary"" will then be written as (JOHN LIKES MARY}). 3.2 The APPEND type as a relation One can also understand feature types as relations much like those in PROLOG. Let us recall the classical PROLOG definition of append: append( [] ,L,L). append( [XlL1] ,L2, [XlL3] ) :- append(L1,L2,L3). in I>ROLOG, the arguments of a term are identified by their positions in the term, and the presence 294 of all arguments is mandatory. This possibility (together with the fact. that typing IV enforced by the system) allows the writing of a typed version of append, in contrast to the untyped PROLOG version. 3.3 Type checking as deduction Contrary to PROLOG, there is no distinction in TFS between top-level types (which could be interpreted as predicates) and inner types (which could be interpreted as arguments): they are all typed FSs, and the same deduction mechanism applies for the top-level structure s well as for all substructures."
Intelligent simulation environments: identification of the basicsPure artificial intelligence development languages start with the traditional symbolic environments, Prolog (Clocksin and Meliish 19841, Lisp (Winston and Horn 19841, and OPS5 (Brownston, et. al. 1985). One system supports a Fortran simulation language and model. The other system supports a Prolog simulation engine which Is capable of monitoring and control (via parameter adjustment) the Fortran based simulation model. Most previous work has been coded In Lisp or Prolog, therefore collected expertise in the form of dialect specific knowledge representation can be found in the The user must understand the five types of basic knowledge necessary to completely model a real-world system.
"The limitation of logicThis gives a approximation to default reasoning (though, as good in this case, if executed by PROLOG, would give rise to an infinite loop, which can, however, eliminated by program transformation be techniques [8]). Holland, Shapiro E. Y., [1983]. ""A subset Concurrent Prolog and its interpreter"", ICOT Technical RePort TR-OOR, Institute of in New Generation Computing Technology, Shapiro E. Y. and Takeuchi A., Tokyo. [1983]. ""Object oriented programming in Concurrent Prolog"", in New Springer Verlag. Berlin. I, 13"
"Logical composition of object-oriented interfacesData types can be protected from TICS' type-free logic by being specified as being of type private. This technique is used in ""Persistent Prolog"" [Gray, Moffat and Boulay 851 [MofIat and Gray 861. [Gray, Moffat and Boulay 85) Gray, P.M.D., D.S. Moffat and J.B.H. du Boulay, Persistent Prolog: A Secondary Storage Manager for Prolog, Persistence and Data Types Papers for the Appin Workshop, University of Glasgow, Glasgow, August 1985, pp. 353 - 368. [Moffat and Gray 861 Moffat, D.S. and P.M.D. Gray, Interfacing Prolog to a Persistent Data Store, 3rd International Conjerence on Logic Programming [to be published by Springer Verlaq, editor E."
"Capturing software processes through the generated objectsLet us say, for instance, that the prototyping form consists of an accurate definition of the prototyping goals, an executable program written in Prolog, a description of the evaluation and synthesis of the prototyping process. There are numerous links between the features of these two forms, some knowledge, such as the assertions, is shared by all the forms, and it is possible to find a basic common representation. Prolog rules and logical clauses are strongly linked, and an interdependence relation can be used to notify mutual updates. [Bob 851 [BGL 851 [Ost 871 [Rae 851 [Rei 841 [Rei 861 [Rue 871 [Slo 841 Bobrow G. ""If Prolog is the answer, what is the question? or what it takes to support AI programming paradigms""."
"Book review: Theoretical Aspects of Reasoning about KnowledgeIt contrasts very nicely with the following paper by Ben-David and Sterling on an expert system for credit evaluation implemented as a Prolog program (""a few seconds._under UNIX on a VAX 750""). Miller supplies a Prolog model of a double-auction market such as a stock market. It is apparently implemented in LISP. MacRae describes a Prolog implementation of a federal income tax law problem-solving system, where the user helps guide the search."
Site reportsThe framework of our work may be sketched as follows: - Programming in Prolog (BIMProlog). -Programming is taking place on a SUN Workstation (SUN 2/120) by using the operating system UNIX bsd 4.2 version 2.0. - The natural language interface (NLI) will be dialogueoriented, and will have a kernel that is independent of application. - There are plans for a project management system as a pilot application. - We are developing a semantic representation language LOLA (LOqui LAnguage) for use in analysis and generation. This division will permit us to make some valuable comparisons between the LISP and PROLOG development environments, and between the resulting systems. The context sensitive constraints are expressed in a version of Restriction Language (Sager 1975) compiled into LISP. The SDC (PROLOG-based) system uses a top-down left-to-fight PROLOG implementation of a version of the restriction grammar (Hirschman and Puder 1986). 144 Site Reports 4.4.
Intensional concepts in an object database modelApart from notable exceptions such as SETL [Schwartz 731, Smalltalk [Goldberg & Robson 831, and Prolog [Clocksin & Mellish 811 in their various ways, programming languages have generally fought shy of providing more than toolkits for dealing with large collections other than arrays. Moreover, object concepts are deeply ingrained in natural language and human thought generally, and find their formal expression in the terms and classes of mathematical logic and in languages such as Prolog. This paper modifies and develops some ideas originally introduced as part of a comprehensive object database model [Beech 871. The treatment of Concepts may be seen to be in the spirit of Prolog functions, except that formulae are not limited to Horn clauses, negation is given its conventional predicate calculus semant its, and generative definitions are provided.
Logic programming with setsHow to model the physrcal structure of the data, and how to define query languages on structures that are more general than flat relatrons One popular model has been non-first normal form rclatlons (non IN&`), whch arc rclatmns m which the components of tuples may be sets of objects rather than sample, atomrc, objects Another mam direction of database research has been how to use logic programmmg languages, such as Prolog, as database query languages [UllSS] (BMSU86] [GM781 [HN84] [Nai83] [Re178][Kow79] Such a language provides a very natural way to express querres on a relational database Furthermore, by allowing recursion, we get a language that 1s more powerful than the relational algebra of Codd [AU791 There has been very httle work, so far, on combmmg these two approaches [BK86] [TZ86] [BNR*86] Thus means both extendmg the data model to capture more of the semantics of the data, while at the same time using a loge programmmg language as the query language In order to do tlus, we need to have some way to deal with complex objects m logic programs. Some types of data structures can be easily represented by Prolog structures Others, m particular aggregation, i e , formmg sets of objects, cannot Therefore, rf we are to use a logrc programmmg language as a query language for non-1NF relations, the language has to be extended to enable it to deal wrth sets of objects We concentrate in thns paper on the problem of how to extend logtc programmrng to handle clggregation We regard such an extension as an essential prereqursateto extending logrc programming to non- 1NF databases Furthermore, the extension we propose may also have applicatrons rn other uses of logic programming besrdes the database apphcations. LPS a logic programming language for nested relatrons To appear G M Kuper and M Y Vardr A new approach to database logic In Proc Thani Annual ACM Sympostum on Przncaples of Database Systems, pages 86-96, ACM, Waterloo, Ontario, 1984 J W Lloyd and R W. Topor Making PROLOG more expressive Journal of Logac Progmmmang, l(3) 225-240, October 1984 F Mazola and A Pirotte CQLF-A query language for CODASYL-type databases In Proc ACM Int?
"Simulated real-time intersection signal controlmlalls 11 3 8 8 11 9 12 I Figure 3: LECAR Controller Under SmallTalk. was tested together with the Prolog class showing the potential use of this object-oriented programming language. The Prolog subclass ""Oldcar"" is created to provide the evaluation, of traffic conditions, of using either the arriving demands passing through or the standing queues waiting at the intersection. Each time the user requests the control history, the program will display a set of bar charts. In addition, the system will also invoke the Prolog method, 'accumulate', to save the pattern and count the number of occurrences."
"Information retrieval activity in pre-university education in the United KingdomThe disciplines of building a database are being investigated in a BLR&DD funde d project with the rather misleading title ""Schools Prolog Information Retrieval an d Learning (SPIRAL)"" [11] . In particular the Logic Programming Group at th e Imperial College of Science and Technology in London has been involved in using th e declarative nature of the language to build and interrogate databases with primar y school pupils . A project on ""PROLOG in history teaching in schools"", funded by th e Nuffield foundation, and one which used Prolog for building and interrogatin g databases in geography are referenced in the CET database on current research an d development in the application of IT in education, mentioned earlier . (Chilter n Advisory Unit, Endymion Road, Hatfield, Herts, ALIO 8AU ) M . Schilling . Schools Prolog Information Retrieval and Learning . Newsletters 1-4 ."
STP: a simple theorem prover for IBM-PC compatible computersLUSH resolution is the sameform of resolution that used by Prolog. The unification algorithm used in STP is basically the one describedby Robinson [RO65]. Even though a complete proof system is assured,LUSH resolution with factoring and subsumptiondoes not appear to be powerful enough to perform well on most problems. LUSH resolution is used by Prolog quite effectively, this may be because Prolog is a constrained theorem prover rather than a generalized theorem prover and uses only Horn clauses [B&3], a subset of general fnst-order logic clauses. Clocksin, W.F. and Mellish, C.S. (1984). Programming in Prolog, 2nd Edition. Springer-Verlag, Berlin, West Germany.
Abstracts of current literatureFive criteria were suggested for judging these representations, and based on these criteria the representations were judged. This paper describes the SDC PUNDIT (Prolog UNDerstands Integrated Text) system for processing natural language messages. PUNDIT, written in PROLOG, is a highly modular system consisting of distinct syntactic, semantic, and pragmatic components. Query evaluation strategies based on the traditional PROLOG deductive mechanism are then examined to determine their efficiency under different environments.
The IX supercomputer for knowledge based systemsIXL defines procedural knowledge in the form of a clause in Prolog. For example, To connect nodes by a link: link(is-a, X, Y). link(not-isa, X, Y). link(instance-of, X, Y). link(a-kind-of, [X,Y,..], Z). link(source, R, X). link(destination, R, Y). link(rule, X, (( asst(R, X, Y):- . . . . prop(R, X, Y):- . . . . isa(X, Y):- . . . . instance(X, Y):- . ...)). The third calculates the sum and decides whether the sum exceeds 100 dollars or not. Although the rule looks like a clause in Prolog, notice that all the solutions of an IXL command can be determined simultaneously. Solutions of a predicate in Prolog are determined sequentially. Therefore, the IXM can be regarded as a parallel logic machine taking this viewpoint. c-5 NP4 6.
"AUTO STAR—a software development systemThe final Ada program° generic type Element is private, package PList is type Replist, type List, is access Replist, type Replist is record elem : Element, rest : List, end record, function EMPTY LIST return List, function ENTER LIST(i : List, e : Element) return function HEAD(ppl : List) function TAIL(ppl : List) end PList, package body PList is exception : ERROR, return Element, return List, function EMPTY LIST return List begin return NULL, end EMPTY_LIST, is function ENTER LIST(i : List, begin e : Element) return return new Replist,(rest end ENTER LIST, function HEAD(pp 1 : List) begin if ppl = NULL then raise ERROR, else return ppl.elem, end if, end HEAD, => 1, elem => e), return Element is 41 List, List is function TAIL(ppl : List) begin if ppl = NULL then return NULL, else return ppl.rest, end if, end TAIL, end PList, Prolog Interpreter return List is The first prototype of software system developed with AUTO STAR is a Prolog interpreter of 700 line ADT codes. ([Zh 88])o The specification consists This specification is also used as a testbed for the AUTO STAR systemo The development together with the scanner and parser consists of 2500 lines of Ada code and could be used as a basis for constructing a practical Toy Interpreter Prolog interpreter. The second prototyping system developed with AUTO STAR system is an interpreter for an experimental an imperative programming language called Toy. -Y.: ',On Specification Language Universe"", Proceedings of III CASCO Symposium, Beijing, 1987. Zhu, M.-Y.: ""A Prolog Interpreter: with AUTO STAR"", Technical Report, System Engineering, 1988. 45 A Formal Development Beijing Institute of"
"The 1985 Fredkin competitionOne heuristic used is minimizing a function d, where: d=a-n a = available hours n = hours to assign n=t-s t = total hours to assign s = actual assigned hours for a teacher. It has been a pretty good effort to use PROLOG for a nonmonotonic reasoning system, because PROLOG uses a ""NEGATION AS FAILURE"" structure and our second implementation has no inside full consistent nature of logic. I., Vol. 13, April 1980 Monfroglio A., ""School Time-Table Intelligent Design with PROLOG implementations,"" SIGART newsletter, N. 92, 1985 Rich, Elaine, ""Artificial Intelligence,"" McGraw-Hill, 1983 Stefik M., ""Planning with Constraints (Molgen: Part 1),"" A. Examples of these architectures are the dataflow machines[39,40], object-oriented architectures[41,42], Lisp machines[18,22], and Prolog-like machines, such as the Fifth Generation Computer System[14]."
Abstracts of current literatureLILOG-REPORT 3 Implementation Aspects of a Natural Language Understanding System in a PROLOG/DB Environment Studer, Rudi, and Walter, Bernd September 1986, 12 pp. This paper discusses some of the problems that occur when an existing database system (SQL/DS) is used for representing the various types of knowledge. Additionally, the design of a rapid prototype PROLOG/SQL system will be presented, which supports the exploration of various mapping and access schemes and considers the fact that the used knowledge representation methods will most certainly evolve during the course of the project. This is achieved by delaying the modification of the program due to the asserts and retracts passed during a proof after the successful evaluation of a goal. We contrast this clean semantics with the PROLOG style of modifying logic programs and discuss the reasons for losing the logical cleanness.
Configuration management by consensus: an application of law-governed systemsThis function is representedby meansof a restricted Prolog program L, which is interpreted as follows. Given a message sending act send (s, m, t ) , the ruling of the law for that act is defined by the evaluation of the Prolog goal send (s , m, t) with respect to L. This evaluation is expected to either result in posing a goal of the form deliver (. . . ) exactly once or result in failure (in Prolog sense). An example of the law is presented in Figure 1. Figure 1: Law L14 4'lhroughout this paper we use the so called Edinborough syntax [l] of Prolog, where variables are capitalized and constants are written in lower case.
"A problem in knowledge acquisitionTakeuchi, ""Object Oriented Programming in Concurrent Prolog,"" New Generation of Computing, vol. 1, pp. 25-48, 1983. This paper is an attempt to provide the functionality of objectoriented programming in a Concurrent Prolog environment. In a Prolog construct of the form A :- BI,_Bn is interpreted in a variety of fashions: l) A is true if BI and ....are true: 2) procedural interpretation, and 3) process interpretation (here the form can be thought of as objects)."
Book review: Annual Review of Computer Science. Ed. by J. F. Traub (Annual Reviews Inc.)proach then you could try Winston (1985) for Frames in Lisp, Frost (1986) does a reasonable job on how to get from data to knowledge representation, Chamiak et al (1987) is a good source for various approaches in CommonLisp, the trusty collection by Schank & Riesbeck (1981) is good for schema-type approaches, and there are numerous textbooks with examples of prolog (e.g. Bratko, 1987). The most impressive and sustained arguments for production systems as a knowledge representation formalism is found in Klahr et al (1987), the work by Newell and colleagues on the SOAR architecture, and of course Anderson's ACT*. I (1985) Readings in Knowledge Representation. Morgan Kaufrnann. Bratko. I. (1987) Prolog Programming for Artificial Intelligence. Addison Wesley. Although Artificial Intelligence is ranked as a major area along with hardware, software, theory, appliearions and special topics but the absence of several hot topics like Prolog and Neurocompufing is badly felt after the third volume.
"Reuse: the two concurrent life cycles paradigmExample tools: KL-ONE [BRACHMAN-851, PROLOG [ETT861, KEE, etc. o Classification and Organization Tools - Used to develop classification . knowledge about the domain and to organize domain information, based on this classification from many diverse sources (DA/CPA), Example tools: PROLOG, RLF [SOLDERITSCH-881, TEXT 204 [=A1 r STAIRS/VM [IBMI, etc. - Used to prepare online domain model documentation with tools such as hypertext tools, which point to the generic products prepared and their descriptions (all activities). Example tools: PROLOG/IBIS [HASJIM-891, KnowledgePro [KPROI , OWL [OWL], etc. 0 Documentation Tools - Used to produce documentation from multiple text, data and graphic images (all activities), - Used to assist the analysis filter through large amounts of online data (all activities). [GOBLE-891 - ""Structured Systems Analysis Through Prolog"" by Terry Goble, Published by Prentice Hall, 1989."
"Macro-by-example: Deriving syntactic transformations from their specificationsThese macros define two new special forms whose translation produces (through details that are of no concern here) an interface to an underlying Prolog semantics. (declare-syntax clauses ((clauses (varl . . .> cl1 . . .) >I (declare-syntax action ((action (fn el ,. .>> (fn (list (pattern el> . . .)I>> Without the ability to adapt the syntax, the interface would have been impossible to use (indeed, an earlier version of our Prolog semantics foundered on precisely this point). With these macros in place, we can write Prolog predicates as Scheme procedures in a moderately convenient syntax, for example: (define Append (clauses (y a d u v) ((nil y y)> (((a . d> u (a . v)> (Append d u v>>>) The production version [Kohlbecker 861 includes a number of additional bells and whistles. [Felleisen 85] Felleisen , M. "" Transliterating Prolog into Scheme,"" Indiana University Computer Science Department Technical Report No. 182, October , 1985 ."
Defaults in unification grammarThe reentrancy for all undefined features under f is represented by X1. The constant NIL of FML* is represented as a Prolog variable ( _Z in this case). Thus, the seemingly space consuming procedure of bringing a formula into FML* NF and transforming the output of (9d) into FML* is avoided completely. Eisele, Andreas & Derre, Jochen 1986 A Lexlcal-Functlonal Grammar System in Prolog. Proceedings of COLING 86, Institut fQr angewandte KommunikaUonsund Sprachforschung, Bonn, 551-553. Oazdar, Gerald & Mellish, Chris 1989 Natural Language Processing in Prolog. An introduction to Computational Linguistics.
"Equations, sets, and reduction semantics for functional and logic programmingEquations can also be used t unify terms and compute with pwrtially defined objects found in kq 0c languages, such as Prolog [CMSl]. Tbns we do not use unification as a primitive operntion in the languqje. Komorowskl, ""qIDG--The Programming Environment for PROLOG in LISP? In Laf/c mminf, Ed. K. L. Clark and S.- A. [WPP77] D.H.D. Warren, F. Pereira. and L. M. Pereira. ""Prolog: the Language and Its Implementstion Comparedwith LISP."""
Knowledge-based graph theoretic analysis of data flow diagrams: integrating CASE tools with expert systemsThe language for implementing the graph algorithms was chosen to be C for its speed and data manipulation facilities on our implementation machine. The target language for the knowledge base was Prolog. The merged substructures were outputted by the C code in the form of a Prolog source file. This was then read into the Prolog interpreter. The output of the Prolog program was a formatted ASCII file containing recommendations for improvements.
Using cautious heuristics to bias generlization and guide example sectionHowever, using algorithmic tools to solve a problem that is answerable only through heuristics renders those tools less useful. The system, implemented in PROLOG, was constructed from complex functional representations of data. Naturally, a project of this complexity involves the programmers very deeply in the implementation environment. PROLOG was studied as an applicative programming language, and yet it was discovered that it is possible to force procedurality onto PROLOG. Here the emphasis is not on specialized programming techniques, but on the programmer's ability to reason inside the problem domain and to communicate that reasoning through the language at hand, be it LFD's actual PROLOG code, or the code of some other computer SIGART Newsletter, July 1988, Number 105 Page 25
Logic-based approach to semantic query optimizationWe discuss the notion of deductive databases in a Prolog-like notation that we use for representing facts, deductive rules (intensional and queries. axioms), integrity constraints, A literal is either an atomic formula or the negation of an atomic formula. Clauses can be written in an equivalent form using implication, such as Rl & . . . & Rn + Sl v .a* V Sm for the clause given above. We use a Prolog-like notation throughout the paper and write this clause as Sl, . . . , Sm t Rl, . . . , Rn. If we use the procedural/declarative meaning of the semantically compiled queries, we can evaluate a query directly in a PROLOG deductive database system, such as MU-Prolog [22].
Computational comparative studies on Romance laguages a linguistic comparison of lexicon-grammarsThe system being quite supple, the user can create his own environment a) by modifying the deduction rules b) by building new structures according to linguistic choices different from those reflected by existing classes (in that cas TRANSLEGSwill make a class from the choosen definition property and those linked to it). The system is written in PROLOG and runs on a VAX Il/ 750 from Digital Equipment. 3. Conclusion We would like Translegs to be computer tool for two main purposes: - To allow an ordinary user to consult comfortably a linguistic data bank, - To allow a linguistic researcher to work to a scientific description of a language or of two (or more) languages to compare by modifying and/or going deeper into lexical or grammatical informations already within the data bank made available by our laboratories. COLMERAUER, A. (1983) Prolog en 10 figures, Proc. of 150 of IJCAI DE ANGELIS, A.(1984) Nominalizzazioni con verbo supporto AVERE, Thesid Diss. unpubl. (eds.), Langue, dialecte, littrature, Leuven University Press ROUSSEL, P. (1975) PROLOG: manuel de rference, Universit# Aix-Marseille 2 Vasseux, P. (1983) Syst 6me LEXSYN, L.A.D.L.
"Learning the space of word meanings for information retrieval systemsHowever, we can determine tile position of the uotion, because we know the notion has relation with wholism, redueLionism, mu, Goedel, Esther, l:laeh and so on. procedm-ul ? wholism 9i t Prolog J i i I I i f i i declorative re du ctionism ?Goed et f i Esther i Goedel Boch I 1 Esch it Bach I i i i (*)Fig. 1 is an explanatory example for the readers who are not familiar with Japanese literature. You can understand what 'something between' in the previous sei 1- tence means by looking at the configuration of tile neighbor space. For example, if you see neighbor ""Prolog' between 'declarative' and 'procedural', you know that ""something between' means tile same kind of relation as 'Prolog' between ""declarative' and 'procedural'. For the same reason, from the linguistic point of view, the semantic spac, e el be useful for under.. standing metaphorical expression such as ""Hofs.. tadter is Prolog between procedural semantics and declarative semantics""."
"Using Ada as a language for a CAD tool development: lessons and experiencesThe advantages above are based on a comparison with ""conventional"" HDL. But, for some years, languages such as Prolog and Lisp have been used for hardware simulation. According to Mouly's paper, for instance, Prolog is too slow (e.g., it cannot be compiled efficiently) and several attempts have to be made before a solution can be found even when faced with a simple problem. When several solutions can be found, these arise mainly from the backtracking feature of Prolog. To reduce the number of possible solutions, rules must be introduced."
Providing natural language assistance in locating objects: a general model for information selection and generationThe linguistic component has not been the main emphasis of the research, but was developed sufficiently to provide for natural language generation that could be used to evaluate the selection algorithm as well as determine if a simple generation scheme would be sufficient. 4.5 Program Results GALOP is written in Quintus Prolog, a version of Prolog (see Clocksin and Mellish [2] for a description of Prolog) which allows for compilation of the code, resulting in much faster execution. functions as a stand-alone interpreter. When executed under moderate load conditions using the compiled version of the code available with Quintus Prolog, the program responds at an average rate of two to three seconds elapsed time per sentence. Cambridge University Press, New York, 1985. [2] W. F. Clocksin and C. H. Mellish. Programming in Prolog. Springer-Verlag, Berlin, first edition, 1981. [3] Barbara J.
"Retrieving re-usable software components by polymorphic typeA very similar problem arises in the implementation of the programming language Prolog. Instead of a key type there is a current goal to be satisfied, and instead of the collection of library component types there is a collection of available heads of program clauses. ACM Transactions on Programming Lunguuges and Systmt~ 4(2), pp. 258-282 (April 1982). D. H. D. Warren, ""Implementing Prolog - Compiling Predicate Logic Programs"", Research Reports 39 & 40. Komorowskl, ""QLGG - the programming environment for Prolog in LISP"". in Logic Programming, ed. K. L. Clark and S."
"Content oriented relations between text units—a structural model for hypertextsThe command ""find(`Operating System')."" entered via the ""Prolog"" window is equivalent to the browse-sequence mentioned above. IMPLEMENTATIONAL REMARKS The development of the TOPOGRAPHIC system is supported by BMFT/GID under contract '1020018 1'. It is implemented in Prolog and C on a CADMUS 9200 with UNIX. The Prolog-System as used in TOPOGRAPHIC was developed as part of the project by augmenting the IF-Prolog interpreter with new built-in predicates. Additional to common features of Prolog it supports accessto frame based knowledge bases and graphical tools for interface management, which are implemented in C for the purpose of efficient execution."
Extensions and foundations of object-oriented programming., Horn clause) relat,ional programming by the same approach previously used to unify functional and relational programming [12], this is relatively straightforward as language design, but presents some interesting implementation problems. 1.1 Logical Programming The original vision of Logic Programming called for using pure first order predicate logic as a programming language 1141. Prolog [l] only partially realizes this vision, since it has many features with no corresponding feature in logic (e.g., cut, is and assert), and it also lacks some important features of logic (such as semantic 1Supported in part by Office of Naval Research Contracts N00014-82-C-0333 and N00014-85-C-0417, and a gift from the System Development Foundation. These foundations are very genera1 and in fact apply to any logical programming language, in particular to FOOPS. They should also apply to ordinary Prolog, and perhaps even to such impure dialects as Concurrent Prolog. 1.4 Acknowledgements We wish to thank: to SRI International and the Center for the Study of Language and Information at Stanford University, where this work was performed, the National Science Foundation, the Office of Naval Research, and the System Development Foundation, which supported it, and Prof. Of course, this simple approach does not handle everything one could imagine (such as programs whose execution modifies the basic datatype definitions), but it seems clear that it can handle assert and retract in Prolog, and the usual imperative constructs. Presumably, one could even give an algebraic definition of FORTRAN in this way!
"An eclectic 5th generation architecture for ultra high speed computingExisting appropriate high level development languages (e.g., SISAL, Prolog) will be applied to the problem of researching techniques for parallel coding test applications. Prolog is concerned with knowledge bases, ordered rules and facts as very high level ""frames"", SISAL is a dataflow implementation language appropriate for research. However, the ICOT research activities have concentrated on machine architectures for knowledge-based systems based on high speed Prolog and relational database machines (Kawanobe 1984) involve no direct research on artificial intelligence or human-computer interaction."
A pictorial aid for programming expert systemsFor instance, the advising system referred to was developed using an expert system shell that allowed PROLOG goals to be written that can be called by the system. The antecedents of certain rules are values generated by PROLOG goals or, in facL are PROLOG goals themselves.
"A rule-based message filtering system`If I receive a message that is from Dept 9W20 with the words AI, PROLOG, or screening in the content, then file it in my ""AI"" box. 3. FILE Al MESSAGES IF: from(9W20), content(natural SYSTEM RESPONSE: The new rule `FILE Al MESSAGES' conflict If s message wers from toronto), wlth the content words Al MESSAGES speclfles messages that I can resolve. language, screener, prolog) THEN: file (al) and the old rule `FILE TORONTO MESSAGES' would locatlon toronto (because 9W20 works at location natural language, screener or prolog. ISCREEN IMPLEMENTATION 4.1 Programs The ISCREEN prototype is implemented Waterloo UNIX PROLOG.' on a VAX 750, using Franz LISP and LISP was used to implement the forms and screen management utilities used in the interface, system was implemented using PROLOG. existing Office Information while the core functionality of the To integrate ISCREEN with the System, two new types of programs were added: a Screening program and an Interface program."
"Database theory—past and futureDatabase Theory: Past and Future Jeffrey D Ullman* Stanford Umversl ty ""The past as prolog "" ""The future IS Prolog too "" We brlefly sketchthe development of the vanous branches of databasetheory One Important branch ESthe theory of relational databases,mcludmg such axeasas dependency theory, umversal-relation theory, and hypergraph theory A secondImportant branch IS the theory of concurrency control and dlstrlbuted databases Two other branches have not m the past beengiven the attention they deserve One of these 1s""logic and databases,"" and the second P ""object-oriented databasesystems,"" which to my thmkmg Includes systemsbasedon the network or hlerarchlcal data models Both theseareasare going to be more mfluentml In the future 1 Apologies I hope the reader ~111forglve me for using the pronoun ""I"" in place of the tradltlonal ""we"" This document IS a personal, >ubJective account of what I thmk IS gomg on m the PODS commumty and what I think should be gong on, these are not necessarily one and the same thm,, May the reader also forglve me for not preparmg a decent blbhography Because of the short time *Work supportedby NSF grant IST-8412791 and a grant of IBM Carp c) 1987 ACM 0-89791-223-3/87/0003/0001 754 avalable to prepare this paper, I have Instead cited several excellent secondary sources for detailed references to the hterature Only some papers that I regard as seminal or likely to be mfluentlal m the future are cited directly 2 On Theoretical Computer Science The PODS commumty IS generally regarded as a branch of theoretical Computer Science, It 18rarely regarded as a branch of database systema, which 19 probably sad As part of theoretlcal CS, we are gomg to be affected by a profound change m the nature of the subJect theoretical CS 1s in the process of fisslonmg into two, or perhaps three parts One part 1sbecommg a branch of Mathematics As the field has evolved, some problems worthy of the best mathematics have been uncovered, and they are now being attacked with the toolkit of the mathematlcmn P = NP ISa fine example of such a problem These questions, d solved, will say very little, d anythmg, about how to compute (well I'm assummg that, m fact, P # NP), yet they are recogmzably mterestmg and exciting questlons There ~111remam a small core of sufficiently general theoretical issues that, while they apply to many different subareas of CS, belong to no one area exclusively These subJects include algorithmic techmques (e g , probablhstlc algorithms and protocols), algorithms for very general sorts of problems (e g , reachability m graphs), and perhaps new work m data structures The remainder of what 1snow called theoretlcal CS will become integrated with other subareas of CS These branches are what now IS carried out m the conferences, PODS among them, that are Jomtly run by SIGACT and one or more other SIG's Perhaps an analogy will help Justify these predlctlons Electrical Engineering 1sa field that has, unlike CS, matured mto a stable configuration In EE there are certam foundational, ""pemxl-and-paper"" subjects analogous to (2) above, such as circuit analysis and sjuthesls However, there IS no such thing as ""theoretical EE "" Rather, different people m that field will respond to problems m dlfirent ways some by wlrlng things together, others by picking up a pencl1 The former correspond to, say, database systems implementors and the latter to database theor&s The difference 1sone of approach, there IS still a shared subJect matter between more and less theoretical engineers m a subfield like Integrated clrcult design Slmllarly, I hope that m the future, we shall not see a large difference between the subject matter of ""database systems"" and the subject matter of ""database theory "" The Iustorlans among us will perhaps remember that the PODS conference was started m response to the mablhty of the more theoretically mchned of the database community to find a home m the mainstream database conferences I'm not sure that the separation of theory from practice IS m the best interests of anyone, and if you believe my model for the evolution of theoretical CS, then you should expect that this Isolatlon will eventually end 3 Branches of Database Theory Since Its inception, the PODS conference has had two prmclpal threads 1 Relational database theory, mcludmg such sub areas as a) Dependency theory b) Universal relation theory c) Acyclic hypergraph theory 2 Transaction theory, mcludmg single-processor and multiprocessor environments and techmquea for assuring a) Atomlcity of transactions, 1e , concurrency control, b) Consistency of rephcated data, and c) Reliability m the face of hardware and software failures To these, I wish to add two more branches worthy of mention 3 The influence of the third branch was felt at the 1985 PODS and appears to have survived for this conference the field called ""logic and databases"" or ""deductive databases "" 4 The fourth branch has, m a sense been around longer than any of the other three, yet has had remarhably httle Influence on the theory Today I shall have more to say about all four of these It IS called ""obJect-onented"" database systems, but I place its roots at the dawn of time, that IS, m the early 1960's along with the first true database management systems threads and how they may mtertwme m the future 4 Relational Database Theory Of course the whole field begins with the paper of Codd [1970] That paper was so profound, that it took five years before Its Imphcatlons could begin to be understood m either the theoretxal or the practical arenas I remember readmg the paper when It first came out and sneering at its foolish attempt to throw some mathematical termmology at what it claimed was a real problem Well, we hve and learn, I guess My squad of history buffs (see the acknowledgements) mdlcate some of the precursors to the field Ed Sclore pomts out that Bosak et al [1962] gave an algebra for relations, prlmarlly for operations on single files or files that needed to be merged Then termmology %reas,"" ""bundles,"" and ""glumps,"" mdxates how much influence this paper has had on the field, it also should make one appreciate Codd's lucldlty The report by Kuhns [1967] anticipates relational algebra as a query language There was even a followup by DlPaola [1969], which showed that domam Independence (generalized ""safety"" of queries) IS undeadable, a result that has surfaced again m recent months Chllds [1968] gives a theory of relations as data that has had little Influence, possibly because of that author's expository style Dave Maler notes the report by Flllat and Kranmg [1970], which has relatlonal algebra (minus selection), functional dependenues, and the conchtlon under which a decomposltton is lossless With Armstrong [1974], a rigorous theory started to emerge However, that paper failed to stimulate much activity because it was ""Just"" theorems, It didn't look at schema design, or complevlty issues, which are necessary to turn theorems into tools It wasn't until Bernstein's thesis (Bernstein [1976], Beer1 and Bernstein [1979]) that anythmg resembling a theory began to develop That work, giving a design theory for third-normal-form database schemes, 1s ancestral to almost all the developments m relational database theory that followed It put normalization and dependency theory on a sound footing, and one can see it as the orlgtn of the ""umversal relation"" idea Bernstem unfectrtl Beer1 that year, when Catrlel was vlsltmg Toronto We hired Beer1 at Prmceton the next year, and he infected me and a number of the graduate students there Honeyman, Maler, Mendelzon, Papadlmltnou, Saglv, Sclore, and Yannakakls Bernstein then went to Harvard, where he infected Goodman, and through him Shmueh, wlule Beer1returned to Hebrew University where he Infected Vardi In addition, there are at least a dozen other people who were either students or colleagues of the people mentloned above, who later got Infected with the relational database theory bug and were thereby caused to pubhsh papers m PODS Thus, even if you don't trace the origin of the field to Bernstein [1976], you at least have to trace the population explosion back to that point 4 1 Dependency Theory The paper that really got the field gomg was F&n [I9771 on multlvalued dependencies 1 Until that point, the world's mtultlon was that functional dependencies were the only hind of constramts one could put on relations I remember quite well Catrlel Beer1 trymg to explain to me how the ""theorem"" that AB w BC IS a lossless Join d'B-*AorB+C was true only If you assumed that the sets of possible relations were defined by FD's only, and I had a great deal of trouble grasping that point With Fagm's paper, it suddenly became clear that there was a whole spectrum of formahsms (that IS to say, classes of dependencies) one could use to define sets of ""legal"" relations, and each one led to a theory of Inference, of normal forms for databases, and of database scheme design Of course, as theoretlclans do, we went ape and forgot the matter of motlvatlon for consldermg such dependency classes Lpe ,lulckly learned far more about the subject than \%a\necessary, a process that contmues to this day Hather than review the entire hterature on the subject let me refer the reader to Maler [1983] or Fagm and Vardl [1986] for comprehensive blbhographles on the subject of dependency theory, as well as the next two topics, hypergraph theory and universal relations 4 2 The Theory of Universal Relations It 1shard to tell where the ""UR assumption"" comes from The idea that data can, at least m prmaple, be thought of as resldmg m a smgle relation IS an mtultlvely appeahng one I see m Bernstem [1976] the Implicit assumption that It makes sense to talk about attributes dlsembodled from any particular relation scheme, and therefore, with a meaning of their own The reader may well be aware of the controversy that surrounded the Idea, almost from its begmnmgs In a nutshell, many, including me, were too anxious to assume that because the idea was mtellectually ""clean"" and ""natural,"" it was therefore useful The detractors, on the other hand, were too amcious to assume that because the notion did not solve all problems, it therefore solved nothmg The controversy began to die down, and nature was allowed to take its course, when the UR idea was put on a mathematlcally sound footing The breakthrough was Mendelzon's ""weak"" or ""representative"" Instance view of universal relations, eventually published as Mendelzon [1984] and explolted by Sagiv (19831m a real system As with dependencies, there are m fact many sound ways one can view the umversal relation Maler, Rozenshtem, and Warren [1986] IS a key paper integrating these cbffermg vlewpomts They also survey a surprisingly large number of systems that have, Imphcltly or exphatly, used the UR Vlewpomt, unfortunately, most of these systems were prototypes, rather than commercial ventures 4 3 Acyclic Hypergraphs It IS natural to describe a database scheme as a hypergraph, where the nodes correspond to attributes and the hyperedges are the sets of attributes that are the scheme for one of the relations Certain very useful properties, such as efficient algorithms for query processing, are possessed by a natural subset of these hypergraphs that has become known as ""acyclic "" Thrs class was Investigated m two different problem areas with quite different, yet equivalent, notations 1 They were Investigated as a class of queries m distributed databases for which optimal processmg IS ample, by Yu and Ozsoyoglu [1979] and Bernstein and Goodman [1981] 2 They were regarded as a class of database schemes for which queries on a universal relation makes sense m Fagm, Mendelzon, and Ullman [1982] It turns out that there are several notions of acychcity related to the one mentloned above, and each has properties of Interest to database theory The synthesis of the subject came m Fagm [1983], which outlined the properties of this and three other types of ""acychclty"" for hypergraphs 5 Transaction Theory The ancestral papers for the theory of transactions m database systems are by Eswaran, Gray, Lorle, and Tralger [1976] and by Stearns, Lewis, and Rosenkrantz [1976] In these papers 1sfound the idea of serlahzablhty as a desirable and feasible way of defining correctness of concurrent transactions The former also gives the fundamental two-phase locking technique for enforcmg serlahzablllty I don't pretend to be an expert on such matters as concurrency, rehablhty, or dlstrlbuted databases My subJectWe view 1s that the next developments pioneered the work on the extent to which twophase locking IS essential The paper by Sllberschatz and Kedem [1980] exposed how different assumptions about the structure of data led to algorithms different from two-phase locking for controllmg concurrency optimally, while Papadlmltrlou [1979] slmllarly exposed how our notion of serlallzablhty was dependent on what we thought atomic operations were A careful treatment of theoretlcal issues m concurrency control for single-processor systems may be found m Papadlmltrlou [1986] Some of the theory for distributed systems 1sm Cerl and Pelagattl [1984] 6 Logic and Databases The booh edited by Gallalre and Mmker [1978] launched the study of logic as an approach to solving certain problems m database systems enriching the query language, handlmg mlssmg or unknown data, and allowmg assertions such as ""A or B IS true"" that typical DBMS's do not handle Two of the papers m that volume, Relter's work on the closedworld assumption and Clark on ""negation as failure,"" are ancestral to the currently exploding work on ""nonmonotomc reasonmg,"" or how one makes vahd inferences from the absence of particular facts m the database A somewhat different direction was mltlated m Aho and Uilman [1979] and Chandra and Hare1 [1980] In these papers, the comparative expresslblllty of forms of logic, treated as query languages, was considered The former also mltlated the apphcatlon of query optimization techniques to languages more expressive than relational calculus At the risk of appearing to pat myself on the back too vigorously, I would hke to cite Ullman [1985] as representative of a new dlrectlon m the loglc-anddatabases field This paper, which manages to be both naive and mcomprehenslble at the same time, ntavertheless says two very important things 1 It IS not enough to worry about e\presslbdlty issues, I e , what does your logic say, does it have unique mmlmal models, and so on7 Rather, we have to think about efficiency Issues, because ultimately, the logic IS going to be used as a query language m a real system This system ~111need tcl optimize queries efficiently, because queries are going to be complex, mvolvmg layers of abstraction built from the logic, and possibly recursive definitions Of course, It will need to process the logic, m its optmllzed form efficiently as well 2 You can make a contribution to the processing of loglcal queries without solving the general problem of processing arbitrary queries efficient]! 21f that's not It, then It must be the nomenclature ""UmverssJ relations,"" conveys nothmg to the bstener, and has always sounded to me vaguely &rty I thmk we'll do much better m the next round, now that we've learned to give our Ideas spiffy names hke ""magic sets,"" FADL, or even NAIL' 8 2 Concurrency Control Here 1sanother area of theory that deserves a better fate The models are sufficiently simple to state, and the dynamic behavior of the systems sufficiently subtle, that proofs of correctness of protocols should play an important role m the development of real systems Perhaps the problem IS that we have been too given to mvestlgatmg the ideal, the algorithms that provide maximum concurrency, rehablhty, deadlock freedom, and so on, under various aszumptlons, that we have not taken the time to develop a design theory Most of the questions that need to be answered to assure optimal performance are intractable The real question m practice 1soften how the throughput of the system can be maxmuzed, by balancing the costs of unnecessarily serial behavior with the costs of deciding what transactions should be permitted to do at any given time 8 3 Dependency Theory Is it possible that this subJect IS being 
exhumed by Saglv [1987]7 The surprise 1s that eqmvalence of sets of dependencies 1s the same as eqmvalence of ""datalog"" programs (Prolog without the function symbols) You need to be able to tell when two programs are equivalent if you are to optlmlze them, and optlmlzatlon of datalog 1san important area for research (see Section 10 ) 9 Knowledge-Base Management Systems It 1s not a well-kept secret that a blending of ""AI"" systems and database systems IS all the rage on both the pragmatic and theoretical fronts Spouting terms like ""expert database system"" or ""knowledgebase system"" yield an instant welcome mto the best of circles One might wonder exactly what a ""knowledge-base system"" is, and how It differs from the garden-variety ""database system n I used to thmk the difference was that knowledgebase systems could do recursion, while database systems use a restricted query language so that access may be done efficiently Fkcuralon seems to be Important for the next generatlon of apphcatlons, such as database support for large-scale design systems, It 1salso necessary for such ""AI-&"" appllcatlons as probablllstlc reasoning or default reasoning However, if you thmk about it, all database query languages are embedded m host languages with the power of a Turing machine Therefore, In prmclple, any database system can do what any other kind of system can do The dlstmctlon between a database system and a knowledge-base system 1s rather one of degree, rather than of different capabllltles COBOL simply IS not as good a vehicle for expressing recursion or for mterfacmg with the user as 1sSmalltalk or Prolog I suggest, therefore, that we confine the use of the term ""Knowledge-base system"" (KBMS) to systems that 1 Provide the efficiency of data access,concurrency control, and rellablhty of a database system, and 2 Provide the user with the ablhty to structure data, to invoke previously written procedures, and to manipulate data m arbitrary ways, using a language or other interface mechamsm that 1s significantly better integrated with the database than are traditional DBMS's As introduced m Sections 6 and 7, there are two competing approaches to the design of KBMS's, and this competltlon mirrors the war between relational and other data models Recall that there are two rather different approaches to the representation of data, which we may call ""obJect-onented"" and ""value-oriented "" 9 1 The Case for Value-Oriented Systems Relational systems are value-oriented, tuples cannot be distinct if they have the same values m correspondmg components Logic-based systems generally use the same data model and should be considered valueoriented As dlscussed m Section 7, these systems have certain problems Their schemes are subJect to the anomalies described by Codd [1970], and we have to be careful not to lose relationships that are represented by Juxtaposltlon of values Because queries can exploit equality of values among arbitrary collections of fields, optlmldatlon of query processing becomes a vital issue naive evaluations of queries are often too slow to be useful Because we must optimize queries, the query language must be sufficiently stylized that the system can be expected to optimize queries well Thus, integration of the query language with a general-purpose host language 1sdifficult Because queries (and therefore, view defimtlons) return copies of data, rather than the data itself, update through views 1shard to define, let alone do ""correctly "" On the other hand, there are key advantages to valueoriented systems too a They encourage the use of declarative program ming, where one expresses what one wants to have happen, rather than how It 1sto happen 21 Queries can be composed easily, because the data types of Input and output match 211 They do not restrict the use of the database to predefined access paths 9 2 The Case for ObJect-OrIented Systems Object-oriented systems present the mirror image, when we consider their plusses and minuses In their favor Since entitles have independent existence, obJectoriented database schemes have an easier time avoiding anomalies Because queries generally follow built-in connections, the system does not have to do extensive query optimization The same language can be used for scheme design, access control, database access, and computations normally done m a host language View descrlptlons and the description of sets to which update IS to be applied produce objects, rather than copies of data, so the semantics of update IS unambiguous Yet obJect-oriented systems present these dlsadvantages a la 221 93 Declarative programming 1s hard to integrate with object-oriented systems Queries do not compose easily, because ""methods"" require data of a particular type, rather than treating all data as of type ""relation "" The dlctlons of obJect-oriented languages favor the user who follows built-m links within the data, I e , those who can use the ""methods"" provided Queries that do not use built-m Imks may not be supported at all, or are supported only with difficulty Future KBMS's A plausible guess regarding what ~111happen m the future IS that development of KBMS's will follow the same trajectory as DBMS's The first to become wallable will be object-oriented, indeed the first commercial system of this type 1s already on the market, and more are expected to follow closely These systems arrive first because they are, frankly, easier to implement, they throw onto the user the task of optlmlzmg database accessthat value-oriented systems take upon themselves However, eventually, value-oriented systems ~111 become available, and these ~111prove more deslrable for the same reason that relatronal systems are generally preferred over other systems (at least for databases that do not have to rely on a mass of existing data in nonrelatlonal format) Value-oriented systems will wm simply because they offer the user arbitrary accessto data, with accessexpressed declaratively 10 KBMS Research While trends m research are very hard to predict, let me offer some guesses 10 1 Optimization of Specml Cases of Logic This guess IS easy These proceedings hold a number of art&s on methods for handling common special cases of logical rules, and the paper by Bancllhon and Ramakrlshnan [19861surveys the previous work m this area very well We may begin to see the emergence of an optlmallty theory, that LS, a way to relate the characteristics of logical rules and their data to the best way to evaluate the relat.lon(s) defined by that logic 10.2 Computational Aspects of Nonmonotonic Reasoning We are also seeing increased actlvlty m how negation ISto be handled properly However, much of this work 1sconcerned primarily with the logical aspects of the problem, and ignores the computational aspects An exception IS Van Gelder [1986], which does deal with algorithms for answering queries mvolvmg negation The general question remains unanswered under what circumstances can we give a plausible meaning to negation m logical rules, and yet have an efficient algorithm to answer queries mvolvmg negations? There has been a lot of work recently on query languages for ""non-first-normaiform relations,"" which gets at some of the structure present in object-onented systems, yet does not seem conducive to supporting object identity Work on ""semantic data models"" lIkewIse gets part of the way toward a theory of obJect-orlented systems Kuper and Vardl [1985] dlscussed a data model whose purpose was to generalize evlstmg data models m such a way that queries could be composed While the term ""object-orIented"" wasn't even mentioned m this paper, what they developed was, m fact, a formal model that supported obJect Identity yet could be programmed m something like relational algebra However, they did not deal with many of the questions m the previous paragraph Perhaps it IS time to do so m this or a sun&r model Since the Idea of user-defined ""methods"" (for access) IScentral to the obJect-oriented approach, any optlmlzatlon techniques WIN have to get Involved m the definitions of these methods, to determine, e g , whether two methods commute One wonders of the recent work on ""transactlonal schemas"" could turn out to hate some apphcatlon m tlus arena 10 5 Parallel Couqmtatlon and Logic There has been a great deal written on parallehzatlon of Prolog, with Its tuple-at-a-time computation model I don't thmk too much of this carries over usefully to the relation-at-a-time processing that goes on m a KBMS Moreover, very httle has been done regarding Interesting special cases For example, it IS known that all linear (one recursive subgoal) datalog can be done m logarithmic time, even a number of processors that 1sa substantial polynornlal m the size of the database However, even for so simple a recursion as transitive closure path(X,Y) - edge(X,Y). path(X,Y) - edge(X,Z) 1: path(Z,Y) there does not appear to be a way to compute the slnglc-source solutton (I t' , find I he set of N quch that yalh(rr,~, N) it, true lor `1 given source node no) in lognrlthmlc tlrne with fewcsrprocessors than the cube of the nurnbt>r of nodes ' How well can we take advantage of parallehsm to solve the angle-source transltlve closure (reachablltty m graphs) problem 7 With a smgle processor, we can do It m O(e) time on an e-edge graph Can we achieve a processor-time product close to O(e) for large numbe s of processors?"
Integrating Ada design graphics into the Ada software development processIn both cases, the programmatical database has been stored as a set of Prolog assertions, and Prolog rules have been used to generate the textual output. 166 The process of mapping graphical representations onto source code has been viewed as a rule-based process which proceeds in two stages: first, the mapping of graphical objects and their relationships onto the intermediate programmatical database, and second, the mapping of the programmatical data onto source text. The syntactical analysis generates a tree-structured representation of the Ada program, exl:,essed as a prolog database. The tree structure is D,.:'A-inspired, though the external form is Prolog to conform to our usage of a Prolog rule base to generate the graphics.
"Preliminary ideas of a conceptual programming languageWhy can't the user write the program using these concepts directly? Even in logic programming language like Prolog, there still is the same problem. The statement ""man is an animal"" is represented as animal(X) :-man(X). Man is an animal. 2). John is a man. Their representations in Prolog are: 3). anim al(X) :-man (X). 4). man(John). Both statements can be represented in CONPL as isa(m an, an im al). isa(John, man). Syntax The top syntax of CONPL is quite similar to that of Prolog. < program> < assertion-list> < assertion> < term-list> < query> < judge-query> < attr-query> < relation-name> ::= < assertion-list> < query> ::= e I< assertion>. < assertion-list> ::= < relation-name> (< term-list> ) ::= e I< term>, < term-list> :"
A constructive view of GPSG or how to make it workThe system is fully implemented in Waterloo Core Prolog using the set of predicates defined by the KIT-CORE Prolog standard [Bittkau et al. 1987], which makes it possible to run it with several other Prolog dialects, too (e.g. Symbolics Prolog). At present, it runs on an IBM 4381 under VM/SP, on a Symbolics 3640 Lisp machine, and on an IBM AT. 4 Conclusion It has been shown how our constructive version of GPSG avoids the: problem of combinatorial explosion that would have arisen if we had tried to implement the GPSG formalism in its axiomatic version [GKPS] in a straightforward way.
Data abstraction mechanisms in SINA/STBoth Sina/st and law-based systems claim to construct more complex systems from user defined rules. In law-based systems rules are Prolog clauses which define the system laws, in Sina/st rules are input interface predicates which specify the message protocols of objects. However, in case of a centrally controlled system, a system failure will have an influence to all the elements of the system. As Minsky also admits [Minsky87], Prolog is a very powerful language and therefore, the programmer can shift the programming task to Prolog, and he leaves this choice to the programmer. We believe that it is dangerous to adopt Prolog for defining laws. Leaving the decision to a programmer to use small and simple laws is not acceptable from a software engineering point of view.
A model and an architecture for a relational knowledge baseA deductive database system consisting of aProlog processor and a relational database management system [Gallaire et al. 84, Yokota et al. 84, 86] is one example, and Prolog machine manipulating a large amount of data [Sabbatel et al. 84] is another. These rules and facts are stored in the term relation in Figure 2. We use DEC-10 Prolog LISTs to denote the trees, [alb] stands for .(a, b) and [a, b, c] stands for . B., Dang, W., Ianeselli, J. C. Nguyen, G. T., Unification for a Prolog Data Base Machine, Proceedings of the Second Internation-al Logic Programming Conference, pp 207-217 July 1984.
"Bottom-Up Filtering: a parsing strategy for GPSGWe have implemented an algorithm based on the Bottom-Up Filtering strategy in Prolog II on a Macintosh SE/30 and obtained interesting results: for a non trivial GPSG of French, most of the analyses for ""usual"" sentences take less than 1 second. Mellish (1989) Natural l.,anguage Processing in Prolog, Addisou-Wesley. Jenscn, K. (1988) ""Issues in Parsing"", in [Biaser 88]: 65-83. Sprechen mit P&rtikeln,W',dter de Gruyter (Berhn). Pereira F., S. Shieber (1987) Prolog and Natural Language Analysis, CSLI Ixcture Notes # 10. 1)errault C. (1983) ""On the Mathematical Properties of IJnguistie Theories"", ACL-2 l."
AuthorsPrior to this, he did research in logic programming and partial evaluation at Uppsala University in Sweden, where he authored a system called Uniform and coauthored a Lisp machine-based Prolog System called LM-Prolog. With others at Xerox PARC, Kahn has been active in designing and implementing CommonLoops, a proposed extension of CommonLisp for objectoriented programming, Common-Log, a logic programming extension to CommonLoops, and Vulcan, a concurrent logical object system.
"A message passing framework for logical query evaluation+O("")) rf there are n constants m the system and at most t variables m any rule Vardl has shown [var82] that for a grven EDB, there 1s a worst-case exponential lower bound on query evaluatron trme as a function of the length of the IDB, provrded that an arbitrary number of variables per rule 1s permrtted So in a sense the brute force bound rs tight for the most general case However, m practice, rules do not have a huge number of variables, and exhrbrt other regularities of behavior, so rt 1suseful to look for special casesthat can be solved more efficrently Henschen and Naqvr [HN84] have reported a method that tries to deal efficiently with a class of these problems, the primary hmrtatron being hear recurzIon, whrch means that the head of any rule 1s recursrvely related to at most one subgoal m the same rule McKay and Shapiro [MS811have reported a more general solutron m which the entire mmlmum model 1snot computed, but intermediate relations that are needed tend to be entrrely computed, even rf only a small part 1sactually useful for answermg the query Walker has descrrbed a system called Syllog [WalSl] The method 1s descrrbed mformally, so rt IS unclear how general it 1s Ullman has proposed a formalism using ""rule/goal graphs"" and ""capture rules"" for analyzmg a wider class of query evaluatron problems mcludmg rules wrth functron symbols [U1184] The focus of that work IS on choosmg among general computatron methods, a capture rule says ""if the problem (or subproblem) has such-and-such proper&s, then such-and-such a method 1sapphcable n Porter has developed an approach based on Earley parsing [Por85] Recent proposals for treatmg thus problem can also be found m [Loz85,Vre85] 1.2 Summary of Results We formulate the problem as a drstrrbuted computation m a network of processes commumcatmg by messages The network structure depends only on the IDB Each processcomputes an mtermedrate relation, more or less by standard relatronal algebra methods During an mltrahzatron phase the specrficatrons for the relatron are recerved m messagesfrom nerghbormg processes, and the process generates messages requestmg the relatrons rt needs as Input Durmg the computatron phase addrtronal specrficatrons (m the form of partial bmdmgs) and result tuples are passed back and forth by messages Finally, termrnation messagessrgnal that the requested relations have been completed No shared memory rs required, however, shared memory for mtermedrate relations can be used to reduce the total space requirement, at a sacrifice m srmphcrty Thus thus formulatron rs amenable to parallel computatron We describe a procedure that ""bmlds"" the network as a rule/goal graph that essentmlly reflects the structure of the IDB, and show that the procedure termmates for any finite IDB An rmportant feature of the rule/goal graph rs that predrcate arguments are drvrded mto 4 classes, un c,""d,"" ""e,"" and ""f"" Class %"" are constants known at graph-constructron time Class ""f' are free varrables, the Job rs to find bmdmgs for them Class ""e"" are free variables whose values are not used, only the exmtence of a value rs mater& Class ""d"" 1sthe Important class for effiaency, especmlly m recursively defined relations, an argument m thusclass 1sbound durmg the computation to a set of needed values Thus a class ""d"" argument functions as a semi-Join operand (Perhaps thmk of ""d"" as standmg for ""dynamrcally bound "") It serves to restrict the computed part of the mtermedrate relatron to values that are (at least potentrally) useful for derrvmg goal tup1es We present a basrc set of messages that drive the computatron, and are sufficrent to carry out the computatron of the query answer The basrc set can be extended m order to pass optlmlzatlon mformatlon, offering the posslblhty of taking advantage of statlstlcs on the EDB and usmg various heurlstlcs Recursive rules produce cycles of messages In particular, this method handles no&near recursJon, m which a goal depends recursively on two or more of Its subgoals m the same rule Nonlinear recursion frequently arises m dlvldeand-conquer algorithms, and occurs m certam polynomlally complete problems [VarSZ] Deletion of duphcates m cycles ensures that nodes become idle when the computation IS complete An addltlonal message protocol allows asynchronous dlstrlbuted detection of the fact that all nodes m a cycle are Idle simultaneously We mtroduce the monotone flow property for rules, and argue that for such rules there IS an efficient way to compute intermediate relations m the absence of other mformatlon Our notion of efficiency mvolves avoldmg the generation of tuples that, do not contribute to the query answer Rules that do not satisfy the monotone flow property have an mherently cychc structure that can produce mtermedlate results that are much larger than the final results, even when the subgoals' relations are palrwlse consistent, I e , parwise, they have no ""danglmg tuples n Experience indicates that the maJorlty of rules that occur m practice have the monotone flow property, so developing a methodology to take advantage of It 1s Justified These results have several possible apphcatlons They enhance the power of logic programmmg mterpreters by freemg the user from speclfymg the order m which rules and subgoals wlthm rules are processed, this IS analogous to the role of the relatlonal database model m freeing users from speclfymg navlgatlonal mformatlon In addition, the method 1s certam to terminate, avoldmg the well-known ""left recursion"" problems of strictly topdown methods Finally, the rule/goal graph with message passing between nodes breaks the problem up mto several modules with well defined mterfaces This decomposltlon offers opportumties to use existing operatmg system features, such as scheduhng, message queuemg, and multi-tasking It also provides a natural approach to parallel Implementatlon of logical query evaluation 2 Rule/Goal Graph Construction 2.1 Basic Rule/Goal Graphs In order to build the basic rule/goal graph correspondmg to the IDB, we begin by constructmg a tree of goals reduced to subgoals through rules, much m the manner of Prolog and other top-down systems, startmg with a top-level goal node for goal Depth first search IS used, and terms ""parent,"" ""child,"" Uancestor,"" and ""descendant"" will refer to the depth first spannmg tree Induced We consider edges m this tree to be oriented from chdd to parent, the dlrectlon m which ""answers"" flow Whenever an EDB subgoal (1 e , a subgoal whose predicate symbol IS m the EDB) 1s created, it remams as a leaf, It IS not processed agamst the actual EDB relation durmg graph constructlon Furthermore, whenever an IDB subgoal IS a variant of one of its ancestors, instead of expandmg It further, we Just create a cycle edge' from the appropriate ancestor to the variant subgoal When these exceptlons do not apply, we expand a subgoal by creatmg a rule node for every rule whose head umfies with the subgoal and connect an arc from the subgoal node to each such rule node The rule node contams a copy of the rule that began with all new varlables, then had the most general umfier (mgu) apphed Thus the head m the rule node m exactly the same as the subgoal of its parent Now we create new gocrl nodes for all subgoals of the new rule node and put edges from the rule node to its subgoals Strong components m the rule/goal graph play an Important role m the computation Recall that a strong component 1sa maximal set of nodes such that each has a path to the other The reduced graph 1s obtained by collapsmg each strong component to a smgle node, and IS acyclic We also use the followmg terminology Definition 2.1: Let, r + s be an arc m the rule/goal graph As usual, we call r a predecessor of s, and call s a successor of r Furthermore, if r and s are m different strong components, we say r 1sa feeder of s, and s 1s a customer of r 0 2.2 Information Passing Definition 2.2: An mformatlon passmg rule/goal graph 1s a varlatlon of the basic rule/goal graph, but 1s a more elaborate form, m which we propagate argument classes ""c,"" ""d,"" ""e,"" and ""f"" from the goal (1 e , parent) of the rule node to Its subgoal nodes Before creatmg a cychc edge to a goal node from an ancestor, we now require not, only that the ancestor ls a vanant, but that the arguments match on their classes as well Cl The class letters are mnemonics for ""constant,"" ""dynamic,"" ""exlstentlal,"" and ""free,"" respectively `In the te-ology of depth first search, ths IS a back edge Thus term 1s clear m a context where tm edges are dwccted from parent to &ld, however, m our context, It would be confusmg to use ths termmology Classes of arguments contammg a variable that appears m the goal are simply passed through to the correspondmg subgoal The subgoal arguments whose variables do not appear m the goal are classified as either ""d"" or ""f"" according to an mformatlon pasmg strategy, assuming the variable appears m more than one subgoal Any such variable appearing m multiple subgoals may be classified as ""d"" m all but one of those subgoals The idea 1sthat the subgoal(s) that retam the ""f"" designation will be evaluated first and will furnish a set of valid values for that argument (hence variable) to the rule node, and the rule node will passthem to subgoals that have ""d"" designations The term ""sideways mformatlon passing"" was coined in [U1184]to describe this technique This 1sslmllar to, but more general than, the technique used m Prolog and other top-down systems to bmd subgoal arguments Essentially, Prolog solves the subgoals m order, left to right Here the system decides m which order to solve them, and can even choose to solve some %imul t aneously"" Definition 2.3: More formally, an mformatlon passmg strategy 1san acychc directed graph on the subgoals of a rule The arc r + s IS present whenever an ""f"" argument of t furrushes bmdmgs for a ""d"" argument of 8 Cl Definition 2.4: A greedy mformatlon passing strategy 1s one m which the set of ""d"" arguments m the subgoals 18maximally pushed forward, m other words, no subgoal relation 18 requested with some argument free If we could wat for tuples from another subgoal that has more bound arguments, and provide a set of bmdmgs for that argument 0 Greedy mformatlon passing 1sbased on the heunstic that maxmuzmg bound arguments 1s more Important than mmmuzmg unbound arguments for the purpose of making mtermedlate relations small If a variable appears m one subgoal and nowhere else m the rule, it 1s labeled ""e n It could be treated as ""f"" and produce correct results, but the ""e"" designation indicates that Its value will not be transmitted, possibly permitting greater efficiency For example, goal p(Xf , Y"") can be satlslfed by producing one tuple for each unique X even though there may be many Y values that go with a given X Example 2.1: Consider an example program PI contammg two EDB relations, r and q, an IDB predicate p, and query p(a, Z), where a 1sa constnat entered by the user The IDB consists of the following Prolog-style rules, where the goal p 1son the left and the subgoals are on the right (Read ""t"" as ""If "") Pl goal(Z) + ~(a, 2) P(X> Y) + P(X, V), q(K V), P(K Y) P(X, Y) + r(X, Y) The greedy mformatlon passing strategy for the recursive rule is P(X9 U) + qw V) + P(V, Y) since only X ISbound mltlally The mformatlon passmg rule/goal graph correspondmg to this strategy 1s shown m Fig 1 (We omit the two top levels of the graph, mvolvmg goal, as they are trivial m this case) Requests for mformatlon flow agamst the dlrectlon of the edges, ""answers"" flow m the edge direction Cyclic edges are shown by dashed hnea The superscripts on variables denote the bmdmg status of the arguments m which they appear Observe that the goal node p(a',Zf) cannot supply tuples to nodes with different bmdmg patterns, necessltatmg a separate goal node for p(Vd, Zf), however, a change m variable name does not prevent a goal node from supplymg tuplea to another node with the same bmdmg pattern Thus p(Vd, 21) supphea tuples to p(Vd, Y') and p( Wd, Zf) in responseto requestsfrom those nodes, each request for tuples from p(Vd, Zf) provides a set of bmdmgs for the first argument The evaluation of the recursive rule for p( Vd, 21) m this graph proceeds as follows The leftmost subgoal inherits a ""d"" bmdmg from the head, 1e , a set of values for the first argument The first step m to determine what p tuples match those values Then the the second arguments of these p tuples are used as a set of bmdmgs for the first argument of q, the second subgoal The set of second arguments for q becomes the set of first arguments for the thud subgoal, the rightmost p Fmally, the set of values for the second argument of the right p are associated with the original bmdmgs, producmg answers However, since p 1srecursive, all steps are interleaved 0 Theorem 2.1: The mformatlon passing rule/goal graph construction procedure terminates for any finite set of function-free IDB rules, and the sizeof the graph 1sindependent of the sizesof the EDB relations Proof There are only a finite number of predicate symbols, argument pmtlons, and permutations of bindings, and hence only a finite number of goal node labels such that no two are variants This provides a bound on the length of a wmple path, which together with finite degree of nodes, guarantees finiteness of the entire graph There 1sa techmcahty that repeated P(OC,29 - p(aC, V'), dud, V'),P(Vd, 2') Ip(vd,j ,,III- p(Vd, 21) c p(Vd,Yf), q(Yd, wqP(Wd, Zf) A A A CL-j r(Vd,2') Figure 1 Greedy mformatlon passmg rule/goal graph for P1 variables can occur m various patterns m different nodes, such as p(X, X, 2) and p(V, V, V), preventing them from bemg vanants, but again, there are only a fimte number of such patterns m When the graph 1s finished, we interpret each node as a processor that performs a relational computation Predicate nodes with rule-children compute the umon of the relations computed by their children, rule nodes combme then subgoal relations using Jom, select, and project The predicate nodes that are connected to an ancestor predicate node by a cychc edge perform a selection on the relation computed by the ancestor Observe that several nodes m the graph may have identical predicates and bmdmg patterns For single processor computation It 1s probably desirable to coalesce such nodes (thereby mtroducmg cross and forward edges) However, for distributed or parallel computation, combmmg nodes may well be counterproductive, so m this paper we shall assume that it 1snot done 3 Message Controlled Computation We now briefly outline how messages are used to accomphsh a dlstrlbuted query evaluation, once the appropriate graph 1s ""bmlt n 3.1 Basic Messages The relation request messagetriggers the beginning of computation and Identlfies the classes of the arguments It originates at the top level goal node and 1s passed through the graph, agamst the orientation of the arcs Note that goal nodes with cychc arc9 out of them will receive at least two requests When a relation request includes some class ""d"" arguments, there follow a series of tuple request messages= the computation proceeds Each tuple request messagespecifiesone bmdmg for all of the ""d"" arguments ' Thus the complete speclficatlon of an intermediate relation consists of the relation request and the set of associated tuple requests Whenever a tuple 1sderived It 1ssent to the parent via a tuple message In the case of a goal node with cychc edges out of It, the tuple message1salso sent to the other successornodes, which are descendants Processesdo not block, watmg for complete answers, before Issumg new requests In fact, m recursive rule evaluation, It would be Impossible to do so 2A further enhancement would be to ""package"" a set of related tuple requests, m case the node eerv~cmg the request can gam some effiuency of volume E g , d an EDB relation r(X,Y) hss no mdex ? This version of acyclicity is also called a-acyclicity. 0 Example 4.1: Consider the following Prolog-style rules, where the goal p is on the left and the subgoals are on the right."
Toward memory-based translationMBT2 ca.n do bi-directional mnslation between an English word-dependency tree and a Japanese worddependency tree. It is implemented in Sicstus Prolog. 2 Need to Combine Fragme nt s The basic idea of example-based translation is very simple: translate a source sentence by imitating the translation example of similar sentencein the database. A tanslation example consists of three parts: • an English word-dependency tree (EWD) • a Japanese word-dependency tree (JWD) • correspondence links For example, in Prolog, ewd e([el,[buy,v], [e2,[he,pron]], [e3, [notebook,n], [e4, [a,det]]]]) . %% He buys a notebook. jwd_e( [jI, [kau,v] , [j2, [ha,p] , [j3,[kare,pron]]], [j4, [wo,p] , [j5, [nouto,n]]]]). %% Kare ha nouto wo kau. clinks([[el,jl],[e2,j3],[e3,j5]]). %% el <-> jl, e2 <-> j3, e3 <-> j5 Each number with prefix 'e' or 'j' in worddependency trees represents the ID of the subtree. This process generates all candidates of translation using Prolog's backtrack mechanism. 4.1 Decomposition In decomposition, the system decomposes a source word-dependency tree(SWD) into translation units, and makes a source matching expression(SME).
A text generation system for explaining concepts in geometryI t s most part has been already programmed on IBM PC/XT/AT (in Ksi Prolog). The FDs are described within Prolog D e f i n i t e Clause Grammars (DFG) notation. The result is a generator with the best features of both grammars: s i m p l i f i c a t i i o n of input by using functional information and e f f i c i e n c y of execution from Prolog. Danlos, Laurence Generation automatique de textes en langue naturelle, Masson, Paris, 1985 Derr, Marcia and McKeown Kathleen - Using focus to generate complex and simple sentences, COLING, 1984 Kay, Martin - Parsing in functional unification grammar.
Knowledge representation for commonsense reasoning with textThe problem solver is based on a straightforward depth-bounded Horn clause proof system, implemented by a Prolog metainterpreter (e.g. Sterling and Shapiro 1986). City University of New York Graduate Center. McCord, M. 1987 Natural Language Processing in Prolog. In: A. Walker, Ed., Knowledge Systems and Prolog. Stickel, M. 1986 A Prolog technology theorem prover: implementation by an extended prolog compiler.
Incorporating inheritance and feature structures into a Logic Grammar formalismIn particular, the :- symbol separates a rule head from the C-terms comprising the rule body. Analogously to Prolog, list-notation (using [, I, and ]) can be used as a shorthand for C-terms representing lists and containing head and tail features. Many of the techniques used in standard depth-first Prolog execution have been carried over to IG execution. We are currently developing a large grammar using this environment. As in Prolog, top-down evaluation is not complete. Earley Deduction (Pereira and Warren, 1980, Porter, 1986), a sound and complete evaluation strategy for Logic programs, frees the writer of DCGs from the worry of infinite left-recursion.
"Lambek Theorem Proving and feature unificationNote that in all cases, the reflexive should combine with the verb before the subject comes into play: the refiexive's semantics can only deal with A-bound variables as arguments. 6 IMPLEMENTATION In this section a Prolog implementation of LTPFU is described. The implementation makes use of the interpreter described in Moortgat (1988). In order to 'implement' a calculus, firstly it has to be described in a proper format. -- and -- are defined as Prolog operators and denote respectively derivability in the calculus and inference during theorem proving. Note that feature unification is added explicitely: identity statements are interpreted ""as instructions to replace the substructures with their unifications"" (Shieber, 1986, p. 23). Prolog, however, does not allow this so-called destructive unification and therefore unification is reformulated."
Abstracts of current literatureThe first stage, CFS to CPM, of AUGUST called AUGCPM was implemented and tested on a CORONA microcomputer using micro PROLOG. The testing showed that the concepts behind AUGUST lend themselves very nicely to the expert system approach. The problems encountered were mostly due to the inefficiency of micro PROLOG and can be corrected by moving to a larger machine and the PROLOG language. It is shown that the kind of programming features that were initially possessed solely by Prolog can also be provided in this extended equational programming paradigm.
A natural language front-end for knowledge acquisition(editor), Natural Language Parsing Systems, Springer-Verlag, NY., 1987. 7. Bratko, I., PROLOG Programming for Artificial Intelligence, Addison-Wesley Publishing Company, Reading, MA., 11986. 8. Clocksin, W. F., & Mellish, C. S. Programming in Prolog, Springer-Verlag Berlin Heidelberg, NY., 1984. . Walker, A., McCord, M., Sowa, J.F., & Wilson, W.G., Knowledge Systems and Prolog, Addison Wesley Publishing Company, Reading, MA., 1987. 24.
"The EXODUS optimizer generatorOvervIew In order to be sufficiently general,an optmnzer generator must be basedon an abstmctlonof opnrmzahon smtable for most data models We declded that quenes and access plans should be expressed as trees, because we beheve that operatortreesare generalto all setortenteddata modelsm which complex quenesarecomposedby nesMg a tite set of procedures The nodes of the query bees are labeled ~nth an operator and its arguments,eg a selection pre4itcate There are two alternative ways of transferring data between operators temporary iiles and pipehnes WIthout precludmg the useof either one, we sllnply refer to them subsequentlyasmputsor streams Before a query can be ophmtzed, an mmtuiloperator tree must be constructed In EXODUS, this ISdone by the user mterface and parser The output of the opmzer, the accessplan, can e&er be mterpreted by a recurswe procedure or It can be further transformed Both approaches have beenusedsuccessfully111exlsMg databasesystems In Gamma[DEWI86], for example, the operatorsm the access plan are mterpreted (though the pre&cates themselvesare complied mto machme language) In System R [SELI79], the accessplan was complied mto machmelanguage Freytag wY85, FREY86a] suggestsapplymg rule-basedtechniquesfor tis step In most database systems, there are frequently severalaltemauve algonthms for the samelogcal operaaon For example,' the relanonti JO~ operator can be Implemented usmg several alternattve JOT methods Our model &SMgWheS betweenoperators,correspondmgto pnmmves provtded by the data model, and methods,that are specific Implementations of the operators The accessplans produced by the optlrmzer are also trees,wltb a method and tts argumentm each node In this model of quenes and access 1A word about the examplesm this paper Fmt, examples basedon the xelaaonal datamodel were chosenbecause they are eastiy understood We firmly believe that the Ideas presented here apply to most other data models Second, larger examplesareendedwltb a R plans, query optumza~on consists of query tree reordenng and method selection Smce this optnmzation scheme 1s centeredaround the algebraof the datamodel, we refer to It asalgebratc optvnuanon As example, consider the query tree and a conespondmgaccessplan shown m Figure 1 Notice that m producing the accessplan on the nght from the query treeon the left, two types of rules are apphedto the tree Frst, the operatorsare rearrangedby pushmg the selection before the JOHI Second, each operator is replaced by a method that unplementsIt select Aa < 100 I hash-JomAb=Bb ]omAb=Bb 1 \ i \ filescan A filescan B SMllA SCXIIB Y:*@ Figure 1 As proposedm [CARE85], we mlhally intended to implement a rule-basedoptmuzer usmg an AI languagehke Prolog [wARR77, CLOC81],OPS5 [FORG81], or LOOPS [BOBR83] as those languagesprowde pattern matchmgand a searchengme,and since umficatron can be usedelegantly to bmld new query trees from old ones In addmon. these languagesallow augmentationof the rule baseat run-tune This capablbty 1sdesnable for two reasons Fn%, m a database system that permtts the &&on of new abstractdata types, accessmetbods, etc. It 1s necessaryto mfonn the optmnzer about thosechanges Second,when the optmuzer -finds that certam sequencesof transfonnanons occur frequently together,the opmzer could augmentthe rule setby addmga smgle rule that combmesthe sequenceof transformahons In successiveoptumzanons,the whole sequenceof transformationscould then be donem a smglestep We mplemented and expenmentedwtth a prototype m Prolog, which, unfortunately, had to be abandoned This prototype had two serious problems Fast, Prolog has a 6xed searchstrategy, depth first search We found that we neededto augmentthe searchstrategydynarmcally wlule the optlrmzer was nmmng, a fauly cumbersometask Second, our Implementation (C-Prolog mterpreter) was slower than we were wdlmg to accept Havmg abandonedthis prototype we decidedto pursuethe Idea of Implementmg a rule-basedoptmuzer generator Whfle bmldmg an optnrnzer generator 111C qmred more work mtaally, it left us ~rlth the freedomto nnplement exactly the desiredfuncttonahty and a searchstrategytuned to the processof optmuzmg algebratcquenes Furthermore, we were able to expenment ~rltb altematlve designs m a stnughtfoxward manner The pnnclpal dtsadvantageof the generatorapproach1sthat the optlrmzer cannot be changed while runmng, a feature other researchershave found useful [STON86j The input mto the EXODUS optnmzer generator consists of a set of operators, a set of methods, algebratc rules for rransfonmng the query trees, and rules descnhng the correspondencebetween operators and methods Tlus mformanon IScontamed111the model descnption file Figure 2 gwes an ovennew of the use of the opmzer generator When the databasesystem1sconstructed,the generator produces a data model specfic optmuzer from the descnpmodeldescnpuonfile 1 I DatabaseSystem GenerabonTune QuerY bon At run nme, eachquery is transformedmto an operator tree by the user mterface,optmuzed by the generatedoptnnlzer, andthen interpretedor transformedmto a Program The generatedoptmuzer transformsthe mitral query tree stepby step,mamtammgmformation aboutall the alternatives explored so far 111a data structure called MESH MESH 1salso usedto hold accessplans for eachquery tree that has not been pruned from the data structure At any ame durmg the optmuzatlon processtherecan be a huge set of possible next transformations These arc collected m a data structure called OPEN2which 1smamtamedas a pnorlty queue OPEN 1snutlahzed to be the set of transformations that can be applied to the iniWil query tree The generalopfimtzatlon algorithm can now be describedas follows while (OPEN is not empty) Selecta transformationfrom OPEN Apply it to the correctnode(s)m MESH Do methodselecttonandcostanalysisfor the new nodes Add newly enabledtransformationsto OPEN The rules govermng query tree transformationsand method selection are spe&c for the datamodel andmust be defined 111the model descnption file 2 2 The Input to the Optutuxer Generator To implement a query optnmzer for a new data model. the DBI writes a model descnption file and a setof C procedures If the new model resemblesone for which an optnmzer has already beengenerated,it rmght bc more convement to augment an exlstmg model descnptlon file The generator program transforms the descnptlon file into a C program This 1scomplied and Imked ~th the setof C procedures Wntten by the DBI to form a data model spectic optlmlzer In the model descnpaon file, the DBI hsts the set of operatorsof the data model, the set of methodsto be con 2 OPEN 1s a standard name for the set of possible next movesm AI searchalgonthms IBARR pExecutionTme Figure 2 sideredwhen bmldmg and comparmgaccessplans, the rules definmg legal transformanons of query trees, termed transformahon rules, and the rules defining the correspondencebetweenoperatorsand methods,termedimplementation rules The model descnptlon file hastwo reqmredpartsand one optional part The first reqmredpart 1sused to declare the operatorsand the methodsof the datamodel It can also include C code and C preprocessordeclarattonsto be usedm the generatedcode The secondpart consistsof transformation rules and implementahon rules The optional thud part contams C code that is appendedto the generatedcode These parts will be discussed m further detad below In ad&non, we til Illustrate how the pieces fit together through a senesof examples In the first part of the model descnpuon file, called the declaration part, the operatorsand the methodsof the data model are declared The keywords Sbopemfor and %methodare followed by a number to mdrcatethe anty and by a hst of operatorsor methodswith this anty Example %operator2 Join %method2 hashAom 1oopsJomCartesian-product In tlus example, an operator ~oln and three methods hashAotn, loopsJOW, and carteslan-product an? (Feb 1986) [wARR77] D H D Warren, L M Peremx,and F Pereua, ""PROLOG - The language and its unplementatlon compared wth Lisp,"" Proceedmgs of ACM SIGART-SIGPLAN Symp on AI and Programmmg Languages,(1977) [wONG76] E Wong and K Youssefi, ""Decomposl~on- A Strategy for Query Processmg,""ACM Transacttons on DatabaseSystems,Vol l(3). pp 223-2.41,(Sept 1976) [YOUS79] K Youssefi andE Wong."
Efficient interpretation of synchronizable series expressionsEach oss function is represente d as a fragment containing six key pieces of information : a list of input variables, an output variable, a list o f local variables, a prolog which is executed before the computation starts, an epilog which is executed afte r the loop terminates, and a body which is repetitivel y executed in order to compute successive elements of the output . The illustration below shows the fragments which represent the four oss functions used i n oss-sum-sqrts . inputs : (vect ) (1) Evecto r output : e locals : (last index) prolog : ((setq index -1 ) body : ((incf index ) (setq last (length vest)) ) (if (or (minusp index ) (not (< index last)) ) (terminateS) ) (setq e (aref vect index)) ) epilog : () (2) Tplus p inputs : (series ) output : serie s locals : ( ) prolog : ( ) body : ((tagbody oss : :L (nextS series (terminateS) ) (if (not (plusp series) ) (go oss : :L))) ) epilog : () (3) implicit map of sqr t inputs : (num ) output : r locals : ( ) prolog : ( ) body : (setq r (sqrt num) ) epilog : () (4) Rsum inputs : (num ) output : su m locals : ( ) prolog : ((setq sum 0) ) body : (setq sum (+ sum num) ) epilog : 0 The loop in oss-sum-sqrts-loop is created by combining the four fragments shown . When two functions are connected by an os s series data flow terminating on an on-line input, th e functions are combined by simply concatenating th e prolog, epilog, and body computations of the fragments .
"""Translation great problem"": on the problem of inserting articles when translating from Russian into SwedishThe children ran home). For this purpose, recursive PROLOG-predicates searching for possible hyponyms in the referent list are used. Consequently, co-reference with ""israeli airplanes"" is not excluded. - whole - part relations: in cases like car - engine etc. definiteness should be triggered. Formulating a PROLOG-rule handling this kind of relation is not a difficult task - the problem is to create an appropriate data base (it would be necessary to include much encyclopaedic knowledge in the lexicon). Co-Referenceseems to be allowed by the following principle: a verbal noun may co-refer with a prcvious predication, if it is semantically not incompatible with the predicate and if the argulnents of the verbal noun are either not specified or co-referential with the arguments of the previously stored predicate. A PROLOG-implementation of this rule may have the following shape (simplified): possible_coref(NewEvent,OldEvent) :- NewEvent= e(m(Mean,verbal),args(A 1,A2)), OldEvent = e(Pred,args(A3,A4)), eventlist(Elist), member(OldEvent,Elist), not(incompatible(Mean,Pred)), (var(A 1),possible_coref(A 1,A3)), (var(A4),possible_coref(A2,A4))."
Low-cost, adaptable tool integration policies for integrated environmentsAlso like Forest, rules are used to determine how rules are changed. However, in Darwin rules are encoded as Prolog programs, rather than the condition-action pairs of Forest. Interpretation of rules is therefore both more powerful (allowing the full deductive capabilities of Prolog), but more costly (requiring the equivalent of a Prolog interpreter). Other research efforts have used much more expressive languages, including Prolog [II], predicate calculus [5, lo], various process programting languages [15, 171, planning languages [8], production systems [3], etc.
Annotated Bibliography Relating to Automatic Indexing in Information RetrievalThe latter are introduced in chapter 1, followed by a discussion of PROLOG in chapter 2. Building on that, chapter 3 treats the extension of DB and chapter 4 deals with the extension of IR systems into knowledge based systems. This article briefly introduces the languages of AI and presents information on some of the new versions of these languages available for personal computers. A tutorial for PROLOG-86, a new microcomputer version of PROLOG, is given. FOCES integrates advanced information retrieval (IR) techniques with a PROLOG-based General Purpose Expert System Shell (GUESS).
AuthorsKriwaczek's research interests include the application of logic programming to decision support systems.and the design of improved human-computer interfaces for Prolog systems. He is currently involved in the design of intelligent spreadsheetprograms in Prolog.
Executing Temporal Logic Programs by Ben MoszkowskiFinally, Chapter 10, Discussion, describes the current state of the implementations, the relationship of tempural logic programming to other formalisms including Prolog and Lisp. One should add that the body reads extremely well, follows the general notation of logical calculi. Thus, NBSA will result in improved teaching and in speeding up the ability among pupils to digest what they learn. A PROLOG-based tool for French Grammar Analysis Barchan, J., Woodmansee, B. and Yazdani, M.
The Software Life Cycle Support Environment (SLCSE): a computer based framework for developing software systemsConvert-ER/Analvze-ER are companion tools that convert Schema Definition Language statements into PROLOG and then analyze the PROLOG form of the schemas to check for consistency. Convert-ER translates SDL into PROLOG, and Analyze-ER processes this PROLOG and checks for consistency within the schema definitions (e.g., relationships have both domains and ~W).
The Pan language-based editing system for integrated developmentGoals are satisfied using backtracking search based on unification as in Prolog. An evaluator for a LCG description begins by executing the goals that are independent of any syntactic structure. The ordering among goals is not formally specified, so standard Prolog programming techniques that rely upon known orderings among tuples in the database may not apply. In particular, the use of assert and retract in a LCG differs from their use in Prolog. 5.4 Example Figure 3 shows a very simple LCG for a language that requires that each name be defined before it is used.
Learning apprentice system for turbine modellingFollowing the same path Kedar-Cabelli developed Prolog-EBG [Kedar-Cab&i 87,881 which usesprolog's resolution to perform the explanation and the generalization at the sametime. Prolog-EBG is implemented as a meta-level interpreter on top of probg, and maintains a proof tree and a generalized proof tree as the explanation structure is built, thus enabling to perform both tasksat the sametime. The Explanation Based Generalization in the current EBL module of our learning apprentice system is basedon Prolog-EBG [Kedar-Cabelli 87,881, with some modifications made to the operational&y criterion detection.
Rule representation and management in conceptbaseEach link of the network is translated to a corresponding Prolog term, and the semantics of £sa and instaneeof axioms is hardcoded into the system for efficiency. To complete the logic program, rule, constraint, and query objects are translated into Prolog rules and queries [LT85]. For the management of large knowledge bases, this direct and formally nice approach has a number of disadvantages. A first prototype was completed in spring, 1988, and distributed to a number of places for experimental applications, a second prototype with the full functionality described in this paper is currently being finalized. The system is implemented in BIM-Prolog and C, using the SUNVIEW package to provide a hypertex-like user interface.
Toto: a tool for selecting interaction techniquesImplementation Note Toto is implemented in Smalltalk V and Prolog V on an IBM AT. The descriptive knowledge (e.g. device taxonomy, task concept network), tools for manipulating it, and the interface are implemented in Smalltalk V. The design processand specialized knowledge about device use are implemented in Prolog V. Two high level Prolog V algorithms guide the process while specific expertise is localized in Prolog V objects.
EPVM: An expert patient-ventilator manager for chemical warfare casualtiesThe functions and constructs provided by these AI (LISP, Prolog, etc.) aren't usually languages powerful enough to free the programmer to concentrate the task of encoding knowledge. One such specialized tool is the M.I development tool (Teknowledge, Inc.). to AI This tool, which features the Prolog language, implementation, provides the necessary for inference engine, with the researcher designing knowledge-base embedded to a specific domain. the The inference engine primarily uses backward chaining. Production rules (If-then) were used to represent the knowledge in the knowledge base. The knowledge is coded in PROLOG. # of Rules = 105 Memory used = 35 KB The key features are flexibility adaptation. 6.0 TEST AND EVALUATION Once the prototype was built, the task evaloating the expert system began. and of While testing is sometimes considered a remedial activity in traditional programming, it's an integral the development process for expert part of systems.
A logic-based Government-Binding parser for Mandarin ChineseAn experime,mfl Chinese parser is running under the euvironments: (1) Vax-I 1/785, (2) Quintus Prolog, (3) lexicon with about 200 words (about 33K bytes), and (4) about 150 production rules (about l 12K bytes). Chcn, tI.1t., I.P. Lin and C.P. Wu (1988) 'A New Design of Prolog-hased Bottom-up Parsing System with Government-l:linding Theory.' Tanaka, et al. (1983) 'BUP: A Bottom-up Parser Embedded in Prolog.' New Generation Computing 1(2), pp. 145-158. McCord, M.C. (1987) 'Natural Language Processing in Prolog.'
A problem in counting digits., Describing PROLO G by its Interpretation an d Compilation, Comrn•ACM, 28 , 12, 1985, pp . 1311 132 1 1 Colmerauer, Colmerauer 198 3 A ., PROLOG in 1 0 Figures, Proc . of IJCAI 1983 , pp . 487 - 49 9 Colmerauer, 198 5 Colmerauer Figures, A ., PROLOG in 1 0 Cornrn .ACM, 28, 12 , 1985, pp . 1296 -131 0 ICAD, 196 5 International Council o f System, Amateur Dancing, Skatin g BULLETIN Vol . 19 No . 2 June 198 7
Speculative computation in multilispParlog: Parallel pro gramming in logic. In E. Shapiro, editor, Concurrent Prolog: Collected Paper 1, Volume 1, Chapter 3. M.I.T. 2nd Annual Hawaii Int'l Con/. on System Science 6, Volume 2, pages 771-779, 1989. [Sha 87] E. Shapiro. Concurrent Prolog: A progress re port. In E. Shapiro, editor, Concurrent Prolog: Collected Papers, Volume 1, Chapter 5. Guarded Horn clauses. In E. Shapiro, editor, Concurrent Prolog: Collected Papers, Volume 1, Chapter 4. M.I.T.
"Auxiliaries and clitics in French UCG grammarRules [ZEEVAT 86] describes 2 grammar rules based on functional application. (4) FA (Forward Application) Functor : HF :CF/(HA:CA:SA:pre:_) :SF :OF :W1 Argument : HA:CA:SA:pre:W2 -> HF:CF:SF:OF:[WI,W2] i where PROLOG conventions are respected : lower case = constant, upper case = variable, _ = anonymous variable (5) BA (Bsckward Application) Argument : HA:CA:SA:post:W1 Functor : HF :CF/(HA:CA:SA:post:_) :SF :OF :W2 -> HF:CF:SF:OF:[W1,W2] We added two rules to these, inspired by functional composition as described in [STEEDMAN 86]. (6) FC (Forward Composition) Functor : HF :CF/(HA:CA:SA:pre: ) :SF :OF :Wl Argument : HA:CA/(npA[Fe,_,Ag,"" lex]:nil:X:_:_):SA:pre:W2 -> HF :CF/(npA[Fe,n,Ag,"" lex]:nil:X:pre:_) :SF :OF :[Wl,W2] FC is basically designed to deal with np-gaps. (7) BC (Backward Composition) Argument : HA:CA/(npAFeats:nihX:O:_):SA:post:Wl Functor : HF :CF/(HA:CA:SA:post:_) :SF :SO :W2 -> HF :CF/(npFeatsmil:X:O:.3 :SF :OF :[Wl,W2] BC is designed to deal with free-order of riparguments of verbs Forward application must be interpreted as follows : 174 If a sign of string Wl and category HF:CF/(HA:CA) unifies with a sign of string W2 and category HA:CA, W1 concatenates with W2, the resulting sign, with string [-W1,W2], is of category HF:CF, where HF:CF is the category inherited from the functor as resulting from unification with its argument,and stripping HA:CA. IMPLEMENTATION The UCG French grammar has been implemented at the Laboratoires de Marcoussis (France) on a VAX 780 in C-PROLOG using PIMPLE, a PROLOG implementation of a PATR-II like tool for development of unification grammars, implemented by the Centre for Cognitive Science of Edinburgh University."
Case studies in fleet operation modelling: an application of AI scheduling techniquesEvaluation of these techniques will be discussed more fully in section 4. 3.1 DELIVS-0 DELIVS-0 has been written in NIP PROLOG ' and makes use of the SunView graphics package that interfaces with NIP PROLOG, in order to provide displays of the schedule and interact with the user. Figure 3 shows a typical capacity plan for a schedule `NIP PROLOG is the product of 111~Programming Systems Group (PSG) at AIAI. The analysis of the distribution logistics problem the development of both DELIVS-0 and IIERhfES: Ken Currie and Richard Tobin for developing the graphical intdarface to PROLOG, Dr Robert Inder and Andrew Ireland in supervising the HERMES project.
"An example of formal specification as an aid to design and developmentIn PLEASE, the types set, list, and map arepre-definedand annotationsarerestrictedto Horn clauses:a subsetof predicatelogic which is also the basisfor Prolog [3]. PLEASE specificationsCanbe used in proofs of correctness,they can also be transformed into prototypeswhich use Prolog to ""execute"" pm- and post-conditions. Predicatedefinitions describe acceptabletuples in a format which hasa simple translation into Prolog procedures. The parametersusedto instantiatemanugerqkg define the properties of the resultant manager. Clocltsin, W. F. and C. S. Mellish. Progr amming in Prolog. Springer-Verlag. New York. 1981. Gehani, N. and A."
Concurrent constraint programmingA fully abstract denotational semantics for Flat Concurrent Prolog. In LICS 88, 1988. Haim Gaifman, Michael J. Maher, and Ehud Shapiro. Vijay A. Saraswat. Compiling CP(1, 1 , &) on top of Prolog. Technical Report CMU-CS87-174, Computer Science Department, Carnegie Mellon University, October 1987. Also to be published by MIT Press, 1989. Ehud Shapiro. A subset of Concurrent Prolog and its interpreter. Technical Report CS83-06, Weizmann Institute, 1983.
Multiprocessor cache synchronization: issues, innovations, evolutionIn Project Aquarius at Berkeley, we are investigating the design of a high-performance, multiprocessor system to execute logic programs, currently Prolog (Dobry, Despain, Patt 1985). We seek efficient synchronization schemes that will allow us to exploit the concurrency inherent in logic programs. (p.19) Specifically, processes in a shared-memory system communicate by taking sole access to some shared data object and writing it, leaving information there for another process to read. One example, typical of Prolog and dataflow, is the producer/consumer relationship. The system of immediate interest to us is the Aquarius multiprocessor Prolog architecture, whose design is being developed (Dobry, Despain, Patt 1985).
An initial report on the design of Ariel DBMS with an integrated production rule systemAnother significant area of research is in logic programruing, primarily the PROLOG programming language [Bra 86]. Research on database rule systems has focused primarily on two areas: (1) deductive databases (e.g. making PROLOG work over a large database) and (2) addition of rule-based programming features to database systems. The goal of the line of research on deductive databases (1) is essentially to extend the query processor of a relational DBMS, or couple a DBMS to a PROLOG system, in such a way that recursive queries can he processed efficiently over large databases [GM78, BJ86, Ull 85, ISW86]. In Larry Kerschberg, editor, Expert Database Systems/Proceedings From the First Inter. national Workshop, Benjamin/Cummings, 1986. [Bra 86] Bratko. PROLOG Programming for Artificial Intelligence. Addison Wesley, 1986.
"Structural Correspondence Specification EnvironmentBut the mu.ltl-langueage dialogue is taken tnto account tn design. It is simpler In PROLOG to add a new dialogue language. The auto-verification option Indicates whether the static coherence (see 4. The system Is designed for being rapidly implemented and east Iy modt f led thanks to Its modular Ity and especially to a htgh level logic programming language: PROLOG (3]. We have tried our best to make the system as user-fr lendly as possible. Donz, ""PROLOGCRISS, une extention du langage and 28 N° PROLOG"", CRISS, Unlverslte II de Grenoble, Juillet 1985. 4."
Organization of array data for concurrent memory accessIn the general case, the compiler doesn't have information about the initial value of the loop counter and it is necessary to generate a prolog sequence of code to initialize the value of base and jump to the correct inner loop. Even though extra code must be executed before execution of the loop proper begins, each loop is executed many times, and the benefits obtained by achieving higher effective memory bandwidth offset the overhead of executing prolog code. Furthermore, in horizontally microcoded and VLlW architectures this prolog code may possibly be executed in parallel with the code that precedes the loop.
Prototyping techniques for different problem contextsFor instance SBAL (Small Business Accounting Language) [23] provides a view of accounting that can be shared by specialists and users in order to explore a variety of solutions and to determine where to build flexibility into the system. Other very high level languages such as Prolog can be used as formal specification languages when based on a specific domain of analysis. Prolog is useful in this context for its underlying semantics which provide a very high degree of abstraction [21]. Lehman M., The environment of program development and maintenance - Programs, program support, Reprinted in SoftwareDevelopment Environmentt Wasserman A., Ed., Computer Society Press, New York, 1981, 3-14. 21. LeibrandtU. and SchnuppP., An evaluation of PROLOG as a prototyping systems, in Approaches 263 CH1'89 PROCEEDINGS to Prototyping, Budde R., Kuhlenkamp K., Mathiassen L. and Zullighoven Springer-Verlag, Berlin, 1984, 424-433. 22.
C-logic of complex objectsFor any two type symbols ~1 and ~2such that pi 5 Lo, TAp contains a formula VX(L~(X) > us), which is also written in Prolog's cnnventiou as Lz(X) :- Lx(X). Then any first-order semantic structure of L' satisfying TAL- would also correspond to a semantic structure of L. CardeIIi L., A Semantics of Multiple Inheritance, in: Semantics of Data Types, LNCS 173, 1984, pp. 51-67. 1231 Debray S.K. and Warren D.S., Detection and Optimization of Functional Computations in Prolog, in: Third international Conference on Logic Programming, ed. Xu J. and Warren D.S., A Type Inference System for Prolog, in: Proc. 5th Znternat. Conf und Symp. on Logic Programming 1988, pp. 604-619. 36P 370 372 373 374 375 376 '377 378
Data flow relation processor for knowledge base machineGeneration of Relational Data Base (RDB) Queries from PROLOG A PROLOGprogram consists of a set of facts and a set of rules. Then these proof-plans are stored in the memory instead of a set of PROLOG programs. When a query is entered, a set of data base queries transformed from these proofplans is sent to the DBM. Furthermore, if a higher level language than PROLOGcontains a large number of PROLOG queries, then the join operation that has to be carried out by the DBM will be enormous.
"Building a large thesaurus for information retrievalCollins Dictionary of the English Language In 1985 we obtained a magnetic tape containing the typesetter's form of CDEL from the Oxford Text Archive and embarked upon the task of converting that to a fact base in the form of Prolog relations (Wohiwend 1986). CDEL is a large dictionary with about 82,000 headwords. By the fall of 1986 Wohlwend, France and Chert had extracted all suitable data from the CDEL tape, placed it in the form of facts that could be loaded into a Prolog system, and collected statistics regarding occurrences (Fox et al. 1986). Workshop on Machine Readable Dictionaries, SRI, Menlo Park, CA. Wohlwend, Robert C., 1986. ""Creation of a Prolog Fact Base from the Collins English Dictionary."""
EUROCAL '85 AbstractsThis paper has two parts. In the first part we show that Prolog is an appropriate language for specifying geometric objects by constraints. The limitations of this approach come from the fact that in geometric computation algorithms and numerical problems dominate, but Prolog does not support these requirements. In the second part we describe a programming system that interfaces Prolog to Modula-2, and thus allows a programmer to bypass the limitations of a special-purpose language such as Prolog with procedures written in a conventional language. ERIL forms part of the algebraic tools developed in Waterloo Prolog for the AVER project in the Department of Computing, Imperial College, aimed at providing an environment convenient for the specification and verification of computer programs.
"Site report: language in the Computer Age: a note on current activities in computational linguistics in GermanyFive types of events were offered: thematic courses, intensive practical programming courses in LISP and PROLOG (elementary and advanced), a lecture cycle by course teachers, invited and guest lectures, and panel discussions. The present writer's selection was Kay on ""Unification Grammar,"" Kilbury on ""Parsing in PROLOG,"" Uszkoreit on GPSG and, further afield, Tiilmann and Schiefer on ""Signal Processing in Experimental Phonetics."""
Knowledge base applications with software engineering: a tool for requirements specificationsAs these rules will be examined throughly in the checking phase, a Prolog-based format was adopted. A number of benefits are realized through the use of a Prolog-based format [16]. Subrahmanyam, The 'Software Engineering' of Expert Systems: Is Prolog Appropriate?, IEEE Transactions on Software Engineering SE-11, 11 (November 1985), 1391-1400. 272
"Safety and correct translation of relational calculus formulasSafety and Correct Translation of Relational Calculus Formulas Allen Vm Gelder* Stanford Uruverslty Rodney W Topor University of Melbourne Abstract 1 Introduction Not all queries m relational calculus can be answered ""sensibly"" once disJunctIon, negation, and umversal quantlfication are allowed The class of relational calculus queries, or formulas, that have ""sensible"" answers 1scalled the domaw Independent class, which IS known to be undecidable Subsequent research has focused on Identifymg large decidable subclasses of domam independent formulas In this paper we mvestlgate the properties of two such classes the euoluoble formulas and the allowed formulas Although both classes have been defined before, we give slmphfied definitions, piesent short proofs of their main properties, and describe a method to mcorporate equa1lt.y Alt 11o11gh cvaluable que~ES have SCnslble answers, It IS uot l tralghlforwartl to corii~~ilc them efiiclently or correctly We Introduce relatronul algebru normal form for formuLti flom whtch form the correct translation mto relatlonal algebra 19 trivial We grve algorithms to transform an evaluable formula mto an equivalent nllowed formula, and from there mto relational algebra normal form Our algorithms avoid use of the stxalled Dom relation, conslstmg of all constants appearmg m the database or the query Fmallv, we describe a restriction under wluch every domam independent formula IS evaluable, and argue that evaluable formulas may be the largest decidable subclass of the domam Independent formulas that can be efficiently recogmzed With the increased Interest m development of deductive database systems and mtegratlon of logic programming languages such as Prolog with relational database systems, It has become more important that relational query systems be able to handle a wider range of relational calculus formulas correctly and efficiently In particular, disJunctlon, negation, and universal quantlficatlon over subformulas, which are excluded from the class of congunctrve querzes [Ull80], should be available Current ""mdustrlal strength"" lmplementatlons handle the class of con-Junctlve queries well, but leave much to be desired m the areas mentioned, we shall give an example later In defense of these Implementhtlons, we should point out that the large maJolky of queries posed by typical users to tradltlonsl databases fall Into the class of conJunctlve quenes However, m sophIstIcated systems of the future we envlslon the queries often being generated not by the user typing them m at the termmal, but by a layer of software posltloned between the user and the relatlonal database system This software will accessa large set of deductive rules m addltlon to the user's query m order to construct relational calculus formulas The Nail' project at Stanford Umverslty [MUVG86] is Just one example of several research proJects headed m this direction *Supported by NSF grant IST-84-12791 and a grant of IBM co1p 2 Problem Statement and Background In this paper we shall be concerned with two main questions 1 Which relatlonal calculus queries can be answered sensibly? If con(z, A) & con(z, B) Figure 1 Definltlons by rules of gen and con snmlar to a Prolog program 3 We Intend that the relations gen and con hold only when they can be estabhshed by a fimte number of apphcatlons of these rules 0 Read the & `s that separate subgoals (to the rlght of the "" If "") as ""and"" For example, the first rule reads, ""x IS generated m P d P IS an edb atom, and ir IS free m P "" %cral predicates appear m these rules to support 111~1tl&nltlons of gen dnd (011 We 1nt~t1t1that they IW . . . . . ,a 4Crll ,~""r/ntp on 7'lWOl (r of Co7,rp/ll/7,q, p'lp,""G IL I I 14, IO80 .J 1, l\ll1lll~ /l7l~UV /11/g ()ClC~/lO/,~ by Computer A Logical Study `I'echiiic~il Report RM -542%Pit, It& Carp , 1967 J W Lloyd and R W Topor Making Prolog more exprrsslve Joarnal of Logic Programmmg, l(3) 225-240, 1984 J A Mahowsky Chalactellzmg data base dependencies In 8th Co11 on Automata, Languages and Programlnzng, Springer Verlag, 1981 Z Manna Malhemaiacal Theory of Computatron McGraw-Hill, New York, 1974 K Morris, J D Ullman, and A Van Gelder Design overview of the Nail' system In Thrtd Int'l Conf on Loglr Prograrnmzrrg, July 1986 I -M N~colnsand It Dcmolombc~ On l/lc ,Slabrlglq of Ilclalioital C)urrl( 9 `I'w 1111ic *II I<(~OII, ON El1A-( '151(`1, 1082 J -M Ni(ohs Logic for iinpioving integllty checkmg m relational databases Acta Informataca, 18(3) 227-253, 1982 R Topor Domaan Independent Formulas and Databases Technical Report 86/11, Umv of Melbourne, 1986 (To appear m Theorettcal Computer Sctence) J D Ullman Prtn clples of Dais base Sysiems Computer Science Press, Rochvllle, MD, 1980 (Revised Ed 1982) A Equality Reduction and Wide Sense Evaluability In this appendix, we tlcsclibe transformations thal normahze foimulds with respect to equality (=), which wc call quality rcductron Many formulas colll`L11l1n~ ( qlldllty do not S.ll 14-y Ilw I~'qIIIlcIIIclII~ for evdliinhility in11 i~lly, but arc cv~~lu."
"Adaptive multiagent planning in a distributed environmentThe DDL is a parallel logic interpreter which is built on the syntax of Prolog and is capable of handling a superset of Prolog programs. Comp., 1980, Chapter 7. 18. Sharipo, E., ""Concurrent Prolog: a progress report,"" IEEE Computer, 1986, 44-58. 19."
Explanation in ecological systemsThe purely arithmetic condition does not influence the certainty of the outcome at all. General Prolog clauses may be included in the condition-list. Versions of the PISCES system have been implemented in both ARITY PROLOG and TURBO Prolog. The system runs on a standard IBM compatible personal computer with 640K RAM.
Application of artificial intelligence to aphasia treatmentAn inference algorithm called MIS (Model Inference System) induces a Prolog program satisfying all the facts provided to the system. In this step, the domain model acts as the oracle as it contains the correct knowledge. Since it is represented as a Prolog program, some goal is evaluated and the value obtained after execution constitutes the oracle's response. We have implemented a prototype of the system in Prolog on a Sun workstation. As mentioned earlier the lexicon contains about 400 items linked to their linguistic properties.
Japanese-to-English project: PROTRAN & TWINTRANWe have since achieved a working prototype of the sentence-for-sentence component known as PROTRAN and work now continues at Kobe University, under SHARP sponsorship, on the development of a textwide component (TWINTRAN) which could run on top of the existing model. 50 2 Sentence-for-Sentence Component: PROTRAN 2.1 Linguistic Rules and the Processing System Our mMn task in the last year of research has been to reformulate the sentence-for-sentence Japanese-to-English system in such a way as to make the complete linguistic information explicit, which are executed by a processing system separate from these rules. The processing system is all programmed in Prolog and executes the linguistic rules by applying a function to each type of ule. McG. : The ALVEY Japanese and English Machine Translation Project, Proceedings of Machine Translation Sunrmit Conference, Tokyo 1987. [2] Jelinek, Jiri : A Linguistic Aspect of Transformation Rules, in Acta Universitatis Carolinae - Philologica, I (Slavica Pragensia, VII), Prague 1965. [3] Jelinek, Jiri : Construct Classes, Prague Studies in Mathematical Linguistics 2, 1966. [4] Matsumoto, Y. : BUP : A Bottom-Up Parser Embedded in Prolog, New Generation Computing, Vol. 1, No. 2, pp.145-158, 1983. 52 3
"Translation by abductionThe idea of interpretation as abduction can be combined with the older idea of parsing as deduction (Kowalski, 1980, pp. 52-53, Pereira and Warren, 1983). C,onsider a grammar written in Prolog style just big enough t,o handle sentence (2). (7) (Vi,j,k)np(i,j) A v(j,k) D s(i,k) (8) (Vi,j,k,l)det(i,j) A n(j,k) A n(k,I) D np(i, 1) That is, if we have a noun phrase from ""inter-word point"" i to point j and a verb from j to k, then we have a sentence from i to k, and similarly for rule (8). ""A Uniform Architecture for Parsing and Generation"", Proceedings, lth Inlernational Conference on Computational Linguistics, pp. 614-619, Budapest, Hungary. [10] Stickel, Mark E. 1989. ""A Prolog Technology Theorem Prover: A New Exposition and Implementation in Prolog"", Technical Note No. 464."
A retrieval model incorporating hypertext linksTo illustrate this, consider the deductive database (i.e. Prolog-like [ClocSl]) p re resentation of a hypertext database shown in Figure 1. For simplicity, we are assuming that N is the only free variable in the formula W. In our Prolog-like syntax, an example query might be ?- about (N ,conceptl5), about (N,concept34). [ClocBl] Clocksin, W., Mellish, C. Programming in Prolog. Springer-Verlag, New York, 1981. [Cohe87] Cohen, P.R., Kjeldsen, R.
An algorithm for generation in Unification Categorial GrammarA sketch of the algorithm Below we present the basic algorithm which implements the informal description given above. We give the algorithm in Prolog for conveniencebecause various refinements to the algorithm to be discussed below (e.g., the use of a chart) depend directly on the procedural aspects of Prolog's control strategy. Implementation The algorithm discussed in this paper has been implemented in C-Prolog. Recent work has looked at generation from semantic representations which are not in canonical format but which are equivalent, under the axioms of associativity and commutativity to the canonical semantics of sentences recognised by the grammar.
A model for generating better explanationsA test version of this model has been implemented in a student-advisor domain using Waterloo UNIX Prolog. Below we present an example to illustrate how the algorithm and the model of the user work together to produce these responses and to illustrate some of the details of the implementation. To actually generate better alternatives and to check whether the user's stated goal is compatible with the user's domain goal, a module of the implemented system is a Horn clause theorem prover, built on top of Waterloo Unix Prolog, with the feature that it records a history of the deduction. The student asking the question is doing poorly in the course and wishes to drop it to avoid failing it. The goals of the query are passed to the Prolog implementation and the response generated depends on these goals, the information in the model of the user, and on external conditions such as deadlines for changing status in a course.
A message processing system with object-centered semanticsImplementation The system is implemented in Objlog ([Dugerdil 89]), a frame language based on Prolog II and featuring multiple inheritance with points of view, selective inheritance for value-sharing in relationships other than taxonomical, and dynamic facets. The grammar Itself is written in Prolog It. A menu-andmouse interface has been developed for the IntexTogation module. 7.
Sixth annual UCLA survey of business school computer usageLISP was the only package identified by five or more schools for the mini/mainframes. Prolog, Exsys, Guru, LISP, and VP-Expert are listed most commonly for microcomputers, with VP-Expert especially strong for instructional use. Attificisl Intelligence, Expert System Software (N = Number of schools reporting software package) Mini/mainframes (N = 20) Microcomputer (N = 69) Instruction Research Instruction Research LISP Other 5 LISP 7 VP-Expert 16 Other 18 Prolog Exsys Guru Prsl Cnlt Other Different Packages 10 11 22 Prolog 15 15 Exsys 8 13 Guru a 12 LISP 8 6 VP-Expert 8 32 Prsl Cnlt 5 Other 22 28 24 TABLE XVII. Programming Language Software (N = Numberof schools reporting software package) Mini/mainframes (N = 117) Microcomputer (N = 115) Instruction Research Instruction Research COBOL 73 FORTRAN 63 BASIC 84 BASIC 58 BASIC 40 BASIC 36 Pascal 30 FORTRAN 38 FORTRAN 28 COBOL 32 C 25 C 31 Pascal 26 Pascal 27 COBOL 25 Pascal 29 C 17 C 24 FORTRAN 18 COBOL 9 PL/l 6 PL/l 10 Prolog 8 Prolog 8 Other 20 Other 16 Other 12 LISP 5 Other 15 Different Packages 19 17 18 16 TABLE XXIV.
Tools and methods for computational lexicologyTwo such models were available to us: a bottom-up, all-paths strategy offered by PLNLP (Langendoen and Barnett(to appear)), and a top-down depth-first approach offered by logic grammars written in Prolog (McCord(1987)). We have versions in PLNLP and VM/Prolog, both of which are basically adequate. The version which supported the work reported here is the Prolog version, however, we are concerned about future problems with the top-down approach when we have to process input that is corrupt. A consequence of (1) is that it takes a large amount of storage to parse an entry. The Prolog version now runs on a 4-megabyte virtual machine under VM/CMS.
Using critics to empower usersWIZARDis an active help systemfor usersof the VMS operating system[9]. PROLOG Explaining [5] critiques a user's explanationof PROLOG code to guide the user toward a better understandingof the PROLOG language.
"The time is ripe for a dyadic executeThe language most commonly used for this applicalions has been Lisp. More recently Prolog and C have become favorites in software development of commercial Expert Systems. Note that both the ""modus pen©us"" and the rule are of the general form common to many non-APL languages, namely the use of IF-THEN clause. The specific implementat/on in Lisp, Prolog and C differs, but the cortstmct exists. Naturally in APL we can write expressions that will have a similar effect, but we do not at present have a primitive runetion to do it."
A compositional semantics for focusing subjunctsz in (23.2), which has dog as its patient. 4 The implementation IDEO (Interpreter Designed for Even and Only) is a limited semantic interpreter that incorporates the semantics for even and only described in Section 3. The implementation is in Edinburgh C-Prolog, running under UNIX on a Sun-4 computer. Because the authors did not have access to a working version of Frail (see Section 1.3), IDEO runs on top of a toy knowledge base, also implemented in C-Prolog, whose retrieval language is (unfortunately) a syntactic variant of Absity's. Firstly, it echoes the sentence in its internal Prolog format. Secondly, the GPSG category obtained for the sentence, which incorporates a parse tree for the sentence, is displayed.
Towards a dictionary support environment for real time parsing(Exactly the same problem would occur ifour natural language systems were implemented in Prolog, since the Prolog 'database facility',refers to the knowledge base that Prolog maintains in main memory.)
Handling shared resources in a temporal data base management systemThe TMM is an extension predicate-calculus data base systems such as PROLOG [2] to handle time. Time maps record information about the truth of propositions that change over time. The main difference between the TMM predicate and those of PROLOG is that in situations like that shown in Figure 7 predications involving total are guaranteed to return with the necessary data dependency informa tion to keep a continuous account of a sum changing over time. Clocksin, W.F. and Mellish, C.S., Programming in Prolog, (Springer-Verlag, 1984). Croft, W. B. and Lefkowitz, L.
Expressing generalizations in unification-based grammar formalismsThe type basic is the only type provided as a primitive in the system, and indicates that only instantiations to an atomic value (in the PROLOG sense of atomic) are legal. In the case where the predicate is a list, it represents a disjunction over adjunct functions, as will be discussed below. This technique has the advantage that one may partition the set of variables employed by the system. Thus in ucG, the set of PROLOG variables that is used to represent variables in an InL formula is disjoint from the set used to represent the predicate introduced by a sign: the type of variables of the first set is stated to be variable, while the type of those of the second set is predicate. This is in distinction to systems discussed by Mellish (1988) and Alshawi et al (1988), in which the set of logical connectives is restricted to those for which an encoding exists using PROLOG terms without repeated variables and for which PROLOGunification provides an immediate test of the compatibility of two descriptions.
"Interpretation as abductionThe syntax portion is represented in standard Prolog manner, with nonterminals treated as predicates and having as two of its arguments the beginning and end points of the phrase spanned by the nonterminal. It is likely that this approach could be extended to speech recognition by using Prolog-stylerules to decompose morphemes into theirphonemes and weighting them according to theiracousticprominence. 5 Controlling Abduction: Hierarchy Type The first example on which we tested the new abductive scheme was the sentence There was adequate Iube oil. ""A Nonclausal Connection-Graph Theorem-Proving Program"", ProcecdingJ, AAAI. 85 National Conference on Artificial Intelligence, Pittsburgh, Pennsylvania, pp. 229-233. [21] Stickel, Mark E., 1988. ""A Prolog-like Inference System for Computing Minimum-Cost Abductive Explanations in Natural-Language Interpretation"", forthcoming. [22] Thagard, Paul R., 1978."
PCTE and Pact--Pact' The Pact 75 Tools Environment Archiving Administration Activity Network External Monitor Monitoring Communication General Tools Textual Query Desktop User-User Communication Project Management Estimation Work-Breakdown Plannin g/S che dulin g Resource Allocation Diary Services Spreadsheet --Pact The Pact 76 Tools Product Management Basic Version Management Structure Control Build Procedures Change Control Life Cycle Support Debugger for C Prolog compiler Common Lisp compiler STRATA Prolog Integration with the OMS ----Pact Pact Common Rationale 77 Services reduce the code to be written by tool writers - reusable building blocks. increase the uniformity and integration- achieved by common structures.
Benchmark semanticsZ/axed 1 Z/txed 1 zF(z)/r(z-[zj) same as domain 1 Zf,ed zr'(z)/r(z-LzJ) same as domain ? ? Prolog adds an additional twist to this, the program defines a relation that behaves as the factorial function as well as its inverse. Gabriel, Performance and Evaluation of Lisp Systems MIT Press, Cambridge, Mass. 1985 [7] R.A. O'Keffe, Prolog Compared with Lisp? SIGPLAN Notices, vol. 18 #5 (May 1983) 48
"Why a single parallelization strategy is not enough in knowledge basesAnother body of relevant research has been performed on parallel and concurrent variations of PROLOG. Much of this research, along with a description of the thme leading languages that have emerged ( Flat Concurrent Prolog, Parlog, and Guarded Horn Clauses ) is summarized in the collection of papers [Sh]. However, there is a fundamental difference between logic program evaluation in knowledge bases, which is performed bottom-up (or forward chaining), and concurrent Prolog, which is evaluated top-down (or backward chaining). Sagiv ""Optimixing Datalog Progrsms,"" Proc. 6th ACM Symp. on PODS, pp. 349362.1987. E. Y. Shapiro ""Concurren t Prolog, collected Papers"", MIT Press, 1987. J.D. Ullman and A."
"A syntactic filter on pronominal anaphora for Slot GrammarLike the Slot Grammar whose input it applies to, 135 the algorithm runs in Prolog, and it is stated in essentially declarative terms. Properties of phrases and relations between them are represented by unit clauses (predications) involving these integers (and other data), which are asserted into the Prolog work-137 space. Because of this ""dispersed"" representation with a collection of unit clauses, the original phrase structure for the whole tree is first grounded (variables are bound to unique constants) before the unit clauses are created. C. (1980) ""Slot Grammars,"" Computational Linguistics, vol. 6, pp. 31-43. McCord, M. C. (1989a) ""Design of LMT: A Prolog-based Machine Translation System,"" ComputationalLinguistics, vol. 15, pp. 33-52."
Finite-state parsing and disambiguationAn alternative and obvious framework for implementing constraint rules is Prolog which would be convenient for the testing phase. Prolog would, perhaps, have certain limitations for the production use of such parsers.
A design rule database system to support technology-adaptable applicationsA general purpose design rule checker, implemented in Prolog as part of the SIDESMAN system, is an example of such a Paper 29.2 verification process. It executes by using the Prolog environment to run the rules translated from DRDL. The complete database definition and manipulation system is implemented on an ORION [14] under UNIX (TM AT & T Bell Laboratories) using Pascal for the main Design Rule Database Management system and Prolog for the DRDL compiler. Current and future work is concerned with the evaluation of the present system definition and implementation, two applications have been experimentally interfaced to the Technology Design Rule Database so far.
"INTERFACILE: linguistic coverage and query reformulation. - an evaluator consults the knowledge base and produces answers to questions given their semantic representation. a general system guides the user and helps him to formulate and reformulate his queries. system is entlrely programmed in PROLOG II and runs on various computers (VAX, SPS rapidly perceived by the user. the interface must be equipped with strategies and procedures for leading the user to adjust his linguistic competence to the capacities of the system. INTERFACILE consultable database system"", Proc. of Conference, 1982. [8] Sabatler P., A Prolog program for doesn't know, but he ECAI knows spelling correction, Note technique, LADL, 1985. [9] Uilensky R."
"Parsing conjunctions deterministicallyAll three systems were executed on a Dec.20 and the times shown for each are just the time taken to build parse trees: time spent on morphological analysis and post-parse transformations is not included. MSG and RPM are written in Prolog and NEXUS is written in Maclisp (compiled). NEXUS was run with the 'no-interpreter' switch turned on. It is not clear whether the parser's speed in the particular cases above comes from divide and conquer or from the differences between Prolog and Maclisp. Nevertheless, as systems are built that require larger, more comprehensive grammars, and that must deal with longer, more complicated sentences, the efficiency of wait-and-see methods like those presented here should become increasingly important. 82 [1] Berwick, R.C. (1983), ""A Deterministic Parser With Broad Coverage,"" Proceedings of/JCA/8, Karlsruhe, W. Dahl, V., and McCord, M.C. (1983), ""Treating Coordination in Logic Grammars,"" American Journal of Computational Linguistics, V. 9, No. 2, pp. 69-91. [5] Fong,S, and Berwick, R.C. (1985), ""New Approaches to Parsing Conjunctions Using Prolog,"" Proceedings of the 23rd ACL Conference, Chicago, pp. 118-126. [6] Ginsparg, J. (1978), Natural Language Processing in an Automatic Programming Framework, AIM-316, PhD."
SESAME a portable data base interface generatorThe grammar and the lexicon are compiled into a Prolog program. Unification which is a basic Prolog operation is thus directly and efficiently used. np :- det, noun, n pp & [np, agr,number] = [noun, agr,number], [noun,compl,concept] = [n_pp, concept], [noun, compl,preposition] = [n_iop,preposition ] . salary :- noun & [concept] = salary, [agr,nuner] = sing, { compl : [concept] = employee, [type] = real, [preposition] = of, [presence] = non obl, [semantic relation] = salary }.
"Lisp implementationsInteractive stepper/debugger allows two-way interaction with source program through the structure editor. Interfaces to CMS, FORTRAN, GDDM and VM/Prolog. Hardware All IBM 370 ""architecture machines Software VM SP3 or later Contact Sales information available from any IBM sales representative Name PC-LISP Standard Franz Lisp subset Missing Features Vectors, bignums, closurs Support It is a shareware program and a donation of $15 is requested if you like the program. Compilers are available for Fortran-77, ISO Pascal, Pascal/VS, Ada, and Prolog, which compile into 3600 machine language. Can do function calls between any of the languages."
Advice-giving dialogue: an integrated systemThis Problem Solver module is based upon a knowledge representation formalism which integrates and object-oriented approach and logic, and is implemented in Prolog [1,2]. The Cooperative Answering Module In the context of traditional applications devoted to company management, like payroll computation, people or programs who have to access data in a 41 Database have a very precise definition of the data they want to access. Henin, Proof 2¥ees for Negation as Failure: Yet Another Prolog Meta-Interpreter, in: Logic Programming, Proe. of the Fifth International Conference and Symposium, Seattle, August 15-19, 1988. [2] A.
A language for legal Discourse I. basic features., they possess an analogue of the unique minimal model property of Horn-clause logic [46, 41, so that every successful query has a definite answer substitution, exactly as in PROLOG. Second, and closely related, the tableau proof procedure for these rules is a straightforward generalization of SLD-refutation for Horn clauses. Instead, LLD allows a user to construct a rule base of deontic rules in the form shown above, and then to query whether, under a particular condition 4, a particular action Q is permitted, forbidden, obligatory, etc. Restricted to these PROLOG-lie inferences, I claim, the proof procedure for the deontic modalities becomes tractable. Bradford Books, MIT Press, 1983. A.J. Bonner. A PROLOG framework for reasoning about permissions and obligations, with applications to contract law.
"Informational zooming: an interaction model for the graphical access to text knowledge basesThe TOPIC system is implemented in C, TOPOGRAPHIC in C and PROLOG, on a CADMUS 9200 with UNIX. The experiences with this type of user however, reveil the dilemma of the interfaces, interaction model underlying formal language interfaces: The more the structures of the database to be accessed are complex - this is a prerequisite effort to supply the user with non for any trivial, relewnt information -, the more dedicated the access language must be. The ""find('Operating System')."" entered terms system command via the ""Prolog"" window is equivalent to the browse-sequence mentioned above. Benlls function: The system asks the user to and the choose operation parameters by pop up menus. activation weight function: Selecting the activation weight in the table of selected concepts will modify the activation weight of the frame. system will ask whether increment decrement is wanted. dialog function: All keybord interaction except function keys is directed to The or the the dialog object. All commands entered way are passed to the Prolog this interpreter. This facility may be used to execute predefined commands - just like the find command mentioned above. zooming the dialog window the gets a command history."
Linda in contextSeveral years ago we published a brief discussion contrasting Concurrent Prolog with Linda [17], but new developments make a comparison between Linda and some of the Parlog solutions recently featured in Communications seem desirable. The server withdraws tuples in arbitrary order using in. The merging problem in Prolog-derived concurrent languages is well-known. Some researchers argue that the solution is simply to add a new merge primitive. Corwmun.ACM 31, :I (Jan. 19881,pp. 10-25. 31. Shapiro, E. ed. Concurrent Prolog collected papers. Vols 1 and 2. The MIT Press, 1987. 32.
EXPRESS: an experimental interface for factual information retrievalThus, SunView events trigger the inv&ation of the functions performed by the underlying Prolog programs. I onscreen presentation I conversion ofanswers of answers check-value browse browse reformulation (broaden/narrow) generation of Figure 2 : The components of EXPRESS In Figure 2 the system components are shown from the functional point of view. At the moment, the reformulation functions are implemented implicitly in the program, each reformulation rule being a specific Prolog clause. In the future, they will be represented more explicitly to separate the inference engine from the knowledge base. Of these, the generic and partitive relationships are partially defined by means of Prolog rules, i.e. the general broader-term reIationship is defined recursively as the transitive closure of the explicit, one-step broader-term] relationship, and narrower terms are derived by inverting the broader-term relationship.
"ESPRIT software engineering environments—a joint European activityNatural semantics ta formalism inspired by Plotkinl has led to the design of a prototyping language, TYPOL and its compiler to PROLOG. Experiments with sample semantic definitions (e.g. A previously implemented prototype (DELTAPROLOG) is used as the basic support for these studies and mill be extended and enhanced accordingly. . data typing in logic programs Prolog lacks a modular type discipline and static or dynamic structure. To make PROLOG really acceptable for non ""single person"" projects, it is proposed to enhance it around a new polymorphic type system and an efficient type checking algorithm, which should include many additional features such as mixed strategy typing, partial evaluation within type elaboration, generic modular structure, incremental processing, compile time macros, etc."
"Hypothetical datalog negation and linear recursionGabbay, for example, has reported a need to augment Prolog with hypothetical rules in order to encode the British Nationality Act. In Proceedingr of the Symporium on the Foundotionr of Computer Science (FOCS), pages 333-347, 1980. D.M. Gabbay. UN-Prolog: an Extension of Prolog with Hypothetical Implications. Joumol of Logic Programming, 2(4):251-283, 1985. D.M. Gabbay and U. Reyle. ""N-Prolog: an Extension of Prolog with Hypothetical Implications."
"Review of ""Natural language processing"" by Hugh M. Noble. Blackwell Scientific Publications 1988.Part 1 presents a description of an extremely simple NLP system by means of the ATN formalism and the programming language POP-11 (partly Prolog, too). The result of the operation of the system--which later is described consistently in a highly limited microworld, adhering to the principle ""from the simple to the complex""--is the parsing of basic English syntactic structures of the simple sentence. The number of possible users of the book would probably have been significantly larger if Prolog had been the main programming formalism used. Because of the various degrees to which mathematical and programming formalisms are mastered by students of linguistics, one cannot' give a definite answer as to the best textbook on CL to be used."
Logic and databases: a responseFurthermore, we did not propose that relational databases should be replaced by programs written exclusively in a logic programming language such as PROLOG (although such a prospect is conceivable and cannot be ruled out provided that PROLOG is suitably enhanced).
"Book Review: Approaches to Knowledge Representation - An Introduction. Edited by G. A. Ringland & D. A. Duce (Research Studies Press Ltd., John Wiley & Sons Inc.(If you want that kind of ""K_R by example"" ap-Page 23 proach then you could try Winston (1985) for Frames in Lisp, Frost (1986) does a reasonable job on how to get from data to knowledge representation, Chamiak et al (1987) is a good source for various approaches in CommonLisp, the trusty collection by Schank & Riesbeck (1981) is good for schema-type approaches, and there are numerous textbooks with examples of prolog (e.g. Bratko, 1987). The most impressive and sustained arguments for production systems as a knowledge representation formalism is found in Klahr et al (1987), the work by Newell and colleagues on the SOAR architecture, and of course Anderson's ACT*. I (1985) Readings in Knowledge Representation. Morgan Kaufrnann. Bratko. I. (1987) Prolog Programming for Artificial Intelligence. Addison Wesley."
New methods and fast algorithms for database normalizationHasan and York [7] have reported on a tool for helping users to specify functional dependencies. Recently, Ceri and Gottlob [5] developed a Prolog-based system for normalization, uniting several heretofore uncorrelated algorithm for projecting functional through Boyce-Codd normal form, by results. They also incorporated a new dependencies on to subrelations. Another tool written in Prolog, which gives the designer a means of prototyping a small but representative database and of executing described by Bjornerstedt and Hulten queries and transactions, has been [3]. One performance enhancement, not used in [5] because of inherent difficulties in implementing it in Prolog, is a method for computing closures in linear time, Algorithm A2 [2].
"SDA: A novel approach to software environment design and constructionInitially, knowledge about the design process is to be expressed in a rule-based formalism based on extensions to Prolog developed at Shizuoka University [Ochi88]. A Prolog rule is used to represent a primitive design activity and predicates correspond to either tool invocations or human design activities. Arguments specify the software objects involved in the activities. The backtracking feature of Prolog has been extended to represent controlled iteration by introducing a new notation for backtracking scope. Nobe, ed., ""Overview of the FASET Project: A Formal Approach to Software Environment Technique,"" internal report, JSD Corporation, 1986. K. Ochimizu and A.. Ohki, ""A Prolog-Based Approach to SDA Prototyping,"" presented at the Twenty-First Hawaii [ntemational Conference on System Sciences, Kailua, Kona, Hawaii, January 1988."
Viewing object as patterns of communicating agentsThe model is fully abstractin the sensethat agentswith the sameexternal behaviour can be viewed asequivalent [20]. We have designed and implemented (ii Prolog) an executable notation called Abacus [24], modelled closely after CCS [20] and CSP [ 131. These rules are implemented in a straightforward way in Prolog, specifying for any given behaviour expression what events may take place, and what the replacement expression will be. We further exploit Prolog in the examples that follow by using functors asa,@ names and lists and tuples asevent names.
"Pattern match reduction for Relational Production Language in the USL MMDBSSome researchers have embraced an ES language like OPS5 and considered an implementation against a disk-resident DBMS [Sellis 88]. Others have tried a similar approach using Prolog [Ioannidis 88, Napheys 88]. Within the database arena, extensions to a relational query language using database procedures have been studied [Stonebraker 87, Hanson 88]. SIGMOD [Ioannidis 88] Ioannidis, Y.E., et al., ""BERMUDA - An Architectural Perspective on Interfacting Prolog to a Database Machine,"" Proceedings of the 2nd International Conference on Expert Database Systems, April 1988. [Napheys 88] Napheys, B. and Herkimer, D., ""A Look at Loosely-Coupled Prolog/Database Systems,"" Proceedings of the 2nd International Conference on Expert Database Systems, April 1988."
Logic and databases: a responseFurthermore, we did not propose that relationa l databases should be replaced by programs written exclusively in a logic programmin g language such as PROLOG (although such a prospect is conceivable and cannot be rule d out provided that PROLOG is suitably enhanced) .
Transfer and MT modularityThis is probably what Arnold et al [6] have in mind when they suggest that transfer should be viewed as a relation between two devices. generating We have recently begun developing a system that seeks to implement such an approach. We have chosen PROLOG II (Universit d'Aix-Marseille) as the implementation language, in order to take advantage of the handling of partial information in a timeindependent manner that is offered by unificationbased formalisms (cf Kay [2]). PROLOG II also has built-in facilities for parallel processing. our system is still in the embryonic stage, Though it can already translate in both directions between English and French, or simply enumerate pairs that are translationally equivalent. of sentences III.
Two views of teaching Ada — integrated and stand-aloneThe other five courses focused on FORTRAN, PL/I, LISP, C, and ProLog. The short course was offered again in the Spring of 1990. Students in Artificial Intelligence or Expert Systems did their programming in LISP or Prolog. Students in Operating Systems sometimes did their programming in C. As already mentioned, during the 1988-1989 academic year, courses were offered in six languages: FORTRAN, PL/I, LISP, C, Ada and Protog. in the Spring, 1990 semester, courses were offered in C, Ada and Prolog. These courses were offered 269 on an experimental basis and have not become part of the regular course offering.
Business implications of knowledge-based systems. part IITwo life cycles: knowledge, shell Expert and programmer Expert and knowledge engineer Somewhat known Create new representations representations One life cycle Two life cycles Some clear, some fuzzy Fuzzy Few to none Very few Cobol, Fortran, Basic, 4th LISP, PROLOG, ES tools generation languages Conversion of specs, Knowledge engineering, interpersonal consulting, high interpersonal Low to high High TABLE 1. More recent announcements promise to provide extensive LISP or PROLOG based computing power for individuals at a substantially lower price. A given problem might be better expressed in a frame language, or perhaps PROLOG. KEE has the capability to create rules and PROLOG, in addition to its frame representation.
Efficient parsing for FrenchThe problems with CUG are that on the computational side, graph-unification is costly and less efficient in a Prolog environment than term unification while from the linguistic point of view (a) NP's must be assumed unambiguous with respect to case which is not true for - at least - French and (b) clitic doubling cannot be accounted for as a result of using graph unification between the argument feature structure and the functor syntax value-set. IMPLEMENTATION AND COVERAGE FG is implemented in PIMPLE, a PROLOG term unification implementation of PATR II (cf. To appear in the Proceedings of the Fourth European ACL Conference (UMIST, Manchester, 10-12 April 1989), 249-255. Calder, J. (1987) PIMPLE ,A PROLOG Implementation of the PATR-H Linguistic Environment.
Future Directions in DBMS Research - The Laguna Beach ParticipantsThe participants were unanimously negative on the prospective research contribution of hardware data base machines, general recursive query processing, and interfaces between a DBMS and Prolog. On other issues such as the importance of research into data base tool kits, the participants held divergent positions. Any 4GL standard is expected to be many years away. 4.3. Prolog There is considerable current research activity in interfacing Prolog to a DBMS.
CLASSIC: a structural data model for objectsAlso, rules and deduction in general are not part of the work on structured terms-instead Ait-Kaci has chosen to merge Prolog with structured terms used as types [4]. 6.2 Non-traditional queries and answers Probably most closely related to CLASSIC is the work on the new data model CANDIDE. [7] It essentially has many of the features of the terminological logics noted above (being based on KANDOR), but is phrased in a notation more `The significant exception is the CANDIDE data model, discussed below. familiar to database researchers, and is extended for expressive ease. These can be manipulated as terms in an extension of Prolog, thus providing considerable generality and power to the language, partly because it is connected to Prolog as a data manipulation language, and partly because the reasoning with these definite terms is carried out as full generalpurpose theorem proving, using predicates like DEMONSTRATE. Goebel, R. G. The design and implementation of DLOG, a Prolog-based knowledge representation system. New Generation Computing, 3:385-401, 1985.
Reducing search by partitioning the word networkHirschman 1982 L. Hirschman and K. Puder, Restriction Grammar in Prolog. In Proe. o the First IaternaHonal Logic Programmlag Con/ereaee, M. Van Caneghem (ed.), Association pour la Diffusion et le Developpement de Prolog, Marseilles, 1982, pp. 85-90. Hirschman 1988 L, Hirschman, Conjunction in Meta-Restrlction Grammar.
"A forward-looking method of Cache memory controlThey are written language ""P"", which is roughly comparable to ""C"" in style, but encouraging greater use of registers and planar operations, and subject to strict environmental control at all times: qsort: Conventional quicksort of an array of 4096 integers bsort: Batcher sort of the same data, using planar arithmetic assem: Microprogram assembly, using top-down token and syntax analysis with backtracking prolog: Interpretive execution of a Prolog test f i l e , making extensive use of short sequences and multiple stacks."
"Higher-order abstract syntaxHigher-order abstract syntax is appropriate and useful for almost all languages, including Prolog, ML, Pascal, various logics and type theories, Hoare logics, etc. Almost all languages have these binding constructs, though sometimes they are not immediately apparent, For example, in Prolog the ""free"" variables in a clause are actually bound in that clause, since they are clearly distinct from variables with the same name in other clauses. An early problem with our type signature specification language was that implicit binding constructs could not be handled. For example, in Prolog the binding of the free variables over a clause is implicit, and it need not have the same type as a variable with the same name in another clause."
Designing families of data types using exemplarsFigure 6 contrasts these two kinds of sharing. Lisp and Prolog currently rely exclusively is an issue, these lists must be constructed prefix-sharing lists permit the efficient on suffix-sharing lists. An evolutionary change in programming technology. with a Prolog-based object-oriented language. In Object-Oriented Programming Systems, Languages and Applications '86 (Portland, Ore., Sept. 16 GOLDBERG, A., AND ROBSON, D. In European Conference on Object-Oriented Object-Oriented Programming in Concurrent Prolog. Vol. 1, New Generation Computing, OHMSHA Ltd., and Springer, 1983, 25-48.
"The parallel complexity of simple chain queriesINTRODUCTION Consider the followmg three queries R2 S(t, Y>- a(c, Zl), qa, Zz)r S(Q, 23), 423, Y) S(t, Y)+- b(z, y) T3 S(z, Y>+- a(t, fl), S(a, Z2)r 422, %3), S(z3, Y) S(z, Y>+- b(z, d They are written m a notation called DATALOG, that IS, PROLOG without function symbols and other Impurities (an orthogonal way of vlewmg DATALOG 1s as Relatlonal Calculus with the additional power of recurslon) For more on DATALOG see, for example, [UV] Both queries above define a view S m terms of the database relations a and b We are Interested m the parallel complexJtyof these and similar queries, that is, the degree to which such queries are amenable to rapid parallel evaluation by the cooperation of many processors Recently, m view of the projected avallablhty of multlprocessmg systems with a very large number of processors, there has been much Interest m such a classlficatlon of computational problems In particular, it has been proposed that a problem be considered satlsfactorlly solved m parallel if there IS an algorithm for it which can be rendered as a circuit with a polynomial number of gates, andpoiyiogarlthmlc depth (that IS, of depth O(logk n), where n IS the length of the input) The class of all problems thus solvable 1s called NC [Co] Obviously, NC 1sa subset of P, the class of all problems solvable m polynomial sequentd time (It IS perhaps amusing that, m response to a sequence of Impresslve breakthroughs m computmg technology, Permlsslon to copy wlthout fee all or part of this matenal IS granted provided that the copies are not made or dlstrlbuted for dnect commerwal advantage, the ACM copyright notlce and the title of the pubbcatmn and Its date appear, and notlce 1s given that copymg IS by penmsslon of the Association of Computmg Machmery To copy otherwlse, or to repubhsh, reqmres a fee and/or specific penmsslon the current concept of ""satlsfactonly solved problem"" m use by theoreticians has actually become less and less ambhous, from recursive sets to P, and now NC ) The mam lesson parallel computation has taught computer sclentlsts 1sthat not all good sequential algorithms can be para! rl 1s a simple variant of the transltlve closure, equivalent queries would reverse the order of S and a m the recursive rule, or use a second S instead of an a As a consequence, the processmg of ~1 and its variants can be done extremely fast m parallel, since the transltlve closure 1san archetypical member of the class NC Interestingly, Ullman and Van Gelder showed that query 7r2 1sP-complete, and thus among the DATALOG queries that are the least hkely to be m NC The difficulty ISnot a function ot the length of the query only, as evidenced by the fact that as 1salso m NC' The issue of Implementmg DATALOG queries 111 ways more Intelligent and efficient than the standard PROLOG interpretation 1s an active area of research Implemcntlug such queries in massively pnrallcl computers 1sal\o ofobvlous interest In this rcagard,It would be Irnportant to tram DATALOG cornpllerz to C~IS~IIIgulsh between queries such as ?"
Infinite loops and how to create themFor example: BASIC: FOR I - 1 TO 100 (Set of statements) NEXT I PASCAL: while (Conditional expression) do (Set of statements) end PROLOG: alterllst (Cl.tl). alterlist (tHead:Taill. CX:YI) :- change (Head,X), alterlist (Tai1.Y). The BASIC code processes the set of statements 100 times. statements The Pasca:h,ode performs the set of until boolean conditional expression is satisfied. The Prolog code is an example of a recursive definition of the reversal of the items in a list, with the exit condition being specified first, indicating that the lists left to be processed are empty.
Syntactic graphs: a representation for the union of all ambiguous parse treesRules for generating triples augment each corresponding grammar rule. Some grammar rules in Prolog syntax used to build syntactic graphs are shown in Figure 3. All readings with a root triple are exhaustively collected by the predicate gen subgraphl using the setof predicate--a meta predicate in Prolog. All readings of a syntactic graph are produced by the predicate gen subgraph, which calls the predicate gen subgraphl for each root triple in RootList. A non-terminal node in a forest with two children nodes has one ]head-modifier relation, and hence the non-terminal with two children in a forest represents one arc in a syntactic gyaph. 13. We use the syntax of Quintus-Prolog version 2 on SUN systems. The special predicate, ( Cond --->Then , Else ), in the algorithm can be interpreted as, if Cond is true, then call Then.
"The PSG system: from formal language definitions to interactive programming environmentsAn almost identical scheme has recently been proposed by Ait-Kaci and Nasr in order to extend PROLOG with inheritance concepts [2]. They propose terms of an order-sorted algebra as the basic PROLOG structure instead of the standard type-free terms, this can shorten the resolution process considerably. The first tuple contains the variables ""ORDINAL"" and ""TYPE"", which are (similar to PROLOG) written in uppercase letters. For simplicity, the names of the variables also indicate their sort (if necessary, indices will be used to distinguish several variables of the same sort). Note that extending unification useful extension of PROLOG. by data-driven evaluation is also considered a We consider this approach to be an alternative to narrowing algorithms [36]."
Discrete discriminant models: a performance simulation with reference to expert systems' applicationsThe major components of the system are written in Prolog and consist of a rule base and an interface (statistical) component is also present. For example, the possible in correlation structures, and missing usefulness of procedure QDF in cases involving log-likelihood reversals summarized in the following simple or unequal covariance matrices can be Prolog fact: try_QDF :- log_likelihood_reversal Hand [18] has discussed necessary , unequal_coy. attributes for statistical expert systems. Pp. 49-55 in Conference on Artificial Intelligence. 4. Cleary, J., K. Goh, and Prolog. Pp. 8-13 in AI, Simulation. 5. Devijver, P. A. 1978.
Research in natural language processingMiller and Gopalan Nadathur, MS-CIS-86-17 In this paper we consider the problem of extending Prolog to include predicate and function variables and typed . We also describe a higher-order logic programming language, called /Prolog, which represents programs as hijgher-order definite clauses and interprets them using a depth-first interpreter. We describe a prototype general user modeling system which we have implemented in Prolog. This system satisfies some of the desirable characteristics we discuss.
"Algorithms to play MastermindWe view this as rather ""unfriendly"" restriction. Code in a large Prolog program can become a somewhat difficult to read, and allowing comments in a_ppropriate place improves enormously the readability and understandability of the code. Some incorrect examples can be found, as well as erroneous and confusing References. Beginning Prolog programmers beware Modularity. Modularity is one of the redeeming features of this product."
"A uniform architecture for parsing and generationIt is interesting to note that the generator is more than an order of magnitude faster than our original PATR generator, which worked purely by 617 top-down depth-first backtracking search, that is, following the Prolog search strategy. The implementation is in Common Lisp and runs on Symbolics 3600, Sun, and Macintosh computers. In any case, although the PrOposal involved using the same arehitecture different formalisms (and hence grammars) were presupposed for the two tasks, ttunning a definite-clanse grammar (DCG) ""backwards"" has been proposed previously, although the normal Prolog execution mechanism renders such a technique unusable in practice. Partial match retrieval or similar techniques from the Prolog literature might be useful here. Nothing has been said alout the importartt problem of guaranteeing that the syntactic and semantic goal properties will actually be realized in the sentence generated."
Kind Types in knowledge representationText understanding demonstrates the usefulness of the system, but many interesting problems in that area of resemch are not addressed by this work. KT is written in VM/PROLOG. It uses a parser, a first-order logic translator and a metainterpreter dew:loped by Stabler and Tarnawsky (19851. The Icxical base for setnantic intcrpretatital in a prolog parser. Wet kshop on the Lexicon, Parsing and Seuaantie Interpretation. Stabler, E.P,, Jr., and G.O. Tarnawsky. 1985, NLProlcg--- A prolog-based natural language facility, To appear. Strawson, P.C, 1953.
"PC-based software: the future is nowA customized expert system, developed in-house or otherwise, is very costly, time consuming, and difficult to write even for a computer expert familiar with PROLOG or LISP. The PC-based expert system shell may be the most effective approach. Edward Mahler, an A1 expert with DuPont, estimates that expert system shells are more efficient than higher level ES building languages (such as LISP and PROLOG) by a factor of eight to one. 4 Stephen Ruth, at George Mason University, states that 95% or more of all the ES 22 implementations are using shells."""
Abstracts of current literatureIn this paper we consider the problem of extending Prolog to include predicate and function variables and typed ? We describe a prototype general user modeling system we have implemented in Prolog. This system satisfies some of the desirable characteristics we discuss. In the first one, two implementations of this algorithm are given, one in C-prolog, one in Interlisp-D. In the second one, the algorithm is compared against the Earley-Shieber algorithm on efficiency.
"On the power of magicPermlsslon to copy wmhout fee all or put of this matcnal 1sgntnted provnkd that the CopKs are no, made or dlstnbutcd for direct wmmcrcml advantqe the ACM fopyruht notla and the tnle of the pubbcatlon and 10 date appear and notIce 8swe"" that CO~Y~W D by permwon of the A.WJCI~O~ for Computing Machmay Tocopyotkwx or to repubbsh. rrqu,rcs a fee and `or specdic twmns~o"" % 1987 ACM O-89791-223-3/87/0003/0269 759 though only the ancestors of John are needed. A top-down strategy(as used,for example,by Prolog), maydo muchbetterby computmgonly theancestorsof John `I'he fht de Computes the nodesreachablefrom John m one step Then the secondrule generatesthe samequery for thesenodes,and the first rule 1sused agamto find the nodesreachablem two steps,and so on There are two modes of zn$mnatzonpasszngm the evaluation of a query The first 1sundicatmn Given a constant m a goal, undicauon with a rule head wdl causesomeofthevatlablesmtheheadtobeboundto that constant. SidewaysInformation Passing A s&ways mfonnatwn passing strategy, henceforth referred to as a sip, is an mherentcomponentof any query evaluauon strategy Informally, for a rule of a program,a sip representsa decision about the order m which the pr&cates of the rule will be evaluated,and how values for vanablesare passedfrom predicatesto otherpredicatesdunng evaluatron Sip strategiesfor the variousrules of a programare not enoughto specifyan evaluauonstrategy A control componentthat specifies, for example,whether to obtam all soluuons for a goal whenit 1siirst called,or whetherto obtamthemoneat a me (as. eg, m Prolog) is reqmred Control is a separate,often independent,component,here,we only dlscllss sips Intmtnfely, a sip describeshow bmdmgspassedto a rule's headby umficauonareusedto evaluatethepre&- catesm the rule's body Thus, a sip describeshow we evaluatea rule when a given setof headargumentsare boundto constants Consider,for example,theprogram presentedin Secuon1 In the query, the first argument 1sbound to John, and by undicahon, the vmable X m the secondrule is bound to John We can evaluatepar usmg this bmdmg,and obtam a set of bindings for Z Thesearepassedto MC to generatesubgoals,which in this casehave the samebmdmg pattern Generalizing from this example,we may say that the basic step of sidewaysmformauonpassmgis the evaluauonof a set of pdcates (possibly with someargumentsbound to constants), and usmg the results to bmd vanables appearmg m another pre&cate This leads to the defimuonof a srpasa labeledgraph,below Let r be a rule, with headprticate p(e), and let ph be a special pre&cate, denoung the head pm&ate resmetedto its boundarguments(If no bmdmgsaregiven, thenph is a hiry predicate,1e , theconstantFALSE In sucha case,we may considerit not to exist at all, asfar asthe followmg discussionis concerned) If a predicate appearsm r's body more then once, we number its occurrences,startmgfrom 0 (The numbermgis Justto identify the posluons m the rule It 1srelevant when umficatlonwith head3of other rules 1sconsidered.)Let P(r) denote the set of predicate occurrencesm the body A sip for r ISa labeled graph that sat&es the followmg condlhons 1 Each node ts either a subset or a member of p(r) (J {Ph} 2 Eacharc 1sof the form N + q, wth labelx, whereN 1sa subsetof P (r ) u {ph}, q is a memberof P(r), and x 1sa setof vanables,suchthat (1) Eachvanableof x appearsmN (II) Each memberof N ISconnectedto a van ablem x (m) For someargumentof q, all its vanables appear m x Further, each vanable of x appearsin an argumentof q that sahsfies this condmon These two condmons define the nature of nodesand arcsof a sip They areexplamedbelow The followmg condltlon provides a consistencyresmcuon on a sip For a graphwith nodesand arcsasabove,definea precedencerelation on the membersof P(r) u {ph) as follows (1) ph prwedesdl membersof P (r ) (11) A prticate that does not appear m the graph,follows every prticate that appears m it (nl) IfN +q Isanarc,andq'EN,thenq'pre =daq We cannow statethe lastcondluon defining a sip 3 The precedencerelauon definedby the sip is acychc, 1e , its tranahve closure1sa part& order We explam the meaning of such a graph, by 6rst explammghow the computauonof a rule usesone arc, thendealmgwith the completecomputabonof the rule. Further, by our defimuon of adornments,an argument 1scon-sideredfree If any vanable m It 1sf&e The latter resmcuon essenually limits us to the class of methods which makeno useof parually mstantu@darguments (Prolog IF an example of a strategy which does not belong m this class) However, If we consider only Datalog programs,this dlstmchon does not arise, and our definition of a methodmcludesall methodswhich mfer facts solely from the logical unphcahonsof the rules An ophmd method 1sdefined to be a method which generates only the facts reqmred by the above definition Wehavethefollowing theorem t Theorem 9.1: Considera query over a setof connected rules P, where a sip 1sassociatedwith each rule Let Pm8be the setof rewntten rules producedby the GeneralizedMagc Setsmethod The bottom-upevaluahon of P mgISoptimal (upto the overheadof generatingthe magicsets) [] Thus, the Mapc Sets method unplements a stp optimally in that it generatesno unnecessaryfacts This clam is modulotheoverheadinvolved m computmgthe magic sets,which 1sthe number of facts of the form muglcp(Q, for someprticate p and someargument hst of constantsC However results m [Banctlhon and Ramaknshnan86b] demonstratethat the number of magic facts is, in general,a small fracuon of the generatedfacts Further, It follows at once from the above theorem that the bottom-up evaluauon of Pw can mimic any method wluch implementsa pven sip In parhcular, all published strategiesm the l~terahnecan be describedby a sip (and somecontrol nnplementmg the SIP),and thus the Magic Sets method does not evaluateany fact that thesestmteees do not generate Thus,we havethefollowing corollary Corollary 9.2: Considera queryover a setof connected rules P, where a sip ISassociatedwith eachrule Let Pm8be the setof rewntten rules producedby the Genera&d Magic Setsmethod The bottom-upevaluaaon of P m8is safeif any safemethodexists for evaluahng P dccordmgto theassociatedSIPS[I Let s I and s2 be two sips for a given rule We saythat s,>s2tiforeveryarcN +p ms2wlthlabel&we haveanarcM +p msl wlthlabel#,whereN rM andXS,+ Sos2~saparhalsip,andslaa@uhalor full) sip which does all the mformahon passingm s2 (and possibly more) For a given set of bound argumentsm the headof the rule, a full sip 1sthus a SIPs 1 suchthat for every possiblesip s2 with the samesetof boundargumentsm the head,sI> s2 We havethefollowmg lemma Lemma 93: Given a connectedrule, and two sips s 1 and s2 for thusrule, the set of facts computedby an ophmal method for s1 IS contamedm the set of facts computedbyanoptunalmethodfors2tfsl"
High-level language debugging for concurrent programsThe ETR tool, the replay tool, assertions were implemented the queries tool and the checker of temporal completely in Prolog [6], while the debugger's database is in fact a Prolog database. Therefore, the limiting efficiency of the interpreters for OCCAM factor of the prototype is the performance and Prolog. Both of these are unrealistically slow, since the Prolog code was not optimized simulates concurrency using time-sharing. and the OCCAM interpreter The OCCAM translator took several minutes to compile and execute debugger.
"Stable models and non-determinism in logic programs with negationTo satisfy this strong need, special constructs were introduced, such as the declarative constructs of choice in LDL [KN,NTj, the witness operator in [AV], and the procedural cut construct in Prolog (although the cut serves many other purposesas well). However, no special construct is neededonce a stable model semantics is used for logic programs, since the (multiple) stable models semanticssubsumesthe LDL choice construct, which, in turn, provides a declarative substitute to Prolog's cut [KNj. The well-founded model semanticsis not suitable for the example application, inasmuch as it produces a partial model that blurs the meaning by assigning an ""undefined"" classification to all the a-st facts listed above. Partial Models, Founded Models and Stable Models Let us start by defining our language (Horn clauses plus negated goals in rules, as Prolog) and basic concepts and notation jUJj. A term is a variable, a constant, or a complex term of the form f (tl, . . . , t,,), where tl, . . . , t,, are terms."
"A recursive interpreter for the Icon programming languageSimilarly, the resolution algorithm fo r logic programming languages such as Prolog is also expresse d concisely by recursion [10-121, where the recursio n corresponds to a depth first traversal of the SLD-tree of th e program . Sussman, St ructure an d Interpretation of Computer Programs, MIT Press , Cambridge, MA, 1985 . J . Campbell (ed), Implementations of Prolog, Elli s Norwood, 1984 . J . Stojanovksi, ""A Note on Implementing Prolog i n Lisp"", Inf . Letters 23(Nov . 1986), 261-264 . J . Cohen, ""Describing Prolog by its Interpretation an d Compilation"", Comm ."
"The ergo support system: an integrated set of tools for prototyping integrated environmentsThe ESS implementation of this interface is used by nearly every component, and has been used to represent expressions in a variety of languages,including Pascal,Prolog, ML, Hoarelogic assertion languages, and others. One important feature that distinguishes this from an environment such as provided by PRL [C*86] is that the current proof goal may contain free variables (""logical"" variables, in Prolog terminology), and thus allows the ""theerem"" to be created during deduction. Gopalan Nadathur and Dale Miller. An overview of /\Prolog. In Robert A. Kowalski and Kenneth A. Bowen, editors, Logic Programming: Proceedings of the Fifth International Conference and Symposium, Volume I, pages 810-827, MIT Press, Cambridge, Massachusetts, August 1988."
Managing knowledge about information system evolutionThe interface of the proposition processor is defined by the behaviour links but mainly consists of the two operations retrieve_proposition(p) and create_proposition(p) which allow the insertion of new propositions and the querying of the propositions in the Proposition Base subject to the content of the CML Axiom Base. Several physical representations (e.g. Prolog workspaces, external databases) of propositions can be managed by the proposition base. The Inference Engines support various proof strategies for question-answering on the KB (in the current implementation, the Prolog prover with some enhancements concerning negation is the only such proof strategy). The GKBMS is being implemented in a UNIX environment, using BIM-Prolog which offers interfaces to graphical display on experiences with the current prototypes, a large number of and external DBMS (relational and Entity-Relationship).
"Mandatory security in object-oriented database systemsTwo approaches to implementing such an inference controller are as follows: In the first approach, the databaseas well as the security constraints are expressed in a logic programming language with support for representing and manipulating objects. An example of such a language is object-prolog [ZANI84]. In the second approach, an object-oriented database system is augmented with an inference engine and a rule base. [MORG87] Morgenstem M., ""Security and Inference in [THUR89d] Thuraisingham M.B., ""Security Checking Multilevel Database and Knowledge-Base Systems"", with Prolog Extensions"", Presented at the 2nd RADC Proceedings of the ACM SIGMOD Conference, San Database Security Invitational Workshop, Franconia, NH, Francisco, CA, May 1987. [ZANI84] Zaniolo C., ""Object-Oriented Programming in Prolog"",Proceedings of the IEEE Logic Programming Symposium, 1984."
"Strategies for interactive machine translation: the experience and implications of the UMIST Japanese projectPile prototype system runs on the ICL PERQ, though much of the development work has been done on a VAX ]]./750. It is implemented in Prolog, in the interests of rapid protohyping, but intended for optimization. This realises f-structure (graph) unification as Prolog (term) unification, greatly enhancing the efficiency of parsing. This is particularly true for a high-level ""programming language"" like Prolog. 5. This is a good example of how 'have a go at anything' systems may be hindered incorporating linguistically from motivated techniques."
Algorithms for generation in Lambek Theorem Proving[Pros:X:Y] => [Pros:X:Y] <- (nossnvar(X), nonvar(Y)) k 1,rue. lVem der Linden and Minnen (submitted) contains a more elaborate comparison of the extended cedcu]tmwith the origins] calculus as proposed in Moortgat (1988). 2A suggestion similar to this proposal was made by Knig (1989) who stated that lexicsI items are to be seen as axioms, but did not include them as such in her description of the L-calculus. SThroughout this paper we will use a Prolog notation because the architectures presented here depend partly on the Prolog un[icstlon mechanism.
Simulation system for the control of manufacturing linesThe language initially used for knowledge representation was EMICAT. l The simulator itself was built in PROLOG. As EMICAT is an object oriented language based on PROLOG, we had a consistent environment.
The University of Washington illustrating compilerSPM is easily extended by writing rules that use an underlying pattern matcher and unifier, similar to that found in Prolog. For example, a pattern describing the operation to advance down the head of a queue is: ( , lookfor two adjacentstatements ,x := head (t-assign (tJutscalar ? Figure 6: Sequence of BFS Data Iliustration In earlier versions of UWPI, the inferencer was implemented in Prolog to exploit that language's pattern matcher and unifier. Unfortunately, the interface between the two parts was slow and rigid, and Prolog's applicative style was more of a hindrance than a help, especially when attributing the IR.
"Dynamic query evaluation plansConsider a model of execution that relies on backtracking, particularly Prolog [12, 131. The same clause is activated repeatedly with different variable instantiations. Pirahesh, ""Query Rewrite Optimization in Starburst,"" Computer Science Research Report, (RJ 6367 (62349))IBM AImaden Research Center, (August 1988). D.H.D. Warren, L.M. Pereira, and F. Pereira, ""PROLOG - The Language and its Implementation Compared with Lisp,"" Proceedings of ACM SIGART-SIGPLAN Symposion on AI and Programming Languages, (1977). W. Clocksin and C. Mellish, Programming in Prolog, Springer, New York (1981). A. Goldberg, D. Robson, and D."
Analyzing explicitly-structured discourse in a limited domain: trouble and failure reportsThe results of analysis ar e passed to a database module, which maps PUNDIT'S representations to pre-defined records in a Prolog relational database. This database can then be queried using a natural-language query facility (QFE). IMPLEMENTATION The TFR Discourse Manager is implemented as a single top-level control module, written in Prolog, which uses PUNDIT as a resource. Its highest-level goals are to collect pre-defined information from the user and send the resulting information state to a database update module.
Regular right part programming languagesWe contrast this situation with a rule-based language such as Prolog. In Prolog, various rules are tried until one succeeds, back-tracking whenever a rule fails.
A dietary recommendation expert system using OPS5Whether to select a programming language (e.g., PROLOG) or a knowledge engineering language (e.g., EMYCIN) is a subtle issue. Stefik, 'Expert systems: perils and promise,' Corn. of the ACM, Vol. 29, No. 9, pp 880-894, 1986. Bratko, I., PROLOG: programming for artificial intelligence, Addison-Wesley, Reading, Mass., 423p, 1986.
Multiple-query optimizationthe system will have to evaluate all three rules in order to come up with the answer. Because of the similarities that Prolog [6] clauses have with the above type of rules, our discussion on multiple-query processing applies to the optimization of Prolog programs as well, assuming that secondary storage is used to hold a Prolog database of facts. In a different direction, we view the application of our method in rule-based systems as a very interesting problem for investigation. For example, Prolog and database systems based on logic [29] can easily be extended to perform multiplequery optimization.
Morphology with two-level rules and negative rule featuresIts morphosyntactic component uses, instead of continuation classes, an extension of PATR 28 clause grammar in addition to the PATP-type unification, and disjunction. It has been implemented in Prolog and runs on a Sun. 3 Summary of Alternative Rule Formalism The basic idea behind the notion of two-level rule (due to Koskenniemi [8]) is that there are two levels of linguistic information to which a rule may refer. What follows is a description of the algorithm used by the code that I have implemented in Quintus Prolog on a Sun. When the rule epenthesisl is read in, it is decomposed into two rules.
A parsing algorithm for unification grammarA Parsing Algorithm for Unification Grammar Sato and Tamaki (1984) proposed to analyze the behavior of Prolog programs, including parsers, by using something much like a weak prediction table. It is a bottom-up left-corner parser using term unification. It is written in Prolog and uses backtracking, but by recording its results as clauses in the Prolog database it avoids most backtracking, so that it is close to a chart parser. University of Chicago, Chicago, IL: 137-144. Pereira, Fernando and Sheiber, Stuart 1987 Prolog and NaturalLanguage Analysis. Center for the Study of Language and Information, Stanford, CA.
An expert system for the selection of indexable inserts and tool holdersIt also can be used data retrieval system. as a Giusti and Santochi [6] developed an expert system using Prolog language for tool selection. They also attempted a self learning (rule creation) process through on line machine monitoring. Expert systems can be build by using either a high level language, like LISP or PROLOG, or using a commercially available shell. The main advantage of using a shell the rapid system development.
"A mathematically focused curriculum for computer scienceParticular attention should be given to recursive programming and backtracking, in contexts such as Lisp and Prolog. The area of study called The Computing Environment contains the ""systems programming"" side of operating systems, and machine architecture. A suitable context for this study is provided by the so-called AI languages (Lisp and Prolog). The study of knowledge representation and exploration of search spaces, begun in CS3, could be continued here. The cluster of texts for Level 4 might contain Henderson, P., Functional Programming, Prentice-Hall, Englewood Cliffs, N.J., 1981, Winston, P., and Horn, B., Lisp, 2nd ed., Ad'dison Wesley, Reading, Mass., 1984, Clocksin, W., and Mellish, C., Programming in Prolog, Springer-Verlag, New York, 1981, Kernighan, B., and Plauger, P., Software Tools in Pascal, Addison-Wesley, Reading, Mass., 1981, Sommerville, I., Software Engineering, 2nd ed., Addison-Wesley, Reading, Mass., 1985."
An experiment in formal software development: using the B theorem prover on a VDM case studyIt is based on a backward-chaining (goal-driven) proof mechanism. 111that sense, it has a similar philosophy as a Prolog interpreter. While Prolog is based on unification and backtracking, B is based on a simple but powerful pattern-matching mechanism whose application is guided by tactics. The scope of these free variables is restricted to the rule where they appear (just like for Prolog clauses). When the list is eventually reduced to a single InvariantPreservationCREP . . . .
"A parallel logic programming approach to combinatorial optimization in designMierowsky, ""Fair, Biased, and Self-Balancing Merge Operators: Their Specification and Implementation in Concurrent Prolog"", Concurrent ProIog, vol. 1, pp. 392-413, MIT Press, Cambridge, Mass., 1987 [Ueda 871 K. Weda., ""Guarded Horn Clauses,"" Concur rent Prolog, vol. 1, pp. 140-156, MIT Press, Cambridge, Mass., 1987 0 1990 ACM 089791-372~8/90/0007/0848 $1SO 848 849 850 851 852 853"
Machine translation for monolingualsNtran: the UMIST English-tu-Japanese system Ntran - its design inspired by Rod Johnson, and developed and first implemented largely by Peter Whitelock - is less target-specific than Aidtrans. The prototype is implemented in Prolog for the sake of rapid and perspicuous development, versions now exist in Cprolog, New Improved (Edinburgh) Prolog, and Quintus.
Knowledge acquisition and representation for product configuration: charting a way through a company's information jungleIt is certain that duplication of data exists on a considerable scale, but it is unrealistic when developing new data to search through relevent sections of data files to check whether the data already exists. 806 Choice Of Programming Paradigm Four main programming paradigms were considered: (i) Database management systems (DBMS) (ii) Expert system shells (iii) Programming language (Prolog) (iv) A major AI toolkit (ART). Prototypes have been developed using each of these. Many shells did not provide this feature, neither did Prolog. The large AI toolkits can represent data in frames, although only a small part the functionality they offer is required for this phase of the configuration process.
Machine translation using isomorphic UCGsNote that in the above example, as ehewhere, the Prolog-like convention is adopted that constants start with lower-case or are within quotes, and variables start with upper-case. The Bilingual sign can easily be decomposed into, or built up from, a Source sign and a Target sign (having a common Semantics), by a Prolog predicate decompose(Bllingual_Sit, Source_Sign, Target_Sign).
A knowledge-based problem-specific program generatorAPPLICATIONEXPERIENCE The development of the system shell (c. i00 Kbyte PROLOG-source) on a personal computer has taken c. 3 months. A similar expenditure has been necessary to build up a knowledge base for c, 150 (mostly simple) subalgorithms (c, 300 Kbyte -60-PROLOG-source). The adaptation phase of an extensive mathematical enterprise model has been reduced from several months to several days (if the knowledge base contained all necessary alternatives) or several weeks (if only a small portion - up to c, 10 X - of the a!
APL2 and AI: a study of searchIn particular, BCHAIN can use unification when the database contains first order logic statements ( See BroC41 for a description of Prolog in APLZ). This is the place to try out boolean inference methods. and support more complete logics than Horn clause based ones. 0 BCHAIN and/or FACT could exploit the computational power of APL2 bY including probabilistic reasoning, or fuzzy logic. to find goals or check for facts. Instead, the predicate expressions may be passed to Prolog to return a binding. Semantically. AND has both functional and logical meaning.
Representation methods for software reuseThis provides information that can be used to expand the knowledge base. Bollinger and BarnesIn report a Prolog based system for finding reusable parts from an electrical load monitoring program written in ADA. Each Prolog rule in this system corresponds to either a single component, or a set of composable components. The Prolog search mechanism is used to locate and generate the required parts given a user specification.
Knowledge based system to diagnose faults in discrete event systemsA fully functional prototype of FES has been implemented in Quintus Prolog running on the Sun 3 family of workstations under the Berkeley 4.3 release of the UNIX operating system. The current implementation contains 1976 lines of Prolog code and 137 lines of plant specific information for the example discused in the previous section.
"Conditioned unification for natural language processingoit hcal operations each C'Ollf'lrled wttJ/i[l a local tree Such local operations ar'c forunulatcd in Lcrms of unicaLion ]Iowevcr, Lhe ordinary unification as in Prolog is insufficient, seeu rrorn both scientific (here, alias liriguJsl,ic) and cngin(.' Actual procedure attaclu'ncrd.s musL be arr-arProlog (Colmcraucr (1982)), for instanc/, is a mcans of tins arringerncnt. ]]y exc(tll.i[]g freeze(V, ""), atomic formula is frozen, i.c , the exccuLlon of' is >-uspcnded until wriable X is instanttat.cd ]f'¢ contams .'(, thcl'cforc, }lop(fully uot. so rnuch Irtforrnat.iol is test. whcc ¢ is cxecuLed Ncvc.rthcless, freeze is problematic in two rcspt(ts Virsk, irJorn]ation cart still be lost when the frozen pro-- ccdtll'CS LIFe cxccnted."
Understanding of stories for animationThe sentence grammar in SENTENCE-PARSER is described using Definite 623 Clause Grammar in Prolog [Pereira & Warren 80]. The assertions are then put into the MORE-MEANING-EXTRACTOR which is based on forward-reasoning. The whole story understanding system is implemented using Prolog on vax 111780. 6. Conclusion This paper presents the story understanding mechanism for creating computer animation scenarios.
Tools to support formal methodsThe a.iialyser cliecks the syntax orhe sl)eciGcatioii aid translales it into a dalahase orProlog facts. Tile Lra.ce gc~iemlor Ll~eu Lalif3 tile Prolog datahe a.ntl produces a set of I.races in botli 1ext.ua.l alit1 Lree form ror any selected process. `Ylic spccifica.tioii a.nalyser was developed under Unis' IlS iiig l,lie la.ngua.ge C and tlie coilll)ilc~l-writiltg tools LEX a.114 YACC. The trace gene&or wa.s implen~entetl iu Prolog. The clevelopment. of tlie prolobgpe toolset. was not a. strit.iglitforwa~rtl tam&. TI iis was done iii order to build ii110 the tra.ce generator the sema.lltics of the ba.sic I,OTOS processes, stop aud wit, and to eoaMe the user to compare the tra.ces of equiva.lcnt processes. The tra.ce geltrra.tor exploits the Prolog facilities of patt.eru ma,tchiug and I,a.cktrackiug 1.0imple-ment these la.ws.
"A system for semantic query optimization.~, scirl '11112the pnOr( I NIC base III 1 iarh84j ri gr,~: II &PI for clr I\ described to integrate tableau techniques and s>ntactlc slmpllflcatlon algorithms to optlmlze queries containing Inequality restrictions Referential lntegrlty constraints like key dependencies, functional dependencies, and value bounds are used to arrive at different forms of a given query The graph 1s used to unify attrlbute values based on referential constraints, to detect cycles that imply equal values for different attributes, anA to predict queries with null answers Both of the above schemes have certain limitations In [ChFMSI], no clear way 1s suggested to categorize a given piece of semantic mformation as a rule or as a view Also, once the set of valid rules are Identlfled for each relation (view), no method IS described to select the profitable rules for a relation (view) in a query context Moreover, no mechanism is available to quantify the profltablllty of a rule for a relation In a query context We belleve that evolution of a profitable query form should depend on three different factors, namely, relations, rules, and query, and this dependency should be dynamic Also, there should be well defined procedures to compare different query forms for their profltablllty In [Jark84], no scheme 1s avallable for an expllclt representation of arbitrary semantic constraints The Prolog hke view representation scheme allows to express a Ilmlted type of constramts on the variables appearing m blew definitions In this method, It becomes the responslblllty of the user to keep track of semantic constramts contained m a view definition Any changes 111the constramts at a later stage makes mamtenance and usage of these views difficult Also, since constraints are hardwired to the attributes of view deflnltlons, they become unsharable by the slmllar attributes orlgmatmg from the query In this paper, we try to overcome the above dlfficultles by using expllclt clausal representation [Kowa83] for integrity constraints as in [ChFM84], and by devising a mechanism for dqnamlc mteractlon between relations (views) and constramts in a given query context Among the valid constramts selected for interaction, only the profitable ones are finally used, and the profitablhty 1s decided by heurlstlcs rules, global parameters, and some assumptions This paper 1s organized as follows Section 2 drscrlbes various types of mtegrlty constraints used m query transformation, their categonzatlon, and reprcsentatlqnal details In sectlon 3, heurlstlc rules adopted to! Cost (Qf) < Cost(Qo) provided the estlmatlon of selection-Join sequence 1s valid If Qf IS dlffereJlt from Qo, let this difference be represenred by three components 1) Set of restriction edges Ef t that are present in Qf but not III ($0 2) Set of restrlctlon edges Eo+ that are prrsenl 111 ($0 but not In Qf, 3) Set of relations Ho I that are present in Qo but not in Ql The edges in Ef+ are syntactically or semantically redundant since they have been added by the algorithm to the initial graph during query-lmplled expansion or srmantlc expansion The fact that they were not eliminated during the semarltlc reduction lrnplles that they belong to the ""profitable"" category, provided the estimated selection-JoIn sequence holds good In this context they represent an additional profit for Qf as compared to Qo All the edges in Eo+ are also syntactically or semantically redundant because otherwise they would have been retained m Qf too The reason for tkelr removal by the semantic reduction stage was that they were not found to be profltable In other words, the edges in Eo+ represent an ellmlnatlon of non profltable part from the original query, If the estlmatlons on relectlon-Jom sequence holds good In short, as compared to Qo, Eat represents the edges lost whereas Ef+ represents edges gamed by Qf The strategy of addlng and ehmmatmg the restrlctlon always concentrates on adding profitable restrictions and removing non profit able ones Both these components thus represent profit provided the sequence estlmatron of selectlons and Joins are valid The set Ro+ repIesenLs a clear profit for Qf because Qf does not have the corresponding JOlJlS To conclude, the cost advantage of C/f ov(br Qo can be represented by C as C = al*/Ef t 1 + a2*IEo+l + a3*jRo+j, where al, a2, a3 drc scaling factors to reflect the relative importance of components as well as validity of the assumption on selection-Join sequence If these assumptions are valid, C represents a posltlve quantity, and in that case larger the sets &X-t, Eo+, Ro+ are, higher IS the resulting cost advantage 7 Conclusion In this paper we have proposed and described a scheme for utlhzmg semantic mtegrlty constraints for optmnzmg a database query A'e have tried to quantify the factors that decide the profit of a query and illustrated how relations, rules, and query can Interact to arrive at an optimum query form The maJor contrlbutlon of the work IS a scheme that dynamically selects from a large collection of rules only the profitable ones for a relation m a query context An algorithm 1s mtroduced to transform the initial query to a semantically equivalent one The algorithm has its best performance If the estlmatlons of selection-Jam sequences holds good In reality Certain maJor factors hke ellmmatlon of redundant Joins are independent of these assumptions, anyway Cases where a query can be answered JUSt using semantic rules and the ones where query conclitlons and/or semantic constramts Imply a null answer are also handled efflclently by the algorithm In other cases, semantic rules aid the query processing by generatlng useful additIona constraints or by ellmmatmg existing redundant constraints We are currently studymg some additional types of Integrlty constramts and optlmlzatlon strategies to mcorporate m the algorithm Usage of conventional integrity constraints like functional dependencies along with the semantic constraints requires further analyqls Methods hhe mtroducmg an additional Join to the orlgmal query (Join mtroductlon) as an optlmlzmg scheme [ l\111g81] also needs further mvestlgatlon from an irnplementatlon point of view IAho79] Aho A V , Saglv Y , and Ullman J D , Equivalences among relational expressions, SIAM J of computing 8, pp 218-246, 1979 [Astr76] Astrahan M M SYSTEM R A relational approach to database mdnagernent , ACM TODS 1 2 , June 1976 [Bern811 Bernstein P A , Query processing in systems for dlstrlbuted databases (SDD-I) , ACM TODS 6 4 , pp 602-625, Dee 1981 jBla577] Blasgen M W , and Eswaran K P , Storage access In relational databases, IBM systems Journal 16, 4, 1977 [ChFMBl] Chakravarthy U S , Flshman D H , and Mlnker J , Semantic query optlmlzatlon In expert systems and database systems, EDS 3984, 326-341 iChGM86] Chakravarthy U S , Grant J , and Mlnker J , Foundations of sernantlc query optlmlzatlon for deductive databases, [Epst78) [GranBOj [Got1751 [HaZd80] [Hevn79] [Jark84] [JaCV84j IKlm79] Epstein R , Stonebraker M , and Wong E , Dlstrlbuted query processing In database systems, Proc ACM SIGMOD conference, Austin, pp 169-180, June 1978 Grant J , and Mlnker J , Optlmlzatlon m deductive and conventional database systems, ~~195-234 In Advances In database theory, vol 1, ed Gallalre H , Mmker J , and Nicolas J M , Plenum Press 1980 Gotlleb L R , Computing Joins of relations, ACM SIGMOD international symposium on management datd, pp 55-63 Hammer M , and Zdonlk S B Jr , Knowledge based query proccssrng, VLDB 1980, 137-147 Hevner A R , and Yao S B , Query processing in dlstrlbuted database systems, IEEE transactions on software engmeermg 5, 3, pp 177-187, May 1979 Jarke M , External semantic query slmpllflcatlon A graph-theoretic approach and Its lmplementatlon in Prolog, EDS 1984, 467-482 Jarke M , Clifford J , and Vasslllou Y , An optlmlzlng Prolog front end to a relatlonal query system, Proceedings of ACM SIGMOD conference, Boston 1984, 296-306 Kim W , relatlonal database systems, ACM computmg surveys 3, 11, pp 185-212, Sept 1979 [King811 [KuHa84] ]Male83] [Morg84] [NlYa78] [Pale741 [Ston76] [UllmSZ] [Wong76) IYao79] [YuOz84] King J J , QUIST A system for semantic query optlmlzation In relational databases, VLDB 1981, 510-517 Kung R , Hanson E , Ioannldis Y , Selhs T , Shapiro L , and Stonebraker M , Heurlstlc search In database systems, EDS 1984, 96-107 Maler D , The theory of relatIona databases, Computer Science Press, 1983 Morgenstern M , The role of constraints In databases, expert systems, and knowledge representation, EDS 1984, 207-223 Nicholas J M , and Yazdanlan K , Integrity checking In deductive databases, pp 325-346 in Logic and databases, ed Galhere H , and Mlnker J , Plenum Press, 1982 Palermo F P , A database search problem lntormatlon systems COINS IV (J r TOIJ, ed), Plenum Press Stoncbraka M It , Wong E , Kreps P , and Held C: , The design and lmplementatlon of INGRES, ACM TODS 13, pp 189-222, Sept 1976 Ullman J D , Principles of database systems, 2nd edition, Computer Science press, 1978 Wong E and Youssefl K , Decomposltlon A strategy for query processing , ACM TODS 13, pp 223-241, Sept 1976 Yao S B , Optimization of query ekaluatlon dlt*tirlthms, ACM TODS 4 2, pp 133-155 Yu T C , and Ozsoyoglu Z M , On determmmg tree query membership of a dlstrlbuted query, INFOR Aug 1983 261-28 181 182 183 184 Example 3 5: 185 Example 4 2: 186 Example 5 1: 187 188 189 190 191 192 193 194 195"
Cooking up referring expressionsCONCLUSION In this paper, we have described the processes used in EPICURE to produce noun phrase referring expressions. EPICURE is implemented in C-PROLOG running under UNIX. The algorithms used in the system permit the generation of a wide range of pronominal forms, one-anaphoric forms and full noun phrase structures, including partitives and pseudo-partitives. Clocksin, William F. and Melllsh, Christopher S. (1981) Programming in Prolog. Berlin: Springer-Verlag. Dale, Robert (1988) The Generation of Subsequent Referring Expressions in Structured Discourses.
"System support for modular order-sorted horn clause specificationsA concept of logic programming with conditional equations in which such extra variables are not admitted would be far too restrictive in practice. The use of extra variables in conditions of Prolog-clauses - often called ""local variables"" in this context - is essential for Prologprogramming. Term notation, including operator declaration, is as in C-Prolog. A specification will be a.utomatically parsed after completing a.n editing session. Conditional completion as developed by the first author is the basic concept behind both these techniques. CEC is implemented in Smalltalk- and Quintus-Prolog. It has been used successfully for nontrivial examples such as the specification of a code generator for a hypothetical target machine [Gie89]."
CLG(n): constraint logic grammarsIn trying to achieve a logically sound and practical implementation, our work has been influenced by the CLP paradigm in logic programming (Jaffar & Lassez, 1988) especially our delayed evaluation Scheme which amongst Other things avoids systematic mputations of normal forms of constraints. All CLG(n) prototypes have been implemented in Prolog using 1 Luis DAMAS Nelma MOREIRA Universidade do Porto,Campo Alegre 823 P-4000 Porto the YAP compiler developed at the University of Porto The results to date have been encouraging. Implementation The CLG(2) parser has been implemented in Prolog. A CLG(2) grammar is compiled by successively compiling type declarations, partial descriptions of phrasal signs, principles, user defined relations and lexical information.
A transfer model using a typed feature structure rewriting system with inheritanceFrom O), this formalism should be in the class of unificationbasedformalisms such as PROLOG, and there should be no distinction between input and output. The two main characteristics of the formalism are (1) type inheritance which provides a clean way of defining classes and sub-classes of objects, (2) the rewriting mechanism based on typed unification of feature structures which provide a powerful and semantically clear means of specifying (and computing) relations between classes of objects. This latexbehavior is somehow similar to the PROLOG mechanism, and grammars can be written to be reversible, which is the case for our transfer grammar.
Introduction to the special issue of the SIGPLAN Notices on the Object-Oriented Programming WorkshopThis paper not only presents the features of CommonObjects but also a comparison with corresponding features in Common Loops, Trellis/Owl, and C+ + . Kahn indicates how Concurrent Prolog (CP), although not itself object-oriented, may serve as a target language for object-oriented source languages. Tokoro and fshikawa examine the integration of object-oriented, concurrent, knowledgerepresentation features in OrientSI/K, Objects consist of a behavior part that specifies a collection of methods, a knowledge-based part that has Prolog-style rewrite rules, and a monitor part that controls the concurrent behavior of the object.
From operational semantics to abstract machines: preliminary resultsThe language TYPOL of the CENTAUR system [ 131, M =i- ( nil M nil) E M-N S) * ( E M {E,N} ::S) E XM X::S) j (X:3 M S) ({E',M} ::E 0 S) =s ( E' M S) ( X::E n+l S) * ( E rl S) ( E XM 4) =s {E,ml , M =k- ( nil nil M ::nil nil) S E (M-N)::C D) * ( S E MxN::ap::C D> S E xM::C D) + ({E,XM}::S E c D> i S X::E n+l::C D) 3 ( S E n::C D) S X::E 0::c D) j ( X::S E ' C D) F:: {E',XM} :S E ap::C D) * ( nil X::E' M::nil (S,E,C)::D) ( X::S E tail (S',E',C'):D) + ( X::S' E' C' D) ( X:3 E nil nil) * X Figure 1: The Krivine machine (top) and SECD machine used to specify operational semantics similar to the style presented here, can be compiled into Prolog. The first-order Horn clauses of Prolog. however, are not strong enough to directly implement our inference rules due to the lack of simply typed terms and universal quantification. A suitable extension of F'rolog, for example Prolog [15]. does directly implement such inference rules.
"Modern introductory computer scienceLikewise, mathematical logic constitutes the foundations of logic programming, with Prolog being a representative example. Here the notions of mathematical relations (starting with binary relations) and logic are used to motivate a basic understanding of declarative programming. The potentially complex syntax and semantics of Prolog need not be understood for students to appreciate the expressive power of this class of languages. Students can now pose queries using these new ""derived"" relations. The query interpreter, which is Prolog like in nature, incorporates a mode which illustrates the query evaluation mechanism."
"Can humans think? -- a general review of HIto the ""state of the art"" in Prolog compilation techniques. The authors use 2 interpreters, Proplog and Datalog, to teach the fundamentals of logic programming before introducing Prolog."
Query optimization in a memory-resident domain relational calculus database systemOur in which different sets of data structures and algorithms have to be devised to take full advantage of the memory-residency of data. Implementations of Prolog [9] that has been widely used as a logic programming language also have some flavor of memory-resident database systems. Warren [38] points out the similarity between a subset of Prolog and the relational database and proposes an optimization technique based on a variant of the hillclimbing technique [45] with an objective (i.e., optimization criterion) of minimizing tuple accesses. Our technique is not a heuristic since it employs a systematic search based on a complete cost model. In general, Prolog has been emphasized more as a programming language than as a memory-resident database system.
Examples: procedural (COBOL, FORTRAN, ALGOL, Pascal, Ada, C), functional (LISP), dataflow (SISAL, VAL), object-oriented (Smalltalk, CLU), logic (Prolog), strings (SNOBOL), and concurrency (CSP, Occam, Concurrent Pascal, Modula 2). 2. Techniques for expert systems in narrow domains (e.g., Mycin, Xcon) and expert system shells that can be programmed for new domains. 3. Implementations of logic programming (e.g., PROLOG). 4. Natural language understanding systems (e.g., Margie, SHRDLU, and pReferencesemantics) 5. For example, besides the usual procedural style (Pascal, Modula-2, Ada), concurrent programming (CSP), functional programming (Lisp), logic programming (Prolog), and object programming (Smalltalk) and their applications can be introduced.
The event calculus and consistency maintenanceThe research reported in this paper was conducted for the development of the temporal reasoning component of a large, Prolog-based expert system. The expert system operates with a changing database and must notify users of changes to previously reported rule conclusions. In our application, histories are computed and recorded for each slot value and then displayed on a graphical user-interface. For such an application, the normal Prolog computation strategy has a major flaw. The use of negation by failure presupposesthat we will evaluate the `persists' predicate by backward chaining each time we wish to examine its solution.
Dependency Unification GrammarDRL is both at the same time. In the same spirit as PROLOG is tailor-made for the purposes of logic, DRL has been particularly adapted to represent linguistic structures. Whereas the interpreter for PROLOG includes a theorem prover, the interpreter for DRL is linked with a parser.
A generalised data base interface for APLR' dbREQUEST 'TC+EMP A-TIMECARD' EMPNO NAME 0033 JUDY ABLE FIGURE 3 Note that, with negation, the logical connective (A) does not trigger a JOIN operation as It does when neither of the two relations are negated. 5.8 EXTENSION TO LOGIC PROGRAMMING The reader who is familiar with PROLOG will have noticed the development of a clausal form of predicate calculus in the form of right argument used with views and negation. The full clausal form of PROLOG, as implemented and described by one of the authors, is available and compatible with the goal of the generalized from of data base Interface - that of easy transportability of the application from system to system.
"Unification and transduction in computational phonologyThis definition of unificati.en, and its implements lion, differs from Prolog unification. 2. All i)p]lorie-PhslIi-,[m:~. Tran'. The movement of the transducei' may then be directed by usin 'the tree-lexicon in paraliel (see Flg.3>. case:_ where the input segment is In. underspecified hypotheses could be made immediately as to the values tlf particular feaflurgs thus excludi5 paths which will eventually led to impossible sequences Inctt.ing the efficiency of the parser. ].i0 hence LEXICON PHONOTACTI("" HitT Ft,3 The model has been implemented in C-Prolog on a Hewlett Packard 9000. Chomsky, . , M. Halle 1966."
The reliability of analytic and holistic methods in rating students' computer programsHer program received low scores under Programming Style due to lack of prolog comments and procedures which performed multiple tasks, In none of the areasrated on the analytic scoring guide did her program receive a score higher than two. Programming Style [40%3 1.- Properly indented and formatted basedon nestling depth (5%). 2,_ Properly commentedincluding prolog commentsfor main programs and.procedures (5%) . 3.- BEGINS and ENDS are labeled (5% ) . 4.
"Classes versus prototypes in object-oriented languagesIn Biggertalkr3, an object-oriented language implemented in Prolog, instances are like classes in all respects, except that they cannot be further refined. LaLonde, W.R., Thomas, D.A., and Pugh, J.R., ""An Exemplar Based Smalltalk"", Tech. report TR-94, Computer Science Department, Carleton University, May 1986. Gullichsen, E., ""BiggerTalkz Object-Oriented Prolog' ', Tech. report SIP-125-85, MCC, November 1985."
Constraint query languages (preliminary report)A major recent development in logic programming systems is the integration of logic and constraint paradigms, e.g., in CLP [JL87], in Prolog III [C87], and in CHIP [DSS]. One intuitive reason for this successful integration is as follows. A strength of Prolog is its top-down, depth-first search strategy. The operation of unification at the forefront of this search is a special form of efficient constraint solving. Journal of Symbolic Computation, 4:191-205, 1987. A. Colmerauer. An Introduction to Prolog III. Draft, 1987. A.K. Chandra, D. Harel. Computable Queries for Relational Data Bases.
Implementing systemic classification by unificationThis technique has been used in an ad hoc way in a number of language processing systems written in Prolog, and probably originates from Dahl (1977). Consider the example network depicted in Figure 8, expressing the top levels of classification normally used for the plant kingdom. Oxford University Press. McCord, Michael C. 1986 Design of a Prolog-based Machine Translation System. In Shapiro, Ehud, Ed., Procs of the Third International Conference on Logic Programming. Springer Verlag. Warren, David H. D. 19771mplementing Prolog: Compiling Predicate Logic Programs: Research Reports 39 and 40, Department of Artificial Intelligence, University of Edinburgh.
A survey of discrete event simulation and state-of-the-art discrete event languagesSimulation Base Language Language A*SIM Ada [Me 188] CSIM C [Sch 86] MicroPASSIM Pascal [Bar 86] Pascal_SIM Pascal [Oke 86c] PASSIM Pascal [Uye 80] POSE SCHEME [Sta 88] Simcal Pascal/Simula [Mal 86] SIMOD Modula-2 [L'Ec 87] SIMPAS Pascal [Bry 80] SIMPOOPS Prolog [Vau 87] SimTalk Smalltalk [K.nap 87] SIMTOOLS Pascal [Sei 88] TC-Prolog Prolog [Futo 86] VSIM C++ [Cal 87] Figure 7.
Literate programmingFor example, backtracking is provided for free in Prolog, but a Pascal programmer has to try very hard to get backtracking. Thus being able to assume the presence of backtracking is part of the paradigm of Prolog, but not of Pascal. Motivated Pascal program:mers can, of course, still do backtracking, but the effort and unreliability of doing it usually discourages them. In a good literate programming environment, the trappings of literateness should flow as if the programmer was an accomplished expositor-just as a Prolog programmer can very easily do things that, in Pascal, take accomplished programming.
"Artificial intelligence approaches in space power systems automation at Marshall space flight centerNICBES NICBES, the nickel-cadmium battery expert system, is integrated with the Hubble Space Telescope electrical power system test bed. Implemented in Arity PROLOG, the expert system resides 362 on an IBM PC/AT. J.: ""Diagnosing Battery Behavior with an Expert Ssytem in PROLOG,"" Proceedings of the 21st IECEC, San Diego, CA, 1986. 8."
Xcite (an expert system for naturalization cases)Both these projects have been interesting mostly from a research point of view. They have both used Prolog as a basis for their work. The main objective for these projects have been to model the statute, and they have not taken into account the other legal sources that are relevant. 3. The main criteria for becoming a Norwegian citizen can be expressed like this : (In PROLOG notation) may-become citizen(X) :- minTmum_Il-years-of-age(X), lived-in norway-last seven-years(X), clean cArnina record(X), not-significant:arrears(X).
Teaching recursion as a problem-solving tool using standard ML., Lisp and Scheme [l]) and logic programming using Prolog has been gaining favor more recently [5]. However, these languages are difXcult to learn because their syntax is unnatural (like Lisp and Scheme) or very different from standard mathematical notation (Prolog).
Discrete mathematics as a precursor to programmingLet's start by listing five primary objectives, and then describe ways in which these objectives can be attained in such foundations courses. l Develop general problem solving skills, and provide a variety of representations for expressing problems, thinking about problems, and expressing solutions. l Teach students fundamental mathematics concepts which can be used as tools for thinking and problem solving. l Use these mathematical foundations to explain the underlying principles of new approaches for computer interaction. For example, logic programming (Prolog, Trilogy) and f unctional programming (Standard ML, Miranda). l Have students gain an appreciation for mathematics and its relationship to computer science. l Learn to use basic mathematical principles to under stand algorithms and algorithmic problem solving. 2.1 General problem solving skills. The mathematics will give students a glimpse into the future and make it easier for them to adapt to new techniques and languages. Some representative examples are in order. Prolog, Trilogy[l7], and many theorem proving techniques used in artificial intelligence are based on mathematical logic.
"A rule-based object/task modelling approach., triggers and constraints. handles dynamic operational schemes in terms of general-purpose tools within an integrated system, therefore enhancing the flexrbrlrty of knowledge based systems to accommodate appllcatlons in multiple domains This approach 1s being designed and partially implemented on top of System G, an extended experimental RDB system CChen 85b3 on a VAX computer In thrs paper, starting from overviewxng the impacts of logrc to RDB through an example, we point out the need to merge the management of facts (data) and the management of domain rules rn terms of an obJect-oriented modelllng approach (Section 21, In order to provide a suitable tool8 we extend the notion of obJect- oriented logic programming to better support semantic representation and database applications, and then propose a rule-based obJect modellrng mechanism, in addxtron with introducing the concepts of associationsl virual ObJeCts and task (Section 3)) To specify the control structure of a task, we comb rne the techniques of forward chaining and backward chaining, to develop a net-orrented task modellrng formalrsm, thus the rules vs obJects and the meta-rules vs tasks are both covered (Section 4)) After demonstrating thxs approach with a task specification example, finally in Section 5 we give some concluding remarks 2 A RULE-BASED FRONT-END TO RDB RDB and LP techniques are moving fast towards a common destination This holds true both in terms of functionality and performance, and 1s made possible both from their common ancestry of mathematic logic and the complementary benefits they can provide The studxes on the mathematrc foundation of RDB and LP have issued a new research field building logic front-ends to database systems for semantic rules representation and deductive retrievals Logic, as a formal system, relies upon an obJect language based on the first order predicate, a semantics or interpretation of formulas in that language and a proof theory [Shoe 671 Well formed formulas (wff's) are def Ined either as atomic formulas or by connecting or quatifying other wffs The general form of clauses that qIl11 represent database facts and deductive rules is Pl & P2 & & Pk -> Rl : R2 : L Rq Logic admits a declarative semantics, that 151 logrc clauses may be interpreted as statements of facts In addltlon. logic admits an imperative semantics in which logic clause5 may be Interpreted as commands An attempt to answer a query is referred to an attempt to satisfy a goal (or to prove a goal) As we traditionally identify association between domalns and represent them using relations, we Will now specify the association between relations and represent behavioral properties by using logic clauses The correspondence between logical predicates and relations 1s that a predicate could reasonably be stored as a relation, and a hxerarchrcally constructed predicate can be implemented as relations with a type hierarchy (such as an aggregation1 We asseme that all variables In a clause are universal quantified (readers may realize that the LP language shown below In the example is a Prolog-like one, where 1 ower case letters stand for constants and predicate symbols, upper case letters stand for variables) We shall Illustrate the concepts described above through an decision-making example concerning a simplified manufacturing order processing system for an instrument assembling company The xnformation needed 1s stored in certain relations (predicates), includes ""order"" (states orders), ""asmb-des"" (lists the parts needed for each model of machines, as well as the assembly time), ""parts-inv"" and ""products--lnv"" (describe the inventories of parts and ready-made machlnesl, and ""parts"" and ""machines"" (descride models and costs), whose instances are vlewed as facts of the following form order (order- id, model, qty, f inish-qty 1 parts (code, cost) machines (model, cost) parts-xnv (code, name, amt) products-inv (model, name, amt) asmb-des (model, asmb-hrs, conf ig (senser, CPU, monitor, frame The rules for processing a single order stated in terms of Horn clauses )) are ordrr-proc (ORDER-ID MODEL. Computzng Surveys, Vol 16, No 2. 1984 [Hammer 781 M Hemmer and D Mcleod, ""The Semantic Data Model A Modellang Mechanism for Data Base Appllcatlons"", Proc SICMOD. 1978, pp 26-36 CJarke 841 M Jarken J Clifford and Y Vasslllau. ""An Ootimlzino Prolog CMR EMR [MS Front-End to a Reletlone Query System"". ""Data Models"", Prentice-Hall, 1982 CUllman 851 J Ullman, ""Impleaentstlon of Logzcal Query Language for Databases"", Proc of ACM-SIGMOD 85. 1985 cvass 831 Y Vessllloua J Clifford and M Jarke, ""How does a"" Expert System 6et its Data"", Proc of VLDB 9, pp 70-72, 1983 CWllson El31 C Wxlson, E Domeshrk, E Drascher and J Dean ""The t'lultlpurpose Representation System"", Proc of VLDB 9, pp 50-69, 1983 CZani 841 c zan1010. ""ObJeCt-0rle""ted PvOgrammlng I"" Prolog"". Proc of Int Logic Programming Sy~,~posium. IEEE 1984 czan1 S51 c Za""lolo# ""The Representatla"" and Deductive Retrlrvdl of Complex Ob JeCts""q Proc of VLDB Il. pp 4X+469. 19135"
Using an architectural knowledge base to generate code for parallel computersIn this paper, we present a compiler for distributed memory parallel computers which performs automatic program partitioning, mapping and communication code generation under the guidance of a strategy rule-base. The compiler is implemented in Prolog, with the code generation advice incorporated as a set of Prolog rules.
Learning about hidden events in system interactionsWe present experimental evidence suggesting that violations of user expectations trigger a process in which hidden events are hypothesized and subsequently linked to user actions using schemata for general classes of situations which violate user expectations. keywords: explanations, example-based learning, models of learning Introduction In studying text-editor learning, Lewis, Mack, and Carroll have reported that learners often construct explanations of how things work and show considerable ability in generating them [Lewis and Mack, 1982, Mack, Lewis, and Carroll, 1983]. Lewis [Lewis, 1986] describes a Prolog model, EXPL, which uses a set of three primitive heuristics to explain which user actions contributed to which system responses in an encoded user-system dialogue. This work draws on work by Lewis [Lewis,1986], Draper [Draper,1986], Miyake [Miyake,1986], and Dietterich [Dietterich,1984] to propose a theory of simple hidden event learning in a restricted domain of interactions in which learners induce system behavior by viewing demonstrations. A Prolog model of such a learning process, built on top of Lewis' EXPL model, is presented.
"Computing covers for embedded functional dependenciesOur recursive deflnltlons of DROP and REDUCE are constructive, they can be adapted easily for implementing an algorithm which computes REDUCE(F,) in functional programming languages such as Lisp and Prolog. However, we Ilke to consolidate the results of this section by presenting an equivalent procedural algorithm. **************************************************** ALGORITHM ""REDUCTION BY RESOLUTION"" (RBR) INPUT original scheme U, set of FDs F on U, subscheme R of U. Finally, we have shown how the problem of testing whether a given database-scheme 1s in Boyce-Codd Normal form can be solved using RBR. The RBR algorithm has been implemented in Prolog as part of a program for automated database design C83. Ceri S. and Gottlob G. ""Normalization of Relations and Prolog"", Communications of the ACM 29.6, June 1986. Codd E.F."
Large lexicons for natural language processing: utilising the grammar coding system of LDOCE(Exactly the same problem would occur if our natural language systems were implemented in Prolog, since the Prolog 'database facility' refers to the knowledge base that Prolog maintains in main memory.) For reasons of efficiency and flexibility of customisation, namely the use of LDOCE by different client programs and from different Lisp and/or Prolog systems, the dictionary access system is implemented in the programming language C and makes use of the inter-process communication facilities provided by the Unix operating system.
A constraint satisfaction approach to operative management of aircraft routing,m) of tasks to be scheduled, consisting of flights and maintenance, two tasks are said to be connectable (denoted th+tk) if the following holds: connectible(Th,Tk):- task-arriva-L_time(Th,ArrT), task-departure-t ime (Tk,DepT), ArrTProlog clause can be paraphrasedby saying that taskThis connectible to the taskTk if arrival time of the first comes before starting time of the second and the arrival airport of the first is equal to the departnre airport of the second. OMAR's kernel is atthe momentcomposedof nearly 20,000 lines of Quintus Prolog code running on a Bull X-20 minicomputer. Acknowledgements Several meetings were necessary to achieve a deep knowledge of the problem and of the solution techniques employed by the human schedulers.This was madepossible thanksto theunderstanding andcollaboration shown atCMO.
Knowledge based document classification supporting integrated document handlingThe classification handler itself is implemented in PROLOG. It consists of a classification control unit and a document analysis component. To free the user from reprogramming the classification handler while updating types, the type definitions are automatically transformed into a PROLOG predicate representation. Thus the classification control unit can be seen as automatically generated from the type information.
Book reviewsThe approach taken is to incorporate modal and temporal connectivities into Prolog. The basic ideas in moving towards Temporal Prolog are discussed and illustrated by considering a selection of the new operators that are required, a fuller exposition of the extended language is promised elsewhere.
New booksThis is followed by discussion of a special type of knowledge representation - formal grammar - which can be interpreted as instructions of the logic programming language Prolog. Also describes Chomsky's hierarchy of formal grammars, the elements of which are shown to be connected with functional programming languages (such as LISP). The final chapter introduces Prolog and describes logic programming. Rules are stated for transforming logical representations into graphic and object representations.
Nominalizations in PUNDITThe PUNDIT system is a highly modular system, written in Prolog, consisting of distinct syntactic, semantic and discourse components. [I-Iirschman 1985] Urbana-L. Hirschman and K. Puder, Restriction Grammar: A Prolog Implementation. In Lo¢ie Pro¢ramminff and ira Application,, D-I.D.
A user friendly ATN Programming Environment (APE)III_IM@LEMENTAjION In orderto facl 11 late prograrrlYH ng in LT, an environment for this language was written tn Prolog-Cr I ss : The manager allows the manipulation of LT programs. The compiler was Implemented with use of a generator Of aoa Iyser s inspired from METAL , but less powerful. The Interpreter Is a mock-up in Prolog which works on the abstract trees resulting from com#t lat ion.
"A microprogrammed interpreter for concurrent euclid., Pratt, Y., Srini, V., Despain, A., ""Compiling Prolog into Microcode: A Case Study Using the NCR/32-000"". Gee, J., Melvin, S. W., Patt, Y. N., ""Implementation of Prolog via VAX 8600 Microcode"". Proceedings 19th Annual Microprogramming Workshop December 1986."
A preference elicitation strategy for multicriteria decision aidingFinally, an example application is developed in Prolog as a demonstration of the theory. CONTRIBUTION OF THIS RESEARCH The significance of the research is that a method for the incorporation of ordinal preference and logical inferencing in an information system is developed.
Retraining teachers to teach high school computer scienceProgramming should be done in one of the languages, such as Pascal, Modula-2, or PROLOG, or whatever language is current at the time. If possible, the course should include teamwork on a significant software development project so the teachers will gain an appreciation of the role of good design in problem solving. Students should learn about one of the logic type languages, such as PROLOG, as well as other standards such as LISP and C.
Panel on concurrency., Flat Guarded Horn Clauses), CP (i.e., Concurrent Prolog), and Prolog to be ,inherently concurrent languages.
"Never mind the language, what about the paradigm?The quotes from Turner earlier were written in 1981, when there was not the ""serious"" LISP and PROLOG programming performed today. Nevertheless, it remains true that most ""production programming"" is carried out in high-level procedural languages. (I have not even considered others, such as logic programming, as exemplified by PROLOG.) I suspend judgment on this for now. Personally, I like the functional style although my background is procedural."
"OSI service specification: SAP and CEP modellingFor this reason other models have been proposed, using severa l description techniques such as LOTOS (2) (3), Numerical Petri Nets (4), or finit e state machines (5), and also languages such as Prolog (13) . In this paper, a way of describing the service provided by an (N)-layer i s studied . URAL, ""Executable Description of the OS I Transport Service in Prolog"", in ""Protocol Specification, Testing an d Verification, IV"", pp . 279-294, North-Holland, 1982 . * This work has been partially supported by the Comission of the Europea n Communities ."
Morphology in the EUROTRA base level conceptConsidering also that the software development in the project is supposed to be based prototyping, it becomes clear that the has to build on some general idea on rapid project about how things will fit together in the end. afford to build independent modules We cannot (e.g. an FST implementation of a morphological component, a PATR-II grammar for our syntactic implemented in PROLOG, some SNOBOL component programming for the treatment of text formatting, special characters etc, and a relational database for our dictionaries) and then start caring about the compatibility of these modules afterwards. EUROTRA (2,3 and 4) in the reference list). The virtual machine has been implemented in PROLOG and an Early-type parser has been used to build the first representation in analysis (viewed as a tree-structure over the input strins).
"Compiling LISP proceduresEarly results are promising. the subject of future reports. Compiling PROLOG Programs Parallel work in progress is concerned with an investigation oT the possibility of producing automatic fashion, for various hardware systems. . SUMMARY Compiling LISF' Procedures Many real-time AI applications on systems whose basic mode of compilers, in a more or"" less dialects of PROLOG and various Is Necessary simply can not be run successfully operation is to interpret the source code."
Acquisition of conceptual data models from natural language descriptionsArchitecture of an integrated NL and graphics environment. 4.1 Dialogue Structure A natural interface using both text and graphics requires a large bit-mapped screen and both keyboard and pointing input devices. An Apollo DN3000 running Quintus Prolog under UNIX has been selected as an environment for development of the system. The prototyping activity described above is ongoing, but in parallel, the overall design is being elaborated, and a purpose-built parser based on LFG is being implemented in Prolog. Work on the 246 generation component has not yet commenced. 7 Summaryand Conclusions This paper has outlined an application area that can serve as a test-bed for work on the processing of natural language text for the purpose of knowledge acquisistiort, a problem that is much wider than the specific case of information systems design.
"Parsing in parallelThe XTRA is a prototype system now running nnd&"" a C-prolog interpreter and fias a wide coverage of English phenomena, even though its vocabulary is rather small (1000 entries). The S]-l-handlers and tile SB-handlers are arrays of roeessors which implement the or-parallelism of Prolog )r the predicates sentence_head and sentencebody respectively."
Sixth generation computing: a conspectus of the Japanese proposalsHowever, the ICOT research activities have concentrated on machine architectures for knowledge-based systems based on high speed Prolog and relational database machines (Kawanobe 1984) involve no direct research on artificial intelligence or human-computer interaction. (ii) Problems in research and development to be solved in the future 1) Problem solving Systems must be developed to apply available knowledge to problem-solving. 2) Intelligent programming technologies Systems must developed for automatically generating problem-solving procedures. 3) Computer languages Languages going beyond Lisp and Prolog, based on a new logic system, must be developed. 4) Application to the development of human intelligent abilities Programming may provide a model of learning and be applied to education. (5) Technologies related to natural language processing (i) Present state Research and development has been mainly: translation, question-answering, and kana-kanji conversion.
"Deriving constraints among argument sizes in logic programs (extended abstract)Top-down rule evaluation is similar to the evaluation method of Prolog, except that the system decides on the order for subgoals and rules. (The second argument functions as a place-holder for the partially reversed list, read `9"" as ""Done."") The Prolog convention of using capital letters for logical variables has been employed. rev(0, R, R). rev(E . In order to assure balanced treatment of the two ""input"" lists, they are interchanged upon recursion. The Prolog style of using Xs to name a list of X, etc., has been adopted. merge(Cl, Ys, Ys). merge(Xs, II, Xs). merge(X ."
Logic programming as constructivism: a formalization and its application to databasesIn [GR 84, GAB 853,Gabbay and Reyle propose to extend Prolog with non-classical, hypothetical implications. According to Proposition 5.4 the rule p(x) + q(x) $ +(x) is cdi, while the rule p(x) + -J(x) & q(x) is not. Prolog programmersare used to make variables in negative goals occurring in a preceding positive literal as well, in order to ensurecorrect runs of programs.Proposition 5.4 gives a logical motivation to this practice. It is indeed important to also investigate other evaluation strategiesthan the one of Prolog and SLDNF-resolution. The constructivistic reading of logic programming seems promising for studying `logical optimization' techniques.
"Magic counting methods(5) Rules 1 and 2, are called counting rules as they define the countmg set CS, while (3) and (4) are called modified rules (J +l IS an obvious notatron of convemence, m actual Prolog we should wrote Jl mstead and have a goal ""Jl IS J+l"") On the other hand, the magrc set method produces the followmg query &M MAGIC SET METHOD MS(a) (1) MS(XI) - MS(X), L (X, XI) (2, Answer(Y) - PM(u, Y) Answer(Y)? (5) Rules 1 and 2, are called the magic set rules as they define the the magic set MS, whrle (3) and (4) are called modified rules Two queries are said to be equrvalent when they have the same answer (as per the well defined semantics of Horn clause queries [VK]) Then, we have the followmg result that estabhshes the conceptual correctness of the magrc set and counting methods FACT 1 (SZl] The querres &, &C and I& are equrvalent U Let us next examme the problem of rmplementmg these methods using a least fixpomt computation To that end, we use a convement mrxture of Horn clause and procedural programming notatron The countmg set CS IS computed by the followmg fixpomt computatron (the semmolon IS used as enddellmiter for both rules and statements) COUNTING SET COMPUTATION begin cs (0, a 1, J =O, while CS( J, X,) do begin CS(J+l, XI) - CS(J, X), L(X, X,), J = J+l, end, end Thus, we assume that we are working with a vsr~- able two-column relation CS correspondmg to the predrcate In the fixpomt computatron, we perform relatronal algebra operatrons on relatrons, which, for stmphcrty and expressivity of notation, we represent by then equrvalent Horn-clause form Thus, m the first step, our variable relatron IS assrgnedthe relation contammg only the tuple (0,~ ) The fixpomt computatron step cons&e of taking the semrJomof the current relation with that representing L (X, X,) and mcrementmg the first column by one We thus assume that the new tuples so generated are added to the variable relation (e g , usmg Prolog assert) Thus, the test CS(J, X1) falls only after the last fixpomt Iteratron has failed to produce any new tuple As we will discuss extensrvely later, there are sltuatlons (I e , m the presence of cycles), where the loop test never falls and the fixpomt computation never terminates In these situations, we wrll say that the countmg method IS not safe, 1e , the answer cannot be computed m a finite amount of time [Ul, SZ2] Using the semmaive fixpomt approach [Ban, BaRI, we can express the fixpomt computation of magic sets as follows (to implement the fixpomt computation we have introduced an index that records the steps at which a value ISfirst introduced) SEMINAIVE MAGIC SET COMPUTATION begin m(O, a ), I =o, while m(I, XI) do begin Rqr+1, X,) - m(I, Xl, L (X, XI), not(m(-, XI)), I =I+l, end, end The final magic set can be computed as MS(Y) - m(-, 0 I e , by prolectmg the index out The difference between the magic set computation and counting set fixpomt 1s thus clear, this difference reduces to the presence of not (m(-, Xl)) m the magic set fixpomt, 1e , to the condltlon that (1+1, Xl) IS not added to m If (J, X1) IS already m m (for some O Basic Magic Counting Methods The basic magic countmg methods Iust detect whether there IS some multlple node m the magic graph When no such a node occurs, they use the countmg method, otherwIse they use the magic set method Thus, Step 1 1s Implemented as follows we extend the magic set predicate with an addItIona argument that records whether this IS the first occurrence of a node (l), or a succemlve one (2) Only first occurrences are used m the followmg steps, the multiple occurrences are not begin mo, 1, a 1, I `0, while m(I, 1, X,) do begin Jw+1, c, Xl) - m(r, 1, X), L(X, Xl), lf Jq t 1, X,) then C=2 else C=l, I =I+l, end, end (note the use of tf -then -eke construct wrth the ous meaning as per any implementation of Prolog) obvl At the end of the above fixpomt computation, If all nodes are smgle (I e , there are no tuples (I, 2, Y) m MS), then RM = 8 and RC IScomputed as follows RC(I, Y) - m(I, 1, Y) On the other hand, If there IS at least one multlple (or recurrmg) node (1e , there are at least one tuple (I, 2, Y) m m), then RC = 8 (or RC = ((0,~ )}, d the method 1s Integrated) and RM LScomputed as follows RM( Y) - m(- > 1, Y) Then the followmg proposltlon follows directly from the defimtlons PROPOSITION 4 The bas:c magrc counttng methods are correct and saje and therr costs are the ones shown tn Table 2 Furthermore, B =R C, B =A,C Ma, B SC C, and C & B Tab 2 Coats of besrc magtc counhng methods 7."
Real-time speech recognition systems. • By reimplementing SRI's Natural Language Parser from PROLOG to C, SRI was able to decrease the parse time by a factor of three. • SRI modified SRI's language processing algorithms to implement a continuum between SRI's Dynamic Grammar Network (DGN) and BBN's N-best algorithm, to balance the computational load between the HMM speech recognizer and the SLS parser. • SRI completed the implementation of SRI's standard VQ front-end on the Berkeley dual TMS320C25 board, and in C. • Implemented corrective training to improve recognition performance, on the standard training set this improves speaker-independent perplexity 60 performance from 6.7% error to 5.1% error, and for a larger training set (about 11,000 sentences), improves speaker-independent recognition from 5.3% error to 4.1% error.
"An example P4 process program for RebusAN EXAMPLE P4 PROCESS PROGRAM FOR REBUS Dennis Heimbigner University of Colorado Boulder, Colorado This ~4 (pronounced ""P-Quad"") program describes a fragment of Rebus, which is a program for creating a graph of functional requirements. 1. p4 Schemafor Rebus P4 may be viewed as an object oriented version of prolog with types and inheritance. The Rebus schema uses two types of objects: graph objects, and requirement objects, which constitute the nodes of the graph. graph isa [object]. requirement isa [object]."
"Maintenance of stratified databases viewed as a belief revision systemRELATED WORK DEDUCTIVE DATABASES 3 determmethemcreasesof all relauons no Increase IS registered Eachrule ISseenhereasa mappmgfrom themeanmgsof the relabons used m IEJhypothesesto the meamngof the relauonusedm its conclusion Herean mcreaseof a relationIS thesetof its net obtamedtuples A rule is calledhelpful If It usesm I& hypothesesa relauonwhosecurrentmcrease1snon-empty Theinterestm thedeltadriven mechamsmstemsfrom the fact that it can be efficiently implemented using standard databaseopemuons,hke Joinsand unions However,smcewe alsoneed to mamtamsupportsattachedto the factsproduced, thusformof Implementatlonhasto becarefullyreviewed The supportsconstructedm subsectmns4 2 and 4 3 use the supportsalreadyattachedto m&vidual facts derived from the hypothesesof the rule apphed To mamtamthesesupports eachnewly derivedfact hasto behandledm&vidually Thusthe delta driven mechamsmwluch producesnew facts m chunks cannotbe apphedhere On the other hand,whenthe form of supportsproposedm the previoussubsecuonIS used,the delta driven mechamsmstdl can be applied Indeed, all facts producedm one delta are deducedby the samerule, so the resultmgupdateof their supportsIS the samefor all of them Thus from the Implementanonpoint of view the solutmn proposedm UussecttonISclearly preferable Notehoweverthatthere1sa trade-otibetweendnefttclent lmplementdtlonof the supportsand the muumizatmnof the nngratlon Indeed to mdmtamsupposeetticlently they should Nzolas and Yazdaman[Nyl considerthe mamtenance problemfor defimtededucuvedatabasesAbsenceof neganon ConsIderablysunpbfiestheIssue Lloyd, SonenbergandTopor [LST] study the problem of mtegnty constramtcbeckmgin shahfieddatabasesusmgconstrucuonssomewhatrelatedto our formattonof Pos and Neg sels Topor and SonenbergflS1 consider the problem of domam mdependentquenes m Stmhfieddatabases NON-MONOTONIC REASONING Doyle [D] mtroducestheclassof Just&aUon-basedT~th MamtenanceSystemsand stu&es them both from a theoncal and pmc~calpomt of yLew De Kleez [dK] and Martmsand Shapuo[MS] introduce(we useherethe ongmal term of de Kleez) the class of Assumption-basedThruth Mamtenance Systems De Kleer gives a new,elegantnotmnof consistency by muuducmgthemuluplecontextGameworkmsteadof using the classicalschemem which only one consutentcontext IS selected andusedby the mamtenancesystem In both papers the nouon of selecuvebacklrackmgm caseof detechonof mconsrstencyIS stud& These issues were subsequently studled m other frameworks,for example in Shmuehet al [SIZE] for thecaseof PROLOG &k_no_wl&@m The fast author profitted fmm an early dIuu\sIon 01,the subJectof tlus paper with Petervan Emde Beds @EmRENCES [ABW] Apt, K , Blax, H andWalker,A, ""Towards a Theory of Declarauve Knowledge"", m Proc Workshopon Foundationsof DeducuveDatabasesand Logic Programmmg,WashmytonD C, pp 546-629,1986 [BMSU] Bancdhon,F , Maler,D , Saglv,Y andUllman,J , `Magic Sets and'Other StrangeWays to Implement Logx Programs m Proc 5thACM SIGMOD-SIGACTSymposmm onPnnclplesof DatabaseSystems,1986 [CH] Chandra,A andHare],D , `Horn ClauseQuenesand Generahzauons"",Journalof Logic Programmmg,vol 1,pp I-15.1985 [Cl Cousot,P , ""AsynchronousIterative MethodsFor Solvmg a Rxed Pomt Systemof MonotoneEquauonsm a CompleteLatUce"",Rapport deRechercheN 88, L A 7, Unrv Scienutiqueet MedIcalede Grenoble.1977 PI Do)le,J . ""BOUM Manueldereferenceet d'uuhsatlon"",RapportInteme du CentredeRechercheBULL, 1984 pr] Przymusmskl,T , ""On theSemanttcsof StraufiedDeducuveDatabases"",UI Proc Workshopon Foundauonsof DeducuveDatabasesand Logzc Programmmg,WashmgtonD C. pp 433-443.1986 [Sl] Shepherdson.JC, ""Negauonas Failure a Comparisonof Clark's Completed Databaseand Relter'sC W A"", Journalof Logic Programmmg N 1,pp 51-81.1984 [S2] Shepherdson,JC, ""Negauonas F,ulure II"", Journalof Logic Programmmg,N 3, pp 185-202.1985 [SS] Stallman,R M andSussman,G J, ""ForwardReasomngandDependency-DirectedBacktrackmgm a System for Computer-Aided Cucmt Analysis"", Art~ficml Intelligence9, pp 135-l%, 1977 [TS] Topor,R , Sonenberg,E A , ""On DomamIndependentDatabases"",m Proc Workshopon Foundationsof DeducuveDatabasesand Logic Programmmg, WashmgtonD C, pp 403-419,1986 [SIZE] Shmueh,0, Tsur,S , Ztira, H , andEver-Hadam,R , ""DynanucRuleSupportm Prolog"",Manuscript,1985"
"Performance estimation in a massively parallel systemInterestingly, for very low activity, speedups significantly higher than the lower bounds are possible. 1 Introduction Parallelization of synchronized iterative algorithms [l] has produced unexplained and often disappointing results. Using a parallelized Prolog system, Carlton and *Presently with NEC Research Institute, Princeton, NJ 08540. PI PI PI [51 PI PI PI PI PO1 PI P21 [I31 M. Carlton and P. V. Roy,""A Distributed Prolog System with And Parallelism,"" IEEE Software, vol. 5, pp. 43-51, January 1988."
Schema method: a framework for correcting grammatically ill-formed inputIf there are no erro's giesentence i. translated into Japanese. This sy,i.em was implemented i Prolog (about 120KB). Performame is reul-.tir,e (answers within 5 seconds). Therefbre to make an applied system is very easy. This tYamework was implemented in Prolog to devise.a Jef'ul CAI system° Acknowledgment We would like to thank Akira Kurematu, president of ATR Interpreting Telephony Research Laboratories (ATR) and Mr.Yada, president of CSK Research Institute (CRI) for their constant encouragement.
Situations and intervalsProblems in Computing Appropriate Representations The critical problems in the semantic analysis of References to situations and their associated times are: I) language encodes several different kinds of temporal information, 2) this information is distributed in many distinct linguistic elements, and finany, 3) the semantic contribution of many of these elements is context-dependent and cannot be computed without looking at co-occurring elements. zPUNDIT is an acronymfor PrologUNderstandsand InteErates Text. It is a modular system, implemented in Quintus Prolog, with distinct syntactic, semantic and pragmatic components (cf. Identity, or the lack of referential distinctness, is handled through Prolog unification. 18) The engine failed. Boundedness: transition hound Event time: M l unifies with moment([fail 1]) Defining these three different relations of event time to temporal structure simplifies the computation of the ordering relations given by the perfect and non-perfect tenses. 5.2.
Designing an intelligent operating system consultant and teacher (abstract). © 1986 ACM-0-89791 - 177-6/86/0002/0506 $00.75 506 responses to be generated by OSCAT in order to guide the teaching process, the machine r,del allows enforcement of pragmatic constraints, the dialogue nDdel keeps focus and context of discourse. A PROLOG Prototype of OSCAT is under construction for VM/CMS system operating on an ig1 4381 miniconuter.
Extended object oriented model to design relational databases (abstract)Datalog is a logic based declarative language, a version of Prolog, suitable for database systems. The Datalog considered here does not support function symbols in logical rules.
A computational model for arguments understandingImplementation and Example We have realized an implementation in Prolog. It is able to analyze a dialogue, to compute argumentative orientations and to learn conceptual relations when necessary. new The syntactic/sernantic analysis is not implemented. The discourse constraints are represented as a set of rules in Prolog describing the process of any new utterance. For each operator, a set el linguistic constraints is listed.
"Efficient disjunctive unification for bottom-up parsingObservations of the time behaviour of this analyser suggest that a significant speed gain is achieved. 1 Introduction This paper describes the approach taken to the unification of disjunctive feature structures in an experimental bottom-up shift-reduce Japanese aaalyser called Propane, for Prolog Parser using the Nadine Grammar. Nadine (Kogure, 1989, Kogure and Nagata, 1990), which is inlplemented in Lisp, is the analysis and translation component of SLoTRANS, the spoken language translation system under development at ATIt Interpreting Telephony Research Laboratories, and its large (12,000 line) grammar and lexicon make extensive use of disjunction. However, because o["" a mundane practical limitation in the Prolog implementation used, Propane is also forced to store (assert in the database) every constituent it. creates, advancing the. parse by successive storing, Ihiling and backtracking rather than by the simple recursion that would otherwise be performed."
Efficient evaluation of right-, left-, and multi-linear rulesWhile the transformation presented in this paper achieves an O(n) speedup as compared to the magic-sets transformation, it achieves a much higher speedup as compared to Prolog. There are database for which Prolog (with or without tail recursion elimination) takes exponential time to find all answers to the query t(xo, Y)?
A look through PRISMA: towards pluralistic knowledge-based environments for software specification acquisitionSyntactic, semantic and pragmatic (heuristic) aspectsof Entity Relationship Models, Data Flow Diagrams and Petri Nets are captured using Prolog as a metalanguage. More general heuristics indicating complementarity consistency between methods are also formal&d. For instance, each I Fig. 4 - Syntactically Incorrect Situations can be captured in Prolog-like notation asrules: has-no-inputs(Proc) I object(proccss,Proc), findall(Y,rclation(input,Y,Proc),Inputs), cmpty(lnputs). has-no-attributcs(Entity) :- object(cntity,Entityy), findall(Y,rclation(has~attr,Y,Ent~ty),Attrs)~ empty(Attrs). has-nogrcconditions(Event) :- object(cvcnt,Event), findall(Y,rclation{precond,Y,Event),Prcconds), empty(Preconds).
An implementation of standard ML modulesThis is the familiar SPUCture sharing idea first proposed by Boyer and Moore in the context of resolution theorem proving [3] and later exploited in the implementation of Prolog [13]. The use of structure sharing in the basic ML type system has been considered, but in that context it does not appear to have a clear advantage over the simpler approach of instantiation by copying. Dissertation, Dept. of Computer Science, University of Edinburgh, 1987. 13. D. H. D. Warren, Implementing PROLOG - Compiling Predicate Logic Programs, Vol. I, Dept. of Artificial Intelligence Report No. 39, University of Edinburgh, 1977.
Abstracts of current literatureWe examine the computational issues involved in a review of recent candidate architectures beginning at one extreme with Prolog, going through ACT and Classifier systems, ending with PDP. Thus categorical grammar emerges as the implicational fragment of a much more general logical grammar. A Prolog implementation illu,,trates applications to polymorphism, optionality, intensionality, bounded and unbounded extraction, and coordination reduction.
An application of L systems to local microcode synthesisThe local microcode synthesis algorithm is implemented in Quintus Prolog .[13] and runs on a SUN 3/260. The program returns an answer if the search is successful. Several heuristics and an inverted representation are used to reduce the storage requirement and to prune the search space. l A prototype is implemented in Quin.tus Prolog. We have demonstrated the method `by deriving local microcode for a data-path designed by a well known RT-level synthesis tool [7]. program took less than 1 CPU seconds to find the answer.
"Using formal procedure parameters to represent and transmit complex data structuresDatum( ""en"", ""enlisted"", end Data_dictionary ""feef'), ""personnel"") The data can be made self-describing [Bent 87], at least by proper comments. There is a resemblance to Prolog ""facts"", though without unification. We can read the text procedurally, thinking of the procedure calls and environment switches that will happen during execution, or we can read it declaratively as a static denotation of data (at least if we limit ourselves to simple statement lists as in this example.) On the other hand, the ""sequence"" structure is always present automatically, so we can always have multiple answers as in Prolog. In the more general case the procedure can have a number of non-procedure input parameters, and perhaps more than one formal procedure parameter: procedure P2 (real X, Y, procedure FP1, FP2, FP3) P2 represents a data structure of the form sequence of discriminated union of parameters for FP1, parameters for FP2, parameters for FP3."
"Micro-21 from the program chairHowever, the slow prototype makes one wonder if a simple microprocessor can be programmed to achieve the same performance for the target applications. • ""Implementing a Prolog Machine with Multiple Functional Units,"" A. Singhal and Y."
Deploying expert systems in Ada.* It is reported tha.t. several logic-based tools support, Prolog in Ada [4], [3], (IO]. Although Prolog can be used to implement, expert systems, its a.pproach and scope are significa.nt.ly different, from expert system tools such as ART-M.
A graphical hardware design languageA rule-based consistency checker (implemented in Prolog) checks datapath covering and generally acts as the analytical portion of a syntax directed editor. CO Req -I I-..- Ack d Figure 6: Four cycle dgrmLling. is also a multiwindow editor for Gdl. [4] Agent/ST can generate a Prolog compatible design description which can be analyzed for clatapath covering, syntax and other forms of consistency checking.
"Higher-order Horn clausesIntroduction logic, higher-order unification, Horn clauses, Prolog, A principled analysis of the nature and role of higher-order notions within logic programming appears to be absent from the literature on this programming paradigm. Some attempts, such as those in [34], have been made to realize higherorder features akin to those in functional programming languages, and have even been incorporated into most existing versions of the language Prolog. These attempts are, however, unsatisfactory from two perspectives. The principal concern here is that of describing an extension to Horn clauses [33], the basis of languages such as Prolog [32], by using a higher-order logic. The use of the term ""extension"" clearly signifies that there is some character of Horn clauses that is to be retained."
Interoperability of multiple autonomous databasesThe presented system, called VIP-MDBS, extends the Prolog database system VIPDBS designed and built by the same team. Another reason is that Prolog statements use mapping by position in relation predicates, whereas SQL and relational languages use mapping by name. The language of VIP-MDBS overcomes these structural properties of Prolog databases for most MSQL multidatabase functions.
Experiments in natural language processingAs an example, we can implement the pure reasoning features of Prolog in a 20 line program, which took about one hour to produce and debug.
Software engineering for distributed applications (abstract)The work done by Umar and Teorey will be extended to show how a specification language (PSL and/or Prolog) can be used for representation of application systems and network configurations.
TACITUS: a message understanding systemPragmatics processing is based on abductive inference, implemented in the Prolog Technology Theorem Prover (PTTP), using a knowledge base encoding commonsense and domain-specific knowledge in the form of predicate-calculus axioms.
"Strategies for scientific prototyping in SmalltalkAreas such as the knowledge-based automatic programming sub-system (actually written in Prolog) are described elsewhere in the literature [3]. Computers in Engineering Conf., San Francisco, Aug. 1988 Russo, M.F., Peskin, R.L., and Kowalski, A.D., ""A Prolog Based Expert System for Partial Differential Equation Modeling"", Simulation, a publication of ""The Society for Computer Simulation"", San Diego, California, Volume 49, No.4, October 1987."
"An expert system for channel routingThe inherent parallelism present in our approach together with the OR-parallelism and the AND-parallism supported by the Argonne Prolog package provides an ideal environment for such a development. 17 9 2333 0 1734333231 3220 9 1021 34' 0 31 22 10 0 22 ! Stefik, M., ""Planning and Meta-Planning (MOLGEN: Part 2)"", in Artificial Intelligence, vol. 16, no. 2, May 1981, pp. 141-169. [18]. Sterling, L., and E. Shapiro, '3.he Art of Prolog"", The MIT Press, March 1987. [19]. Suzuki, K., Y."
Debugging concurrent programsThe YODA system for Ada tasking programs [LeDoux and Parker 19851 stores the event history as Prolog facts. Prolog predicates define the common temporal relationships such as during, before, and after. Still other examples can be found in declarative languages such as Prolog or higher level languages as described in Goldberg [19861. SC,hist replay none hist browser none sel, hist browser path rules n/s none none sus/cont scroll tp none SC,sel, hist none none sus/cont none none sus/cont none none sus/cont none none sus/cont replay none sus/cont replay none none replay none hist browser none select browser TSL select browser none none prolog none none none none none none BS none replay yes, n/s sus/cont scroll tp yes, n/s sus/cont browser temp. logic SC,select browser none none TQuel TQuel none includes process time diagrams that require a global clock.
"Parameterized programming in OBJ2These techniques would also be effective in constructing a library system [i0] for a conventional procedural language such as Ada [5] or Modula-2 [21], as well as for adding a module system to so-called logic programming languages such as Prolog [3,11]. mechanisms are based on algebraic specification techniques [2,16,17] and can provide powerful and clear techniques for hierarchically structuring software. Joint Conf. on Artificial Intelligence, Jul. pp.i045-1058, 1977 [3] Clockin,W.F. and Mellish, C.S., ""Programming in Prolog"", Springer-Verlag, 1981 [4] DiJkstra,E.W., Notes on structured programming, in ""Structured programming"", Academic Press, 1972 59 [5] United States Department of Defense, Reference Manual for the Ada programming language, ANSI/MIL-STD-1815 A, 1985 [6] Futatsugi,K. and Okada,K., Specification writing as construction of hierarchically structured clusters of operators, Proc. of IFIP Congress 80, Tokyo, Oct. pp.287-292, 1980 [7] Futatsugi,K. and Okada,K."
"Knowlege-based expert systems and their application(tutorial sessionExamples of programming languages used for KBES development include symbol-manipulation languages such as LISP [241 and PROLOG [25], and object oriented language such as SMALLTALK [261. AAAI-84, 1984 M.A.I)reuer, ""Design Automation of Digital Systems : Theory and Techniques"", Prentice-Hall, 1972 R.Davis, ""Interactive transfer of expertise: acquisition of new inference rules"", Artificial Intelligence, vol. 12, PP. 121-157, 1979 A.van de Brug, J.Bachant, and J.McDermott, ""Doing Rl with Style"", In Proc. 2nd Conference on Artificial Intelligence Applications, PP. 244-249, 1985 Paper 31.1 [241 1251 1281 [271 1281 1291 [3Gl [311 [321 [331 r341 I351 I381 P.H.Winaton and B.K.Horn, ""LISP"", Addison-Wesley, 1981 K.L.Clark and F.G.McCabe, ""PROLOG: R language for implementing expert systems"", In Machine Intelligence 10, PP. 455-470, 1982 A.Goldberg and D.Robson, ""SMALLTALK-80: The language and its implementation"", Addison-Wesley, 1983 W.van Melle, E.H.Shortliffe, and B.G.Buchanan, ""EMYCIN: a knowledge engineer's too1 for constructing rule-based expert systems"", In Rule-based Expert Systems, B.Buchanan and E.Shortliffe teds.), Addison-Wesley, pp. 302-328, 1984 R.O.Duda and R.Reboh, ""AI and decision making: the PROSPECTOR experience"", In Artificial Intelligence Applications for Business, 1984 S.M.Weiss, K.B.Kern, and C.A.Kulikowski, ""A guide to the use of the EXPERT consultation system"", Technical Report CBM-TR-94, Computer Science Dept., Rutgers University, 1980 C.L.Forgy, ""OP.95 user's manual"", Technical Report CMU-CS-81-135, computer Science Department, Carnegie-Mellon University, 1981 C.L.Forgy, ""Overview of OPS83"", Technical Report, Computer Science Department, Carnegie-Mellon University, 1983 T.P.Kehler and G.D.Clemson, ""An application development system for expert systems"", In Systems and Software, vol. 3. no. 1, 1984 Teknowledge, ""$3.1 product description"", Teknowledge. 525 University Ave., Palo Alto, Calif., 1984 G.Kahn, S.Nowlan, and J.McDermott, ""MORE: An Intelligent Knowledge Acquisition Tool"", In Proc."
An object-oriented operating system interfaceINKA [Alexander] is an application using both Smalltalk and Prolog. Again, the user interface was implemented in Smalltalk and a knowledge-based expert system system was built in Prolog.
"Book review: Information and misinformation: an investigation of the notions of information, misinformation, informing, and misinforming by Christopher Fox (Greenwood Press, 1983)The Same document could be represented in a logical language, such as PROLOG, as ""loves(John,Mary)"" with no such semantic loss."
"A bibliography of APL articles on modeling and KBESWatson Research Center, Yorktown Heights, NY 10598 a Section 2: APL and Knowledge-Based Expert Systems (KBES) [1] APL2 Programming: Language Reference IBM manual number SH20-9227, 33VA/284, Kingston, NY [2] Alronseca, M. 1980, ""Automatic Solution of Sorites,"" IBM Madrid Scientific Center, Paseo de la Castellana, 4, 28046 Madrid (Spain), Kybernetes, Vol.9:1, p. 37-44. [3] Al£onseca, M. 1985, ""APL, Graphics and Artificial Intelligence,"" APL et l'Ingdnierie Informatique, AFCET, Paris, Dec. 1985, Pub: Actas, p. 61-72. [4] Alfonseca, M. and Tobar, M. 1986A, ""'Emulating Prolog in an IBM PC APL Environment,"" APL Quote Quad, Vol. 16, No. 3, March 1986, pp. 13-15. [5] Alfonseca, M. and Tobar, M. 1986B, ""Extending APL to Logic Programming,"" APL86 Conference Proceedings, APL Quote Quad, Vol. 16, No. 4, pp. 272-275. [6] Alfonseca, M. 1987, ""The Logic Auxiliary Processor: AP998,"" APL2 Programming: APL2 for the IBM PC User's Guide, SC33-0600-1 Vol. 16, No. 4, pp. 259-264. [7] Alronseca, M. and Brown, J. 1987, ""Parallel Solutions to Logic Problems"" SEAS Spring Meeting 1987, SEAS Proceedings, Vol. Jones, A. 1960, ""An APL approach to Presentation Graphics,"" IBM Systems Journal, Vol. 19, No. 3, pp. 367-381. [98] Pantziarka, P. 1990, ""Object Orientated Data Base Using Frames in Second Generation APL,"" APL Quote Quad (APL90 Conference Proceedings), Vol. 20, No. 4. [99] Parkhouse, G. 1989, ""British APL Association News: AIMS at British Air,"" Vol. 6, No. 1, pp. 13-18. [100] Perez, Jean-Claude 1988, ""De Nouuelles Voles Vers L'Intelligence Artificielle"" (New Ways in Artificial Intelligence) MASSON Editor,Paris, Docteur-Ingenieur, Advanced Techniques Compagnie IBM France, La Pompignane, Rue de Painville Montpellier (Herault), B.P. 1021--34006 Montpellier Cedex, France, Phone 67 34 69 19 [1011 Peterson, A. 1987, ""Expert System Shell in NIAL,"" Technical University of Denmark, Electric Power Engineering Department, DK-2800, Lyngby, DENMARK [102] Peterson, N. 1989, ""APL2 for the IBM PC, Version 1.01,"" Science Software, John Wiley & Sons, New York, Vol. 5, No. 3. pp. 246-250 [103] Polivka, R. and Pekin, S. 1975, APL: The Language and Its Usage, Prentice-Hall, Englewood Cliffs, New Jersey. [104] Quaglia, P. 1988, ""Intelligent Front End to SQL Data Base"" IBM Milano, Italy [105] Quaglia, P. 1988, ""A Prolog-like Interpreter in APL2"" IBM Milano, Italy [106] Quaglia, P. 1988, ""An Algorithm to Extract Knowledge from a Relational Database"" IBM Milano, Italy APL Quote Quad 17 [107] [108] [109] [110] [111] [112] [113] [114] [115] [116] [117] [118] [119] [120] [121] [122] [123] Quaglia, P. 1988, ""A Set or APL2 Functions for Managing Frames Alternatively to LISP"" IBM Milano, Italy Quaglia, P. 1988, ""A Rule-Based Expert Sytem Shell in APL2"" IBM Milano, Italy Quaglia, P. 1989, ""Object Orientated Programming in APL2 Compared to LISP"" IBM Milano, Italy Reitman, W. 1964, ""Heuristic Decision Procedures, Open Constraints, and Structure of III-Defined Problems,"" Human Judgements and Optimality, edited by M."
The automated tutoring of introductory computer programmingThe languages targeted for demonstration are Lisp, Prolog, and Ada. Rather than creating a series of independent tutors, we have begun to devise a prototypical system architecture that can be instantiated to produce efficient tutors for different languages. Current Implementation Efforts We have recently begun to implement the PUPS architecture and have developed a rudimentary tutor for small subsets of Ada, Lisp, and Prolog. We plan to implement our tutoring engine using an existing structure editor from the MacGnome programming environment [7] recently constructed at CMU for the Apple Macintosh.
"Extensions to communicating sequential processes to allow protocol performance specificationSome work on using the first-order predicate language, Prolog, on specifying the transport layer of the OS1model has beendone by Logrippo [3]. ""Executable Description of the OS1Transport Service in Prolog"", Proceedings4th International Workshop on protocol Specification, Testing, and Verification, North Holland, 1984 PI [lOI 1111 [41 Reed,G.M., and Roscoe,A.W., ""A Timed Model for Communicating Sequential processes"",Automata, Languages,and Programming 13th International Colloqium Proceedings,Lecture Notes in Computer Science,Springer-Verlag, Berlin, New York, 1986 PI Zic, J.J."
TPS (abstract): a tool for communicating software requirementsThe frame language provides constructs for classifation of objects into generic and sub classes, and for property inheritance, eg. programmers are a sub-class of software-engineers and sub-tasks of a Database task inherit values for slots(properties) DESC (task description) and AUTHORIZED STATUS of the major task, in the absence of any ther values designated for the properties of these sub-tasks.The implementation language of TPS is Prolog. There are many advantages to using a logic programmlng language for S/W rapid-prototyping (Geneser 85) to build tools for increasing productivity in the programming environment.
((lambda (discussions) (report on x3j13)) (first year report))At the Paris meeting of SC22, I was named convenor of an ad hoc working group to develop New Work Item (NWI) proposals for international standards work in Lisp and Prolog. Those NWIs have been accepted by SC22 and will very likely be accepted by TC97 (or its successor).
IMT-RB/ED: a system based on multi-reorganization (abstract)For example, the basic relational algebra operations union,intersection,join,selection, projection and hence relational DML can be implemented in PROLOG ([2]). Unfortunately, other aspects of a DBMS, like DDL, concurrency,sophisticated indexing,security,data integrity and query optimization are very dfficult to impIement in a logic programming environment like PROLOG.Another difficulty is that most LPS are in-memory systems, i.e. all information is loaded in memory before execution.
A framework for visualizing object-oriented systemsThe Transformat source code. Modern programming environments parent Prolog Machine [9] is an example for relational or offer debugging tools such as browsers and inspectors pro- logic systems. Beck, A Diagram for Object-Oriented Programs, ACM Sigplnn Notices 21, 11 (1986), 361-367'. M. Eisenstadt, M. Brayshaw, The Transparent Prolog Machine (TPM): An Execution Model and Graphical Debugger for Logic Programming, Journal of Logical Proyramming 5 (1988), 277-342.
Unification in many-sorted algebras as a device for incremental semantic analysisThe first tuple contains the variables ORDINAL and TYPE, which are (similar to PROLOG) written Upper case letters, For the sake of simplicity, in The_on Considering tuples as special terms, if the bAG induces an upper semilatt.ice, tuple-wise the names of the variables also indicate their sort, Thus, the first tuple states that 'a' may be an array of unknown index and component type and that the still missing index expression is oE the Sam: ordinal type, the right hand side must be of the saj type as the array component type. Fortunately, this does not happen very often, and as mentioned above, something better will probably not exist for arbitrary equational theories, Note that extending unification by data-driven evaluation is also considered a useful extension of PROLOG. We consider the approach to be an alternative to narrowing algorithms We have seen that unification, intertwined with evaluation, gives a useful basis for incremental semantic analysis.
Logic programming semantics using a compact data structureWe also generalize beyond the terms of formal logic. Commercial Prologs make available other data structures, such as integers, finite decimals and character strings.
Toward a common prototyping languageAlthough it is felt that it is unlikely that any one existing language or environment meets all the stated requirements in its current form, it is clear that a number of languages and environments, including for example Lisp, Prolog, APL, SmaliTalk, ML, and others meet many of the requirements. Brown, chief archi teet of APL2, captured the entire logical analysis portion of PROLOG in approximately 50 lines of APL2. EVOLUTION OF APL2 In 1966 the classical APL notation was first made operational on a computer.
A simulator for asynchronous hypercube communicationsThe approach adopted here, and implemented in t:he hypercube simulator is that each node processor runs a copy of the same program, which is typically a Prolog or Lisp interpreter. However, the input to the inter preter for each processor constitutes a different program. Unfortunately, this also requires special operating system privileges and has the ability to degrade the CPU performance if done incorrectly. 6.3 Multiple Node Programs 6.1 Prioritized Messages It would be useful in certain applications (e.g. Concurrent Prolog) to have a mechanism for sending messages of different priorities.
Editorial pointersThis month Jacques Cohen and Alain Colmerauer trace recent developments in constraint logic programming and the new Prolog III generation. For author Cohen this brought to mind a startling metaphor with the famous escape artist Houdini, handcuffed, gagged, and locked in a box with no hope of escape from piercing swords.
Abstracts of current literatureA constraint is said to be satisfied if it is true in some Herbrand model of a metatheory concerning the logical implication of formulae in T (the conditions that the suitable metatheories and Herbrand models must satisfy are identified in the thesis). Semantic checkers have been implemented in Prolog for some restricted forms of theories. Some of the implementations concern theories under nonmonotonic assumptions. The computational model was developed using a rule-based system written in Prolog. The system represents the independent conversational knowledge of both conversants simultaneously, and can simulate their simultaneous action.
Building analytical models into an interactive performance prediction toolHere the do loop llll.label-LE: movl d2,dl add1 a5Q(-780),dl movl dl,d7 movl d3,d6 fmoved fp7,fpO vmoved --BLNK--+24000+32:1[d7:l:d~,vO vmuadd fpO,vO,--BLNK--+2400O+4O:l~d7:l:d~,v0 vmuadd fpO,vO,--BLNK-~+2400O+48:l~d7:l:d~,v0 fmoved fp0 ,fpO vmuld vO,fpO,vO vmoved ~~BLNK~-+24000+8:1~d7:l:dl,v3 fmoved fp7,fpO vmuadd fpO,v3,--BLNK--+2400O+l6:l~d7:l:dl,v3 vmuadd fpO,v3,~~BLNK~~+24000+24:l~d7:1:dl,v3 vaddd vO,v3,vO fmoved fp6,fpO vmuld vO,fpO,vO vmov ed --BLNK--+8000:l[d7:1:dj ,v6 fmoved fp7,fpO vmuadd fpO,v6,--BLNK,,+1600O:l[d7:l:d],v6 vmuadd fpO,v6,,, BLNK--+24000:1[d7:1:dl ,v6 vaddd vO,v6,vO vmoved v0 ,,,BLNK,,+O:l[d7:1:d] add1 aSQ(-796),d2 vcnt32 llll.label~LE Figure 2: Assembly Code for Inner Loop of Kernel 7 S: 5 [cycles=81 Concurrent Prolog Start S: 8 [cycles=141 Concurrent Vector Loop Start k = 1 : na S: 13 [cycles=241 Vector Loop Start S: II, V: 14 C cycles = 636 1 Vector Loop End S: I [cycles=31 Concurrent End S: 3 [cycles=71 No of cycles = 54+na/#p/32*636 Figure 3: Analyzer Output for Kernel 7 is converted to a vector parallel loop by the compiler. Assuming no references to memory the computation will take fP = cm + [Wl (a + PW321) cycles of time where P is the number of processors, C,,, is the serial prolog and epilog time and CYand /3 are respectively the amount of scalar and vector code in the loop body.
"Alpha du centaur: a prototype environment for the design of parallel regular alorithmsIt is made of two specialized components, intended to be used as co-routines : the Virlval Tree Processor (VTP), which handles syntactic aspects, and the logical machiibe, i.e., a Prolog interpreter, whose function is to handle all semantic aspects. The semantics of the language, dcscribcd using the language TYPOL, is compiled into Prolog. TYPOL is based on the so called ""Natural Semantics"" ([21]) The man-machine interface ma,kes it possible to have several views, each one of which related to one particular point of view on the program being edited, or on the specifications of the language itself."
"The architecture of a Linda coprocessorA wide variety of parallel computation models have been studied including shared memory architectures [15], message based architectures [19], object oriented architectures [ll], dataflow machines [16][4], systolic architectures [12], concurrent prolog machines [20], and data-parallel architectures [13]. Symposium on Computer ATchitecture, pp 292-300, 1985. [20] M.J.Wise ""Prolog Multiprocessors,"" Prentice-Hall, Australia, (in press)."
Partitioning parallel programs for macro-dataflowThese models define t 8renulafity of pa.allel,am at the finest level possible, e.g. instructions in dataflow, combinators in graph nduction, goals in Conoen-et Prolog. The eoormous schedulin 8 and communication overhead incuned by fine grain ptrallelism has prompted several implementen to attempt a coarser granularity. Prec.SIGPLAN '86 Symposium ou Compilmr 1996. 210 14. Slap/ro,E. Y. A Subset of Concurrent Prolog and Im Inteqrem. TR-003, The Weizmann Inst/tuteof Science, Israel,Feb.,1983.
GRAPHICAL ENTRY OF WEATHER FORECASTSThe principal application for the tabular data will be a PROLOG-based package, which will automatically generate English and French language textual forecasts .
HyperflowCurrently, users of a machine such as the Mark III view it as a collection of von Neumann machines, each running a program written in a highlevel language such as C, Fortran, or Prolog. These programs are essentially independent and interact only via messages passed between them. Included in the former are MIRANDA [Tur79] and Lucid [AsWa76,WaAs8.5] and in the latter are Lisp and Prolog. Languages like MIRANDA and Lucid are completely free of side-effects which makes them more suited to parallel execution. 1.1 Data Algebras and simple expressions Lucid is a family of programming languages in which each member of the language is determined by a data algebra.
Support for policy makers: formulating legislation with the aid of logical modelsWe cannot predict at this point what all these requirements will be, but we know that more general theorem proving techniques than those provided by, for example, PROLOG will be required. A simple example will suffice to show this. A rule might be something like OfPensionableAge(X) c=> (Age(X,A) & ((A >= 65) v (Sex(X,Female) & A>= 60))) If we are using the Horn Clause subset of logic for execution with a PROLOG like theorem prover, we will need to commit ourselves to one of the elements being the head, perhaps OfPensionableAge(X) c- Age(X,A) & A >= 65 OfPensionableAge(X) c Age&A) & Sex(X,Female) & A>= 60.
AND and OR parallelism in dprolog (abstract)In a fact oriented system, fact retrieval from the database must be rapid to be effective. Prolog consists of facts and rules which the user utilizes by asking questions, which are called queries.
"A retrieval model based on an extended modal logic and its application to the RIME experimental approachSoevery storageand accessfacility havebeencodedin PROLOG for simulation purposes,which is of course not realistic considering full-scale applications (up to tensof thousandsmedical reports). This is due to the preselectionon terms: the more a query is complex the more the preselectionis effective, and the less semantic expressionsare submitted to the matching process.The total cost is thus a compromisebetweenthecostof the preselectionandthe costof the matchingprocess. - what was more surprising was the averageresponsetime of one secondthat we effectively obtained for a query despite the simulation of the databaseoperations in PROLOG. If we acceptthat theresponsetime is proportional to the numberof documents,then theevaluationof a content requirement using our experimental systemon a corpus of 10,ooOmedical reports would require about 5 minutes.Consideringthat in the next versionof RIME term preselection will be processedusing ORACLE we considerthat this performanceis quite encouraging. - aside improvements about the implementation further work has to bc done to improve the deductive capabilities of the prototype, i.e to integratedeductive knowledge (which is in fact expert knowledge) such as: ""a Iung opacity the diameter of which is greater than 1Ommis a pathologic opacity""."
Knowledge representation in “Default”: An attempt to classify general types of knowledge used by legal expertsFacts of the case, expertise and experience of our sources, and the user's preferences guide selection among choices at each level. The representation scheme uses Prolog terms to represent individual decision branches in the network, and additional information about selecting branches. We represented information reflecting possible choices at each node by Prolog terms with the general structure: Possible(node),lcondition listl,branch,source).
Proving circuit correctness using formal comparison between expected and extracted behaviourFunctional extraction and abstraction is done hieramhically through two steps: (1) A PROLOG programextractsthe functionality of the hierarchy leavesfrom their layout. (2) Consider a module in the hierarchy. Simonis [lo] proposed a canonical form built on the boolean operators rr (logical and) and @ (logical exclusive or). They inserted it in a PROLOG system performing an extended unification (boolean unification).
Knowledge based modeling and analysis of computer architecturesHowever, the trend has changed and functional languages such as LISP and Prolog are becoming more popular. Also, there is an ongoing research in the development of new AI languages that will be suitable for fifth generation computing systems. Examples include procedural languages (e.g., PL/I, Pascal, C, and Fortran), functional languages (e.g. LISP, PROLOG), Database Languages (e.g., SQL), and parallel programming languages (e.g.
Sentence fragments regular structuresFragments in three domaiu Total centers Percent fragments CASP.EPS 153 ]s.JFOP. 41 TFR 35 53% 7S% 51% The PUNDIT system is highly modular: it consists of a syntactic component, based on string grammar and restriction grammar [Sager 1981, Hirschman 1985], a semantic component, based on inference-driven mapping, which decomposes predicating expressions into predicates and thematic roles almer 1983, Palmerlg 85], and a pragmatic• component which processes both referring expressions )ah 11986], and temporal expressions assonneau 1987, Passonneau 1988]. 1 Prolog UNDer#h,isO ol ltzgrzd Teal 2. DIVISION OF LABOR AMONG SYNTAX, SEMANTICS, AND PRAGMATICS We argue here that sentence fragments provide a strong case for linguistically modular systems such as PUNDIT, because such elislons have distinct consequences •t different levels of linguistic description. [mnchman 1985] L. H]zschxnn and K. Puder, Restriction Gramm*r: A Prolog Implementation. In Logic Programming and its Applications, D.H.D.
"Intelligent logical design of relational databasesThis new knooledge is bein 'a plied in our &ill developing ayatea ERDS <""E-l geaign Syatea""), now written in PROLOG. which does the follouino: a) ERDS aaaists the data base designer with interactive construction of an E-R diagraa E for the desired information avstea."
An information retrieval system for software componentsThis gets round many of the problems of classifier and retriever using different keywords to describe a component yet aUows the same term to be used to represent differ concepts. The system is implemented in Prolog on a Sun workstation. In designing a component catalogue or, indeed, any reuse support system, there are a number of factors which must he taken into account. As requests and descriptions have the same internal representation, namely component descriptor frames, using Prolog's built-in control and search mechanisms means the matching process is only dependent on rules for the best-match of the two.
"Inheritance and persistence in database programming languages,andthis mhlbztedthe useof database managementin many apphcaaonssuch as the many branchesof engmeermgm which specialdatastructures havebeendevelopedfor varzousforms of design(eg CAD/CAM) ThefmtpraChCaldemonstrahOn ofalanguagem which anyvaluecouldbe madepersistentwas PS-algol[A&183] Very few other databaselanguages haveadoptedthis prmcrple, of thosewe havedtscussed, only Gal&o and Amber provrde a umform approach In order to use persrstencem a strongly typed envrronment, the authors suggestedtwo prmcrples that should govern the design of a databaseprogrammmg language (1) PersistenceIS a property of values and should be independentof type (2) Whrle a value persrsts, so should rts descrrptron OYPa The secondcondmon guardsagamstthe possrbrlny of wrmng out a datastructure asonetype andreadmgrt in asanother,a common causeof error m mampulatmg files in conventronalprogrammmg languages If we areto adopt this view that persistenceis mdependent of type, there are at least three approacheswe may take to definmg persistence111programmmg languages The first, and snnplest,ISall-or-norhzng persrstence that 1scommonly usedwith mteracuveprogrammmg languages Someversionsof Lisp and Prolog, for example, allow one to save the state of an mteractrve sessronand resumeit later on This 1susually achreved by copying a complete core nnage (or possibly an imageof all user-definedstructures)to secondarystorage While simple to rmplement,this approachdoesnot provrde adequatestructure for databasework it does not allow sharmgof values amongprograms,moreoverthe usercannot separatethe relatrvely constantstructureshe has created (the database)from the extremely volatrle structuressuch as experrmentalprograms In tins form of persistencethe survrval of the database1shighly dependenton the mtegrrty of the programmmgsystemas a whole The secondform of persrstence1scontrolled by havmg program mstructums that move structures m and out of secondary(persrstent)storage We shall call this replzcurzng persistence smce structures are replicated in secondarystorage In a sense,languageshke Pascal offer some form of rephcatmg persrstencem fiie types However, as we have already seen, the structures that can be placed m files are hmtted, e g they cannotcontampointers, and they do not carry then own types Another example of replicatmg persrstenceis to be found m APL Falk733 Here arbrtrary values may persist and then type 1s camed wnh them, however APL's data structures are all jlat, and therr types relatrvely simple (functrons are stored as characterarrays) Amber provrdesthe mostcompleteexampleof rephcatmg persistencethrough the use of dynarmc types For example, the code m Amber to perform these operatrons is, approxnnately, Qpe database = -- Type de&anon for a database var d database= -- Code to mmahze the database extern(`DBFde', dynamic d), and to accessthe databasem a subsequentprogram, type database = -- Type declarahon for a database(as before) var x = rntern `DBFtle', var d = coerce n to database -- Code to query or update the database where the coerce operaaon would fad rf the type associatedwrth the dynarmc value d were not database In Amber, when a dynarmcvalue 1sexterned, tt tames with rt everythmg that 1sreachablefrom that value such as structuresthat arereferencedby that value or, m the caseof functmn values,varrablesthat areglobal to that funcuon. Smth, J&f. andSm.&, D CP , ""Database Abstrachons- mgauon andGenerahza-UOn""ACM Tkansachonson DatabaseSystems,2,2, June 1977 Smth,JM , Fox,S andLandeqT., ""ReferenceManualfor ADAPLEX"", Computer Corporattonof Amerxa, January1981 WI&, N , ""The PmgrammmgLanguage PASCAL"", Acta Informattca,1,197l Zamolo,C , ""DatabaseRelationswith Null Values"",JCSS,28 1,pp 142-166,February 1984 Zamolo,C ""Prolog A DatabaseQueryLanguagefor All Seasons"",Proc IEEE-ACM Intemahon~ExpertDatabaseSystemsWorkshop,Klawah Island,October1984"
Monitoring distributed systemsGarcia-Molina et al. describe a methodology graphical Prolog debugger) and for debugging distributed systems that relates to problems (1), (2), and (5) listed in Section 1.1 [ll]. Interfaces to Jipc currently exist for the Ada, C, Lisp, Prolog, and Simula programming languages. Jipc processes communicate by exchanging messages through the use of a blocking protocol based on Thoth [6]. Many techniques have been defined for specifying communication protocols, a survey is given in [21]. We have implemented a console in Prolog called the Protocol Checker that accepts a specification of the allowable process interactions for a particular distributed system.
Multi-moded relations in ParlogOne advantage of a logic language system such as Prolog is its ability to perform full unification thus presenting no constraints on the nature of the usage of arguments.
"Alan J. Perlis—1922–1990: a founding father of computer science as a separate disciplineFunctional programming (. like USP, EP, or ML) . . . nonprocedural programming (. . PROLOG). "" . . . these have captured our imaginations much as Algol did 25 years ago."
SDI software: AI is not the answerMuch recent attention has been paid new AI languages such as PROLOG and expert system languages such as OPS 5, that enable one to build complicated programs efficiently.
"Partial evaluation applied to numerical computationKomorowski [12] has investigated the application of partial evaluation to Prolog, and Danvy[?] has done some interesting new work on applying partial evaluation to the compilation of pattern matching programs. Mogensen: ""A Self-Applicable Partial Evaluator for the Lambda-Calculus"", proceedings of the IEEE Computer Society 1990 International Conference on Computer Languoges, New Orleans, Louisiana, USA (March 12-15, 1990) Henryk Jan Komorowski, ""A Specifica tion of an Abstract Prolog Machine and its application to Partial Evaluation""."
"How to detect grammatical errors in a text without parsing itCLAWS was originally implemented in Pascal, but it is currently being recoded in C and in POPLOG Prolog. CLAWS can deal with Unrestricted English text input including ""noisy"" or ill-formed sentences, because it is based on Constituent Likelihood Grammar, a novel probabilistic approach to grammatical description and analysis described in [Atwell 83]. Pauline McCrorie and Matthias Wong worked on the POPLOG prolog and C versions of CLAWS. Various other colleagues have also offered advice and encouragement, pacularly Geoffrey Sampson, Stuart Roberts, Chris Paice, Lita Taylor, Andrew Beale, Susan 42 Blackwell, and Barbara Booth."
Parallel objects on distributed constraint logic programming machinesThe body of the Horn clause together with the axioms defined in the object and the built-in predicates give the meaning of the method. Methods are executed serially as pure Prolog programs in a depth-first backtracking manner.
"Book reivew: LOGIC PROGRAMMING: FUNCTIONS, RELATIONS AND EQUATIONS. Edited by Doug DeGroot and Gary Lindstrom (Prentice-Hall)Logic programs are nondirectional, which makes them more expressive but harder to understand, for example, a single relation, such as PROLOG's append relation, cab be used in several different ""modes."""
The twisted double helix: a minimum distance architecture for 5th generation computingAcademic Press, COMPUTER, 1985(28)22-33. Shapiro, E. The bagel: a systolic concurrent prolog machine. Lecture Notes. The Weizmann Institute of Science, Rehovot, Israel, 1983.
From mathematical specifications to parallel programs on a message-based systemThe system is being implemented on a Cadmus 9900 under (M)UNIX. Most of the system is coded in IF-PROLOG [IF 871, some parts are written in the C language. Mevenkamp: MIMD-Fortran GMD-Report November 1986 I. Schubert et al.: IF-PROLOG Version 3.1, InterFace Computer GmbH , Miinchen 1987 J.R.
Parallelization of loops with exits on pipelined architecturesOverlapped schedule with an II=3 for the DO loop in Fig. 3. cycle MEMORY INTEGER FLOAT CONT. stuffpred brtop pred L.C ESC 0 read(bl) add(bwU 00000 0000000001 99 6 : brtop 00000 00000 0000000001 0000000001 99 99 66 3 read(b2) add(b2.4) 00000 0000000011 6 4 00000 0000000011 ,:: 6 5 brtop 00000 0000000011 98 6 6 read(b3) add(b3,4) 00000 0000000111 97 6 7 fgt(u1,O.O) 00000 0000000111 97 6 8 brtop 00000 0000000111 97 6 9 read(b4) aWb4,4) 00000 0000001111 96 6 10 fgt(u2,O.O) 00000 0000001111 96 6 11 brtop 00000 0000001111 96 6 12 read(b5) add&g ,4) stuff 00000 0000011111 ,: 6 13 fgt(q,W 0000x 0000011111 6 14 fmpy(ui,ui) brtop 0000x 0000011111 95 6 15 read(b6) add(b6A) stuff ooox- 0000111111 94 6 16 fgt(u4,O.O) oooxx 0000111111 94 6 17 fmm(u2~u2) brtop oooxx 0000111111 94 6 18 read(b7) adWv,4) stuff ooxx- 0001111111 93 19 write(bl,ml) fgt(u5,O.O) ooxxx 0001111111 93 2 20 fmw(u343) brtop ooxxx 0001111111 93 6 . i*3 read@i+l) aWbi+l,4) stuff --xx- ---1111111 99-i 6 i*3+1 write(bi-5.mi-5) fgt(Ui-1.0-O) --xxx ---1111111 99-i 6 i*3+2 fmPY(Ui-3Si-3) brtop --xxx ---1111111 99-i 6 300 stuff --xx- ---1111110 0 , 301 write(bgwwd fgtbgg.O.0) --xxx ---1111110 0 302 fmm(u97,u97) brtop --xxx ---1111110 0 : 303 stuff --xx- ---1111100 0 4 304 write(b96mg6) fgt(Ul00~0.0) --xxx ---1111100 0 4 305 fmPY(UgS.U98) brtop --xxx ---1111100 0 4 306 stuff --xx- ---1111000 0 307 wriWw.mg7) --xxx ---1111000 0 z 308 fmpY(u99+99) brtop --xxx ---1111000 0 3 309 stuff --xx- ---l 110000 0 2 310 write(bg8,mgg) --xxx ---1110000 0 2 311 fmpY(uloowoo) brtop --xxx ---1110000 0 2 312 --xx- ---l 100000 0 1 313 write(bg9,mgg) --xxx ---1100000 314 brtop --xxx ---1100000 i 11 315 --xx- ---1000000 0 0 316 wriWloo.mloo) --xxx ---1000000 0 0 317 brtop --xxx ---1000000 0 0 The stuff operation takes the boolean produced by Cycles 0 to 17 represent the loop prolog, while the fgt operation and stores asserted (unasserted) thus cycles 300 to 317 represent the loop epilog. The first (SCl)*II cycles when all stagesof the loop body are not yet executing concurrently is the prolog. Similarly, the last (SC-l)*11 cycles constitute the epilog.
An approach to sentence-level anaphora in machine translationThe '+' operator indicates that the sister relation should hold between the antecedent and some intermediate node and the ancestorrelation between this intermediate node and the anaphor. The Prolog-variant of (17) is (18)• So, the c_command relation holds between the I-structures ANT and ANA when one of ANT's sisters is ANA's ancestor. Artificial Intelligence 13 F Pereira , S Shieber, 1987: Prolog and Natural £anguage Analysis. CSLI 1987. S Shieber, 1986: An introduction to unification based approaches to grammar.
"A framework to support an object-oriented view of existing engineering databasesThe transformation rules are used to transform a query involving relationships not known to the database schema into a query against the database schema. 1 The knowledge base is defined using the Horn clausal form first order predicate calculus as implemented in Prolog [Cloc84]. Th e knowledge base is used to store facts that are true of t,he database schema. (Cloc84] Clocksin, W. F. and C. S. Mellish, Program ming in Prolog, Springer Verlag, 1984. [Daya84] Dayal, U. and Hwang, H, ""View Definition and Generalization for Database Integration in a Multidatabase System"", IEEE Trans. on Software Engineering, SE 10, 1984."
An exemplar based Smalltalk., C [Cox 84], Pascal [Tesler 847, Forth [Duff 84], and Prolog [Shapiro 83, Vaucber 867. Exemplar based systems include Act/l[Lieberman 81, Smallworld [Laffgl], Thinglab [Borning 827, and Actra [Thomas 857. Vaucher, J.G. and Lapalme, G., POOPS: Object Oriented Programming in Prolog, Tchnicai Report 565, Laboratoire INCOGNITO, Dept. d Informatique et de Recherche Operationnelle, University of Montreal, March 1986. 17.
An intelligent user interface to CIM multiple data basesPARSE TREE DCG PARSER key NL QUERY i . ..m , RESPONSE Figure 4 The Structure of Natural Language User Interface The DCG Parser takes an input sentence as a string and uses the DCG grammar (Gazdar and Mellish [8]), which is an extension of top-down Context Free Grammars, to parse the sentence of query and produce the parse tree (deep structure) in the form of PROLOG terms. The grammar used in this parser is a domain-independent rather than domain-specific grammar of English that provides for a variety of basic English construetion, including all common sentence types (declarative, imperative and interrogative), complex auxiliaries and modals, relative clauses, comparatives, conjunctions and time expressions. Gazdar, and C. Mellish, Natural Language Processing in PROLOG: An Introduction to Computational Linguistics, Addison-Wesley Publishing Company, 1989.
Using syntactic analysis in a document retrieval system that uses signature filesSmeaton wrote a parser of noun phrases in English and implemented the parser in Prolog. The pairs generated in thia case would not necessarily be adjacent so that implementing this strategy would be prohibitively expensive of storage using an inverted file system, since the technique of storing word offsets is no longer applicable. As a result we were able to parse text 30 times as fast as our NU-Prolog implementation of the grammar in [Smeaton 881.
A generalized model management system for mathematical programmingAmong the functions to be supported are (C), DBMS (FORTRAN, Pascal, or C), model solutions (FORTRAN), and knowledge which can probably best be supported management (Lisp or Prolog), each of by a different high-level language (as shown in parentheses). The problem is that these functional environments imply a high degree of incompatibility. Lisp or Prolog interfaces. DBMSs, for example, do not currently support The issue then is whether to develop an integrated MMS in one language that will be suboptimal in several functional areas or to use multiple languages that will then require the extr,a overhead of building workable interfaces between them. This is a common practice in developing expert systems that are often prototyped in Lisp or Prolog and then rewritten in C or Pascal for production use.
INFORMATION RETRIEVAL: THE USER-INTERFACEA hardware design methodology based on this framework entails: a) writing a specification of required design, b) designing a circuit intended to implement it, c) proving mathematically that the design meets its specification. Prolog is used both as a representational language for describing the design specification and implementation and also as an inference mechanism for proving its functional correctness.
"Recruiting more computer science students—what to do after the “glamour” has gone away?In support of this effort a number of ""quick-start"", one-hour language courses were introduced which include such languages as C, Lisp, Prolog and Ads. The idea is to get students up and running in a new language as quickly as possible and allow the students to have some control over the language they choose for their projects in upper division courses."
Lessons from Norstar's distributed call processing systemHowever, we have been looking at language support for the broadcast model. In particular, work has been done on using Prolog unification as a guard (and variable binding mechanism) for tasks to sort out which messages they should act upon.
Experiences teaching concurrency in AdaIn addition, many o f them were exposed to a 'ariety o f other languages including LISP , PROLOG, or PL/1 . The topic of concurren t programming was introduced by means o f some standard examples .
"An inexpert system for system developmentThe SHLEMIEL will request acknowledgement of the LADI with the SHLEMASEL which replies that i t is not a LADI, i t is WIFE of the SHLEMASEL's, this guarantees that the SHLEMIEL does not get to the f i r s t database with the BLONDE at the end of the BAR. 3.0 Architecture The illogical elements in the inexpert system are based on unspecific techniques: circular reasoning, retarded reasoning (sometimes called ""ball'n chaining"" to contrast with "" a r t i f i c i a l l y "" intelligent techniques}, and reasoning by poor example. The system, as a prototype was written in PROLOG, the final version will be self-coded (auto-coded) in CODA."
GRAPHICAL SUPPORT FOR ACCESSING A KNOWLEDGE BASEPasta's Architecture PASTA's functionalities are properly divided between two modules: The graphical interface 22 April 1988 Volume 19 Number 4 (written in C) and the semantic interface (implemented in Prolog). Graphical interface Accept all user input in form of mouse selections - Transmit the selections to the semantic interface - Display results received from the semantic interface Semantic interface - Interpretation of queries Knowledge base access - Evaluation of retrieved data Interaction Problems No HELP The interface was laid out for direct manipulation, but no help facility was implemented.
Concepts and paradigms of object-oriented programming^s D irRoZ ,MM..oI I Figure 6: Paradigms of Program Structure 21 Functional programming paradigm lambda calculus, Lisp, FP, Miranda, ML, HaskeU no side effects, first-class functions, lazy evaluation Lisp(1960) ---->FP-Miranda(1970s) --->ML(1980s) ---->Haskell(1990s) Exemplars: lambda calculus, Lisp Logic programming paradigm Prolog, Concurrent Prolog, GHC, Parlog, Vulcan, Polka relations-constraints, logical variables, unification Prolog(1970s) --->concurrent-logic-languages(1980s) Exemplar: Prolog Database paradigm SQL, Ingres, Encore, Gemstone, 02 persistent data, management of change, concurrency control hierarchical ---->network -->relational ---->object-based no dominant exemplar The above paradigms are not mutually exclusive. For example, Ada is both a blockstructure and an object-based language. Concurrent Prolog is both a concurrent and a logic programming language. Turing machines are state-transition of Computation Paiims State Transition State Machines Fortran Turing Machines Fortran Communication Classification Messages Types, Constraints Distribution Inheritance SmallTalk ML.SmallTalk CSP, CCS Prolog Argus, Nil Figure 9: State-Transition, Communication, and Classification Paradigms 24 mechanisms in which the instructions are determined by the input symbol and current state.
Generating editing environments based on relations and attributesThis solution would require handling problems including possible nontermination of queries and decreased efficiency of query evaluation and view updating. Another possibility would be to use Prolog [4] in place of a relational database. Although this is an intriguing idea, the absence of any incremental recomputation in current versions of Prolog makes this approach impractical. S. of Programming Languages (Williamsburg, Va., Jan. Programming in Prolog. Springer-Verlag, New York, semantics. Ph.D. thesis, Univ. of Wisconsin grammars.
Benchmark semanticsGabriel, Performance and Evaluation of Lisp System 8 MIT Press, Cambridge, Mass. 1985 [7] R.A. O'Keffe, Prolog Comparedwith Lispf SIGPLAN Notices, vol. 18 #5 (May 1983) ioi r
KNOWLEDGE SYSTEM FOR SUPPORTING STATISTICAL ANALYSISThe data management system was programmed in Turbo-Pascal, the rest was developed in a PROLOG-based expert system shell -- ALL-EX. The shell was elaborated parallelly by the system.
The future of high performance computers in science and engineeringAnother group at Berkeley has produced a first generation Prolog machine that has outperformed the fastest Japanese special fifth generation machines. The next generation Prolog computer is a multiprocessor/multicomputer to exploit both fine grain and message passing for parallel processing.
Probing limits to automation: towards deeper process modelsThe system is based on an AI planning paradigm, where plan recognition is used to detect and avert process errors and planning is used to cooperatively automate the process. A Prolog implementation of a plan recognizer that incorporates the deepmodel reasoning described here is now operational.
A practical approach to semantic configuration managementHowever, such an unsoundness cannot occur in our logic, since the deductive closure of axioms T contains only positive atomic facts. 8.2 Applying the Method Our logic has been implemented (by Gail Harrison) in Prolog [32]. Our initial experiments showed that estimates can be too large when the variables of interest are related to many other variables. Journal of Logic Programming, 1(1):51-79, June 1984. [32] L. Sterling and E. Shapiro. The Art of Prolog. The MIT Press, 1986. [331 [341 [351 [361 W.F.
Spoken language systems IIWhen tested on 24 sentences from the resource-management domain, the parser achieved a mean parsing time of 12 seconds on a Sun 4/280 running in Prolog, on an 884-word subset of the 1000-word vocabulary.
A formal description of Arabic syntax in Definite Clause GrammarConclusiml This grammar has been implemented in a syntactic analyzer [8] developed in Prolog on a 1'C/XT-286 and tested on a large number of Arabic sentences.
"On compile-time query optimization in deductive databases by means of static filteringThe reader should be aware of the difference deductive databases and that adopted in PROLOG. an implication with nonempty between the terminology of By axiom (or rule) we mean premises and consequent. We also use `0"" instead of A in bodies of the rules, as in PROLOG. 3. QUERY EVALUATION AND SYSTEM 3.1 System Graphs GRAPHS Let S be an IDB. The practice of querying relational databases and programming in Prolog shows that for ""realistic"" rules the number of unequals is unlikely to be so high."
An empirical study of the reliability of UNIX utilitiesThe second class of pointer problems is caused by references through a null pointer. The prolog interpreter, in its main loop, can incorrectly set a pointer value that 1, I I-I-I -1 - I is then assumed to be valid in the next pass around the loop. Our search for the cause of a bad pointer in the prolog interpreter's main loop was complicated by the interesting weaving of control flow caused by the goto statements.
Programming at the processor-memory-switch levelLee and Goldwasser's DICON*l is a configuration language used to glue together a set of sequential programs written in Prolog or C to form a distributed program. DICON allows a close coupling of the processes, including passing of pointers to structured data (lists, trees, etc.), which are then used by the interprocess communication servers to retrieve and copy the data. Programs are not as independent from each other as they are in Durra (e.g., according toll, C programs need to know if they are communicating with a Prolog program and are restricted in the types of data they can send or receive).
Review of Parallel execution of logic programs by John Conery. Kluwer Academic Publishers 1987.Chapter 2, Logic Programming, covers the main concepts of logic programming -- syntax, semantics, and serial execution -- along with features of Prolog placed in this general comext. In the discussion of serial execution, Conery presents his concept of the goal, or query, tree: a tree in which the root of the tree is the user's query, and in which each descendant is a new query derived by resolution from its parent.
Object identity., at run-time) or static. Figure 1 includes Pascal [Wirth 1971] and Prolog [Colmerauer 1975] as representatives of these languages. SQL uses tuple variables and QBE uses domain variables, as does Prolog, to identify temporary objects. There are several problems with identifier keys which are due to the fact that the concepts of data value and identity are mixed.
Seventh RIMS Conference on FORMULA MANIPULATION AND ITS APPLICATION TO MATHEMATICAL STUDYThe interpreter is based on a set of transformation rules and its performance is almost the same as that of Prolog which carries out the occur check. The executable expressions include goals like VX : (p(x, y) -- q(x,z)), where y and z are variables to be instantiated.
"A RISC architecture for symbolic computationThis is the tack taken by the designers of the Xenologic X-1 processor [2], an application accelerator for Prolog. This scheme has the disadvantage that other standard parts that might Someday be used in the data path of the G151 processor, such as a floating-point coprocessor, may require a 32-bit data path, resulting in an internal data path width incompatibility. (2) Let the internal data path of the G-processor be 32 bits and accommodate the tags in memory with an auxiliary byte not necessarily contiguous with the data word with which the tags are associated. P., Despain, A. M. and Patt, Y. N., ""Performance studies of a Prolog machine architecture,"" Proc. of 12th Internat."
"A graph transform model for configuration management environmentsWe will use the term""knowledge base"" (I(B) as opposed to the term `Ldatabase"" to indicate that both data and rules are being stored. One obvious analog is a system such as Prolog [CM81]. It is intended that the knowledge base contain all software objects. [CM811 [DL86] [Eri84] [Est85] [Est88] [Fe1791 W. F. Clocksin and C. S. Mellish. Progrumming in Prolog. Springer-Verlag, New York, 1981. Klaus Dittrich and Peter Lockmann."
DALI-a knowledge base management systemUnfortunately, most of this research was performed assuming that PROLOG (and not LISP) is used as the programming language. ,Shortliffe,E.: Rule-based Expert Systems, Addison- Wesley(1984). CAMP 84 Campbell, J.A.: Implementation of Prolog, John Wiley and Sons(1984). CER 83 CeriS.: Methology and Tools for Database Design, North Holland Publishing Company(It 83).
"Review of ""Computer interpretation of natural language descriptions"" by Christopher S. Mellish. Ellis Horwood Limited 1985.Dahl Unisys This book describes work in the areas of semantics and reference resolution for text understanding, exploring the idea of early semantic analysis. These ideas were implemented in a Prolog program for analyzing word problems in physics at the University of Edinburgh as part of the author's Ph.D. thesis."
Implementing a campus-wide computer-based curriculumLikewise, the ability to support several high level languages such as FORTRAN, BASIC, TURBO Pascal and other esoteric languages such as C, LISP, and PROLOG were viewed as plus for the IBM PC compatible computer.
Abstraction mechanisms in hypertextThis requires further study but we hypothesize that the usage of a language such as PROLOG is apt for this purpose. Basically the predicates in the hypertext form the database of 2-place predicates for a PROLOG engine. 6 CONTEXTS: AN EXAMPLE In [DS87] D 1' 1 e 1s e and Schwartz have suggested the use of contexts for partitioning a hypertext.
"Review of ""Interpreting anaphors in natural language texts"" by David M. Carter. Ellis Horwood 1987.Her group is developing PUNDIT, a large text processing system in Prolog. She designed and implemented PUNDIT's components for reference resolution and noun phrase semantics."
An overview and bibliography of ENCOMPASS: an environment for incremental software development using executable, logic-based specificationFor example, [10, 19] describe an Ada based version of PLEASE in which pre- and post-conditions are translated into pure Prolog which is executed by a standard interpreter. [6,17] describe a C++ based version of PLEASE which uses a different execution mechanism. [10,12, 15, 19] give examples of PLEASE specifications.
A morphological parser for AfrikaansStructure The system was implemented on VAX/VMS in Quintus Prolog and consists of the following parts: (1) The compiler, which takes as its input two-level rules and produces final state automata (transducers). (2) The lexicon module which provides a user interface for the creation and updating of the lexicon - the lexicon input module.
Basic concepts in object oriented programmingLogic programming using first order predicate logic is currently the most important example (Prolog). It seems obvious to the author that alI these three perspectives should be supported within any new general programming language in the future.
"Efficiently supporting procedures in relational database systems%apshots "", Proceedings of the 6th International Conference on Very Large Data Bases, Montreal, [ALLM76] [BANC86] [BAT0851 [BAT0861 [BLAK86] [BUNE79] [CARE861 [CHAN77] [CHOU85] [COPE841 October 1980 Allman, E et al, `%QUEL Reference ManualR, Umverslty of Cahfornia, Technical Report UCB/ERL, Berkeley, CA, 1976 Banclllhon, F , and Ramakrlshnan, R , ""An Amateur'8 Introductton to Recur-8tve Query Processmg"", Proceedmgs of the 1986 ACM-SIGMOD International Conference on the Management of Data, Washington, DC, May 1986 Batory, D S and Kim, W, ""Modeltng Concept8 for VLSI CAD ObJecte"", ACM Transactions on Database Systems, (10) 3, September 1985 Batory, D S , et al, ""GENESIS A Reconjigurable Database Management System"", Umverslty of Texas at Austm, Technical Report TR-86-07, Austm, TX, March 1986 Blakeley, J A Larson, P and Tompa, F W, ""Effi crently Updatrng Materlalrzed Views"", Proceedings of the 1986 ACM-SIGMOD International Conference on the Management of Data, Washington, DC, May 1986 Buneman, 0 P and Clemons, E K , `%fficlently Monrtor,ng Relational Databases"", ACM Transactions on Database Systems, (4) 3, September 1979 Carey, M , et al, ""Object and File Management :n the EXODUS Eztenelble Database System"", University of Wisconsin at Madison, Technical Report, Madison, WI, March 1986 Chandy, K M , ""Models of Dgatrtbuted Systems"", Proceedings of the 3rd Internatlonal Conference on Very Large Data Bases, Tokyo, October 1977 Chou, H and Dewitt, D J , ""An Evaluataon of Buffer Management Strategree for Relatronal Database Systems"", Proceedmgs of the 11th International Conference on Very Large Data Bases, Stockholm, August 1985 Copeland, G and Maler, D , ""Makrng Smalltalk a Database Sy8temrt, Proceedmgs of the 1984 ACMSIGMOD International Conference on [DERR86] [ESWA76] [FINK821 [GRAN81] [GRAY781 [GUTT84] [IOANSSa] the Management of Data, Boston, MA, June 1984 Derrett, N P et al, ""An ObJect-0r:ented Approach to Data Management"", Proceedmgs of the 1986 IEEE Spring Compcon Conference, Eswaran, K P et al, `The Notrons of Consistency and Predacate Locks an a Database System"", Commumcatlons of the ACM, (19) 11, 1976 Fmkelstem, S , ""Common Expressron Analyet in Database Applzcatrone"", Proceedmgs of the 1982 ACMSIGMOD International Conference on the Management of Data, Orlando, FL, June 1982 Grant, J and Mmker, J , ""Opt:mlratton tn Deductrve and Conventzonal Relatronal Database Systems"", m ""Advances In Data Base Theory"" , vol 1, H Gallave, J Mmker and J-M Nlcolas, Eds , Plenum Press, New York, 1981 Gray, J N , ""Notes on Data Base Operatrng Systems"", IBM Research, Technical Report RJ-2254, San Jose, CA, August 1978 Guttman, A, ""`New Features for Relatronal Database System8 to Support CAD Appltcakone"", PhD Thesis, University of Cahforma, Berkeley, June 1984 Ioanmdls, Y , ""Proceae~ng Recursron an Deductrve Database Systems"", PhD Thesis, University of California, Berkeley, July 1986 [IOAN86b) ""On the Computatron of the Z'ransrtrve Closure of Relatronal Operators"", Proceedmgs of the 12th International Conference on Very Large Data Bases, Kyoto, Japan, August 1986 [JARK84] Jarke, M , Clifford, J and Vasslhou, Y , ""An Opttmrtcng PROLOG Frontend to a Relatconal Query System"", Proceedings of the 1984 ACMSIGMOD International Conference on the Management of Data, Boston, MA, June 1984 [KERS84] Kershberg, L , Editor, Proceedmge of the First Intetnatronal Workshop on Ezpert Database Systems, Klawah Is1 , [KJ3RS86] [KOOI82] [KUNG84] [LARS85] [MATT70] [MOHA86] [MORR86] [ROSE801 [ROUS82a] [ROUS82b] [ROUSSS] SC, October 1984 Kershberg, L , Editor, Proceedtngs of the Fgret Internatronal Conference on Expert Database Systems, Charleston, SC, Apnl, 1986 Kool, R and Frankfurth, D , `(Query Optrmrzatron rn INGRES"", Database Engmeermg, (6) 3, September 1982 Kung, R et al, ""Heurrstrc Search $11 Data Base Systema"", m [KERS84] Larson, P and Yang, H , ""Computrng Quertes from Dertved Relations"", Proceedings of the 11th Internatlonal Conference on Very Large Data Bases, Stockholm, August 1985 Mattson, R L et al, ""Evaluatton Technrquee for Storage Hzerarchres"", IBM Systems Journal, (9) 2, 1970 Mohan, C , ""STARBURST An Extencable Relahonal DBMS"", Panel Dlscusslon on Extenalble Database Systems, Proceedings of the 1986 ACMSIGMOD Internatlonal Conference on the Management of Data, Washmgton, DC, May 1986 Morris, K , et al, ""Desrgn Overvrew of the NAIL! System"", Stanford Umverslty, Technical Report STAN-CS-86-1108, Stanford, CA, May 1986 Rosenkrante, D J and Hunt, H B , ""Processing Conlunctlve Predleates and Queraea', Proceedmgs of the 6th International Conference on Very Large Data Bases, Montreal, October 1980 Roussopoulos, N , ""Vtew Indexrng an Relatronal Databaeecr"", ACM Transactions on Database Systems, (7) 2, June 1982 Roussopoulos, N , ""The Logteal Access Path Schema of a Database"", IEEE Transactions on Software Engmeermg, (8) 6, November 1982 Roussopoulos, N and Kang, H , ""Prelamrnary Deesgn of ADMS* A Workstatron-Matnframe Integrated Architecture for Databaee Management Systems"", Umverslty of Maryland, Technical Report, College Park, MD, February 1986 [SELI79] [SELL851 [SELLSSal [SELL86b] [STON75] [STON76] [STON84] [STON85] Sehnger, P et al, ""Acce88 Path Selectton in a Relatronal Data Base System"", Proceedmgs of the 1979 ACMSIGMOD International Conference on the Management of Data, Boston, MA, June 1979 Selhs, T and Shapiro, L , ""Opttmrtatlon of Extended Database Languages,,, Proceedmgs of the 1985 ACMSIGMOD Internatlonal Conference on the Management of Data, Austin, TX, May 1985 Selhs, T , ""Global Query Optrmlzat(on"", Proceedings of the 1986 ACMSIGMOD International Conference on the Management of Data, Washington, DC, May 1986 Sells, T , ""Optrmtzatzon of Extended Relatronal Databaee Systems"", PhD Thesis, University of California, Berkeley, July 1986 Stonebraker, M , UImplementatron of Integrrty Constrarntcr and Vtews by Query Mod$catron"", Proceedings of the 1975 ACM-SIGMOD International Conference on the Management of Data, San Jose, CA, June 1975 Stonebraker, M et al, ""The Design and Implementatton of INGRES"", ACM Transactions on Database Systems, (1) 3, September 1976 Stonebraker, M et al, ""Quel as a Data Type"", Proceedings of the 1984 ACM-SIGMOD International Conference on the Management of Data, Boston, MA, June 1984 Stonebraker, M et al, ""Extendmg a Data Base System with Procedures"", Umverslty of Cahforma, Technical Report UCB/ERL/M85/59, Berkeley, CA, July 1985 [STON86a] Stonebraker, M , Selhs, T and Han .-, E, ""Rule Indezrng Implementattotas rn Database Systems"", m [KERS86] [STON86b] Stonebraker, M and Rowe, L , ""The Deeagn of POSTGRES"", Proceedmgs of the 1986 ACM-SIGMOD Internatlonal Conference on the Management of Data, Washmgton, DC, May 1986 [ULLM82] [ULLM85] [VALD86] [WONG76] vOUS78] [ZANI83] [ZANI84] [ZANI85] Ullman, J , HPrlnclples of Database Systems"" , Computer Science Press, 1982 Ullman, J , ""Implementation of Logacal Query Languages for Data Bases,,, Proceedings of the 1985 ACMSIGMOD International Conference on the Management of Data, Austm, TX, May 1985 Valdurlez, P and Boral, H , ""Evaluatron of Recuretve Querres Ustng Joan IndIces"", in [KERS86] Wong, E and Youssefi K , ""Decompoectlon A Strategy for Query Proceesrngn, ACM Transactions on Database Systems, (1) 3, September 1976 Youssefi, K , ""Query Processrng for a Relatronal Database Syetem""`, PhD Thesis, University of California, Berkeley, 1978 zan1010, c ,""The Databaee Language GEM,,, Proceedmgs of the 1983 ACM-SIGMOD International Conference on the Management of Data, San Jose, CA, May 1983 Zaniolo, C , ""PROLOG A Database Query Language for all Seaeons"", m [KERS84] Zaniolo, C , ""The Repreeentatron and Deductrve Retrreval of Complez Objects"", Proceedings of the 11th International Conference on Very Large Data Bases, Stockholm, August 1985"
Reusability library framework (RLF)Using knowledge bases that model Ada units, as well as testing heuristics associated with Ada language features, Gadfly assists in generating a high-quality test plan. n AdaKNET (Knowledge NETwork) is an Ada implementation of a semantic network system, based in part on a Unisys-proprietary semantic network system implemented in Prolog. For the librarian application, AdaKNRT provides the library structure. n AdaTAU is based upon TAU (a mnemonic for Think, Ask, Update), a Unisys-proprietary production rulabased system. RLF Knowledge Representation Systems (continued) l AdaKNET Features: o Rigorous enforcement of specialization semantics o Modelling of features best suited to library frameworks o Same model information can be used in multiple applications l AdaTAU Features: o Gives guidance in navigating complex domain models o Extensible rule-base generic abstractions o Tailorable for use with different inferencing strategies UNiSYS RLF Knowledge Reprementetion Systems (cont.) n The semantic network model provided by AdaKNET is modeled on features present in the well-known KL-ONE system and a proprietary Prolog-based Unisys system known as K-NET. AdaKNET provides a means of denoting objects and relationships between them.
Categorial semantics and scopingAll that is required is a calculus of functional objects in which those objects satisfy their usual algebraic properties, such as what is provided by X-Prolog (Miller and Nadathur 1986). For instance, in a X-Prolog realization of the proposed system, abstractions arising from the [abs] rule or its derived rule surrogates could be calculated through a combination of universal quantification in the metalanguage (the language in which the proof system is described) and higher-order functional equations solved by higher-order unification (Felty and Miller 1988).
Using an architectural knowledge base to generate code for parallel computersIn this article, we present a compiler for distributed memory parallel computers which performs automatic program partitioning, mapping, and communication code generation. The prototype compiler is implemented in Prolog, with the code generation advice incorporated as a set of Prolog rules.
Book review: Readings in Distributed Artificial Intelligence. Ed by A. H. Bond and L. Gasser (Morgan Kaufmann, 1988)Although Artificial Intelligence is ranked as a major area along with hardware, software, theory, appliearions and special topics but the absence of several hot topics like Prolog and Neurocompufing is badly felt after the third volume.
"Review of ""The case for lexicase: an outline of lexicase grammatical theory"" by Stanley Starosta. Pinter 1988.When programming languages for natural language are discussed (pp. 314-316), Lisp is briefly introduced (a few sentences), followed by a description of Planner (two pages), a language only of interest to AI archaeologists. Nothing is said of Prolog and its growing importance. Because so many diverse topics are covered, an accusation of superficiality cannot be entirely avoided."
"Review of ""The computational analysis of English: a corpus-based approach"" by Roger Garside, Geoffrey Leech, and Geoffrey Sampson. Longman 1987.For anyone trying to make practical use of text, this book is extremely enlightening. English is not an inferior substitute for Prolog, and treating it as such is not only a mismatch, but also unnecessary for many tasks."
Policy discussionThe early accomplishments under this plan included the new design and layout, the Programming Pearls column, Viewpoint commentaries, From Washington, significant improvements in Computing Practices, and a variety of highly-edited special issues and special sections on timely themes: Architecture Jan 85 Knowledge Based Systems Sep 85 Prolog Dee a5 Robotics June 86 Teaching Programming Sep 86 Parallel Computing Dee 86 A severe budget cut in 1986 must be preserved in the ACM.
"Review of ""Revue québécoise de linguistique"" by Université du Québec à Montréal.According to Plante, Deredec is more appropriate than general purpose languages such as Lisp or Prolog as a programming environment for linguistic manipulations."
Functional structures for parsing dependency constraintsStrongly pronounced and in wide use this vantage point becomes in Prolog. Recently fresh views of parsing as constraint systems have also surfaced, such as FUG (Kay, 1985, Karttunen and Kay, 1985), LFG (Bresnan, 1978), and PATR-II (Schieber, 1985).
An integrated system for morphological analysis of the Slovene languageStructure The system was implemented on VAX/V-MS in Quintus Prolog and consists of the following parts: (1) The compiler, which takes as its input two-level rules and produces final state automata (transducers). (2) The lexicon module which provides a user interface for the creation and updating of tile lexicon - the lexicon input module.
Bureaucracies as deontic systemsDR is an applied a simple language, DR, for processing form of a logic programming language (the prototype is written in Prolog). Like Prolog, computability is attained by restricting assertions to the Horn-clause subset of predicate calculus.
Efficiency considerations for LFG-parsers: incremental and table-lookup techniquesIn the execution phase the system will Use only the subsuming (i.e. larger) f-description. E.g. if a dictionary entry in the PROLOG code, produced in the preprocessingphase, has the specifications as (TSUBJ NUM) = SO, and simultaneously: !
Using temporal hierarchies to efficiently maintain large temporal databasesFor the most part, query processing in the TMM is the sameasquery processing in Prolog [lo] with certain changesin notation: Cambridge-Polish notation is used instead of prefix notation, conjunctions are (production-status lathe 14 free) I b (operational-status lathe 14 in-service) I I (malfunction lathel4) H (operational-status I I lathe 14 out-of-service) (routine-service lathe 14) H (operational-status lathe 14 in-service) (production-status lathe 73 in-use) I I (production-status lathe 73 free) I I (production-status lathe 73 in-use) I b (operational-status I lathe 73 in-service) b (manufacture part 42 job 321) I-------- t-1 (installed slot-cutter 17 lathe 14) I I FIG. Organizing Large Temporal Databases The most expensive operation distinguishing temporal database manipulations from those performed by static database systems (e.g., Prolog) involves finding tokens that satisfy certain temporal constraints. Conclusion In conclusion, the TMM provides a wide range of functionality (backward and forward temporal inference, dependency-directed default reasoning, temporal reason maintenance) in a simple-to-use system (predicate-calculus syntax and Prolog compatibility) in which routine temporal reasoning is optimized using caching and searchtechniques to speedinference.
Forth organizations and vendorsBox 8231 San Jose, CA95155 408/277-0668 GENIE 800/638-8369 (with modem) type liHH To sign up: following U# prompt, type: XJt 411849, GENIE Harvard Softworks RO. Box 69 Springboro, OH 45066 513/748-0390 A Prolog implementation in F83, other Forth products. Vendor of an inexpensive Forth engine kit based on the NC4000.
Developing computer aided design technology in ChinaThe Center currently teaches about 3,000 students per year through 10 courses covering FORTRAN, BASIC, PASCAL, COBOL, LISP, PROLOG, database management, operating systems and utilities, and Tektronix IGL.
"A new paradigm for parallel and distributed rule-processing+m #I- 29601 87 C 0074, and by the Center for Advanced Technology dl Columbia Ln~vcrs~tyunder contract hYSSTF-CAT(89)J Perm~ssmnto copy wthout fee all or pan of thusmatenal IS granted prowded that the copsesare not made or dutnbuted for drect commeraal advantage,the ACM copyqbt notmz and the btk of the publwatlw and I& date appear. and notme u pen (hat copyog IS by pamum of the Asrouatvan for Computmg Mach~ncty To copy otbemse, or to repubhsb, reqwes a fee and/or speafic permMMm 0 1990ACM lW79136.5 WWOOOYO133$1 SO wtthout commumcatton overhead, namely pure parallellzauon Thus type of parallekzatlon 1srestncted m its appllcabllrty. only some classesof programs can be purely parallellzed To overcome &us Imutatlon, UI [Cw] we proposed a strategy that does recur an overhead,but can be applied to every smgle-ruleprogram wuhout constants We show that all the strategiesQscussedm our pevtous works are special casesof the data-reduction paradigm, that we tntroduce tn Ouspaper It supulates that parallellzation is obtatnedby having each processorevaluate the orlgmal program, but with less data Generally, thts 1salso what parallel processors do when addmg two vectors m parallel In this paper we demonstratethat &us idea 1sapplicable to rule processmg,and analyzeit III ths amtext In extension to the smategtesdiscussed111our pre-VIOUSworks, data-reductton1sapplicable to datalog programs with muluple rules. constants,andnegation A data-reductron strategy 1s obtamed as follows Every smgle-processordatalog evaluation method can be regardedas a sequenceof rule-mstanuatlons, m eachrule-mstanhatlon, the vanables m the rule we replaced by constants from the mput The purposeof data-reduction IS to parutton the mstantlattonsamong multtple processors,such that if each processor uses a smgle processor method to evaluate the ongmal program, then it processesless data The works on the NCcomplexq of programs(e g [AP, CK, K, UV]) also partttlon the mstantiatlons.but they assign one mstanuatton to a processor,assummga polynomm1(m the databasesize) number of processors The works idenufy the programs for which the evaluation can complete tn polylogarithmic ume If the number of processorsis COnstant(as we assume), then the NC-type of evaluauon algonthms can be adapted, by asstgnmgthe work of multiple processorsto a single processor However, tt turns out that which multiple processors are assigned to a smgle one, 1e how the pieces of work are grouped. 1svery unportant as far as overhead (particularly if the processorsdo not have sharedmemory) and evaluation cost are concemcd The present paper studies the partltlonmg of work amongthe processors Smcethis paper 1sdevoted to data-reducbonissues,m the next paragraphswe explam the paradigm m detail, and pomt out its relatlonshp to other relevant work The databasecommumty observedthat given massive amounts of data, a declarative program,such asdatalog,should be evaluatedm a set-oriented,rather than tuple-oriented (a la Concurrent Prolog [DL, Sh]) fashion The set-oriented,or relational, evaluation of a programP amounts to Itcratlvely computmg a relational algebra expression for each rule of P, until a fix-point 1sreached([U]) Example 1 Consider the transltlve closureprogramP 1 ~(x,Y)=~(w). Benjamm-CummmgsPubhshmgCo, 1987 F Mattem, ""Algonthms for Dlstnbuted Termmahon Detection"", Dzstrlbuted Computrng, pp 161-175, 1987 F Mattem, ""Global QuiescenceDetechon Based on Credit Dlstnbutlon and Recovery"". to appear,ZnformatronProcessrngLetters A J Pas&, ""A Methodology for ProgrammmgProductlon Systemsand its Jmphcatlonson Parallelism"", Ph D Thesis, Columbia Umverslty, 1989 R Ramaknshnan, ""Parallelism 111Logic Programs"", Umv of Wlsconsm, Computer Sa Dept, TR #892, Nov 89 L Raschld,T Selhs, and C C Lm, ""Exploltmg Concurrency m a DBMS Implementation of produchon Systems, Proc International Symposium on Databasesm Dlsmbuted and Parallel Systems,Austm TX, Dee 1989 0 Shmueh "" Decldablllty and Expressiveness Aspectsof Logic Quenes,"" Proc 6th ACM Symp on PODS,pp 237-249,1987 E Y Shapiro ""Concunent Prolog, Collected Papers"", MlT Press,1987 S Sengupta,A Dupuy, J Schwartz, 0 Wolfson, Y Yemm, `The Net-mate Model for Network Management"", m IEEE Network Operatrons and ManagementSymposrum.Feb 1990 S J Stolfo, D P Maanker and R Mills, ""A snnple processmgschemeto extract and load balance unphclt parallehsm m the concurrent match of produchon rules"", In proc of the AFIPS symp on fifth generatlon computmg,AFIPS.1985 J D Ullrnan, ""DatabaseandKnowledge-baseSystems Volume l"", computerSciencePress,1988 J D Ullman and A Van Gelder, ""Parallel Complexity of Logic Programs"",TR STAN-CS-85-1089,Stanford University P Valdunez and S Khoshafian, ""Parallel evaluation of the Translnve Closure of a DatabaseRelation"", International Journal of Parallel Programmmg 17,1, Feb 1988 0 Wolfson and A Sllberschatz, ""Dlstnbuted Processmg of Logic Programs,"" Proc of the ACMSIGMOD Conf , pp 329-336, 1988 0 Wolfson, ""Sharmg the Load of Logic Program Evaluation"", F'roc of the Intl Symp on Databasesm Parallel and Dlstnbuted Systems,Austm, TX, Dee 1988"
Using current literature in two coursesThey were also able to do some readin g about languages with which they had no t explicitly worked such as Prolog , Smalltalk, Modula-2, and SQL . STUDENT RESPONS E In an evaluation at the end of th e computer organization course, I asked th e students to list five topics or activitie s that they found most informative or usefu l in the course .
Knowledge representation and semantics in a complex domain: the UNIX natural language help system GOETHEIt covers all of UNIX' file handling, containing a static knowledge base of more than 70 UNIX programs. It is written in Quintus-PROLOG and C, and takes by average less than 10 seconds for generating an answer to a user's request. 361 3 Requirements on Knowledge Representation and Semantics for a UNiX natural language help system It is the task of the knowledge base in a UNIX natural language help system to serve as a baals for correctly and adequately answering a user's questions in one of the following situations: (1) the user needs to know a UNIX cormnand, or series of commands in order to carry out a certain i:ask, (2) hc has sent off a I JNIX command and the system has resulted in a different .qa[e !
Workshop on Distributed Expert-Based Information Systems: A PerspectiveTo supplement that knowledge, which simplifies handling of the target collection of AIList Digest messages, the Collins Dictionary of the English Language has been transformed into a Prolog fact base that provides ready access to a large amount of general linguistic information ....
DLT: an industrial R & D project for multilingual MTThis automatic disambiguation system, written in Quintus PROLOG, now largely serves as a rating (preordering) of parallel surface translations, prior to the disambiguation dialogue which follows it.
"The PSI/PHI architecture for prosodic parsingEikmeyer, H.J., 1986. ""CheOPS: an object-oriented system in PROLOG."" User Manual. Bielefeld. Eikmeyer, H.J. & Gibbon, D., 1983."
Abstraction mechanisms in hypertextThis requires further study but we hypothesize that the usage of a language such as PROLOG is apt for this purpose. Basically the predicates in the hypertext form the database of Zplace predicates for a PROLOG engine.
XY-WINS: an integraded environment for developing graphical user interfacesThese include interfaces for a syntax-driven editor for a two-dimensional language, a highly graphical environment for simulating concurrent systems, a document layout system, a Prolog database system, and XY-WINS tools themselves. For example, AGIP and APE are now being used to provide a graphical user interface for a Prolog system. Acknowledgements The author of this paper would like to thank the students who participated in the implementation of XY-WINS tools at Stony Brook, typically, as part of their Master's projects or theses.
"Proving temporal properties of hybrid systemsNarain, S. (1990), ""A New Simulation Technique and its Implementation in Prolog,"" To appear in Prolog and its Applications, A."
Unification in primal algebras, their powers and their varietiesThere are, however, two studies of integrating unification in Boolean rings (using both Boole's and Lowenheim's methods) with Prolog reported in [3] and [24]. The main application in both casesis hardware simulation and verification. Hence, there is no additional degree of backtracking over multiple unifiers. Depending on the architecture of a Prolog system, it can be very simple to add on new unitary unification algorithms. Another undesirable property of unifying mixed terms is that the resulting theory is not necessarily unitary, even if all individual theories are. In a Prolog context, the combination problem can be avoided by requiring that every term contains function symbols from one theory only and that variables and argument positions of predicate symbols are typed, that is, belong to one theory only.
Readings in scheme., October 1985. Matthias Felleisen, Transliterating Prolog into Scheme, Computer Science Technical Report #182, Indiana University, Bloomington, Indiana, October 1985.
"Faculty support services: a transformer between user needs and a changing technologyIn order to successfully involve faculty in a new application, one does not need to have or claim expertise with the new application. In Spring 1986 at UNCG, a seminar on PROLOG was advertised as an opportunity to ""come learn with us"", the result was a dynamic interchange between the computer center staff and the faculty participants."
A model for growth in the intelligent automation industry: case studies in robotics and artificial intelligence. • Component technologies available: Programming languages, such as Lisp and Prolog, and powerful personal workstations with bit-mapped displays, enabled more rapid prototyping and implementation of the reasoning system and knowledge base. • Commitment to ezperiment by a few major corporations: In contrast to the robotics case, the corporations investing in AI during Stage One represented a broader range of industries (e.g. heavy industrial equipment, computers and communications, oil exploration).
"Review of ""Natural language understanding"" by James Allen. Benjamin/Cummings 1987.(The second appendix cover, the essential ideas underlying Lisp and Prolog, though without taking the 96 Natural Language Understanding form of a primer for either language.)"
An efficient implementation of PATR for categorial unification grammarEarlier PATR implementations, written in Lisp and Prolog, require the high overhead of an interpreter. C- PATRs 135k of source code compiles into a 58k stand-alone application on the Mac, and an 82k stand-alone on the Sun-4.
A guide to natural namingThe convention is only partially applicable to declarative languages like PROLOG or to a language like LISP where only functions and no procedures are known .
Algorithms and proofs: mathematics in the computing curriculumWe may try to make algorithms more like proofs, as in PROLOG. Or, we may instead attempt to make proofs algorithmic.
Parallel vision techniques on the hypercube computerThen, we transfer painted subimage boundary pixels between processors, and where the labels are compatible, by some criterion such as the label of one falls within the bucket of the other, then we paint the boundary pixel a standard connecting color, e.g. white. 7 Work in progress We have ported Lisp and Prolog to the Mark 3 hypercube. We have done some work on shape from shading algorithms and stereo matching algorithms.
ABSTRACTS: Sixth RIMS Conference on FORMULA MANIPULATION AND ITS APPLICATION TO MATHEMATICAL STUDYThe hybrid computation system is a symbolic manipulation system with an interface to numerical computation. The system is written in the Prolog and runs on personal computers. Given an ODE with initial conditions, the system transforms it into a set of linear ODE's and computes a formal solution symbolically.
"Reasoning about digital systems using temporal logicFujita, H. Tanaka, and T. Moto-oka, ""Verification with Prolog and Temporal Logic,"" Proc. Computer Hardware Description languages and their Applications, North Holland, Amsterdam, 1983."
An Ada-based software engineering courseWhile proceeding through [PRAT84] the students are introduced to the C language, PROLOG, and advanced topics in Ada. Thus, when the students enter the Software Engineering course they should have had two quarters exposure to Ada and a general exposure to several other languages.
Workshop on toolsCurrently on top of Lisp with Flavors, moving to CLOS and C++, generates code for Lisp and Prolog. Oriented towards fast prototyping. Provides for grouping classes into Modula-2-style modules to help segment a system for multi-person coordination. 3 faculty members (1 full-time), 2 Ph.D. students, over 100 student users.
"PeriPhrase: lingware for parsing and structural transferThe syntax of PeriPhrase was heavily influenced by its predecessor ""PHRASE,"" which in turn borrowed from BNF, rule-based programming languages like PROLOG, and expert systems. There are obvious similarities to PARSIFAl., Marcus ' Deterministic Parser, and many ot/ler projects."
Phonological processing of speech variantsThe phonological parser and the extension procedure have been implemented in Arity PROLOG V5.1. The extension procedure described here was developed as part of the research project Phonological Rule Systems at the University of Bielefeld which was financed by the Research Institute of the Deutsche Bundespost.
"Knowledge-based simulation at RANDWe have developed a new logic-based modeling environment called MODL, implemented in Prolog, whose powerful deductive mechanism greatly facilitates answering questions beyond ""What if...?""."
A new proof of undecidability of safety of logic queriesThen all negative results for Horn queries also hold for general queries . Following Prolog, variables begin with a capital letter . A substitution a is a set of the form {Vt/ti, ...
"Automatic indexing and Government-Binding TheoryKnecht, and M.J Cellio, (1988), ""A News Categorization System,"" in Proceedings o1'the Second Conference on AEplied Natural Langu,c Processing, Austin, Texas. Kuhns, R.J., (1986), ""A PROLOG Implementation of Government-Binding Theory,"" in Proceedings of the Xlth International Conference on Computational Lint_fistic, Bonn, West Germany."
"Review of ""Machine translation: past, present, future"" by William John Hutchins. Chichester 1986.Some of the advances in computing which resulted largely from work in MT laboratories include the foundations of formal language theory (Chomsky at MIT), ATN parsers (Woods at Harvard), and Prolog (from Colmerauer's Q-systems at Montreal). Purists might object to the condensed treatment that Hutchins (necessarily) gives to topics in linguistics and computing."
Configuration management in the PACT software engineering environment. - Tools are provided for project mahagement, configuration management, C language support, Lisp support, Prolog support, document editing, etc. This paper provides a high-level discussion of configuration management in PACT, outlining the radical approach taken by PACT.
"Design of a pictorial knowledgebaseKarukonda, S. K., ""Knowledge Programming Constructs in Prolog"", M.S. Systems Science Project, Department of Computer Science, Louisiana State University, Baton Rouge, LA, October 1986."
JRS: integrated design automation system (IDAS)The PCs are used primarily as work stations in the System, with all of the interactive synthesis processes and many of the system data entry processes resident in them, in Smalltalk and Prolog. 17 the PC software is implemented
"An overall structure of intelligent computer program in ChinaWe will put our efforts on the following aspects: (1) To provide powerful language environment for different AI applications, such as those for Prolog, Lisp, OPS5 and Smalltalk 80, etc.. (2) To study some kind of ""base"" language which would be able to support most of existing AI programming languages, and also could be implemented in a certain parallel architecture efficiently. (3) To try to create some kind of AI programming languages to support multiple programming paradigms and AI applications."
Minutes: (sigda meetings)There will be a June workshop on CAD engines He has been asked to organize a working conference on Prolog and LISP-based systems in 1989 for IFIP. These would be good opportunities for joint sponsorship.
Local cohesive knowledge for a dialogue-machine translation systemIt transfers Japanese sentences into English ones. It was implemented in Quintus Prolog on a SUN-4 system and its program size was 3.4MB.
PIAF: a knowledge-based/algorithm top-down floorplanning systemThe total CPU time for the complete floorplanning process on this example was 54 minutes for a Quintus PROLOG based implementation running on a DECstation 2000.
"Introducing knowledge-based projects in a systems development courseModule III: Implementation Tools One of the following approaches is considered: i) Declarative Programming: Using this approach students build a knowledge-based system from scratch. Lisp or Prolog is widely used for such purposes. This implies that students design the inference engine and representation scheme ~~,,u,les,"",~,,~t,~e from scratch."
Introducing parallel processing at the undergraduate levelWe believe that the concepts and techniques shown are within the grasp of advanced undergraduates and should be introduced as early as the junior level. VI. Conclusions VII. [ll Bratko, Ivan, Prolog Programming & Artificial Intelligence, Addison Wesley Publishing Company, 1986. ask for a partial solution while (there may still be work or I am a slave and have not yet been told to exit) if I have a partial solution row-number = length of partial solution obtained + 1 solution-found = false for i = 1 to N while solution not found if i is in list of remaining column numbers compute upward diagonal, ud compute downward diagonal, dd if ud is in list of remaining upward diagonals and dd is in list of remaining downward diagonals insert i in the N-tuple at position row-number if row-number = N add N-tuple to solution list solution-found = true else create a new struct to hold a partial solution copy the partial solution into the new struct delete i, ud and dd from the appropriate lists of the new structure add the new structure to the problem pool ask for a partial solution Number of Processes Boardsize 1 2 4 6 6 10 12 14 12 1 1.98 3.90 5.77 7.56 9.25 10.80 12.21 Relative Speed-ups @ 1988 ACM 0-89791-256-X/88/0002/0063 $1.50 63 64 65 66 67
"Review of ""Planning and understanding: a computational approach to human reasoning"" by Robert Wilensky. Addison-Wesley 1983. And review of ""In-depth understanding: a computer model of integrated processing for narrative comprehension"" by Michael George Dyer. The MIT Press 1983.Making reference to earlier implementations (especially PAM) and their weaknesses, he introduces the special-purpose programming language PEARL - a frame-like formalism also resembling Prolog, and implemented in Lisp. The representations, which are likened to an extended version of Conceptual Dependency (but which do not actually look quite so abstract or deep), are illustrated, and in Chapter 12 a particular implementation, FAUSTUS, is discussed."
A relational model for unstructured documentsIf the extended specification languageis exocutable, the specification methodis also a prototyping method or, if the execution is efficient, also an implementation method.Evenas an inefficient implementation such an executable specification languagehas significance as a practical tool in studying user requirements for document handling and Information retrieval from documents.Our first experiment in the implementation of the document model as an extension of an executable specification language Is a language called EDLA (Experimental Document database Language). EDLA is the Prolog implementation of the slmple document model presented in this paper. On the (,u,.:. hand, we can study the extension of some existing speclfidua languagessuch that document handling properties are addedto the languages.Our first experiments in this direction contain a Prolog implementation of the simple document model presented in this paper.
How to write parallel programs: a guide to the perplexedThis form of communication was first proposed by Kahn [1974] and forms the basis for communication in most concurrent logic languages (e.g., Concurrent Prolog [Shapiro 19871 and Parlog [Ringwood 19881) and in functional language extended with constructs for explicit communication (e.g., [Henderson 19821). Category (2) includes records, objects instantiated from class definitions, sets and multisets with distinguishable elements, associative memories, Prolog-style assertion collections, and other related objects. ACM 28, 1 (1985), 22-33. SHAPIRO, E., ED. 1987. Concurrent Prolog Collected Papers. Vols. 1 and 2. MIT Press, New York.
"A PARLOG implementation of Government-Binding TheoryKashket, M.B.I (1987), A Government-Binding Based Parser for Warl, Technical Report 993, MIT Artificial Intelligence Laboratory, Cambridge, MA. Kuhns, R.J., (1986), ""A PROLOG Implementation of Government-Binding Theory,"" proceedings of COLING '86."
The central role of mathematical logic in computer scienceautomata, formal languages, computability, complexity, recursive function theory, * artificial intelligence deduction systems, expert systems, cognitive science, formalisms, automated proofs, natural language processing, * programming languages / data structures logic programming (PROLOG is but one such language), resolution, functional languages, semantics (Hoare, denotational, procedural, realizability), language design, computational completeness, data abstraction/operations, type theory, object-oriented approaches, parallel processing (optimality and equivalence to sequential algorithms), * database systems discussed above: * software engineering program verification, including testing (path manipulation) and correctness, `formal specifications and program design, executable specifications, * hardware circuit design/optimization, hardware design languages, processor verification, correctness of OS kernel, language implementation on given processors, * philosophical foundation for CS profound correspondences between reasoning and computation, formal systems, constructivity as a basis for CS influencing language design, semantics, etc.
Dynamic display of computing processesComputer, Vol . 18, no . 2 , 67-76, 1985 . [28] A . Pashtan . A Prolog implementatio n of an instruction-level processo r simulator .
Comments, assertions and pragmasAt the other extreme, it may be hard to find anything worth adding to a well-written rule in Prolog: the code is enough. 79 SIGPLAN Notices, Vol. 24, No. 3 The usual convention for comments, in which comments are equivalent to white space, dates from a time when there were few software tools and programming languages required many comments because they were low-leveL The current situation is different.
"Binding performance at language design timeKozen and Hare1 jll] later presented a first order inductive definition language equivalent to FP, more recently Papadimitriou [25, proved that PROLOG definitions without negation is also equivalent to FP. Papadimitriau, C. ""A Note On The Exprestivc Power of PROLOG"". ihditin OJ EATCS +?6 (1985). 21-23. 26. Reif,J.H. and Lewis,H.R.."
From decision support to expert systemsThe learning strategy is based on the Perceptron algorithm 11 Conclusion The Kent Course Adviser is implemented in Prolog and runs on an ICL2900 main frame computer. The database and adviser modules are currently restricted to provide help only with one of the three faculties of the University.
And still more on retraining mathematics faculty to teach undergraduate computer scienceWe built an operatin g system in the two-semester Operatin g Systems course, and Artificia l Intelligence involved large projects i n both Lisp and Prolog . We may personall y lack the character of those described b y Ballew, who trained themselves, but I doubt that any of us would have finishe d all these projects and learned all thes e languages thoroughly enough to teach them on our own .
A quantifier scoping algorithm without a Free Variable ConstraintFurthermore, the algorithm is somewhat simpler than H&S's algorithm and makes no appeal to logical syntax. There is a Prolog implementation of the algorithm. 2 Quantification in Logic Semantic theories generally recurse over the syntax of the object language.
"A hardware mechanism for priority queueNagannuma et at.,""High-Speed CAM-Base Architecture for a Prolog Machine (ASCA)"", IEEE Transactions on Computers, Vol. 37, No. 11, Nov. 1988, pp. 1375-1383 [7] Ah 0 et al., The Design and Analysis of Computer Algorithms, 1974. 169"
A computer graphics courseThe current honours curriculum offers th e following topics, from which a total o f 60% must be selected : a) Software Engineering and Real Tim e Programming (10% or. 15% ) b) The UNIX Operating System (5% ) c) Artificial Intelligence and Functiona l Programming (10% ) d) PROLOG and its Implementations (5% ) e) Expert Systems (10% ) f) Tutoring Systems (5% ) g) Systems Analysis and Networking (10% ) h) Microprogramming and Computer Desig n (10% ) i) Computer Interfacing (10% ) j) Computer Music Tools (10% ) k) Code Generation Theory (10% ) A major project (30%) and a practical wor k portfolio (10%) make up the remainder o f the assessment .
"A DEVS-scheme simulation of an electronic meeting system., ""Information Technology to Support Electronic Meetings,"" MIS Quarterly, vol. 12, no. 4, December 1988, pp. 591-624. [7] Elmaghraby, Adel S., ""A Prolog Simulation for a Delphi-Based Problem Solver,"" Simulation Digest, Winter 1988/1989, pp. 36-43. [8] Gallupe, Brent, DeSanctis, Gerardine, Dickson, Gary W., ""The Impact of Computer-Based Support on the Process and Outcomes of Group Decision Making,"" International Conference on Information Systems, December 1986. [9] Green, Thad B., ""An Empirical Analysis of Nominal and Interaction Groups,"" Academy of Management Journal, vol. 18, no. 1, 1975. [10] Grossman, Stephen R., ""Brainstorming Updated,"" Training and Development JourTal, February 1984. [11] .]arvenpaa, Sirkka L., Rao, V."
The textplanning component PIT of the LILOG systemAn exmnple of a plau, inleresting_eature , is given below (the planner is implemented in PROLOG so the atoms with capital letters are variables): plan(intoxosting.featuxe(0bject), nucleus: [say(0bjeot)], satellite: [say(Featuxo)], nuoleuszequizement: axtd([subsozt(Objoct,object)]), satellitezequizement: [], nucleus and..satelliterequirement: and( [ attxibute(0bjeet, zemarkability: Fontal:e), not(bel(heazer, attribute(Object, remarkability: Feature)))]), nucleus gzowthpoirtt: [interesting. feature(Feature)i, satellite.growth_point: []) Among the 12 plans used by PIT are domain dependent ones as. well as domain independent ones.
"""The first million is hardest to get"": building a large tagged corpus as automatically as possibleFor the disambiguation, we have started on a first prototype of a 'learning' program, i.e. the program can be trained to make a best possible choice in different situations, where the situations are sequences of ambiguous tags (Karlgren 1989). It is a Prolog implementation of principles presented in Kiillgren (1984b)."
From WashingtonAbout 20 percent listed varieties including Lisp, Prolog, Ada. Among operating systems, UNIX and Cray's COS or CTSS were each listed by about half of all respondents.
Sometimes an FEXPR is better than a macroContents: Knowledge representation, First order logic, PROLOG, Semantic nets, Relational data model, Transition networks, Petri nets, Discrimination nets, Covers, Frames and Scripts, Fuzzy Knowledge, Search methods, language processing, Speech processing, and processing.
A method for specializing logic programsHence, program specialization in order to restrict the relation efficient specialized program. becomes particularly interesting for logic programs to a specific subrelation, thus producing a more In this paper we consider logic programs that consist purely of sets of definite clauses with complete resolution. not satisfy this requirement. The existing implementations of PROLOG do Because of efficiency reasons, resolution is depthfirst, and unification does not generally consider occur-checks. Therefore, we share the opinion of most researchers in the field of logic programming, that the lack of declarative semantics in PROLOG is a problem that has to be solved in order to take advantage of the logic programming style. We are also studying how much of the method can be adapted to pure PROLOG. A new definition of equivalence among programs, which is based on the depth-first search strategy, has been given.
Contribution of a category hierarchy to the robustness of syntactic parsing.A prototype of such a module has been implemented in Prolog , it detects agreement mistakes and can propose corrections by means of a morphological generator.
Recognizing advice, warnings, promises and threatsIn the initial set of examples, the principal speech act is determined by examining the structure of the argument and the syntactic form of premise's consequent. Program output is in boldface. C-Prolog version 1.4 I% [pasa]. pasa consulted 33004 bytes 7.449997 sec.
Lazy evaluation and the logic variable`There is a close connection between read operations on monotonic records and unification of read-only variables in Concurrrnt Prolog ,Zlj. The main difference is that our logic variables arv `rradonly' by default, and no special syntax is required to get read-only behavior. 4.2 Demand propagation To understand the relevance of monotonic records to demand propagation, it is useful to consider the following analogy. ACM TOPLAS, April 1985. E. Shapiro. A subset of concurrent Prolog and its interpreter. Technical Report TR-003, Institute for new generation computer technology, 1983.
"Temporal deductive databases and infinite objectsxpomts we mtroduce the notion of an mfimte obJect and Its speuahzatlon to the temporal domam ObJects provide an altematlve Herbrand umverse Many least fixpomts, mfhute m the standard Herbrand umverse, become &ute m thus new muverse In query answermg, obJects may be returned mstead of n&ute sets of standard,""flat"" answers We enumerate several propertles that a set of temporal rules should satisfy m order to deal with ob-Jects m an ""acceptable"" way We define a class of separable rules which satisfy these properties Speufically, least fixpomts of sets of separable rules are iimte Infimte obJects are a subJect of ongomg research and much of the contents of tlus se&on IS rather tentative Fmally, m Section 4 we relate our work to other computatlonal approaches to tune modehng The first group of &ems on our agenda IS clear those have been ""traltlonal"" database questions, at least smce the Prolog revolution The second group IS related to the recently debated issue of safety of quenes m the presence of function symbols Rules with function symbols have miimte Herbrand muverses and may generate mfimte answers to queries A query IS defined to be safe If for all databases, the answer to the query 1s flmte, and unsafe otherwise The approach put forward e g m [BBS871 can be summar Ized as ""detect and disallow"" (unsafe queries) Here we argue with this pomt of view In our opuuon, there are two ckstmct reasons for a query to be unsafe The first IS semont:r a query hke { (x,y) 7 R(x,y) } IS meamngless, because, aslde from practical reasons, It 1s not even clear what the type of the answer should be The second IS repreaentottonal suppose we state a rule that professors hold office hours every week and the fact that Professor BBKmg IS startmg this Thtlmday officeJiIours(Thia Thureday,BBKiag) officeHour6(t~) ~Offidour6(t+7~). We wrll abm look upon a temporal database m a set of trplcr A tmyond gwry 16 a negative Horn clause, consistmg only of negatrve temporal hteral6 A temporal form& IS a set of temporal rules, a temporal database, a temporal query or a conpnct~on of those Temporal terms wrll appurt m bold font Predxate names d rtart mth a capital letter, constants wrth a letter from the begmnmg of the alphabet (4b A,B, ) and mrrables wrth a snmll letter from the end of the'alphabet (s,y ) Thrs conventron goe6 agamst the gram of current Prolog pmctrce, but 16 more ae6thetmally pleacung Calhgrapluc letter6 wrll denote meta-obJect6, for example ""lome databslle D"" Moreover, we wdl wnte k mstead of u(O)) ), and t+k instead of h tame* I( (6(t)) ) A number 0 corre6ponds to a temporal term i ET natural way We wrll say that a temporal term t2 is greeterthan a temporal term tl (t2>tl) dtt=tl+k for 6ome k We wrll Ilse z to denote a vector of non-temporal values We reqmre that there IS at most one temporal variable per rule Thucl all temporal terms wrll be of the form t+k or k for ~ome k Addmg 1 to the biggest such k m a rule, we obtam the Lameter of thrs rule gubstrtutmg a ground temporal term v for the temporal vanable m a formula 9 gves a tempond~gnmnded wutance @{t/v) of ths form& TMs m6tance does not have to be ground non-temporal mrrables may be &ll unbound If the temporal term m the head of the ruIe IS greater than all the temporal term6 m the body, the rule 16foruw$ otherwrse It TVbeckward The fin&e set of all temporal term6 m database tuphw wrll be called the temporal domatn of the database 2.2 Interpretations and models We nrtnct our attention here to %r6rand mterpretatrons of a temporal formula, I e mterpretatrons whmh are subset6 of its Herbrand base, and to Herbrand modeZs Both the Herbrand umverse and the Herbrand base of a temporal formula are mfimte By the results of [vEK76], every defimte temporal formula has a least (Herbrand) model Of speual mtere6t wdl be the followmg fimte subsets of a model M of a temporal formula * slrcecr M[t] conslstmg of tuples where the temporal component assumes only the value t segmentsM[tl tl] where tl"
Towards a semantic theory for equational programming languagesIn general, the bindings generated for the 'result' variable in a query are the successive approximations to the final value. The incompleteness of Prolog requires clever ordering of the subgoals, and even then execution may be excruciatingly slow. The translation may work better with extended versions such as MU-Prolog (Naish, 1085) which allow more refined control. 9.
"A mechanism for ellipsis resolution in dialogued systems[Hirschman,Puder,86] Hirschman, L., Puder, P.: ""Restriction Grammar: A Prolog implementation"". En ""Logic Programming and its applications""."
Arrays of objects in rationalized APLAll the language extensions proposed herein have been implemented in an experimental rationalized APL interpreter written in (Turbo-) Prolog for the IBM PC. The interpreter, which proved to be a valuable field for experimentation and testing of new language features, has also been used to verify those extensions.
Experiments with an MT-directed lexical knowledge bankAn experimental environment, the Semantic Work Bench (implemented in Quintus Prolog) development, in which the knowledge bank is under and the various decision mechanisms SWESIL uses can both be tested and developed further.
An overview course in academic computer science: a new approach for teaching nonmajorsIn fact, students are given examples of programs from eight different languages with the point being that many other languages such as FORTRAN, PL/l, etc. are similar in structure to the Pascal that they have already learned and that some other languages such as LISP and Prolog are rather different. The final exercise of the hardware-software study is to trace the execution of a sample Pascal assignment statement through all of the stages from compilation, to execution on the architecture, through the operation of the computational circuits to the migration of electrical carriers in the semiconductor fabrication.
Integrating speech and natural-language processingWe show both median and mean values for these measures. The parsing times are for a parser running in Prolog on an 8-megabyte Sun 3/60 workstation. At the 400K pruning threshold, the median parsing time per sentence was just over one minute, and at 500K, just over two minutes.
Human-computer interface development: concepts and systems for its managementBecause Prolog translators are available, this representation is also executable and allows for rapid specification, implementation, and modification of an interface. An application example involving representation of a carrier-based air traffic control system took about 100 Prolog rules versus more than 5000 lines of Pascal code. Although the idea of using Prolog as both a representation and an implementation tool is interesting, the complexity of learning to create Prolog programs needs to be investigated, first-order logic is certainly not common knowledge.
Disjunction without tearsA wide variety of notations have been used in this context-- PROLOG terms, PATR-II specifications, FUG functional descriptors, GPSG category specifications, and so on (Pereira and Warren 1980, Shieber 1986, Kay 1985, Gazdar et al. 1985).
Anticipation-free diagnosis of structural faultsColing 88, Budapest: 608-613. Yazdani, M. (1988) Language Tutoring with PROLOG, Papers of the International Workshop on Intelligent Tutoring Systems for Second Language Learning, Trieste: 150-155. 3
Common fallacies about expert systemsMany of these courses, such as those by the Continuing Engineering Education Program at George Washington University and those by Integrated Computer Systems, allow the student to obtain hands-on experience in working through various expert system shells, LISP, and Prolog . For a more complete understanding of expert systems, the layperson might want to take a semester course at a major university like Stanford, M.I.T ., Carnegie-Mellon, Rutgers, University of Maryland, or George Washington University.
A semantic matcher for computer algebraThe feature of interchangeability of program and data is already familiar to users of LISP and PROLOG. In line with the expert systems paradigm, this matcher is expected to be most useful in mathematical domains with numerous algorithms, heuristics, or rules-of-thumb, which are not expressed easily in the language of an existing computer algebra system.
"Review of ""The from of information in science: analysis of an immunology sublanguage"" by Zellig Harris, Michael Gottfried, Thomas Ryckman, Paul Mattick, Anne Daladier, T. N. Harris, and S. Harris. Kluwer Academic Publishers 1989.Formulas can be implemented in a fairly straightforward fashion using Prolog terms, relational database tables, a semantic net, an object-oriented system, or a frame-based representation."
A unified approach for multilevel database security based on inference enginesOur plan is to use INGRES as the DBMS which will run on a network consisting of eight SUN workstations and a VAX 11/750 running UNIX BSD 4.3 all connected via Ethernet. The rule base and inference engine will be PROLOG-based. Utilization of the system will be application-based and will be an option for those users who wish to benefit from its ability to handle security in a multilevel database environment.
"The linguistic connectionThese are logical operations, in a strong sense of the word, as evidenced by the fact that unification is also a basic operation of logic programming in general, and Prolog in particular. Logic programming, and computation with constraint-based grammars rests heavily on implementing the notion of a logical variable, as opposed what programmers have usually called ""variables"", and which are really names of storage locations."
Setting the direction for computer user groups: the City University of New York experiencePlease check any CUNY/UCC Users' Group(s) you might be interested in joining: Artificial Intelligence (e.g. Expert Systems, LISP, Prolog) Social Science Applications/Statistical Packages (e.g.
The scheme environment: continuationsThe continuation model is of course important quite apart from Scheme. For example, the semantics of Prolog can be understood quite well by imagining that each expression has not one, but two implicit continuations: a failure continuation and a success continuation [3].
Esprit project P1085 - reconfigurable transputer projectAST has been used to produce a Prologcanpiler andamulti-transputer version of Prolog is r-owt&ngtested anddocumented. No matter how good the operating system, program developnenton a parallel machine is nore difficult than on a serial machine.
Retirement savings plan advisor: a knowledge-based expert system for tax deferred savings investingImplementation Shells The system was originally developed on a PROLOG-based shell which runs on a PC. The knowledge base was subsequently translated to IBM's Expert System Development Environment (ESDE).
An approach to tableau inferencing with “hardwired” heuristicsTHE FORMAL METHOD As with convcnticnal inference engines (e.g., Prolog), semantic tableaus rely on a reductio ad absurdum or indirect proof strategy.
"An object/task modleing approach based on domain knowledge and control knowledge representationEZani 843 C.Zaniolo, ""ObJect-Oriented Programming in Prolog"", Proc. Int. Logic Programming Symposium, IEEE 1984."
Office automation in ChinaArtificial Intelligence: The session began with a discussion of expert systems in modeling environments, followed by a group discussion of various expert systems projects developed by the delegates and Chinese participants. Discussion continued with a comparison of PROLOG vs LISP implementations, and Dr. Jacob's description of current work at the Naval Research Laboratory.
Knowledge based + database = intelligent systemsParadoxically this definition has attracted criticism because of its emphasis on rule-based programming in logic as exemplified by one of the front-runners in its development, namely PROLOG. Professors M. Lehman (Computer Science, Imperial College) and D.
Accelerating the development of effective expertise through knowledge-based feedbackSimulated case situations are 1. This program has been developed using Turbo Prolog for IBM-compatible microcomputers. used to provide extensive experience with specific problems.
Porting PUNDIT to the resource management domainThe sentences (training and test) were run on PUNDIT, under Quintus Prolog 2.2 on a Sun 3/60 with 8 MB of memory. Because PUNDIT normally produces many parses, especially when run without selectlonal eonstraints, we allowed the system to run to a maximum of 15 parses per sentence.
Dictionary organization for machine translation: the experience and implications of the UMIST Japanese projectThe prototype system runs on the ICL PERQ. although much of the development work has been done on a VAX 11/750, a MicroVAX II, and a variety of Sun equipment. It is implemented in Prolog,ln the interests of rapid prototyping, but intended for later optimization.
Logic and databases: a critiqueIssue-Driven Research Looking back at this critique and at the [GMN] paper as a whole, it seems to me that languages, and language-driven scientific research, are the main matter in hand, as is the case, one might add, with that more general area of computer science of which logic and databases is an outgrowth, namely, logic programming and the Prolog family of programming languages. Although, as we said at the start, the paper treats many central database topics in a uniform and readable way, it would appear that the importance of some of the most basic issues, such as indefiniteness and impliciteness of data, the relative expressive power of data definition and query languages, and their computational complexity, is still lost on the reader, as a consequence of the language-dominated approach taken therein.
A new parallel algorithm for generalized LR parsingGttC statement (Fig.3) functions as a cut symbol of Prolog. When goal 'a' is executed, a process of statement (1) is activated and the body becomes a new goal in which 'b(Stream)' and 'c(Stream)' are executed simultaneously.
Issues in the development of expert systemsThe design only t h e system may c o n c l u d e t h a t the expert system is a functional requires that the program use rules and f a c t s to make c o n c l u s i o n s . example, PROLOG uses l i s t s o f T h i s can be done i n s e v e r a l ways.
An implementable semantics for comparative constructionsMcCord, M. C. 1987. Natural Language Processing in Prolog. In: Walker, A. (ed.) Knowledge Systems and Prolog. Proc. 26th ACL, 75-86. Pereira, F. N. C. and Shieber, S. 1985. Prolog and Natural Language Understanding. CSLI lecture notes.
Functor-driven natural language generation with categorial-unification grammarsThe values for ptaon are structured as difference lists. The use of this data structure, inherited from PROLOG, allows us to concatenate functor categories with their arguments either to the left or to the right.
Preliminary report on a practical type inference system for common LispThere have also been a number of suggestions for incorporating this technique into compilers for various dialects of Lisp, APL, Smalltalk, and Prolog. However, to our knowledge, no compiler in widespread use for any of these languages currently performs any nontrivial type inference.
Computing as a disciplineExamples: procedural (COBOL, FORTRAN, ALGOL, Pascal, Ada, C), functional (LISP), dataflow (SISAL, VAL), objectoriented (Smalltalk, CLU), logic (Prolog), strings (SNOBOL), and concurrency (CSP,Occam, Concurrent Pascal, Modula 2). Techniques for expert systems in narrow domains (e.g., Mycin, Xcon) and expert system shells that can be programmed for new domains. 3. Implementations of logic programming (e.g, PROLOG). 4. Natural language understanding systems (e.g.
Managing expert systems projects: factors critical for successful implementationExplanation Capability Development Approach $,,,lopment Evaluation Methods Skills: Programming Other Risk 1, DIFFERENCES BETWEEN DSS AND ES DSS Perform task, support of decision maker Complex, broad Human queries the machine Numerical Factual knowledge No Limited Prototy ing method0 ogles rr User, System Analyst, Programmer Some clear, some fuzzy 4th generation languages Interpersonal Low to high ESS Perform task, simulate ' expert, explain relearn Complex, narrow ,,,z$e queries the Symbolic Procedural and factual knowledge Yes, limited Yes Prototypjng, knowledge engineering Expert and knowledge engineer Fuzzy LISP, PROLOG, ES tools Knowledge engineering, modelling, high interpersonal High 2.1. Table 2: ES Development Tools General Purpose/ General Purpose Shell/ Low Level Programming Representation Skeletal Characteristic Languages Examples LISP Primary Focus System: knowledge base and inference engine Flexibility high: define own representation and inference Effort Required to Use System Skill Level Required to Use System mechanism high high Difficulty in Learning high low: inference mechanism and representation provided low low Language Systems OPS-5 PROLOG ROSIE Sl Ml PERSONAL CONSULTANT User need in external environment low A series of other tools are evolving, very quickly, in particular hybrid systems and application shells.
"Des heuristiques pour la recherche du theme d'un discours et de l'antecedent d'un pronom""Resolution des anaphores et Programrrmtion en Logique"" Papier Pr 61iminaire [Sedogbo 87] Sedogbo C. ""SYLOG : A DRT System in Prolog"" Second International Workshop on Natural Language and Logic Programming Simon Fraser University, Vancouver, B.C Canada (1987) [Sidner 83] Sidner C."
EditorialExamples are LISP, which specializes in the manipulation of strings of symbols that denote expressions and values, VAL and LUCID, which specialize in dataflow computations where operations fire as soon as all their operands are available, REDUCE and MACSYMA, which specialize in symbolic algebraic expressions-differentiation, integration, and reduction to minimal terms, SQL, which specializes in queries of relational databases, APL, which specializes in applying functions to vectors of data, and PROLOG, which specializes in evaluating expressions in a deductive logical system.
Answers and questions: processing messages and queriesThe first three components are currently running on Sun workstations under Quintus Prolog, and VOYAGER, which is written in Lisp, runs on a Symbolics machine.
Retraining high school teachers to teach computer science—observations on the first courseThe team project which we assigned involved developing a Prolog-like database of facts for a coffee shop. The facts were stored in sequential files.
Getting things out of order: an LFG-proposal for the treatment of German word orderDRRE (this vol.), A Lexical Functional Grammar System in Prolog. HAIDER, Hubert (1985), Verb second in German.
What makes users happy?For example, major computer languages tend to provide added productivity in different areas: Fortran for formula translation, Cobol for business applications, Basic for beginners, and Lisp and Prolog for artificial intelligence. Combined with an efficient/ effective database for promoting security and reducing redundancy or duplication, these languages can become even more productive for these specialized areas.
"The design of POSTGRESSupport for Procedural Data The main performance tactic which we will utilize IS precomputmg and caching the result of procedural data This precomputatlon has two steps 1) compllmg an access plan for POSTQUEL commands 2) executing the access plan to produce the answer When a collection of POSTQUEL commands 1s executed both of the above steps must be performed Current systems drop the answer on the floor after obtaining It, and have special code to invalidate and recompute access plans (eg [ASTR761) On the other hand, we expect to cache both the plan and the answer For small answers, we expect to place the cached value m the field Itself For larger answers, we expect to put the answer m a relation created for the purpose and then put the name of the relation In the field itself where it will serve the role of a pointer Moreover, we expect to have a demon which ~11 run m background mode and compile plans utlllzlng otherwise Idle time or idle processors Whenever a value of type procedure 1s inserted Into the database, the runtime system will also Insert the identity of the user submlttmg the command Compllatlon entalls checking the protection status of the command, and this ~111be done on behalf of the submitting user Whenever, a procedural field 1s executed, the run-time system will ensure that the user IS authorized to do so In the case of ""fastpath,"" the run-time system will require that the executmg user and defining user are the same, so no run-time access to the system catalogs 1s required This same demon will also precompute answers In the most fortunate of cases, access to procedural data IS mstantaneous because the value of the procedure 1s cached In most cases, a previous access plan should be vahd sparing the overhead of this step Both the compiled plan and the answer must be invalidated if necessary The plan must be Invalidated lf the schema changes mapproprlately, while the answer must be invalidated if data that it accesses has been changed We now show that this mvahdatlon can be efficiently supported by an extended form of locks In a recent paper [STON85cl we have analyzed other alternate Implementatlons which can support needed capablllties, and the one we ml1 now present was found to be attractive in many situations We propose to support a new kmd of lock, called an I lock The compatlblhty matrix for I locks 1s shown in figure 4 When a command IS compiled or the answer precomputed, POSTGRES will set I locks on all database obJects accessed during compllatlon or execution These I locks must be persistent (1e survive crashes), of fine granularity (1e on tuples or even fields), escalatable to coarser granularity, and correctly detect""phantoms"" [ESWA751 In [STON85al, lt 1s suggested that the best way to satisfy these goals 1s to place I locks in data records themselves R W I R ok no ok W no no * I ok no ok Figure 4 Compatlblhty modes for I locks The * In the table m figure 4 mdlcates that a write lock placed on an obJect containing one or more I locks ~111simply cause the precomputed obJects holding the I Iocks to be mvahdated Consequently, they are called ""mvalldate-me"" locks A user can Issue a command retrieve (relation I) where quallficatlon which w111return the identifiers of commands having I locks on tuples m questlon In this way a user can see the consequences of a proposed update Fields of type POSTQUEL can be compiled and POSTQUEL fields with no update statements can be precomputed Fields of type procedure can be compiled and procedures that do not do mputloutput and do not update the database can be precomputed 5 2.3 Alerters, Triggers, and Inference This sectlon describes the tactic we will use to implement alerters, triggers, and inference Alerters and triggers are specified by including the keyword ""always"" on the command The proposed Implementatlon of ""always"" commands IS to run the command until it ceases to have an effect Then, it should be run once more and another special kind of lock set on all 0bJect.swhich the commands will read or write These T locks have the compatlblhty matrix shown m figure 5 Whenever a transaction writes a data object on which a T-lock has been set, the lock manager simply wakes-up the corresponding ""always"" command Dormant ""always"" commands are stored m a system relation m a field of type POSTQUEL As with 1 locks, T locks must be persistent, of fine granularity and escalatable Moreover, the Identity of commands holding T locks can be obtained through the special field, T added to all relations R W I T ok no ok ok i no no * # I ok no ok ok T ok no ok ok Figure 5 Compatlblhty modes for T locks Recall that mferencmg will be support by virtual fields (1e , ""demand"" commands) ""Demand"" commands will be Implemented slmllar to the way ""always"" commands are implemented Each""demand"" command would be run until the collection of objects which it proposes to wr1t.e are isolated Then a D lock IS set on each such object and the command placed m a POSTQUEL field m the system catalogs The compatlblhty matrix for D locks IS shown m figure 6 The ""82' mdlcates that when a command attempts to read an obJect on which a D lock has been set, the ""demand"" command must be substituted into the command bemg executed usmg an algorithm slmllar to query modlficatlon to produce a new command to execute This new command represents a subgoal which the POSTGRES system attempts to satisfy If another D lock 1s encountered, a new subgoal will result, and the process ~11 only terminate when a subgoal runs to completion and generates an answer R W I T D R ok no ok ok & W no no * # no I ok no ok ok ok T ok no ok ok ok D ok no * # ok Figure 6 Compatlblhty modes for D locks Moreover, this answer can be cached m the field and mvahdated when necessary, If the mtermedlate goal commands set I locks as they run This process IS a database version of PROLOG style unification [CLOCSl], and supports a backward chalnmg control flow The algorithm details appear m [STON85b] along with a proposal for a priority scheme 5 3. Version Management Versions will be Implemented by allocating a differential file [SEVR76] for each separate version The differential file will contain the tuples added to or subtracted from the base relation Secondary indexes will be built on versions to correspond to those on the base relation from which the version 1sconstructed The algorithm to process POSTQUEL commands on versions 1s to begin with the differential relation correspondmg to the version itself For any tuple which satisfies the quallficatlon, the V-IID of the inspected tuple must be remembered on a list of ""seen IID's"" [WOOD831 If a tuple with an IID on the ""seen-id"" hst 1s encountered, then It 1s discarded As long as tuples can be inspected In reverse chronological order, one will always notice the latest version of a tuple first, and then know to discard earher tuples If the version IS built on top of another version, then continue processmg In the differential file of the next version Ultimately, a base relation will be reached and the process will stop If a tuple m a version 1s modified m the current version, then It IS treated as a normal update If an update to the current version modifies a tuple m a previous version or the base relation, then the IID of the replaced tuple will be placed m the V-IID field and an appropriate tuple inserted Into the dlfferentlal file for the version Deletes are handled m a slmllar fashion To merge a version into a parent verston then one must perform the following steps for each record m the new version valid at time T 1) If It IS an Insert, then insert record into older version 2) If it 1s a delete, then delete the record m the older version 3) If It 1s a replace, then do an insert and a delete There 1s a conflict If one attempts to delete an already deleted record Such cases must be handled external to the algorithm The tactics In [GARC84] may be helpful in reconcilmg these conflicts An older version can be rolled forward into a newer version by performing the above operahons and then renaming the older version 6 SUMMARY POSTGRES proposes to support complex obJects by supportmg an extendible type system for defining new columns for relations, new operators on these columns, and new access methods This faclhty 1s appropriate for fairly""simple"" complex objects More complex ObJects, especially those with shared subobJects or multiple levels of nesting, should use POSTGRES procedures as their defimtlon mechamsm Procedures will be optlmlzed by caching complled plans and even answers for retrieval commands Triggers and rules are supported as commands with ""always"" and ""demand"" modifiers They are efficiently supported by extensions to the locking system Both forward chaining and backward chaining control structures are provided wlthm the data manager using these mechamsms Our rules system should prove attractive when there are multiple rules which might apply m any given situation Crash recovery IS slmphfied by not overwriting data and then vacuuming tuples to an archive store The new storage system 1s greatly slmphfied from current technology and supports time-oriented access and versions with little difficulty The major cost of the storage system IS the requirement to push dirty pages of data to stable storage at commit time An optical disk IS used effectively as an archival medium, and POSTGRES has a collection of demons running m the background These can effectively utilize otherwise idle processors Custom hardware could effectively provide stable maln memory, support for the LOG relation, and support for run-time checkmg of tuple vahdlty Lastly, these goals are accomplished with no changes to the relational model at all At the current time coding of POSTGRES 1sJust beglnnlng We hope to have a prototype running m about a year ACKNOWLEDGEMENTS Research sponsored by the Air Force Office of Sclenhfic Research Grant 83-0254, Defense Advanced Research Projects Agency under contract N39-82-0235, and National Science Foundation Grant DMC-85-04633 [ADIBBOI Adlba, ME and Lindsay, B G , ""Database Snapshots,"" IBM San Jose Res Tech Rep RJ-2772 , March 1980 [AFSA851 Afasarmanesh, H , etal, ""An Extensible ObJect-Oriented Approach to Database for VLSI/CAD ,"" Proc 1985 Very Large [ALLM761 [ASTR761 [ATKI84] [BUNE791 [CLOC811 [CODD701 [COPE841 [DERR851 [DEW1851 [ESWA751 [GARC841 [HELD751 [GUTM841 Data Base Conference, Stockholm, Sweden, August 1985 Allman, E , et al, ""Embedding a Relational Data Sublanguage m a General Purpose Programming Language,"" Proc 1976 ACMSIGPLAN-SIGMOD Conference on Data, Salt Lake City, Utah, March 1976 Astrhan, M et al, ""System R A Relational Approach to Data,"" ACM-TODS, June 1976 Atkmson, M P et al, ""Progress with Persistent Programmmg,"" m Database, Role and Structure (ed P Stocker), Cambridge Umverlsty of Press, 1984 Bunemann, P and Clemons, E , ""Efficiently Monitoring Relational Data Bases,"" ACM-TODS, Sept 1979 Clocksm, W and Melhsh, C , ""Prog-ramming m Prolog,"" Sprmger-Verlag, Berlin, Germany, 1981 Codd, E, ""A Relational Model of Data for Large Shared Data Bases,"" CACM, June 1970 Copeland, G and D Maler, ""Makmg Smalltalk a Database System,"" Proc 1984 ACM-SIGMOD Conference on Management of Data, Boston, Mass June 1984 Derrltt, N , Personal Commumcatlon, HP Laboratories, October 1985 Dewitt, D J and Carey, M J, ""Extensible Database Systems,"" Proc 1st InternatIonal Workshop on Expert Data Bases, Klowah, SC , Ott 1984 Eswaren, K , ""A General Purpose Trigger Subsystem and Its Inclusion m a Relational Data Base System,"" IBM Research, San Jose, Ca, RJ 1833, July 1976 Garcia-Molma, H , et al, ""Data-Patch Integratmg Inconsistent copies of a Database after a Partition,"" Tech Rep TR# 304, Dept Elec Eng and Comp Scl , Prmceton Umv , 1984 Held, G et al, ""INGRES A Relatlonal Data Base System,"" Proc 1975 Natlonal Computer Conference, Anaheim, Ca , June 1975 Gutman, A,""R-trees A Dynamic Index Structure for Spatial Searching,"" Proc 1984 ACM-SIGMOD Conference on Management of Data, Boston, Mass June 1984 [JARK85] [KATZ851 [KUNG84] L LORI831 LUM851 [ROB1811 [ROWE791 [ROWE821 [ROWE851 [SELI79] [SEVR761 [STON751 [STON761 Jarke, M et al, ""Data Constructors On the Integrahon of Rules and Relations,"" Proc 1985 Very Large Data Base Conference, Stockholm, Sweden, August 1985 Katz, R H , Information Management for Engineering Design, Sprmger-Verlag, 1985 Kung, R et al, ""Heurlstlc Search m Database Systems,"" Proc 1st International Workshop on Expert Data Bases, Klowah, SC , Ott 1984 Lorle, R , and Plouffe, W, ""Complex ObJects and Their Use m Desmg Transactions,"" Proc Eng Design Apphcatlons of ACM-IEEE Data Base Week, San Jose, CA, May 1983 Lum, V , et al, ""Design of an Integrated DBMS to Support Advanced Appllcatlons,"" Proc Int Conf on Foundations of Data Org , Kyoto Umv , Japan, May 1985 Robinson, J , ""The K-D-B Tree A Search Structure for Large Multldlmenslonal Indexes,"" Proc 1981 ACM-SIGMOD Conference on Management of Data, Ann Arbor, Mlch , May 1981 Rowe, LA and Shoens, K , ""Data Abstraction, Views, and Updates m Rlgel,"" Proc 1979 ACM-SIGMOD Conference on Management of Data, Boston, MA, May 1979 Rowe, LA and Shoens, K ""FADS - A Forms Apphcatlon Development System,"" Proc 1982 ACM-SIGMOD Conference on Management of Data, Orlando, FL, June 1982 Rowe, L, ""F&m-the-Form Programming,"" Proc 1985 Very Large Data Base Conference, Stockholm, Sweden, August 1985 Selmger, P et al,""Access Path Selection m a Relational Data Base System,"" Proc 1979 ACM-SIGMOD Conference on Management of Data, Boston, Mass, June 1979 Severence, D, and Lohman, G, ""Differential Files Their Apphcatlon to the Maintenance of large Databases,"" ACM-TODS, June 1976 Stonebraker, M , ""Implementation of Integrity Constraints and Views by Query Modlficatlon,"" Proc 1975 ACM-SIGMOD Conference, San Jose, Ca , May 1975 Stonebraker, M , et al ""The Design and Implementation of INGRES,"" [STON81] [STON83al [STON83bl [STON83cl [STON84aJ [STON84bl [STON85al [STON85bl [STON85cl [STON861 [TICH821 [TSIC82] [ULLMSBI [WONG841 ACM-TODS, September 1976 Stonebraker, M , ""Operatmg System Support for Database Management,"" CACM, July 1981 Stonebraker, M , et al, ""Performance Analysis of a Dlstrlbuted Data Base System,"" Proc 3th Sympossum on Rehablllty In Dlstrlbuted Software and Data Base Systems, Clearwater, Fla, Ott 1983 [WOOD831 [ZANI831 Stonebraker, M , ""Document Processing m a Relational Database System,"" ACM TOOIS, April 1983 Stonebraker, M , et al,""Apphcatlon of Abstract Data Types and Abstract Indexes to CAD Data,"" Rot Engineering Apphcatlons Stream of 1983 Data Base Week, San Jose, Ca , May 1983 Stonebraker, M et al, ""QUEL as a Data Type,"" Proc 1984 ACMSIGMOD Conference on Management of Data, Boston, Mass, June 1984 Stonebraker, M and Rowe, LA, ""PORTALS A New Apphcakon Program Interface,"" Proc 1984 VLDB Conference, Singapore, Sept 1984 Stonebraker, M , ""Extendmg a Data Base System with Procedures,"" (subnutted for pubhcatlon) Stonebraker, M ,""Triggers and Inference m Data Base Systems,"" ROC Islamoora Conference on Expert Data Bases, Islamoora, Fla , Feb 1985, to appear as a Sprmger-Verlag book Stonebraker, M et al, ""An Analysis of Rule Indexmg Implementations m Data Base Systems,"" (submitted for pubhcatlon) Stonebraker, M , Yncluslon of New Types m Relational Data Base Systems,"" Rot Second International Conference on Data Base Engmeermg, Los Angeles, Ca , Feb 1986 Tlchy, W F, ""Design, Implementation, and Evaluation of a Revlslon Control System, Rot 6th Int Conf on Soft Eng , Sept 1982 Tslchrltzls, D C ""Form Management,"" CACM 25, July 1982 Ullman, J , ""Implementation of Logical Query Languages for Data Bases,"" Proceedmgs of the 1985 ACM-SIGMOD International Conference on Management of Data, Austin, TX, May 1985 Wong, E , et al, ""Enhancmg INGRES with Deductive Power,"" Proceedings of the 1st International Workshop on Expert Data Base Systems, Klowah SC, October 1984 Woodfill, J and Stonebraker, M, ""An Implementation of Hypothetlcal Relations,"" Proc 9th VLDB Confernece, Florence, Italy, Dee 1983 Zamolo, C , ""The Database Language GEM,"" Proc 1983 ACMSIGMOD Conference on Management of Data, San Jose, Ca, May 1983"
Special purpose simulator development (tutorial session)The DIF format is difficult to read with Fortran. Some languages such as C and Prolog support the direct reading of data from the Lotus worksheet.
Knowledge-based scheduling for flexible manufacturing systemsWhen there is no feasible solution or there are number of conflicting solutions, pairwise comparison of Analytic Hierarchy Process (AHP) is employed as the decision tool to solve the scheduling problems. This system is written in Turbo Prolog and is designed to implement scheduling on microcomputers at the shop-floor level.
FWEB: a literate programming system for Fortran8xThis raises the question whether the concept of literate programming is restricted to highlevel programming languages only, or if it might be possible to develop useful WEB-systems for all languages, maybe even for non-procedural languages like Lisp and Prolog. We do believe that such systems are likely to prove viable in the future.
Logic and databases: a critiqueIssue-Driven Research Looking back at this critique and at the [GMN] paper as a whole, it seems t o me that languages, and language-driven scientific research, are the main matte r in hand, as is the case, one might add, with that more general area of computer science of which logic and databases is an outgrowth, namely, logic programmin g and the Prolog family of programming languages . Although, as we said at th e start, the paper treats many central database topics in a uniform and readable way, it would appear that the importance of some of the most basic issues, such as indefiniteness and impliciteness of data, the relative expressive power of dat a definition and query languages, and their computational complexity, is still lost o n the reader, as a consequence of the language-dominated approach taken therein .
"A semantic and logical front-end to a database systemCho, ""KPSP: A Knowledge Programming System based on Prolog"", Proc. of the fourth International Conference on Entity-Relationship Approach, Chicago, Oct. 85, pp: 2-9. fS J."
A knowledge representation for use of catalyst activity patternsAnd especially for the estimation of the reaction mechanism, a frame system associated with a production system is used. INCAP is written in Prolog and running on a 4.3BSD UNIX-based SONY NEWS workstation with MC68020 CPU.
DAME: a rule based designer of microprocessor based systemsSubsequent generations of tools such Knowledge Craft encapsulate several environments (such as OPS-CRL, PROLOG, the Palm Editor etc.) plus a user friendly interface for increased productivity and application control.
"Plan revision in person-machine dialogueThe revision mechanism is currently implemented in an experimental prototype of the ESTEAM-316 Dialogner (written in PROLOG and running on SUN Workstations). This approach seems appropriate for the type of dialogues where the Uexpert"" advice giving system has a quite directive - 158- give parm (amount, EF) request expl (amount, EF) give parm (delay, EF) request exp} (delay, EF) request expl (EF) refuse (EF) Acts concerning Cash Need and other subplans give parm plan (P1) request expl plan (P1) refuse plan (P1) Others request expl (CN) refuse (CN) Acts concerning .Emergency Fund and other subplans give parm plan (Pl) request expl plan (PI) refuse plan (PI) Others Trans/ormation o/ the Ezpectation Stack help user formulate problem ask parameter amount help user formulate problem returno 1/.. ask parameter amount Transformation of the SSI Figure 4: A Example of revision: Changing Subject - 159- control of the dialogue."
Object oriented programming in APL2This order can usually be deduced by visual inspection of the program. A non-procedural program (written in PROLOG, for instance) contains a certain number of instructions that will not be executed in a predefined order.
Functional programming, the IEEE floating point standard and APLAlong with APL, other languages of the applicative sort are LISP and Prolog. Backus [BI and Williams [WI have formalized functional programming and placed it on an axiomatic basis.
"ADESSA — an Ada expert system style advisorSE-11, No.11, November, 1985, pg. 1263. 19. Bobrow, D.G., "" I f Prolog is the Answer, What is the Question? or What i t taken to Support AI Programming Paradigms"", IEEE Transactions on Software Engineering, Vol."
GTEX—A group technology expert systemFox (1983) - SRL: Schema Representation Language - Technical Report, Robotics Institute, Carnegie-Mellon University, Pittsburgh, PA [12] Guida G. (1986) Metodologie • strumenti per il progetto di sistemi esperti - Automazione e Strumentazione Settembre 1986, pagg. 163-171, Italia. [13] Laurent J.P. (1984) - Control Structures in expert system - Technology and Sciences of Informatics 3 (3), pagg. 147-162. [14] Clocksin W.F., Mellish C.S. (1984) PROGRAMMING IN PROLOG (second edition) - Springer-Verlag Berlin, WG. [15] Brownston L., Farrel R.Kant E., Martin N. (1985) - Programming Expert Systems in OPS5 - Addison Wesley Publishing Company, MA. 1.
Morphosyntactic correction in natural language interfacesIf semantic constraints prove this interpretation to be impossible, the next hypothesis is chosen, and so on. This part is implemented in Prolog and calls on the Pascal module described in section II. 712 best interpretation: ,0 bl les petits chatte miaule =the (plur.) small (masc.plur.) cat (fern.sing.) mews (sing.)
"Adapting an English morphological analyzer for French., and Thomas, J. (1984) ""WALRUS: lligh-quality text-to-speech research system,"" Proceedings of IEEE Speech Synthesis and Recognition, pp. 19-28. McCord, Michael C. (1986) ""Design of a Prolog-Based Machine Translation System', ['roe. Third International Conference on Logic Programming, Springer-Verlag, 350-374."
Extended graph unificationNearly all existing unification grammars of this kind use either term unification (the kind of unification used in resolution theorem provers, and hence provided as a primitive in PROLOG) or some version of the graph unification proposed by Kay {1985) and Shieber (1984).
A knowledge-based approach to computer-aided design of structuresCDAconsists of a backward chaining expert system shell written in PROLOG,a relational database managerwritten in IQRTRAN,a laminate analysis program also written in FORTRAN, and a rule-based knowledge base.
Solving ambiguities in the semantic representation of textsOur semantic analyzer is written in the VM/Programming in Logic (VM/PROLOG) programming language [_11]. The semantic analyzer takes as input the annotated syntactic tree(s) resulting from the syntactic analysis.
Synergistic use of direct manipulation and natural languageThe techniques described here have been implemented using various versions of Chat [13, 19], a natural-language question-answering sys-MAY 1989 tern implemented in Prolog. Two systems exist: the SHOPTALK system at SRI, and the CHORIS system at Lockheed.
A parallel processing course for undergraduatesIn the last month, the students do an individual project where they investigate in depth an area of parallel processing, e.g., data flow architectures, concurrent prolog, or parallel graph algo rithms, give a class presentation and write a research paper. 3.1 Texts and Materials The first time the parallel processing course was taught, I used the text by Hackney and Jesshope[8].
A computational framework for lexical descriptionThere is a special variable consisting of only an underscore (.... ), which never gets bound but can be used to match--anything (cf. Prolog). All other variables have a consistent interpretation throughout a rule. When negation is used no bindings that are made within a negative pattern are passed on through the match (agalin cf. Prolog), although bindings can be passed into negations.
Coordination in reconnaissance-attack parsingBerwick. 1985. New approaches to parsing conjunctions using Prolog. Proceedings of the Twenty-Third Annual Meeting of the Association for Computational Linguistics. 118-126.
MANDOLIN—a communications management expert system using a reduced form of the Dempster-Shafer uncertainty theoryInferencing System The inferencing system in MANDOLIN is rule-based, with rules specified in a Prologlike format. Facts are also specified in a Prolog-like format, consisting of a predicate and a list of arguments.
"Towards an implementation of a knowledge-based system design and simulation environmentInference Engine Design MODSYN shell has been implemented in Turbo Prolog and runs on IBM PC compatible machines. The inference engine uses the strategy of ""generate and test"", i.e., it takes the imtial data from the user and the hypothesis generated by the knowledge base to prune the search space tree."
Abstracts of papers in the Journal of Symbolic Computationand a query patrn q for ]P into • new program IP which, for the given query pattern, will behave in the same way under the standard computation rule of Prolog as the origius] program behaves under • specified instantiation based computation rule..
Choices (class hierarchical open interface for custom embedded systems)Example specialized computer systems include support for robotics applications, network controllers, aerospace applications, high-performance numerical computations, parallel language processor servers for IFP, 2 Prolog, Smalltalk, and reconfigurable systems. Examples of advanced operating system features include fault-tolerance in asynchronous systems, real-time fault-tolerant features, load balancing and coordination of very large numbers of processes, atomic transactions and protection.
Parsing tinyada in a programming language design courseThe book i s organized around two major themes : 1. a set of abstract principles o f language design 2. the five conventional generation s of programming languages, as exemplified b y p-code and FORTRAN (1), ALGOL (2), Pasca l (3), Ada (4), and LISP, Smalltalk, an d PROLOG (5) . By skipping one of the two chapters o n Ada and one of the three chapters on LISP , we were able to cover the entire text in a term of twelve weeks .
"Review of ""From syntax to semantics: insights from machine translation"" by Erich Steiner, Paul Schmidt, and Cornelia Zelinsky-Wibbelt.Then there is a long discussion of valency theory, though how this fits in with everything else is not clarified, and then there is some more formalism (p. 36), which is comprehensible if you know some Prolog and you assume that the formalism has the same conventions."
"An algorithm for ordering subgoals in NAIL?seen that the size of a rule-goal graph 1sbounded Smce the badness of an adorned goal cannot depend on itself being bad, we need not traverse backarcs m the adorned rule-goal graphs There are four cases to consider The simplest case, and the basis of the mductlon, 1swhen we have an adorned goal that 1sbad because it IS uncapturable Such an adorned goal cannot be part of an AARGGh by defimtlon In the second case, we have an adorned rule that IS bad We show that all adorned rule-goal graphs mcludmg It contam an uncapturable adorned goal There are two sub-cases The first 1s where the adorned rule IS bad because all Its unordered subgoals are bad adorned goals The proof that an adorned subgoal of the adorned rule 1s bad 1s shorter than the proof that the adorned rule IS bad, since we need not re-examme adorned goals already considered Thus we can use mductlon on the number of steps needed, to show that the unexplored part of all adorned rule-goal graphs followmg from the adorned subgoals must contam (or be) uncapturable adorned goals The second subcase 1swhere the adorned rule 1sbad because the adorned rule resulting from adding one of its (non-bad) adorned subgoals to the adorned rulegoal graph 1s bad By the same argument as before, we can use mductlon on the number of steps needed to show that all adorned rule-goal graphs contammg the new adorned rule also contam an uncapturable adorned goal Fmally, if we have an adorned goal that 1sbad, by definition it must be because one of the adorned rules followmg from It are bad There can be no AARGGh mcludmg the adorned goal d any of these adorned rules lead to uncapturable adorned goals We use mductlon agam to show that the bad adorned rule must be part of a subgraph contammg an uncapturable adorned goal, and so no AARGGh can contam the adorned goal 0 Lemma 3 The algorithm will succeed If the entry point 1s not bad Proof: We suppose that the algorithm falls, and show the entry point must be bad The proof 1s by mductlon of the depth of recursive calls to ""genGoal"" and ""genRule"" In the base case, ""genRule"" makes no recursive , calls and fads (returns 0) If all the unordered subgoals are uncapturable, that IS, the tests on lines (6) and (8) fall, causing the test on hne (13) to fall so that the variable arcs will be empty when Ime (21) 1s reached By defimtlon, if all the adorned subgoals of an adorned rule are bad, then the adorned rule 1s bad, so It follows that the algorithm falls with no recursive calls if its argument (an adorned rule m this case) IS bad Since we assume that there are rules defining each predicate, ""genGoa1"" never returns 0 without a call to ""genRule"" Now consider the general case The function ""genGoa1"" falls if the recursive call to ""genRule"" on Ime (8) fmls on one of the adorned rules for the adorned goal's predicate Since the test on Ime (9) of ""genRule"" ensures that ""genGoal"" IS never called recursively on the same adorned goal, the number of calls to discover the adorned rule falls IS strictly less than those taken to discover that the adorned goal falls Thus we may use mductlon to say that the adorned rule 1s bad By definition, an adorned goal 1sbad If one of the adorned rules derived from It 19bad, and so we conclude that the adorned goal 1s bad The function ""genRule"" falls on line (21) if the test on Ime (13) fa& for every unordered subgoal of the adorned rule - that is, none of the unordered subgoals could be added to the graph Tlus happens tf a subgoal 1s uncapturable, ss we have seen, or If the call to ""genGoal"" fouls In the latter case, we use the inductive hypothesis to show that the adorned subgoal 1s bad Thus ""genRule"" falls on Ime (21) If all the unordered subgoals are bad In addition, the function ""genRule"" may fall on Ime (18) if an adorned subgoal was added to the graph and the recursive call to ""genRule"" could not expand the resulting adorned rule Once agam, we use the mductlve hypothesis to show that the resulting adorned rule was bad, and so by defimtlon the ongmal adorned rule was bad So, If the algorithm given m Figures 2 and 3 falls to produce an AARGGh for an adorned goal, then It 1sbad 0 3 Discussion The algorithm as described above can be improved, and the version that has been implemented includes the followmg modlficatlons The ""most-bound-first"" heurlstlc described later has also been implemented l When expanding an adorned goal, we check to see If It has been expanded anywhere else m the graph, rather than Just as an ancestor of the current adorned goal This modlficatlon has no effect on the result, but saves some search l We keep a set of ""forbidden"" adorned goals, in the SCC we are working on Certam capture rules (such as the algorithm given m Bancllhon et al [1985J) may only work on AARGGh's that do not contam some particular adorned goals m the SCC, they may speedy these (m the case of the magc sets algonthm, at least one argument m the recursive predicate must be bound) In addltlon, when we discover that an adorned goal cannot be expanded because It leads eventually to an uncapturable or forbidden adorned goal (that 18,It ISbad), we can add It to the set of forbldden adorned goals so we will not attempt to expand it agam Before adding an adorned goal to the graph, it 18checked agamst the set of forbidden adorned goals Most-Bound-First Heuristic In the algorithm as stated, we simply work on the subgoals m the order they appear m the rule Although this choice will not lead to loops or falure as can happen m Prolog, it may lead to unnecessary uses of more inefficient capture rules In the graph given m Figure 1, for example, we must perform an unrestrlcted lookup on the down predicate If we add the subgoals m order If we choose to work on sg""f mstead, we will obtam a bmdmg for the first argument of down If we reorder the subgoals so that we try to add those with the most bound arguments first (tie breakmg by prefermg adorned subgoals with the fewest free arguments), we avoid domg unrestncted lookups m most cases Optima& We make no clauns about optlmality of the graphs produced by this algorithm The ""most-bound-first"" heurlstlc tends to produce better graphs, but m general finding the optimal order of subgoals would requue exammmg all possible orders."
"A functional level simulation engine of MAN-YO: a special purpose parallel machine for logic design automation(ed) , North-Holland Publishing Company) pp.137-152(1983) [i0] S.M.German and K.J.Lieberherr, ""Zeus: A Language for Expressing Algorithms in Hardware"", IEEE Computer, Vol.18, No.2, pp 55-65, Feb. 1985 [11] S.Tomita, K.Shibayama, T.Nakata, S.Yuasa and H.Hagiwara, ""A Computer with Low-Level Parallelism QA-2 Its Applications to 3-D Graphics and Prolog/Lisp Machines -"", Submitted to 13th Int'l Symp. on Computer Architecture [12] LMI, ""The Microcompiler"" 208"
"Telos: representing knowledge about information systemsFor this purpose we encode formulas in the base language 2 as abstract syntax trees (Prolog terms or Lisp lists in prefix every logical and non-logical notation), assuming that for symbol of Y we have a corresponding constructor. This paper has shown how Telos can be used to build metumodels of the various subworlds and software engineering activities involved in developing an information system, and to populate these metamodels with specifications and development projects. of particular software environments Telos is an object-centered language which has a number of special features that have enhanced its utility -it supports the organization for maintaining a software knowledge base: of knowledge built up from ""atomic facts"" through the use of classification and generalization hierarchies, -it is relatively easy to extend and customize with abbreviations by provid ing higher order classes, including attribute metaclasses, the syntax of ""attribute categories"" and the underlying tions"" are particularly useful, simple framework of ""proposi -it supports evolving views of objects and a hypertext-style browsing inter face, by treating attributions as individuals, -the consistency of the knowledge entered can be verified through con straint rules, and new values can be inferred by triggering the evaluation of rules, -a complete ""longitudinal"" view of various domains can be captured be cause of the powerful yet tractable model of time which has been tightly integrated into the language, -the evolution of the knowledge ""belief' times associated with software maintenance, There have been three prototype base can be recorded through the use of facts, and this can be used to support implementations of the language, all in PROLOG, carried out at the University Passau 1211, and SCS Hamburg of Crete 1531, the University of 1291."
New hope on data models and types: report of an NSF-INRIA workshopA major recent development in logic programming is the interaction of logic and constraint paradigms (CLP, Prolog III, CHIP [JL87, D+88]). While declarative database query languages have been proposed, constraint programming has not really influenced query language design.
Parallel channel routingThe project is to develop a tool for or-parallel execution of Prolog. Figure 8 demonstrates the above method for our search tree.
Knowledge-based optimal IIL generator from conventional logic circuit descriptions., 1979. W.F.Clocksin and C.S.Mellish, Programming in prolog,Springer-Verlag, 1981. KJshihara, et al., Hitachi's research and development in knowledge engineering, AlCA'85, Italy, October, 1985. note: AA(very good or quite easy).
Model-based analysis of messages about equipmentTheir system, PUNDIT [Palmer 1986], is written in PROLOG but has many points of commonality with PROTEUS in terms of overall structure, grammar, and semantic representation.
A hypertext knowledge based for primary care - LIMEDS in LINCKSIn u%% much attention has been paid to the user interface, by which access is supplied to an integrated patient record, support for diagnostic analysis and choice of therapy. The core representation format is a PROLOG-like language, PROPS-P, since the focus is on the expert system component of the multi-function system.
Automatic generation of hypertext knowledge bases. ,2-O < matnmemory ... >G,o -Z programming language: ( Turbo-Prolog jc-, z s, -z system software: ( Xenix }pBr > s, < application software ... >2-o < ... z To illustrate thesepoints, simply consider the frame displayed in Fig-l.
"Abstracts of papers in the Journal of Symbolic ComputationThis uniqueness property allowsto embed the data type 'boolean expression' into logic programming. First experiences with an integration into a Prolog system are shown. R. Paige and F. Henglein: ""Mechanical Translation of Set Theoretic Problem Specifications into Efficient RAM Code -- A Case Study"" This paper illustrates a fully automatic top-down approach to program development in which formal problem specilications arc mechanically translated into emcicnl RAM code."
"Overview of concert multilisp: a multiprocessor symbolic computing systemSeveral application programs have been and are being written and studied, including sorting [12], simulation of logic circuits [6], event-based simulation [23], part of a speech recognition system [22], semantic net retrieval [4], a subset of Prolog not including ""cut"" [27], a kernel of EMYCIN [21] (developed at MCC), the Boyer benchmark from the Gabriel benchmark set [9], polynomial manipulation, traveling salesman, parallel parsing of Lisp expressions, and the Multiiisp compiler itself."
Comparative efficiency of general and residual parsersWhereas most efforts on the implementation of partial evaluators have bee n restricted to declarative-style (e .g ., Lisp-like or Prolog-like) languages, the manual methodology is quit e compatible with imperative languages .
Algorithm 670: a Runge-Kutta-Nyström codeThe specification of the code is given in an extended prolog which is based on the DEPAC specification [22] whose overall approach and that of the NAG Library, DO2 chapter [9] the code described here follows.
Compiling LISP procedures. --- Compiling PORLOG Programs Parallel work in progress is concerned with an investigation of the possibility of producing compilers, in a more or less automatic fashion, for various dialects of PROLOG and various hardware systems. 5. SUMMARY --- Compiling LISP Procedures Is Necessary Many real-time AI applications simply can not be run successfully on systems whose basic mode of operation is to interpret the source code.
A word database for natural language processingGuenthncr / Lehmann / Sch 6nfeld, 1986). All of this information we encode as Prolog tcrms, and we also store these in SQL/DS, but separate from the word relation described above.
APL as a prototyping language: case study of a compiler development projectC and etc. in respect of criteria of CONCISENESS and ENVIRONMENT. We have excluded LISP and Prolog from our considerations because of our lack of experience in using them to construct large systems.
The using of inference mechanisms to improve the retrieval facilities from large relational databasesA top-down phase (corresponding to the top-down functioning of PROLOG interpreters), during which the program corresponding to the selected rule or rules is executed by generating particular right hand sides (at least a part of the values deriving from the expression to betransformed are .transmitted to the right hand side) and thus new speci-fic queries to the database this is the execution phase.
Concurrent programming in Orient84/K: an object-oriented knowledge representation languageThe syntax and semantics of the knowledge-base part owe much to Prolog [Warren and Pereira 19771. We extended the kinds of terms and modified the syntax in defining the interface with the behavior part. 3.4.
Some relational query language design issues and the language MQLThe result will be displayed on the default output device. Views are defined with a Prolog-like [Clocksin and Mellish, 1981] language. A formal description of the query and grouping statement syntax is presented in the appendix.
French order without orderUsing terms and term unification, the forward version 1 of functional application can then be stated as follows. (2) Forward Application Functor PhonologyF :CategoryF/PhonologyA : CategoryA : SemanticsA :prc :SemanticsF :OrderF Argument PhonologyA : CategoryA : SemanticsA : pie Result PhonologyF PhonologyA :CategoryF :SemanticsF :OrderF were upper letters indicate Prolog variables. In effect, the rule requires that the active part of the functor sign term unifies with the argument sign.
"Structural disambiguation with constraint propagationMukai, K. 1985, ""Unification over complex indeterminates in Prolog,"" ICOT Technical Report TR-113. 10. Savitch, W.J. et al."
The Tera computer system$t.SO even has strong support for implementing non-numeric languages like Lisp and Prolog and highly applicative languages like Sisal and Id.
Unification-based semantic interpretation in the BBN Spoken Language SystemWe have therefore modified the algorithm so that it treats constraint node empty symbols specially, not expanding them when the parse tables are built but instead waiting until parse time where it solves them top-down through a process that might be thought of as a kind of all-paths non-backtracking Prolog. A problem still appears when constraint nodes receive traces as arguments.
Automatic production of controller specifications from control and timing behavioral descriptionsISYN, for example, does The control specifier is written in Quintus Prolog and not analyze loops or include them in constraint sa,tisfac- runs on a Sun 3/280 under UNIX.
Efficient processing of flexible categorial grammarIt is a theorem of the Lambek-calculus as well. 23 (12) RA : A/B B -> A LA : B BA -> A (product) introduction: I: A B =>A*B inference rules : P : AB->C, DC=>E D*A B => E R : AB->C AB=>C The system in (12) is a subset of the Pcalculus, which is able to generate a strictly left-branching derivation for every of a given sentence of the grammar. reading The Prolog fragment in (13) shows how the restricted system in (12) can be used to define a simple left-associative parsing algorithm. (13) parse([C] ==> C) :- !.
Software factory engineering, today and the futureAs for the ill-defined/ill-structured problems, currenty almost nothing is available for use except those LISP /PROLOG programming paradigms and some algebraic and object-oriented environment on which the user plays around the programming tasks in a `trial and error' fashion.
Transforming syntactic graphs into semantic graphsFor example, 50 (vpp lives in) and (ppn in jungles) are transformed into (in lives jungles). These transformations are represented in Prolog rules based on general inference forms such as the following: (stype X declarative) & (voice X passive) & (vpp X by) & (ppn by Y) => (subject X Y) (vpp X P) (ppn P Y) &: not(volce X passive) => (P X Y).
Remarks on plural anaphoraIMPLEMENTATION The RefN-processes and sum formation are currently being implemented in Quintus-PROLOG on a MicroVax workstation. The present implementation allows one to represent and create RefOs and (1) their descriptions by way of designators (internal proxies for names and definite NPs), (2) their descriptions by way of attributes, which specify properties (sorts) of the represented objects themselves (not their designations) and relations between them.
Word games and search spacesWe are also considering the possibility of writing the entire svstem m Prolog, dispensing with the shell, and running it on our PDP 11/44 rather than on the PC's. 7.
Reducing managerial risk with expert systemsThe conceptual area extends from knowledge-base to control system, to situation data base, to Expert Systems, and the use of PROLOG, the application includes management decision making, capacity planning analysis, goal setting, and productivity r management.
Graphic interfaces for knowledge-based system developmentConsider how an expert system is typically developed using a tool such as OPS5, Prolog or EMYCIN [2, 4, lo]. The system developer writes a large number of rules and initial facts in a file using a text editor.
Sampling of submitted papersThe system deals with the design of parallel synchronous non homogeneous architectures and has been used for the design of dedicated architectures such as a Prolog engine, a floating point processor, a processor for multi-level simulation of logical circuits.
Verification of hardware descriptions by retargetable code generationRecently, MSSC was used to implement Warren's abstract PROLOG-machine (WAM) on the SAMP [Sch88]. This was done by writing an interpreter for the WAM in MIMOLA and compiling .this interpreter into machine code for the SAMP.
Some considerations on intelligent tutoring systemsOf course one can use the programming facilities of a logic language such as Prolog, but we chose the Kee environment because of the possibility to represent and manipulate knowledge in a highly structured way.
A morphological recognizer with syntactic and phonological rulesLaurl supplied the initial English automat on which the orthographic grammar was based, while Fernando furnished some of the Prolog code. Both provided many helpful suggestion and explanations as well.
A model of mental model constructionThe previous action heuristic combines a form of the temporal coincidence principle (Duncker, 1945, see also Shultz and Ravinsky 1977), according to which effects are presumed to be near their causes in time, and the priority principle (Bullock et al. 1982), which requires that causes precede effects. Imnlementinp the heuristics. A small PROLOG program, called Expl, is capable of performing analyses like that just shown.
"Lexical gaps and idioms in machine translation\I Research Report RC draft, Feb 1986, T.J.Watson Research Center, Yorktown i leights, NY 10598. [9] McCord, Michael C. 1989 ""Design of I.MT: A Prolog-Based Machine Translation System"", Computational Linguistics, Vol. 15, No. 1. [10] Nagao, Makoto and Jun-ichi ""['sujii. 1986 ""The transfer phase of"" the Mu Machine Translation System"", in Proceedings of COLING'86, ACI., pps 9%103. [11] Niremburg, Sergei and hene Niremburg. 1988 ""A Framework for Lexical Selection in Natural I.anguage Generation"", Proceedings- of the 12th International Conference on Computational l.inguistics, Budapest, 22-27 August, 1988. [12] Pdchardson, Stephen D. 1980 A l ligh-Level Trans[er Language for the BYUqSI Interactive Translalion System"", M.A. ]hesis, Brigham Young University. [13] Santos, Diana. 1988 ""A fase de transfer 6ncia de um sistema de traduqfio autom,5_tica do ingl 6s para o portugu 6s', Tese de .Mestrado, Instituto Superior Tacnico, Universidade Tacnica de Lisboa. [14] Santos, l)iana. 1988 ""An Nll prototypefiom I!"
Intelligent back end of a goal directed simulation environment for discrete-part manufacturingFord and Schroer (1987) describe a system developed in 883 Prolog. This system uses a natural language interface to extract information from the user and build SIMAN in models.
"Review of ""Machine translation systems"" by Jonathan Slocum. Cambridge University Press 1988.Part 1 presents a description of an extremely simple NLP system by means of the ATN formalism and the programming language POP-11 (partly Prolog, too). The result of the operation of the system--which later is described consistently in a highly limited microworld, adhering to the principle ""from the simple to the complex""--is the parsing of basic English syntactic structures of the simple sentence."
Partial computation as a practical aid in the compiler construction courseMos t of the studies have been confined to suc h relatively exotic languages as Lisp an d Prolog, and this is probably one of th e reasons why the concept remains s o underappreciated in the general computin g community . 3 .
Paradigmatic morphologyThis allows statements of the following kind, where + represents string concatenation, represents an inequality between strings and PROLOG conventions for marking variables are followed. (7) Stem+Affix = Word, Stem = Prefix+C+V, V ¢ vowels, C E consonants, V y, Affix = d (7) might be taken to describe the behaviour of vowel-final verbs under affixation of the past tense morpheme.
Metonymy and metaphor: what's the difference?., it actually recognises metaphors, metonymies, redundancies, etc), and resolves any lexical ambignity in those sentences. Meta 5 is writtert in Quintus Prolog and consists of a lexicon containing the sanse-frames of 460 word-senses, a small grammar, and semantic routines that embody collation and screening, the two processes of CS.
Prime rule-based methodologies give inadequate controlOf course the answer is not as simple as that: rule based languages (e.g. Prolog) are Turing complete. Furthermore, as this is an observed shortcoming, programmers have introduced their own solutions.
Extending the expressive capacity of the semantic component of the OPERA systemThe linguistic front-d of OPERA is a cnprehensive grmr of Vrench, and ]1:s semantic cnponent translates the syn-EX'INDING Tfiq PlKPRESSIVE CAPACITY OF TfE SFIMANTIC (DMPONENT F [, OPFJA SYST CELESTIN SEDOGBO CENTRE DE IECHRCHE BULL 68, ROUTE DE VE,RSAILLES 78430 [3UVECIENNES FRANCI a) given a data base in relational (e.g Prolog like ) form the answers to queries (which are themselves translated into logical forms) n he given in terms of the satisfaction conditions of these formulas.
Asymmetry in parsing and generating with unification grammars: case studies from ELUThe second solution adds an additional 'connect' clause in the Prolog program, specificto gaps, in order to assure that the gap is first instanfiated before further processing, this solution raises the issue of Imingprograms to treat specific problems as they are encountenxL There are other constructions which raise the same kind of problem, the fronting of apparently non-constitnent verbal sequences in German (Nerboone, 1986) introduces more complex dependencies, while in English the phenomena of Gapping and Verb-Phrase Ellipsis both manifest themselves syntactically in the absence from a sentence of a verb and possibly other material.
The common Lisp object system metaobject kernel: a status reportThe method call supported unification of the input arguments with the parameter patterns, as is done in Prolog. A backtracking search among applicable methods finds one that return a successful answer, or the generic function reports a failure.
Algorithm specification in a very high level languageSince data structures in PS are almost identical to Pascal or Modula data structures, it is easier to shit from the PS specification to an equivalent production program than from Lip or Prolog. In the continuum between nonprogrammer and expert, PS can be used to generate component modules of a system.
Querying part hierarchies: a knowledge-based approachMore theoretical work (well-surveyed in [BANC86]) has focused on the problem of coupling relational databases to relational-algebra recursion equations or to powerful, recursive Horn clause languages such as PROLOG. But some issues important for part hierarchies receive little attention.
The changing relationships between computing centers, other campus units and university administrationsPerhaps we should accept that a service center cannot be at the leading edge of computer science development, I don't expect such a facility to support Prolog yet, or even Ada, but surely there should be facilities comparable to those found on most microcomputers - - spreadsheets, WYSIWYG text editors, data base systems, and graphics in a problem solving environment.
When something is missing: ellipsis, coordination and the chartBerwick. New Approaches to Parsing Conjunctions Using Prolog. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, Chicago, Illinois, 1985.
Eurotra: practical experience with a multilingual machine translation system under developmentThe implementation of the virtual machine is done mainly In C-Prolog. A new version of the software Including a relational data base for the coding and maintenance of the lexicon (to be extended to grammars) has Just been released.
Flow-control machines: the structured execution architecture (SXA)Are its Test languages such as LISP or Descriptors useful in AI? Can Prolog be implemented easily on an SXA machine? Is runtime linking sharing tests?
Programming languages, OOP, and C++In addition and in contrast to this project, students are given short exercises which utilize functional programming in LISP and logic programming in PROLOG. The fundamentals of language design, specification, and implementation form the basis for the course, the purpose of the project and the supplemental exercises is to give life and meaning to the concepts which are presented.
Multikey access methods based on term discrimination and signature clusteringSignature file methods, in fact, have been proposed for various applications, such as multikey retrieval [17,18,19], text retrieval [6,11], office systems [4,10], and prolog systems [1,3,16]. A signature (descriptor) in the signature file method is associated with each record, the signature being an encording of the index terms used to retrieve. the record.
A logical treatment of semi-free word order and bounded discontinuous constituencyObject language variables are uppercase-initial atoms. (I.e.,they follow the Prolog convention.) Lowercase Greek lettersare metavariables over descriptions of structures of the corresponding intensional type.
Tenses as anaphoraAccordingly, the system consists of three major modules: LFG-Parser: I f-structure Composer: I Proto-DRS DRS Knowledge base The whole system is implemented in PROLOG. Here mainly the Composer and the Resolver will be discussed with respect to the treatment -45- of the tenses in these modules.
Distributed processing of logic programsThe program is written in DATALOG (see [MW]), i.e., pure PROLOG. T(x,y):-T(x,z)A(z,y). T (x ,y):-A (x ,y). If the relation A is replicated at two different processors, pi and p2, we can partition the work of computing (the relation for) the predicate T as follows.
Functional unification grammar revisitedThe testfor the equalityof loci in Pl and P3 isdone through PROLOG unification of variables. As in the previous DCG example, arguments with the same variable name must be equal.
New results on deriving protocol specifications from service specificationsIn our approachto the derivationof a protocol specification from a given service specification, an assignmentof the service interactions to the different service accesspoints must be given, the derivation algorithm then provides specificationsof all protocol entities serving the different accesspoints. The algorithm has been implemented in Prolog together with translationsbetween a subsetof the Lotos specification language [Bolo 871 and our service specificationlanguageDen 891.
Modeling complex structures in object-oriented logic programmingIn this work, the notion of first order term is extended and inheritance is taken into account in the unification process of Prolog. However, this work applies in the context of logic programming and complex values ($-terms) are built using the tuple constructor only.
Partial order programming (extended abstract)The procedural semantics for logic programming can then be viewed accurately as a process of rewriting one goal to another that contains a reduced binding (reduced system of equalities) as a disjunct. The rewriting process combines the Prolog II reduction process for equations, presented in section 3 of [2], and goal elimination, the replacement of atomic subgoals by goals corresponding to the bodies of rules.
Experience with the automatic temporal analysis of multitasking Ada designsThe operational semantics of COL are defined by a bottom-up inference engine written in Prolog. The inference engine applies the implication fornlulae describing the program to a current PSA in order to deduce a new PSA, the first current PSA is the initial PSA.
A relational approach to monitoring complex systemsLinton suggested using Quel, Garcia-Molina et al. suggested using Sequel, LeDoux and Parker used Prolog, and DiMaio, Ceri, and Reghizzi used Ada. Quel, Sequel, and Ada, because they have no natural way of expressing time-dependent queries, are inappropriate used to express time-dependent for this application. Prolog can be queries. Interval logic [23], regular expressions augmented with a shuffle operator [5], and path expressions [8] have also been suggested.
Office-by-example: an integrated office system and database managerTo the authors' knowledge, there is no other systematic implementation of such a system except for some Prolog systems. However, Prolog systems mainly emphasize language issues rather than database management system (DBMS) issues.
ACORN: APL to C on real numbers. • Header analysis: This analyzes the function header, and produces a C function header, locals declarations, and function prolog and epilog code. • Syntax analysis: This is performed by a reduction analyzer, implemented as a finite state machine.
Knowledge representation for closed loop controlSo, if control scheme PI has integral action we might state has_controller_property ( pi, integral action ). with the process requirement for zero error, process_demand ( no ss error ). and, generic_controller_property ( no ss error, integral_action ). The Prolog-like declarative rule, deduce_.control ( X ) :- process_demand ( Y ), generic_controller_property ( Y, Z ), has_controller_property ( X, Z ). obviously has the effect of yielding appropriate controller configurations to match the process requirements, but does not as yet reflect the complexity of the selection process which impinges on the controller choice as well as the tuning and monitoring steps. 4.1.
An expert system for maintenance of riveting machines, vol. 1.DEVELOPMENT TOOL SELECTION There is a wide spectrum of languages and tools commercially available for the development of expert systems. AI languages, such as LISP and PROLOG, are designed to handle symbolic processing, but using an AI language to develop an expert system can be very tedious and time-consuming.
Neural network learning: a new programming paradigm?This result is completely different from the case of using a IBC architecture, as we can see if we consider the simple case of an expert system implemented in Prolog: the search tree size increases with the number of symptoms and/or diseases and therefore the consulting time increases.
VLSI design synthesis with testabilityAlso extending automatic feedback strategies, and automating testability measures earlier in the synthesis process, ie. evaluating test measures for chained operations would be investigated in the future. CATREE has been implemented in Quintus Prolog. Special thanks to Dr. R.J.Gebotys for his helpful comments.
Pattern recognition applied to the acquisition of a grammatical classification system from unrestricted English textA discovery procedure would start by assuming that the context-set of every word could be partitioned into five subsets, and then it would attempt a Prolog-style 'unification' of pairs of similar context-subsets, using belief revision techniques from Artificial Intelligence (see, for example, (Drakos 86)).
Programming paradigms involving exceptions: a software quality approachHe has written a functional requirements document for a software metrics tool set which analyzes the quality of Ada source in terms of a hierarchical metrics framework and produces various report forms of that analysis (including rule-based assistance). Mr. Gorzela also has experience in using Prolog for writing formal specifications and as a development tool for code generation and validation during the development of ADAMAT (an Ada Measurement and Analysis Tool developed internally at Dynamics Research Corporation).
"IOTA: a full text information retrieval systemWe are of course mterested by deep understanding and a first prototype was developed last year (NlE 85) in PROLOG, and was able to distinguish, for instance, external search attributes from content search attributes such as in the following queries : ""I want the books about Mao Zedon~"" ""I want the books from Mao Zedong' By the way, the parser also identifies the external attribute ''book"" as a selection criteria among all the document types (i.e only the book documents will be selected)."
Database theory columnFinally, instead of augmenting Datalog one might consider starting with Horn clause s with function symbols and add sets (i .e., Prolog with sets) . This is accomplished in [BK] . Note that, such extensions are necessarily untyped, and usually without a negation primitive . 3The languages have to be put in an appropriate context, e.g ., by adding sorts to LDL which was originall y not sorted . 7 Some Open Question s 1.
Surface interaction: a paradigm and model for separating application and interfaceTo illustrate the manipulability of Presenter interfaces, here is the same surface rearrangedinteractively by the user,without applicationinvolvement: Interfaceshavealsobeencreatedto an Ada debugger[6]: to a UNIX file manipulationsystem[lo]: and to an interactivedatabasemanagementsystem[9]: Presenter has also provided interfaces for a Mascot 3 Paintbox [29], and a CORE requirementsmethod workstation 133.Current projects at York are using Presenter in an interactive conferencing system, as the front end for a Prolog graphics database,and for image processing applications.
Incremental parsing and reason maintenanceConflicting information is simply thrown away, hus in a sense making the system even 288 More recently, Zernik and Brown (1988) suggest a coupling of a DCG parser with a JTMS, both of which are embedded in a Prolog system. The DCG is extended with default rules to enable nonmonotonic reasoning.
A computational model for organizations of cooperating intelligent agentsWe can imagine a simple control structure similar to Planner or Prolog, but this could be changed, 14. An agent should probably communicate its commitments truthfully to affected agents, or at least respond truthfully to requests for information concerning its commitments. 15.
Cost-effective design of application specific VLIW processors using the SCARCE frameworkA Computer with Low-Level Parallelism QA-2 - Its Applications to 3-D Graphics and Prolog/Lisp Machines -. In The 13th Annual International Symposium on Computer Architecture, pages 280-289, IEEE Computer Society and Association for Computing Machinery, June 1986.
Processing natural language syntactic and semantic mechanismsMost AI and NLP programs are written in LISP or PROLOG,and APL has the ability to duplicate all such algorithms [8].
An architecture framework for application-specific and scalable architecturesCurrently, one of the most important activities within the SCARCE project is the development of application-specific processors. Currently paper development is being done on a prolog processor, a graphics-list processor, a real-time heart-image processor, and a general-purpose VLIW.
Planning for problem formulation in advice-giving dialogueAt the moment we have a prototype of a dialogue module written in Prolog which implements general strategies for person-machine advice-giving dialogue.
New booksAI is discussed in relation to languages such as Lisp and Prolog, and to applications such as expert systems. In Page 13 addition, the authors offer a variety of ways to incorporate AI into business, education, and other areas. * Maps out how AI fits into an emerging high-tech society by tracing its progress from its conception, through its development, to its projected future. * Describes many existing systems (including R1), as well as how to obtain and use an AI system. * Gives References for futher reading, organizations, groups, and agencies with more information about AI that will help you leap the boundaries of technology. * Complete appendices with addresses and related sources of information, such as AI training programs. * A thorough AI glossary. * Numerous relevant illustra'ions.
The Tera computer system$t.SO even has strong support for implementing non-numeric languages like Lisp and Prolog and highly applicative languages like Sisal and Id.
Multiple vs. wide shared bus multiprocessorsProcessors are connected to memory buses through caches at each cross point. Aquarius is a multiprocessordesignedfor Prolog, which has a different model of execution to conventional languages, and imposeshigher demandson the memory system.
A cooperative yes-no query system featuring discourse particlesFinally, moving sideways to verify, sondern is the particle. 551 The PASSAT System The tiny database query system PASSAT, consisting in one PROLOG II program comprising approximately 100 clauses, is designed to demonstrate a register of rules regulating choices, of alternatives to lexical items and of particles of discourse, in accordance with semantic relations and in terms of polarity.
Control of cognitive processes during software design: what tools are needed?About five minutes after the beginning of the session, a solution with central processing, a global queue of requests, and a Prolog model of computation is adopted. He produces many cycles of simulating the solution, debugging it locally, and simulating it again.
On the verification of sequential machines at differing levels of abstractionThe approachestaken to solve the sequential verification problem include the use of temporal logic[bro85] and PROLOG[ma%]. The use of temporal logic helps for asynchronous In the special case of a one-to-one,cofrespon+nE betwee?
Complexity and parallel processing: an interview with Richard KarpI intend to look at branch-and-bound, game trees, goal-subgoal structures, prolog-like structures, backtrack search, and all of the various kinds of combinatorial searches, because I think that such problems are really well suited for parallel computation.
Untagged data in tagged environments: choosing optimal representations at compile timeThis algorithm is very general and can be applied to a number of different tagging schemes, In practice, this algorithm is efficient and easily implemented. 1 Introduction Tagged data representations are popular in the implementation of many modern languages, including untyped languages such as Lisp, Scheme, or Prolog, and languages with static type checking such as ML.
A case-based system for trade secrets lawMore recently, the work of Sergot (1986], based on the use of Prolog, has attempted to model statute law, in particular the new British Emigration Act.
Application of machine learning to the maintenance of knowledge-based performanceThe performance element is a deductive retriever similar to Prolog. Performance is measured while the performance element attempts to solve a query posed by the user.
Plant control expert system coping with unforeseen events—model based reasoning using fuzzy qualitative reasoningThis mechanism is implemented on a PSIII(Persona1 Sequential Inference Machine) using ESP(Extended Self-contained Prolog), and is under experimental implementation. The open problems remain as follows: (1) Reftnement of Knowledge Estimator A new mechanism is needed to deal with the priority of the limitation constraints and to analyze the effect of the temporal operations against the constraints violation. (2) Reflnement of Simulator In the experimentation, the qualitative reasoning using fuzzy logic doesn't produce reasonable results in all cases.
"FAST: A large scale expert system for application and system software performance tuningExplanation for a Diagnosis REFERENCE3 1. Bobrow, D., ""If Prolog is the Answer, What is the Question? or What it Takes to Support AI Programming Paradigms,"" IEEE Transactions on Software Engineering, Vol."
The detection and representation of ambiguities of intension and descriptionImplementation We have implemented a prototype system that incorporates the ideas discussed above. The system is written in Prolog, and is built on top of Popowich's SAUMER formalism for syntactic and semantic rules (Popowich 1984, 1985). 7.
A generalized object modelAs an alternative to the most-specific and nondeterministic strategy, we could use the Prolog approach: the programmer would order the guards, and the first guard that matches the message signature would be chosen.
Knowledge-based learning integrating acquisition and learningis used to make processing in the system more efficient as done in PROLOG programs. The special cut operator / is used to segment the rules of the knowledge base into independent sections.
"The algebraic specification language LOTOS: an industrial experienceIn our experience, the difficulty of learning LOTOS can be roughly compared to the difficulty of learning other ""unconventional"" functional or logic-based languages, such as LISP or Prolog. Of course, learning was facilitated by the fact that, unlike other specification languages,LOTOS is (at least partially) executable. 4."
Computational semantics of mass termsIMPLEMENTATION The inference algorithm has been implemented in PROLOG. To test it out we have built a small (toy) natural language question-answering-system around it.
Version control in the Inscape environmentFacilities like Ada's default values for parameters, C's ability to have parameter lists of arbitrary length, and Prolog's 'don:t care' argument are the kinds of features that would expedite this approach. 9.
"A system for compiling fontsI Font IJ mono-spooed. tne width of the font Is etcred In WIDTH. a The font bound1np box 13 computed in FONT,BOUNDING,BOX (x.Y,x,Y) a The stole foctcr Is assumed Lo be ,001 n The Pro log poster Ipt. code I3 produced by PROLOG I141 I151 I161 t 171 I I81 I191 [201 n The Epl lop postscr Ipt code Is produced by EP I LOG * if 0 Bezler curve For o parllcular nomed character Is net present "" In the WS, fhen that character Is om I tted from Che Font. fhle I al lows the Font to be tested OS It I s balnp developed."
A functional programming language compiler for massively parallel computersThe initial and final structures, and the full deduction, can be reproduced using a backward-chaining theorem prover, such as Prolog [S]. 2.2 Indexing Information for Computational Functions The scheme described in Section 2.1 for inferring the effect of routing functions can be extended to expressions involving computational functions.
CIBELE: a knowledge based system for short-term production schedulingThe tool adopted is Knowledge Craft (KC), the most powerful environment for developing expert systems, whose main feature is the presence of different but deeply integrated software tools, including a frame-oriented representation language (CRL), an object-oriented programming language (CRL-OOPS) and two different inferencestrategies (CRL-OPS and CRL-PROLOG for forward and backward chaining programming, respectively).
Issue spotting in a system for searching interpretation spacesNotice, that in contrast to the notion of facts used in Prolog, these facts can be arbitrary wffs, they are not restricted to atomic formulae.
A multi-purpose interface to an on-line dictionaryA text processing application, typically written in Lisp or Prolog, requires that its lexicai data is represented in a compatible form, say Lisp s-expressions of arbitrary complexity.
APL2 implementations of unificationA variable is: . a simple character vector whose first character is * . a simple character vector whose first character Is uppercase. . a simple character vector whose first character Is A and which represents a legal APL2 name. Various versions of PROLOG use the first two conventions. In this paper, we use the last convention.
"A critical evaluation of commensurable abduction models for semantic interpretationIt would be a mistake to use the rules given here in a strictly top-down manner, just because they are reminiscent of Prolog rules. (3) There is no notion of a ""good"" or ""bad"" interpretation, except as an epiphenomenon of the interpretation rules."
Interpreting statutory predicatesWe foresee that this work will eventually complement work on legal reasoning, like that modelling statutes with expert systems and PROLOG [Sergot cl al., 19861 which often must confront difficulties of interpretation.
"The complexity of ordering subgoalsTHE PROBLEM Consider the evaluation of log& queries, usmg clauses such as the famous ""same-generation"" rules, which we write as rl &W) f2 w(X, Y) - parl(X, XP) 82 w2(Y, YP) 4~ -v(Yp, XP) Those who have comrmtted these rules to heart will notice two surprises 1 We dlstmgulsh between the two par subgoals, by subscripts Both par1 and par2 are intended to refer to a single predicate par 2 We have switched the order of the arguments m the recursive call sg(Yp,Xp) This change does not affect the answer to queries, but It affects the bmdmg pattern m calls A query IS a predicate p with some arguments bound to given values The desired answer IS the set of tuples k, such that p(p) IS true, and p has the given values m the bound arguments For example, Work of J D Ulbnan supported by NSF grant IST-84-12791 and a grant of IBM Carp Permmuon to copy without fee all or part of this materml 1s granted provided that the copms are not made or dlstrlbuted for &rect commercmi advantage, the ACM copynght notlce and the title of the pubhcatlon and Its date appear, and notlce 1s given that copymg 1s by pernusslon of the Assoclatlon for Computmg Macbmery To copy otherwlse, or to repubbsh, reqmres a fee and/or specific permlsslon 0 1988ACM O-89791-263-2/88/0003/0074 $1 50 query sg(joe,X) asks for all pairs (joe,X) such that sg(loe, X) follows from the gven database (the par relation) and the rules Adornments When dlscussmg evaluation strategies for logical queries, we often need to talk about bmdmg patterns, and we shall use the ""adornment"" notation of Ullman [1985] A predicate p superscrlpted by an adornment (list of b`s and f's) 1s an adorned goal, and the adornment tells whether each argument of p, m order, 1s bound (h) or free (f) A bmdmg for an adorned goal 1s a finite relation over the bound arguments (those arguments corresponding to b's m the adornment) For example, p""`* would be bound by a relation conslstmg of pairs of values, say {ac, de} The problem posed by this adorned goal IS to find all those tuples of the form aXc 01 dXe that make p true SometImes, the adornment determines whether we can solve the problem posed by an adorned goal 1 When rules have function symbols, convergence may depend on certain bmdmgs A canomcal example goodLzst(nz1) goodLzsi(H T) - good(H) 8 goodL1d(T) That IS, the empty hst 1s ""good,"" and a hst 1sgood If Its head element 1sgood and its tad 1sa good hst If we ask a query with a bound argument, I e , an adorned goal goodlzst"", we can solve the plohlem by an algorithm such as Prolog's top-down eupanslon However, if we ask goodLzstf , 1e , produce all good lists, we cannot answer the query by any method 2 We may wish to restrict the use of database rela tlons to lookups based on some index For example, suppose par 1sa database relation with mdlces on both attributes We could then ""solbe' prrj `*, par*f , and parf*, but not pnrff Rule/Goal Graphs An essential step m applying many techniques for logic evaluation ISconstruction of a ""rule/goal graph"" (RGG) that mdlcates the order m which subgoals are to be evaluated m rules and mdlcates the way m which variable bindings pass from one subgoal to another within a rule The RGG construction 1sused in the NAIL' strategy selection system (Moms [1988], Morris et al [1987]) It, or an eqmvalent, IS used m a variety of specific algonthms, such as Bancllhon et al [1986], and Sacca and Zamolo [1987] Formally, a rule/goal graph 1s a graph built from a collection of mutually recursive predicates (often Just one predicate) It has nodes correspondmg to adorned goals and to rules 1 There IS an arc from goal node pa to rule nodes correspondmg to each of the rules with head p These rule nodes are associated with the adornment Q, and if p appears with other adornments m the RGG, then other nodes for p's rules are created There 1san arc from a rule node to nodes for each of its subgoals The order of the subgoals must be selected by the constructor of the RGG, and the adornments for the subgoals follows the prmclple that 1 An argument can be bound only d it 1s occupied by a term all of whose variables are bound 2 A variable 1sbound only by appearmg m a bound argument of the head or an argument of a previous subgoal The set of mutually recursive predicates from which an RGG 1sformed 1scalled a strongly connected component (SCC,) Goal nodes of the RGG that do not belong to the SCC are external Example 1 Consider the SCC {sg} In Fig 1 1s one possible RGG for the same-generation rules as written above Rule 11 has no body, so ~1 nodes have no successors Fol rule ~2 we have chosen the subgoal order purl, sq, PUT:!"
How to invent distributed implementation schemes of an object-based concurrent language: a transformational approach., M.I.T, 1981. [Kursawe 861 P. Kursawe: How to Invent a Prolog Ma chine, Lecture Notes in Computer Science, Vol. 225, pp. 134-148, Springer-Verlag, 1986.
"On the role of old information in generating readable text: a psychological and computational definition of ""old"" and ""new"" information in the NOSVO systemWith this informatiion it picks the type of grammar that will place the particular argument or adjunct first and sends the choice along with the predicate to the English generator. 4.2.8 The English generator The English generator is a prolog grammar segmented into the various old information first syntaxes, e.g. prepositional phrase first, object first rules, and a plain vanilla syntax."
SPARK—an annotated Ada subset for safety-critical programmingThis involved the construction of a declarative model of the 28002 processor and a subset of its instruction set. Since this definition was expressed in Prolog, it was executable, and could be employed to translate the 28002 assembly code mechanically into the modelling language of SPADE.
Interacting with an active, integrated environmentIn this respect, the object attribute constraint mechanism is similar to the idea of procedural attachment to frame slots Minsky 19751. The current system is implemented in Quintus Prolog using object-oriented extensions devised by one of our collaborators in this project.
Integrated environment for intelligent controlEven in the branch of processing, many different languages processed symbolic and tools (such as Lisp, Prolog, OPS5, KEE, EMYCIN, on) may be applied to build individual and so symbolic reasoning systems.
Rapid prototyping with AdaExamples: design systems used for • Sets & Maps- SETL, Vienna Development Method (VDM) • Arrays - APL • Indexed Sequencesrelational databases • Trees - LISP, Prolog • Streams - Unix 310 Record Types • Control Sequences Record Types typically describe objects that are components of bulk data structures in Ada. • General access to inner record structure is awkward within bulk data structure primitives but • certain operations on record contents are usually required (e.g. display field values, compare selected fields, ...).
OROS: toward a type model for software development environmentsTo date, we have built two interactive user interfaces (browsers) for OROS, one in Prolog and the other in Lisp. Both of these maintain type systems by allowing type definitions to be created, modified and deleted, both also perform full consistency checking.
Models for visualization in parallel debuggersThe clearest support for domain decomposition is found in parallel versions of functional and logic languages such as Parlog, Concurrent Prolog, *Lisp, and MultiLisp, but some procedural languages provide related features (e.g., Parallel Pascal, iPSC parallel C library).
A self-controlling interpreter for the relational production languageA non-trivial expert system for awarding financial aid for a graduate program is concurrently being developed in YAPS [Allen 83], RPL, and Prolog. This will provide the framework for an in-depth evaluation of the RPL approach.
Survey of software engineering educationCurtis, Measurement and Experimentation in Software Engineering, Proceedings of the/EEE 68, 9, 114.4-1157,September 1980. [17] R.E. Davis, Logic programming and Prolog: A Tutorial, IEEE Soft-are 2, 5, 53-62, September 1985.
Overview of garbage collection in symbolic computingThe crushing of pointers is a common occurrence in languages for symbolic computation (e.g., Lisp or Prolog). The frequent crushing of pointers to objects over a period of time results in the accumulation of a large amount of garbage.
PassivesThe semantics of the features in the rules is that provided by ordinary (i.e. Prolog-style) unification. The semantic expressions associated with the rules are instructions for building logical forms in a kind of 'intensionless Montague': a typed higher order logic, like that in PTQ without the intension and extension operators.
A methodology for multiple rule system integration and resolutions within a singular knowledge baseThere are a wide variety of logical languages that have be used to write assertions of rules, conditions and states, such as the first order predicate calculus as implemented by PROLOG. Such logical (formal) language constructs as output, may be combined with other assertions, to assist in non-context-free solutions or verifications of prior states or conditions with associated trees and mappings reducing the search space.
"The specification statementIn this context if - - - fi resembles the ""cut"" of Prolog, allowing failure (preventing backtracking) if no solution is found within (beyond)."
Temporal ontology in natural languageHowever, certain properties of the event-based calculi of Kowalski and Sergot. and of Lansky. seem to offer an appropriate representation for a 3 A Prolog program incorporating the above exmnsion to the event calculus is under construction and will be presentedin Moens (forthcoming). semantics of this kind.
Selected AI-related dissertationsUniversity of California, Berkeley Ph.D. 1985, 157 pages. High performance execution of Prolog programs based on a static data dependency analysis.
Querying constraintsWe conclude by reporting briefly on how notions of negation and canonical representation used in linear constraints can be generalized to account for cases in term algebras, symbolic computation, affine geometry, and elsewhere. 1 Introduction Various forms of declarative arithmetic are built in languages of the CLP class [JL] such as CLP(32), CHIP, CAL, Prolog III, Br\TRProlog. Declarative arithmetic has also been introduced in languages not related to Logic Programming such as Mathematics and Trilogy, and in principle at least could be introduced in the paradigms of Functional and Object Oriented Programming.
A file structure supporting traversal recursionRecent work on recursive queries has focused mainly on the problem of coupling recursive Horn clause languages like PROLOG to relational databases. Bancilhon and Ramakrishnan [BR] give an excellent overview of recursive query processing strategies.
The partial metrics system: modeling the stepwise refinement process using partial metricsEach hypothesis of acceptability is expressed as a Prolog clause, where the arguments at the head of the clause correspond to each of the seven partial metrics.
Oaklisp: an object-oriented scheme with first class typesThe Schcm¢ semantics of Oaklisp allows these implcmentations to play 8ames with higher order functions, using deviant Conniver-style control structures of the sort that provided the original motivation for developing Scheme and Prolog. Coercable Types In this section we define a new metatype.
Loop optimization for horizontal microcoded machinesIn order to illustrate the method, suppose we have an architecture that can perform two concurrent memory accesses without conflict, and that all operations take one cycle to complete, and suppose we want to execute the following loop: for i = 1 to 100 do f tl[il = t2Cil t t3kl * t4[il, 1 If we unroll and compact successively several iterations of the loop, then we always obtain the same I t1 t2 t3 t4 t5 t6 t7 Cl c2 Cl c3 c2 Cl 9c3 c2 c3 prolog new loop body epilog Cl Cl Cl Cl c2 I c2 c2 c2 ....... c3 c3 c3 c3 Figure 5: Software pipelining 9,JB c\JD E iF the dependency graph A = read t3[i] B = read t4[i] c=* D = read t2[i] E=+ F = write tl[i] AB CD A E BD F C A E BD F C A E BD F c - E F code after 4 iterations Figure 6: Example of loop unrolling scheduling of the iterations after an unrolling of degree 2 (number of unrolling), as shown in Figure 6 where successive iterations are listed separately, side by side.
The BANG file: A new kind of grid fileThe BANG file* a new kind of grid file Michael Freeston k#CRC European Computer-Industry Research Centre Arabellastr 17 D-8000 Munchen 81 West Germany A new multi-dimensional file structure has been developed m the course of a project to devise ways of unproving the support for interactive queries to databases and knowledge bases Christened the `BANG' file - a Balanced And Bested @id - the new structure 1s of the'gnd file,- type, but 1s fundamentally different from prr\~tms grid file designs m that it does not share their c`,rnmon underlying properties It has a treestructured cllrec tory wluch has the self-balancing propert, ~4 a B-tree and which, m contrast to previous design*, almavs expands at the same rate as the data, whatever bhr form of the data &strlbutlon Its partltlonmg utratrgy both accurately reflects the clustering of pomts m the data space, and 18 flexible enough LO adapt gracefully to changes m the distribution 1 Research directions The eventual mm of the research reported here 18 to devise appropriate support structures for knowledge bases The immediate practical obJective towards that end has been to find a more powerful and flexible replacement for the INGRES structures on which the logic programmrng/database system EDUCE [BOCC85] currently relies EDUCE m turn supports the KBMS Prolog-KHZ U ALL861 Of course, the speclfieation of Permission to copy without fee all or part of this material ISgranted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notlce and the title of the pubhcatlon and Its date appear, and notlce ISgiven that copymg IS by permissIon of the Assoclatlon for Computing Machmery To copy otherwise, or to repubhsh, reqmres a fee and/or specfx permlsslon 0 1987 ACM O-89791-236-5/87/0005/0260 754 an `ideal' knowledge base support structure will change as knowledge bases develop, but It seems clear that It must for the present include at least all the features of the `Ideal' structure for a conventional relational database But the structures which support current relational databases are clearly not Ideal Specfically, they are still almost without exception one-dimensional, so that access to a file via more than one key mvolves multiple Indexes with associated update overheads Such structures may be adequate to support menu-driven user interfaces, for which the form of the allowed queries IS entirely controllable and predictable, but they are a very poor match for an Interactive query language This deficiency rapidly becomes clear to anyone who uses an interactive query language, and over the past ten years or so there has been a variety of attempts to Improve the situation by the design of new multidimensional file structures and access mechanisms The guiding principle of all these designs has been that the response to a query should depend only on the complexity of the query, and not simply on the particular combmation of attributes named m It Research m tbrs dvection has followed three distmct lines 1 Tree structures a generahsation to n dimensions [BENT79 ROB181 GARDBS] Multi-dimeneional extendible [FAG179 OUKS83 OT0085] hashing Grid tiles an explicitly geometric approach, representing n-tuples aa pomts in a partitioned, n-dimensional hyperspace [NIEVIl BURK83 HINR85 OZKA85] A detailed review of recent work m these areas [FREE861 was encouraging, to the extent that a number of novel approaches have been demonstrated to be effective for certain classes of application But all appeared to have some serious drawback as a general database ?
"Implementation and evaluation of a list-processing-oriented data flow machineComputer Architecture, pp.363-369, IEEE, 1983. [9] N.Itoh, Y.Masuda and H.Shimizu, ""Parallel Prolog Machine based on Data Flow Model,~ ICOT Tech. Rep."
Adding relational abstraction to programming languagesWe prefer to use it as an adjunct to other abstraction mechanisms in programming Iangauges. I am not aware of any Prolog implementations (even in Lisp - Relations are scoped.
An object-oriented design system shellAs we consider other languages, standard procedural ones like Pascal, powerful functional ones such as Lisp, or logic based ones such as Prolog, we feel that we would be forced to a much greater extent into full specification and design, prior to implementation, rather than prototyping and trying alternative approaches.
On the efficiency of logic-based diagnosisIt is possible to consider H as the set of all possible hypothesis instances ranging over the application domain's universe of discourse U, e.g., Prolog implementations of Theorist consider U to be Herbrand universe of F u H u 0.2 Observations are a set of formulas of L representing observed behavior of a system to be diagnosed.
Expressing structural hypertext queries in graphlogIn this paper, from a practical point of view, we survey several existing hypertext systems and queries described by their authors and show how they can all be expressed in GraphLog. lIn fact, the name of the language comes from its close relationship to Datalog, in turn a relative of Prolog. THE QUERY LANGUAGE The graph-based query language GS provided a starting point for GraphLog.
A plan-based intelligent assistant that supports the software developmentThe TMS and related facilities for deeper process understanding are implemented in a Prolog version of the plan recognizer, GRAPPLE is not tied to a particular software environment, Figure 9: Revised Assumptions rather, it accepts command streams transcribed from actual terminal sessions or fabricated for experimental purposes.
Foreign functions and common LispAt the other extreme, requiring a Common Lisp implementation to be able to load the binary object files for another Lisp or • Prolog and then he able to call to and return from that other programming system as a foreign function seems a bit extreme.
Logical foundations for knowledge representation in intelligent systemsCleary's (1986) implementation of interval arithmetic as an extension of Prolog may be used as an inference system for the standard uncertainty logic from which probability theory and fuzzy logic derive.
Object subclass hierarchy in SQL: a simple approachFor instance, in We note that view update remains of the inclusion constraints at the [7], the automated translation of the a problem for further research (see expense of retrieval performance. In conceptual model into a Prolog pro[4] and [13]). Due to the use of objectoriented modeling, however, the resulting tables tend to be in third normal form [2], in which each nonkey attribute directly depends on the primary key.
Design of a text formatter with AUTO STARWe have applied AUTO STAR to a number of system developmen t projects such as a Prolog interpreter, an interpreter and a compiler for a small programming language Toy, an interpreter fo r a second - order lambda - calculus language Power, etc .
Sheaved memory: architectural support for state saving and restoration in pages systemsIn a wider context, sheavedmemory can be used to support the execution of software in which backtracking is used, in Prolog programs, for example, when side effects are produced while following a path that is unsuccessful, sheavedmemory allows the side effects to be undone without programmereffort.
Compiling separable recursionsHowever, because of its superior performance on queries on separable recursions, and because it is computationally simple to detect separable recursions, we expect that this evaluation algorithm will be a useful component of a recursive query processor. 2 Separable Recursions We consider queries on relations defined by functionfree pure horn clause programs. We use Prolog syntax, and require that the heads (consequent) of the rules contain no repeated variables and no constants.
Teching PL/I using a microcomputerIt has also bee n demonstrated that the giving of readin g assignments related to relevant compute r science articles in magazines and journal s is beneficial to the students . 1 Clocksin, W . F . and Mellish, C . S ., Programming in Prolog . Spring-Verla g Berlin Heidelberg, 1981 . Associates, Inc ., 1973 . [31 Ghezzi, Carlo and Jazayeri , Mehdi .
Wide-range restructuring of intermediate representations in machine translation., Slocum, J, Norcross, E. 1981 The METAL System. RADC-TR 80-374. McCord, M. C. 1985 LMT: A Prolog-Based Machine Translation Sys-78 IntermediateRepresentationsin MachineTranslation tern.
The A+ programming language, a different APL[McCrosky 88]: Carl McCrosky, Anthony Kusalik, Improving First-Class Array Expressions Using Prolog, Logic Programming. Proceedings of the Fifth International Conference and Symposium, MIT Press, 1988.
ABSTRACTS (Chosen by G. Salton from recent issues of journals in the retrieval area).The design of the intermediary system uses the principle of search space abstraction, employing menu selection from a touch terminal and encapsulating the necessary intermediary expertise using rule-based techniques programmed in PROLOG. CANSEARCH performed well enough to justify the approach taken, suggesting that further development of CANSEARCH and of intermediary systems for document retrieval in other subject areas should be undertaken.
On distributed processibility of datalog queries by decomposing databasesThe program is written in DATALOG (a dialect of PROLOG). T(w, +A(+ Y) 4 T(w, Y), A(+, Y) --, T(x, Y).
Large-scale concurrent computing in artificial intelligence researchSame examples include special purpose hardware such as the FAIM machine [9], the Apiary [23] the connection machine [19], the iPSC [6,14], and the Butterfly applied to AI computations, Special purpose parallel languages such as MultiLisp, Qlisp, Concurrent Prolog, Actor languages [I], and operating system parallelism in systems such as MACE [14], and systems such as the Butterfly, FAIM [9], iPSC/MACE [6,14], Orient/S4 [28], ABCLl [30], ABE [12], AGORA [5], etc.
Providing expert systems with integrated natural language and graphical interfacesKnowledge Craft is a knowledge engineering tool based on a schema-oriented knowledge representation language, called CRLTM, and incorporating OPS-5 and Prolog inference engines and a powerful graphics system.
The latent damage system: a jurisprudential analysisNote there was by no meansa perfect match. The Oxford Project's structure (implemented in Prolog) was more sophisticated than that of Crystal's.
A statistical approach to diagnosing intermittent performance-problems using monotone relationshipsPrentice-Hall, 1968. Domanski87. Bernard Domanski. A PROLOG-based Expert System for Tuning MvS/xA. Proceedings of the Computer Measurement Group, pages 160-166, 1987.
Intelligent support for interface systemsThe Poplog system [Barrett851 was chosen because it is an AI environment that runs on the same hardware (Sun Workstations) as the D language, it can be linked to other systems and allows for the rapid development of prototypes, Poplog is an AI programming environment which had its origins in the AI group at Edinburgh in the 60's and is now a commercial product market world wide by Systems Designers. At present the system provides three languages Prolog, Lisp and Pop 11, a syntax directed editor, ved, comprehensive on-line teach, help and material and a large library of procedures.
"Solving thematic divergences in machine translation[McCord, 1989] Michael C. McCord, ""Design of LMT: A Prolog-Based Machine Translation System,"" Computational Linguistics, 15:1, 33-52, 1989."
CHECKER: an efficient algorithm for knowledge base verificationExamples of the first generation of traditional tools include EMYCIN, KAS, EXPERT, ROSIE, OPS-5, and Prolog [l]. A number of other shells that are basically clones of one or more of the above systems are available commercially.
Indexing medical reports in a multimedia environment: the RIME experimental approachFinal result : ( / dLi\ / p-sur\ cancer , a-v-v~ \ uretere position deviation zdiarmosticl V - Conclusion The first experimentations in Prolog on a Sun workstation have led to very encouraging results, which demonstrate the validity of the approach.
Abstracts of current literatureIt also has a DBMS frame interpreter to transform the information into executable Prolog clauses representing a frame. With the support of these facilities, the system is capable of exploiting passive data in the data base as active knowledge for making useful inferences.
A taxonomy of user interface terminologyThe cognitive engineering branch is broken down into three sub-branches : 2 .1 Cognitive Science 2 .2 Normative Models 2 .3 Descriptive Model s The three sub-branches of cognitive engineering may the n be further broken down into subtopics as shown below : 2 .1 Cognitive Scienc e 2 .1 .1 Cognitive and Experimental Psycholog y 2 .1 .1 .1 Experimental Design and Analysis 2 .1 .1 .2 Human Intelligence and Abilitie s 2 .1 .1 .3 Personality and Motivatio n 2 .1 .1 .4 Human Information Processing 2 .1 .1 .4.1 Learning 2 .1 .1 .4 .2 Memory 2 .1 .1 .4 .3 Decision Makin g 2 .1 .1 .4 .4 Problem Solving 2 .1 .1 .4 .5 Attention 2 .1 .1 .4 .5 .1 Selective Attentio n 2 .1 .1 .4 .5 .2 Divided Attention 2 .1 .1 .4 .5 .3 Focused Attentio n 2 .1 .1 .4 .5 .4 Attentional Resource s 2 .1 .1 .5 Perception 2 .1.2 Artificial Intelligence 2 .1 .2 .1 Knowledge Representatio n 2 .1 .2 .1 .1 Semantic Nets 2 .1 .2 .1 .2 Frames 2 .1 .2 .1 .3 Production Rules 2 .1 .2 .1 .4 Script s 2 .1 .2 .2 Symbolic Programmin g 2 .1 .2 .2.1 Lisp 2 .1 .2 .2.2 Prolog 2 .1 .2 .2.3 SmallTalk 2 .1 .2 .3 Knowledge Engineering 2 .1 .2.3.1 Knowledge Acquisition 2 .1 .2 .3.2 Machine Learning 2 .1 .2 .3.3 Inference 2 .1 .2 .4 Machine Vision 2 .1 .3 Language Understanding 2 .1 .3 .1 Synta x 2 .1 .3 .2 Semantic s 2 .1 .3 .3 Discourse Analysi s 2 .1.3.4 Text Analysi s 2 .1 .3 .5 Language Acquisitio n 2 .1 .4 Neuroscience 2 .1 .4 .1 Neurophysiolog y 2 .1 .4 .2 Action 2 .1 .4 .3 Human Vision 2 .1 .4 .4 Learning and Memory 2 .1 .4 .5 Hemispheric Differences 2 .1 .5 Philosophy 2.1 .5 .1 Ontology 2 .1 .5 .2 Epistemolog y At present, the section of normative models simply list s some of the more prominent approaches .
Operational semantics of a parallel object-oriented languageFinally, this kind of operational semantics could be a good basis to explore the possibility of automatic implementation of parallel languages by means of a interpreter (for example Kahn [Kahn 1985] translates transition systems in Prolog clauses). 207 5. REGGRENCN$ [America 1985a] Pierre Aazerica: Deffmition of the progranmng language POOLo'K ESPRIT project 4t5, Doc Nr. 0091, Philips Research Laboratories, Eindhoven, the Netherlands, September 1985.
An augmented context free grammar for discourseDefinite Clause Grammars [21], if decoupled from their commitment to Prolog programming, are also very similar. Generalized Phrase Structure Grammar[7], as well as related theories such as HPSG and LFG, share many aspects of our approach: ar emphasis on context free surface structure, and the use of a unification process to enforce the desired agreement and inheritance behaviour on the values of attributes.
"Decidability and undecidability results for boundedness of linear recursive queries$cl ence, Ithaca, J987, pp 106-l 15 [HN64] Hens&en, L J, Naqvl, S A On complhng quenes m rrcurslve first-ordrr databases J ACM 31( 1984), pp 47-85 [Im86] Immcrman, N RelatIonal qucrlcs com putable m polynomial time Injormalton and Conlro168(1986), pp 86 -104 [I0851 Ioanmdls, Y E A time bound on thr materlahzahon of some rrcurswely defined views Proc 11th Int'l ConJ on Larry Large Data Bacq Stockholm, 1985, pp 219-226 [JCV64] Jarke, M , Chfford, 7 , VasstI~ou, Y An optlmlzmg Prolog front-end to a relatlonal query system Proc ACM Conf on Management of Data, 1984, pp 296 306 [Ka86] Kanellaklq, I"" C Logw programmIng and parallel complexity In I,bundatzonr of Deductlue Databases and Logic Progmm mmg, J Mmker rd , (to appear) [Mo74] Moschobakls, Y N Elementary Induc tron on Abstract Structure, North Ilolland, 1974 [MUVSS] Marer, D , Ullman, 7 11, VardJ, MY On the foundatlonq of the nnwcrsal relation model ACM Tranq on Dalabayr Systems 9( 1984), pp 283-308 [Na86a] Naughton, J F Data Independent re cursJon m deductive databasrs Proc 5th ACM Symp on Prmrlplet of Dalabarp Systems, CambrIdge, 1986, pp 267 279 Full version - Stanford UmvrrsJty Twhnlc al Report STAN-CS-86-1102, to appear In J Computer and Systrm Srrrncrs [NaBGb] Naughton, J F Redundancy In Funrtlon-frre Horn clauses Proc IEEE Lvv 4 on Logtc I'rogrammtng, Salt Lake CJty, 1986, pp 236-245 [Na86c] Nanghton, J F Uptlmtzrng junrtlon free rccuratvp mfcrence rulrs Tcchmcal Rc port STAN-CS-86-1114, Stanford, 1986 [NS87] Naught on, J F , Sagw, Y A decldablr class of bounded recursions Proc 6th ACM Symp on Prrnclplec of Databare Syrtrnag, San Dlego, 1987, pp 227 236 [Sa85] Sagw, Y 0 n computmg rcstrictrd pro JcctJon9 of reprcsentatwe in9tancrs rroc 4th ACM Sy17np on I'rrnctplc~ oJ Ilatabaqe Sytlrmc, Porlland, 1985, pp 171 -180 [UT851 IJllman, J 1) Tmplrmentatwn of loglcal qnrry languagrs for databasrs A CM Trans on DnlnbncP Syrlemr 10(198!"
Unfounded sets and well-founded semantics for general logic programsA Horn rule ra one with no negative subgoals, and a Horn bgic program is one wrth only Horn rules. 0 In keepmg with Prolog's convention, logical variables begm with a capital letter We use the same symbol, e g , p, to refer to both a predicate and ita relation The arguments of a predicate are terms aa customarily defined in logic 1 A variable or constant ia a term. 2 A function symbol with terms as arguments is a term Terms may also be viewed as data structures of the program, with function symbols serving as record names.
Programming environments for highly parallel multiprocessorsThere is a tradeoff between efficiency and convenience which frequently occurs in programming languages. For example, languages such as APL, Smalltalk, Prolog, and Lisp are frequently more convenient for the programmer than more conventional languages such as Fortran, C or Pascal.
On the first-order expressibility of recursive queries.: Com puting with Logic: Logic PTogTamming with Prolog, Benjamin Cummings, 1988. [M074] Moschovakis, Y.N.: Elemen taTy Induction on A batTact &!
Expressiveness of restricted recursive queries.: Com puting with Logic: Logic Programming with Prolog. Benjamin Cummings, 1988. [Mo74] Moschovakis, Y-N.: Elemen tary Induction on Abstract Structures.
Arrays and referencesSuch a data structure is called a circular list in Lisp, or an infinite tree in Prolog.. SHOW (CDR (CDR L)) r!::l 2 rrml REFERENCES, ARRAYS AND THE STANDARD Let's come back to the APL Standard.
The limits of unificationPereira, Femando C. N. and Stuart M. Shieber (1987) Prolog and Natural-Language Analysis, Center for the Study of Language and Information. 16.
"A process-oriented approach to configuration managementThese c:onstraints are expressed as ""directed"" closed well-formed formulas written in a Prolog style, with references to the attributes of a version and of the versions derived from this version, before and after the events."
Market automation: self-regulation in a distributed environmentA formal representation of the rules for a simple auction written in Prolog, which can be readily reinterpreted for implementation in many other languages appears in 191.
Message pattern specifications: a new technique for handling errors in parallel object oriented systemsESSJSD's ESs are, by the authors' admission, very verbose and are not separated from the main specification in any way. ESSJSD's specifications are expressed in Prolog and then translated, implying some reliance on the logic paradigm.
Beginners' strategies in example based expert systemsS i m i l a r c l a i m s have been made f o r LISP and e s p e c i a l l y f o r PROLOG, b u t t h e s p r e a d s h e e t f o r m a t of a good r u l e i n d u c t i o n system i s much more f a m i l i a r t o t h e t y p i c a l domain e x p e r t than nested l i s t s The following sections detail our students have learned or Horn c l a u s e s . some of the lessons we and about the process of going from an initial idea of a system's suitable for translation into environment such as rules, goals to a working prototype a more general expert systems frames, or procedural code.
A transitive closure and magic functions machineThis allows a more general use of graph operations, which is better suited to the evaluation of knowledge base queries of the kind expressed using Datalog or Prolog syntax. The EDB is a Database Digraph (a digraph is a directed graph).
Generation as structure driven derivation., DSrre, J.: A Ixlcal FUnctional Grammar System in Prolog. In: Procredlng 8o] COL[NG 86, Bonn 1986 [Halvorsen 87] Halvorsen P.
Resource requirements of dataflow programsFunctional and other declarative languages such as Id, Miranda, ML and Prolog invariably require a heap storage model and insist on implicit storage reclamation.
Knowledge-based agents in a command and control simulationIn SARGE, we have knowledge sources implemented using LISP flavors [17], the WORLDS Prolog system [20], and an entire GBB subsystem developed separately.
An eductive interpreter for the language LucidIn execution speed the pLucid interpreter compares well wit h interpreters for Prolog or lazy functional languages . But it i s still slow compared to code produced by a Pascal or C compiler .
"One-sided recursions(ct.i IIg onc-sided reclIl'siol'IS, Jn I,his paper \ve, consider function-free pure horn ('Iallse definit.ions consisting of one linear recursive rule (that is, a rule in which UIC predicat.e in t.he onsequ(nt, a.ppears exactly once in the aut.ccedcnt) and SOBle arbit.ral'Y nonrecursive rule. We use Prolog synt.a.x, a.nd require that. the heads (consequent) of the rilles c,ontain ))0 repeat.ed variables and no constants. 1) Give a.ll variables in rules subscript 0, 2) S := 0, 3) CtuSt 7""ing:= t, 4) while t,ue do ("" S := S U{ (!"
"Extending logic programming. , t, are terms and f IS a function symbol A predrcute 1s a formula of the language that 1s of the form p (t), where p IS a predicate symbol with anty n (n20) and t IS a sequenceof n terms (arguments of the predlcute) A lrterul 1s either a predicate (posrtrve Irterul) or its negaclon (negutrve literal) A term, predicate or literal 1sground If it is vanable free Two hterals are complementaryif they are of the form A and -J , for somepredicateA In general, given a hteral A and a set of ground hterals X, -A denotes the complement of A and -X denotesthe set of hterals (-J 1B E X ) Moreover, X' (resp X-) denotesthe set of all positive (resp, negative) hterals m X Fmally, we say that X 1sconsrstentIf there are not two hterals A and B m X such that A = -8 A negutwe rule (or, snnply, a rule) 1s a formula of the language representedwith the usual Prolog's notation [L] as follows Qo-Ql> >Qm where Qo, , Q,,, are hterals, Qo IS the head of the rule, and QI, , Q,,, IS the body of the rule If QO1spositive then the rule 1s a seminegufrve rule, moreover, if also QI> 9 Qm are all positive then the the rule IS a posttrve rule (or Horn clause) Given a rule r, H (r ) denotesthe head of r and B (r ) denotesthe set of all hterals m the body of r A rule 1s afact d It has an empty body and 1sground if it 1s vanable free A negativeprogram 1sa set of rules If all rules are semmegahve (resp, positive) then the program is called a seminegutive program (resp, positive program) Let P be a negative program The Herbrand's Universe of P (denotedby HP) 1sthe set of all possible ground termsrecursively constructed by usmg constants and function symbols occurrmg m P The Herbrand's Base of P (denotedby BP) 1s the set of all possible ground predicates whose predicate symbols occur m P and whose arguments are elements of HP A ground rnstunce of a rule r m P 1s a rule obtamed from r by replacmg every vanable X m r by e(X), where @ 1sa mapping from the set of all vanables occurrmg m P to HP The set of all ground mstances of all rules m P 1s denotedby ground (LP ) An rnterpretutlon for P 1sany consistent subsetof Bp v -8~ Let I be an mterpretation for a negative program P, then T denotesthe set of predicates{A 1A e Bp, andneither A nor 4 1s m I) Note that, accordmg to the mterpretatlon I, a ground literal 1strue d and only if it IS memberof I, therefore, f contams all the elements of the Herbrand base for which no value has been assigned m the mterpretatlon (undefined elements)[FB, P3, SZ] An mtexpretatlon1stotal if T is empty For a positive or semmegatlve program P, those total mterpretabonsfor P that make true all rules m ground(P) are called total models and a total model M for P 1smmunal if there exists no other total model N for P such that M' 1sa proper subsetof N+ It 1sknown that a total model exists for every positive or semmegahve program, moreover, the mmunal total model of a positive program 1s unique and representsthe meamng of it [L, U] On the other hand, the notion of model cannot be easily extended to negative programs as mconslstency can now anse because of negative head predicates and there are many alternative ways to cope with mconsistency In &us paper, the semsnhcsof negative programs will be eventually explamed as a parttcular caseof a more generalclassof logic programs(orderedprograms) Defwtron 1 (a) An ordered program 1sa fimte parhally-ordered set of negative programs (called components)where `I"" 1s the parhal order (b) An mterpretatron for an ordered program m a com ponent C, 1s any mterpretahon of C,*, where C,* denotes the negative program (r 1r E C, and c, s c, ) cl Let P be an ordered program The restnctlon of ""I"" to all pairs of dtstmct components 1s denoted by `I<"", moreover, given two dlstmct components C, and C,, C, c> C, meam that neither C, < C, nor C, < C, Throughout all examples of thts paper, an orderedprogram P 1srepresentedby a pan cC,L> where C 1sthe set of componentsand L 1sthe relahon ""<"" Fmally, given a rule r m ground(C,*), C(r) denotesthe component C, contnmng the rule of whch r 1s the ground mstance If a rule occurs m more than one component then we assumethat it has dishnct ground mstances so that C 1s actually a funchon from ground mstancesto components Every component C, of an ordered program can be thought of as a module or object with local rules (thus those defined m C,) and wtth global rules (thus those defined m all other components C, such that C, < C,). where local rules may hde (overrule) global m1e.s The ""4' relation 1sa sort of Isa hierarchy for the components and provide the ground for mherltance It turns out that a predicate can be defined m different ways m the various components,thus the program P has severalmeamngs,one for eachof its components Example 1 Consider the ordered program P1 of Figure 1 To the best of the knowledge of Cl, the penguin IS not a ground urwnal and flies whereasthese facts are contradicted m C, On the other side, C1 can mhent a rule from Cz to mfer that thepIgeon flies 0 Defmltlon 2 Given an mterpretahonI for P m C,, a rule r m ground (C,*)is appluxble if B (r ) E 1, applred if it IS applicable and H (r ) E I, blockedIf there exists A m B (r ) such that -A E I, overruled d there exists a non-blocked rule i m ground (C,*) such that C(i) c C(r), and H(i) =-J?"
Constructs and evaluations strategies for intelligent speculative parallelism—armageddon revisitedSEARCH CONCEPTS In existing systems, search procedures either have to be laboriously described using a non-search oriented language (such as LISP) or they are built into the programming language and then the user or programmer cannot easily specify a different search strategy from the one provided. For instance, Prolog has a built-in search procedure which is depth-first.
Delirium: an embedding coordination languageCoordination Languages Lawzww Coordination Model Notation Delirium restricted shareddata embedding ADA rendezvous embedded OCCAM protocol embedded RPC protocol embedded Linda shareddatabase embedded Concurrent Prolog shad variables radiC.Sl ALFL shared data AiCal EnhancedFortranK task-oriented embedded Emerald/Sloop protocol embedded Table 2: Coordination Model Comparison 9 A Critique of the Model We have shown how to implement some common types of applications while operating within these boundaries.
"A finite presentation theorem for approximating logic programsShapiro, ""A Type System for Logic Programs"", in Concurrent PROLOG: Collected Papers, Vol. 2, MIT Press, pp 211- 244, 1987. . @ 1990 ACM 089791-343-4/90/0001/0197 $1.50 197 198 199 200 201 202 203 205 206 207 208 209"
On the expressive power of datalog: tools and a case studyPapadimitriou, A note on the expressive power of Prolog, Bulletin of the EATCS 26, 1985, pp. 21-23. 0.
An incremental constraint solverSeveral such languages have now been implemented, including Prolog III [7], CLP(W) [19, 231 and CHIP [S, 201. Most of these systems include incremental constraint satisfiers, since constraints are added and deleted dynamically during program execution.
"On the modes and meaning of feedback to transaction designersThe actual mechamsm for findmg the solution 1s 3The undecldablhty of higher-order umficatron ISnot an 1331x here We merely pattern match this vanable wth our fimte lemma base PROLOG-lrke and ~111be Illustrated m the followmg set t1ons 3.1 Deleting down a hierarchy One common example of update propagation ISa Lerar thy m which one deletion must give ruseto others Consider the previous example m which contamment of r2 m rl IS part of a hierarchy The transaction conslstmg solely of the deletion of an element of rl as before gives rise to the test (not (member a r2)) Now we rewrite the above, replacing sets (r2 m the above example) by variables and attempt to find bmdmgs for which It can be proven to be true The lemma (not (member x (delete x r))) unifies with the answer r2 + (delete a r2), and this says that an additional update to relation r deleting the element a from the smaller set r2 would make the transaction safe Consider the casewhere the constramt 1sreferential m tegrlty, specified by our higher-order function refer ' (refer rl Icl r2 fc2) which meansthat the proJection on the ICI attrlbute of the rl relation must contam the proJection on the 1~2attribute of the r2 relation Now given a transaction that attempts to delete an element from rl, we need to prove (refer (delete a rl) Icl r2 tc2) -+= (refer rl Icl r2 fc2) Using a rewrite rule, the followmgresldual term ISobtained (if (member (`cl a) (project r2 1~2)) (member (1~1a) (project (delete a rl) `cl)) true) or, in clausal form (not (member (`cl a) (project r2 `~2))) V (member (`cl a) (project (delete a rl) `cl)) Now the system attempts to backcham from each hteral, disregarding those m which the only updated set 1srl The idea behind the heurlstlc ISthat since the user has specified this particular update, the one he/she mIssedmust 4Thls function IS more general than needed by refemtml mtevtY affect someother relation Note m the caseof real referen tial mtegrlty as m our Job-agencyexample, `cl would be a key on rl and so the second hteral would be false and can be eliminated The lemma that the first literal unifies with IS the followmg (not (member x (pro+ (remove s f x) `4 where (f x y) = (equal (tc x) y) This lemma states that after removal from a set of all tu ples whose c-attribute IS equal to x its proJection on the c-attribute does not contam x Unification binds x to (1~1 a), Ic to `~2, and the suggested bmdmg for r2 gives the suggestedupdate (remove r2 h (`cl a)) where (h x y) = (equal (`~2 x) y) In other words, an update that, d added, would cause the constraint to be obeyed IS the removal from r2 of tuples whose c%-componentIS equal to the cl-component of the deleted rl-tuple 3.2 Additional Updates: Use of Meta-lemmas The mechamsm for update propagation becomesmore complicated when meta-lemmas are involved The basic idea ISthat the conclusion of the meta-lemma suggeststhe update and the meta-hypothesis gives us the constramts on the variables involved m the update Consider the constramt m the Job-agency example de scribing that the placed field of every person m the persons relation IStrue d and only d that person ISIncluded m the placementa relation This constramt IStranslated using the redun function (Recall that the expression (redun rl tf Ig r2) meansVxErl If(x) = tg(x,r2) ) m the followmg way (redun persons placed g placements) where (g x r) = (member (pld x) (project r pld)) This means that V pEpersons p placed 3 (p pld E project (placements, pld)) Supposea transactIon only changesa certam person's (whose pld equals name) placed field to true, leavmg out the mser tlon mto the placements relation, we begm examining the updated integrity expression (redun (update persons transf pred) placed g placements), where (transf x) = (person (pld x) (pname x) true)s, (pred x) = (equal (pld x) name) Now, exammmg the meta-lemmas, we find the following (redun (update rl It `p) `f fg (insert newtuple r2)) = true cz (redun rl If Ig r2) The meta-hypothesis ISgiven by Vx'xErl (If (`P x) (lg (It x) (insert newtuple r2)) = (If (`t x)) (fg x (insert newtuple r2)) = (tg x r2)) The consequent of the meta-lemma says that the redun constraint 1smamtamed under an update to rl and an m sertlon to r2 provided the meta-hypothesis IS vahd This meta-hypothesis requires that whenever the update to rl changesa tuple x to (ft x), the relation between the tg func tion and the ff function holds, and for those tuples that are unaffected by the update, the tg function IS unaffected by the insertion mto r2 Since this meta-lemma IS a candl date for suggesting additional updates, its meta-hypothesis ISexamined If a contradiction emerges,then it ISrejected, otherwise it yields some (sufficient) constraints on the un known data elements (newtuple) involved m the additional update (insert) suggested by this meta-lemma The else part of the hypothesis does not lead to useful constraints, but the then part leads to"" 6person w the function whkzh constructs a tuple of person tuple 6We wll report on the constramt srmplderelsewhere (member name (insert (pld newtuple) (proJect placements pld))) This suggests that safety can be attamed through the mcluslon of an update that inserts mto placements a tuple newtuple meeting the above constraints 4."
Modeling the software architecture of a prototype parallel machineThe intended application of the machine is speech understand|rig in (almost) real-time, trying to exploit the intrinsic parallelism of M-oriented languages like Lisp and Prolog [4]. The application algOfithm will be composed of a set of concurrent OCCAM [5] (the machine hmguage of the Transputer, derived from Hoare's CSP [6] ) processes, which am automcally distribmed among the Prof.
Using tolerances to guarantee valid polyhedral modeling resultsRandolph Franklin, Peter Y.E Wu, and Sumitro Samaddar. Prolog and geometry projects. IEEE CG & A 6,11 (November 1986), 46--55. [6] Leonidas Guibas, David Salesin, and Jorge Stolfi.
Specification level interoperabilityWe are currently working on bindings for C, C++, and Prolog. C++ in particular should exercise the UTM notions of inheritance and subtyping.
Knowledge-based monitoring and control: an approach to understanding behavior of TCP/IP network protocolsThe first was a procedural implementation (coded in C) and had only a limited range of knowledge from which to make its lirntited recommendations.4 The second was a logic-based implementation (coded in Prolog), it was used to further develop the types and amount of knowledge available to the program.
Type inference and semi-unificationRiIycroft and R. O'Keefe. A polymor phic type system for prolog. Artificial Intelligence, 23:295-307, 1984. [MP85] L.
Constraint-based hypertext for argumentationFigure 15 gives part of the definitions of the constraint schemata used, using a Prolog-like notation in which the names of variables begin with uppercase letters.2 The preceding discussion has treated display constraints as hard constraints: predicate-calculus-like propositions that would presumably have a truth value of either true or false.
Relational specifications of infinite query answersWe should note that it computes only the repetitive part of the specification. We use a Prolog-like notation. The second and fourth clauses should be repeated for any non-constant function symbol f appearing in 2.
CommonLoops: merging Lisp and object-oriented programmingA user who wants to add such methods to CommonLoops can do so by defining a special method class and using the method-lookup protocol to specify method-lookup rules. different We believe that handling incomplete type specifiers and the possible resolutions (backtracing, unification, 26 production system rules) is a fertile area for language design and research, and perhaps a foundation for a graceful merger of Lisp, Prolog and production systems. Structural versus Procedural Views of Objects The object-oriented programming community is split on the issue of whether the specification or interface description of a class of objects should be strictly procedural, or whether it should be split into procedural and structural parts.
A parallel language and its compilation to multiprocessor machines or VLSICompared with other high-level programming environments that allow parallel implementations such as Shpiro's systolic programming in Concurrent Prolog [20] and Snyder% Poker programming environment, Crystal goes one step further by automating the process of decomposing computations co par-Mlel processes.
"The input/output complexity of transitive closure.- arc(V,W) path(V,W) - path(V,X) & path(X,W) (12) Here, we use Prolog notation, and the two rules are read ""there 1s a path from V to W d there IS an arc from V to W,"" and ""there 1s a path from V to W If there exists a node X such that there 1s a path from V to X and a path from X to W "" Semmalve evaluation applies the rules repeatedly, starting from the data (the arc facts), and gettmg successive approxlmatlons to the path facts In semmalve (as opposed to naive) evaluation, care 1s taken that when applymg a rule, at least one of the facts m the body (right side) IS ""new,"" m the sense that It was Just discovered on the prevlous round Semmalve evaluation might not look at facts for every triangle, for example, It would not If the set of arcs were empty However, If the set of arcs 1sa complete graph, then on the second round, the recursive rule finds all path facts ""new,"" and attempts to apply the recursive rule 111all possible ways Then, all triangles {V, X, IV} of path facts will appear simultaneously m memory, when the recursive rule 1s apphed to that triple of nodes (m any of the six orders) Similarly, we might use either of the two hnear forms of the recursion for transltlve closure Semlnaive evaluation of the rules path(V,W) - arc(V,W) path(V,W) - arc(V,X) & path(X,W) (13) or the rules 3 See Urnan [1988] for a dxcuss~on of semmave evaluation path(V,W) - arc(V,W) path(V,W) - path(V,X) & arc(X,W) (14) are standard algorithms Here, the triangles each involve two path facts and an arc fact, but there 1s nothmg m the defimtlon of ""standard"" that requires the facts all be path facts Ale there algonthms m use that are not ""standard"" m our sense?"
Recent AI-Related DissertationsUniversity of Aberdeen (United Kingdom) Ph.D. 1988,230 pages. PERSISTENCE AND MODULARITY IN PROLOG. DAI V50(04), SecB, pp 1508. University Microfilms Order Number ADGDX-85559.
"Service specification and protocol construction for the transport layerUral,""Executable description of the OSI Transport Service in Prolog,"" Protocol Specification, Testing, und Verifications, IV, 1984, North-Holland, 1985."
"Integrating object-oriented data modelling with a rule-based programming paradigm65S/90/0005/0225$150 The feaslblllty of such an approach has been shown by many authors, mostly at a theoretical level [BeerBB,Ablt89,KlWu 89) This paper presents an overview of LOGRES , a novel approach to the integration of obJect-orientation and rule-based programming paradigms for databases The proJect LOGRES 1s currently under development at the Pohtecnlco dl Mllano as the follow-up of ALGRES [CerlBB,CCLLZ89], a main-memory based programming environment supportmg an Extended Relatlonal Algebra The mam features of LOGRES are summarized as follows The LOGRES data model 1s based on the objectorlented approach, it supports classes of objects, with generahzatlon hierarchies and obJect sharing These features take advantage of the mtroductlon, at the instance level, of obJect-Identifiers (olds) However, the LOGRES data model supports also conventional and extended relations, similar to those supported by ALGRES [UllBB,CGT89] The static structure of a LOGRES database 1s based on the use of type equatzons, which satisfy several structural properties, m particular, the consistency of legal database states IS dictated by a collection of antegtaty constraants, which are automatically built from type equations Integrity constraints are expressed using the standard rule-based programmmg language The user language of LOGRES IS rule-based, it extends Datalog to support sets, multlsets, sequences, and controlled forms of negation Through the rule-based paradigm It 1spossible both to perform queries and updates [Ablt88a] Further addltlons to Datalog enable old umficatlon, though olds are not vlslble to users The LOGRES system supports modules, a module 1s a collection of type equations and rules In partzcular, the evolutaon of a LOGRES database IS ob This work 1s supported by the Esprit Project P2424, Stretch, and by the Prolect Logldata+ of the National Research Council of Italy tamed through sequences of apphcatrons of update modules to exrstmg LOGRES database states l When specrfymg the apphcatron of a module to a LOGRES database, the user specifies the mtended mode ojapplacatron, which dictates the srdeeffects of the module apphcatron on the LOGRES database, modes of apphcatron mdrcate as well the particular semantics that should be given to rules (e g mflatronary vs non-mllatronary), with thus mechamsm, LOGRES modules and databases are parametrrc wath respect to the aemanttca of the rules they support This collectron of novel features makes LOGRES an ideal setting for testing varrous mnovatrve Ideas, ALGRES provides a fast prototypmg envrronment In particular, the very hberal structure of the closure operatron m ALGRES makes rt possible to change the semantics of rules very easily We plan to prototype LOGRES upon ALGRES, though rather mefficlently, by mtroducmg the notion of olds above ALGRES This paper presents the varrous features of the LOGRES prolect the data model (Section 2), the rulebased language (Section 3) and modularlsatlon (Sectron 4) Each sectron IS structured by mcludmg an overview and a comparison with recent approaches presented m the literature, which highlights the novel features of LOGRES, formal defimtrons of the data model and the rule-based language are m Appendrx 2 Data Model In this section, we grve a descrrptron of the LOGRES data model The fundamental chorce of the data model 1s to have both relatrons (called assocaatrons m LOGRES) and classes therefore, LOGRES integrates value-oriented models for complex oblects, and pure object-oriented databases Our approach 1s similar to that of the language IQL of [AbIt additional LOGRES features mclude multrset and sequence type constructors, the handlmg of multiple mherrtance, the generatron of active referential integrity constraints from type equations, the use of data functions A more completed comparison with IQL and other approaches 1s made m Sectron 2 2 2.1 Overview A LOGRES database includes classes and aaaoctat~ona, theu schema 1s defined by LOGRES type equatrona Classes are sets of obJecta, each object has a unique object rdentajier (oad), old's are managed by the system, and not vlsrble to users Assocratlons are sets of tuples, usual NF2 relations are examples of assocratlons Ob-Jects can be shared, at the mstance level, obJect sharing IS provided by old's Assocratrons include classes, while classes cannot include assocratrons, at the mstance level, this 1sobtained by mcludmg old's wlthm tuples of assocratrons Tuples are collectrons of attrrbutes and old's, legal values for attrrbutes are defined by domarn equatrons These equations may include classrcal burlt-m elementary types, such as rnteger, atrrng Classes or associations may be extensions of predrcates m the LOGRES query language, while domams may not, m essence, domams can be used as type constructors, but they are not first-class crtrsens of the LOGRES world The drstmctron between classes and assocratrons 1s needed, for a number of reasons m first place, classes introduce obJect sharing and inheritance m the LOGRES data model and assocratrons preserve conventional and NF2 relatrons mto rt In addrtron, not all data items deserve the status of an obJect, m partlcular, results of queries are typically assocratlons Frnally, since elements of a class are always dlstmgmshed by therr old's, we do not have the posslbrhty of removmg undesrred duphcates, because a class never contaana duplrcatea Thus, we need assoclatrons for those computatrons where ehmmatron of duphcates 1s needed (e g fixpomt computations) In a LOGRES database, each domain, assocratron, or class 1s defined through its own type equataon A type equatron has the form LHS = RHS where the LHS 1sthe name of the type being defined and the RHS 1sa list of type constructors and other types, each of which IS a basic type or appears as the LHS of one equation Names of types m the RHS must be unique, a labellang mechanasm allows for including two or more occurrences of the same type m the RHS of one equation, each labeled by a different name Whenever needed, labels can be used to drstmgursh among two or more occurrences of the same type m the RHS of type equations Type equations express the notion of domaan refinement the domain of the type on the LHS 1sa subset of the domain of the type constructed on the RHS Thus, every type equation defines the schema and the domaan of the LHS type, namely the structure of its elements and the values that are compatible with the schema, further, type equatrons also drctate the actaue domaan, or anstance, of the LHS type, namely the set of elements of that type present m a grven state of the database The active domam 1s the range of the Imphcrt quantlfiers present mto a rule This assumption IS very useful when we have negated hterals m the RHS of a rule we assume that variables which are only present m negated hterals be restricted to then current actrve domam If the class T2 1s referenced m the RHS of the type equation of the class Tl, then at the mstance level we Impose that the old of the obJect of type T2 must be set to that of an exlstmg object of the class T2 (whrch 1s ensured by the system through an actaue referential antegraty conatraant), or be the nal value, whrch 1sa legal value for old's of any type In contrast, we do not accept nal old's within assoclatlons each assoclatlon mstance must refer to ezaatang objects Types can be built by using the followmg type constructors a TUPLE (or record) constructor 0, b SET constructor {}, c MULTISET (set with dupbcates) constructor [] d SEQUENCE (ordered set) constructor <> A tuple constructor allows mtroducmg internal labels mto type defimtlons, for mstance If we want the internal record (T2,T3) to be labeled N, we have T = (Tl, N (T2, T3)) Example 2.1 The following type equatrons define the schema of a football database Note that Score 1s a complex domain burlt as a tuple of two Integer values, each Player can have a set of roles, a Team mcludes a sequence of base-players and a set of substitutes Player and Team are modeled by classes, while Game 1smod-eled by an assoclatron Domains section NAME = STRING ROLE = INTEGER DATE = STRING SCORE = (INTEGER, INTEGER) Classes section PLAYER = ( NAME, ROLES { ROLE } ) TEAM = ( TEAM-NAME, BASE-PLAYERS < PLAYER >, SUBSTITUTES { PLAYER } ) Aesociation section GAME = ( H-TEAM TEAM , G-TEAM TEAM, DATE, SCORE) 0 Set valued functions (cfr [AbGr88]) are included m LOGRES, as a shorthand notatron for assocratrons A functron 1sdeclared as follows F Tl - 7'2 where TI and T2 are previously defined types, and T2 1s a set type, 1e T2 = {Ta} for some type T3 Nullary functions (functions with 0 arguments) can be used for namang the extensron of a type Example 2.2 As an example, we declare the function CHILDREN, based upon the assocratron PARENT, as follows (we anticipate from the next sectron the rule defining the functron's body) An Functiona section CHILDREN PERSON - { (PERSON, BDATE) } member(T,CHILDREN(X)) + PARENT (FATHER X,CHILD Y, BDATE Z), T=(PERSON Y, BDATE Z) example of nullary functron 1sthe followmg Fkmctions section JUNIOR - { PERSON } member(X,Junior) + person(X, age A), A 5 18 cl Generalization hierarchies (iea relationships) are extabhshed between classes with the usual meanmg A generalmatron 1sexpressed m the type defimtlons by adding the statement TI asa T2, which means that each object of the class Tl also belongs to the class T2, hence, the class Tl 1s a subset of the class T2 For mstance, the followmg type equations provide a legal defimtron of a generallsatlon hrerarchy, m whrch, by vrrtue of the classic mhentance property, we may regard BDATE and ADDRESS as propertres of STUDENT PERSON = (NAME, BDATE, ADDRESS) STUDENT = (PERSON, SCHOOL) STUDENT rsa PERSON Labels may be needed to drstmgulsh among several mstances of the same type m the RHS of a type equatron, for instance EMPL = (emp PERSON, manager PERSON) EMPL emp ISA PERSON At the mstance level, we model generahzatlon hlerarchres by msertmg the old's of sub-classes wrthm the old's of the super-class Thus, If John 1s a student, he has a unique old which 1sused both wlthm the PERSON and the STUDENT classes Multiple inheritance 1s also allowed, namely, the possrbrhty of declarmg a class as a subset of two or more classes However, we only allow multiple inheritance among classes which share a common ancestor, as we do not postulate the exrstence of a umversal class As a consequence of this constraint, the universe of all old's 1s partitioned mto disJomt subsets, such that each subset 1s the root of a (possrbly empty) generahzatron hierarchy A renaming pohcy 1sprovided m order to solve conflrcts m multiple mherltance Object sharing 1s used whenever the type equatron of a class contams another class mto Its RHS An object may be contamed into one or more obJecta, as illustrated by the followmg example PROFESSOR = (PERSON, COURSE, SCHOOL) SCHOOL = (NAME, ADDRESS, KIND, DEAN PROFESSOR) Assoclatlons cannot contam other assocratlons Thus, the RHS of type equations of assocratlons may only melude classes or domams 2.2 Comparison with related approaches NF2 models have mtroduced structural complezaty wrthm value-based models, In contrast, obJect-orrented data models have introduced the concepts of adentaty, obJect aharang, anheratance Both these mgredlents have been selected for the LOGRES data model Several works treat these models and then declarative semantrcs formally, the LOGRES data model follows and extends the ideas of [KV84,Mar86,KrWu 89,Abrt89] Dlfferences between the first three approaches and the LOGRES data model are evident LOGRES has strong typmg and allows statlcal type-checking, as m the relational model, there 1s a clear separation of the notron of instance and schema Instead, m [Mar86,KrWu 891 there 1sno mstance-schema separation, query languages m the above proposals can be consedered as untyped extensrons of Prolog LOGRES 1s also drfferent with respect to ""flat"" object-oriented data models such as (KV84], because rt includes assoclatlons and complex type constructors LOGRES shares the same basrc assumptions as IQL [Abrt89], but rt doffers m a number of features LOGRES uses data functrons, whrch have been mtroduced wrth two mam purposes performing nestmg and unnestmg operations (see example 3 2 below), and allowing a more drrect apphcatron of anheratance polymorphaam (cfr [CardSa]) In contrast, IQL uses obJect rdentitles for mampulatmg set types, and thus leads, m our opmron, to less readable and declarative programs In LOGRES, umon types are not present and mherrtance 1shandled duectly, m IQL mherrtance 1shandled mdrrectly, through umon types Finally, LOGRES extends the use of type constructors to multlsets and sequences 3 Rule-Based Language The rule part of LOGRES 1s a typed extension of Datalog, intended to be complete both for queries and up dates Features of the rule-based language mclude a determmlstrc semantics, negation m the body and m the head of rules, data functrons, complex (typed) vanables and creatron of objects through the mventron of new old's Two drfferent semantrcs can be assrgned to LOGRES programs, thus obtaining two different (mflatlonary and nonmtlatlonary) languages, m this paper, we describe only the mflatlonary semantics The expressive power of these languages 1sstudred m [Ablt88a] (where also the nondetermmrstrc case 1sconsidered) and then prop&lea are investigated m [AbSr89] 3.1 Overview The structure of a LOGRES rule 1sthe followmg LCLl, ,Ln where L, L1, , L, represent posrtrve and negated hterah., each hteral may mclude variables of three kinds a Ordmary, typed variables, they are labeled by then type name b Old variables, defined only m the context of a pred icate correspondmg to a class These variables are labeled by the language keyword self Values of these varrables are not vlsrble to the user c Tuple varrables, correspondmg to collectrons of or dinary and old variables In particular, tuple varrables defined for a class include the old of the class, though this part 1s not vlsrble to the user These varrables are not labeled Laterals may also include constants, of approprrate domams, constants are labeled by then type name Unification 1s legal between constants and variables of compatible types, two types are compatible If one IS obtained as a refinement (see Appendrx A) of the other one Suppose a tuple variable rs used wrthm a predlcate and also the old and other ordinary variables are named Then, when the old and ordinary variables get bound, the same bmdmgs are propagated to the corresponding arguments of the tuple variable Not all the arguments of a predrcate need to be present m a rule, however, no literal without arguments 1s allowed, If rt refers to a non-0 argument predicate We will discuss safety requrrements below Example 3.1 Consider the followmg set of type equations (where domam declaratrons are omitted) Classes set tion PERSON = (NAME, ADDRESS) SCHOOL = (NAME, ADDRESS, KIND, DEAN (PROFESSOR)) STUDENT = (PERSON, STUDSCHOOL SCHOOL) PROFESSOR = (PERSON, COURSE, PROFSCHOOL SCHOOL) STUDENT Isa PERSON PROFESSOR Isa PERSON Association section ADVISES = (PROFESSOR, STUDENT) The followmg are examples of legal LOGRES predicate occurrences 1 person(name Smith, address X) 2 person (self X) 3 person(X) 4 person(name X,Y,self 2) 5 school(dn-ector(self X)) 6 advlses(professor X) 7 professor(X) The followmg varrables and constants umfy 1 Variable X m Ime 4 and constant Smrth m Ime 1 2 Varrable Y m Ime 4, variable X m Ime 3, variable X m Ime 6, and variable X m Ime 7, 3 Varrable Z m Ime 4, varrable X m hne 2, and variable X in line 5 Cl The above example has shown that all arguments of predicates can be referenced by appropriate use of labels and parentheslzatlon In an assoclatron Tl which has a class T2 mto its type equation, we can reference the class Tz erther through an old or by a tuple variable, thus, the followmg cases are equivalent Association section PAIR = (P-NAME NAME, S-NAME NAME) pazr(X, X) d- pro jessor(X1, name X), student(Yl,name X), advtaea (Xl, Y 1) pazr(X, X) 4- projeaaor(aelj Xl, name X), atudent(aelj Yl, name X), adrnaea (Xl, Y 1) Notice that variables Xl and Yl are tuple variables m the former case, old variables m the latter A particular 
mterpretatlon of old variables must be given with generalazataon haerarchaea Let Cl and C2 be classes with compatible types and consider the rule Cl(Y) t- C2(X) Here two cases are possible a Neither Cl aaa C2 nor C2 aaa Cl hold, then, the rule IS considered legal, for each object of class C2, a new object of class Cl IS created, with the same values as those of C2 and with a new old b Either Cl zaa C2 or C2 aaa Cl hold, then, smce two obJecta in a generahzatlon hierarchy must have the same old, Y 1sunified with X Consider now the rule Cl(X) +."
Draft report on requirements for a common prototyping systemAlthough it is felt that it is unlikely that any one existing language or environment meets all the stated requirements in its current form, it is clear that a number of languages and environments, including for 12 Common Prototyping System Draft Nov 12, 1988 13:29 example Lisp, Prolog, SETL, APL, SmallTalk, ML, and others meet many of the requirements. Most such applications have been built in Lisp, Prolog, shells built upon them, or in other special purpose languages.
"Type theories and object-oriented programmimgAlthough these terms are used to represent objects, there is no attempt to hold methods within these terms, the functions and Prolog-like relations that perform or guide computations are kept separate from the first-order terms manipulated and created by these computations. The correspondence of +-terms with first-order terms and of q-term unification (i.e., the glb operation on q-terms) with unification on first-order terms naturally suggests an extension of Prolog that makes use of Q-terms. The resulting language provides an excellent example of straightforward and theoretically sound integration of Type Symbol Orderings: student 5 person Austin 5 cityname Dallas 5 cityname ""abc"" < string ""einstein"" 5 string q-terms: t1 = student( id => name(last => X:string), lives-at => Y:address(city=>Austin), father => person(id => name(last => X), lives-at ==> Y)), t2 = person( id => name, lives-at => address(city => cityname), father => person), Resulting Q-term Ordering: t1 5 t2 Figure 17. q-term inclusion. inheritance with logic programming [Ait- that have been put forth for types in OOP Kaci and Nasr 19861."
A graphics interface for linear programmingA matrix and solution file analyzer (ANALYZE The LPFORM system consists of some 6000 lines of PROLOG code [?`I. The graphical interface was developed on an IBM PC/AT using a package of graphical interface development routines (EVA UIMS/GDB [ll]). 4.
A french text recognition model for information retrieval systemOne first version of this analyzer was written in PROLOG, a language which allows one to remain very close to the expression of the linguistic model.
"Cost/benefit analysis for incorporating human factors in the software lifecycleCorrigenda The following corrections have been made to the Computing Practices article, ""Normalization of Relations and Prolog,"" by Stefano Ceri and Georg Gottlob, that appeared in the June 1986 issue of Communications."
DIB—a distributed implementation of backtrackingConsiderable work is being done in designing distributed and parallel languages for different models of computations. Examples are Lynx [23], Prolog [24], Multilisp [ll], and Linda [lo]. Most of these efforts include work on efficient implementation of specific parallel algorithms that are required for implementing the language.
Acquisition of semantic patterns from a natural corpus of textsA preliminary version of the PETRARCA system has implemented in VM/Prolog on an IBM mainframe, and interfaces with the DANTE system for morphosyntactical analysis and derivation of phrasal patterns. 2.
Incorporating hierarchy in a relational model of dataHowever, through the use of logic programming, such as PROLOG or DATALOG, on top of out hierarchical data model, we are able to provide an even more powerful inference mechanism with no loss of succinctness.
The software lifecycle with Ada: A command and control applicationHe has also accomplished software development in the area of 3-D flight simulator graphics (C and IRlS graphics language), expert systems (Prolog), simulation modeling (SIMSCRIPT), and database design (CODAYSL).
"Global query optimization~, an Rklataonal Database Systems"", In Advances an Data Base Theory, vol 1, H Gallau-e, J Mmker and J -M Nlcolas, Eds , Plenum, New York Guttman, A, ""New Fkatures for Relataonul Database Systems to Support wJJ741 [=7f31 [IOAN86] CAD Applzcataons"", PhD Thesis, Umverslty of Cahforma, Berkeley, June 1984 Hall, P V , ""Common IdentafScataon an Subexpresszon General Algebraac Systems"", Tech Report UKSC 0060, IBM United Kmgdom Sclentlfic Centre, November 19'74 Hall, PV, ""`@tamazatzon of a Single Relataonal &pressaon an a IWataonal Lkta Base System"", IBM Journal of T,,arch and Development, (20) 3, May Ioanmdls, Y , Trocessang Rxursaon an Databases "", PhD Thesis, Umverslty of California, Berkeley (in preparation) [JARK84a] Jarke, M , Chfford, J and Vasslhou, Y , ""An qPtamazan.g PROLOG F+-ont-end to a hklatamal Query S&stem': Proceedmgs of the 1984 ACM-SIGMOD International, Conference on the Management of Data, Boston, MA, June 1984 [JARKEMb],,o,kecenM , ""Common Subexpressaon an Multaple Query @tamazataon"", In Query *ocessmn.g an ktabase astems, W Knn, D Remer and D Batbry, Eds , Springer-Verlag, New York [KIM84] [ KUNGl34] [LARS85] [RICHES] [ROUSSZa] fim w, ""Global ~tamazataon of Relataonal Querzes A First step "" In Query Bocessang an Database Systems, W Ku-n, D Remer and D Batory, Eds , Springer-Verlag, New York Kung, R et al , ""Heunstac Search an Data Base Systems"", Proceedings of the 1st International Conference on Expert Data Base Systems, Kawah Isl, SC, October 1984 Larson, P and Yang, H , `Computzng Queraes from lknved l&lataons"", Proceedings of the 11th International Conference on Very Large Data Bases, Stockholm, August 1985 Rich, E , ""Artajkaal Intellzgence': McGraw-Hill, 1983 Roussopoulos, N , ""View Indexang an Relataonal Databases"", ACM Transactions on Database Systems, (7) 2, June 1982 [ROUS82b] Roussopoulos, N , ""ti Logacal Access Path Schema of a Database "", IEEE Transactions on Software Engineering, (8) 6, November 1982 [ RTI84] EQUEL/C User's tiz&, Version 2 1, Relational Technology, Inc , Berkeley, CA, July 1984 [SELJ79] Selmger, P et al, `Access Path Selectaon an a Relataonal Ada &se System"", Proceedings of the 1979 ACMSIGMOD International Conference on the Management of Data, Boston, MA, June 1979 [SELL85a] Sellls, T and Shapiro, L , `Optzmzzatzon of Extended Database Languages"", Proceedmgs of the 1985 ACM-SIGMOD International Conference on the y,,,gement of Data, Austin, TX, May [SELL85b] Selhs, T , ""Optzmzzzng a Set of Relatzonal Expressaons': Manuscript, [SELL%] [ STON76] [ ~~0~651 [ULLM82] [ULLM65] University of caldorma, Berkeley, June 1985 Selhs, T , ""Optamzzataon of &tended Relatzonal Database Systems"", PhD Thesis, University of California, Berkeley (m preparation) Stonebraker, M et al , ?"
Automatic generation of fixed-point-finding evaluators for circular, but well-defined, attribute grammarsAddison-Wesley, 1977. Bijan Arbab. Compiling Attribute Grammars into Prolog. IBM Los Angeles Scientific Center, July 1985.
Query processing in main memory database management systems&man Mchael J Carey Computer Sctenccs Department Untversity of Wisconsm Ma&son, WI 53706 Most pmv~ouswork m the ama of mam memory databasesystems has focused on the problem of developing query processmg techmoues that work well wnh a very large buffer pool In thus paper,-weaddressquery processmgissues for memoryresrdent relauonal databases,an envuonment wrth a very dtfferent set of costs and pnonues We present an arclutectum for a main memory DBMS, discussing the ways m whtch a memory resident database differs from a disk-based database We then addressthe problem of processmgrelauonal quenes 1nbus archttecture,cons1denngaltema-t1ve algonthms for seleetron, pmpecuon, and Join opemnons and studying then performance We show that a new mdex structure, the T Tree, works well for selectton and JOM processing in memory restdent databases We also show that bashmg methods work well for processmg pro~cttons and JOUIS. and that an old Join method, sort-merge,shll hasa place m mam memory 1 Introductron Today, medmm to hrgh-end computer systems typmally have memory capacmesm the rangeof 16to 128megabytes, and1t1spro-Jetted that chp densmeswill contmue their current trend of doubling every year for the foreseeable future [Rs86] As a result, It IS expected that mam memory sizesof a ggabyte or mote will be feasible and perhaps even fanly common wuhm the next decade Some researchersb&eve that many apphcaaons wuh memory requuements whtch currently exceed those of today's technology wtll thus become memory restdent apphcauons 1n the not-too-dntant future [GLV83], and the databasesystems area 1scertam to be affected 1n some way by thesetrends Pmv~ousstudies of how large amountsof memory will affect the design of databasemanagementsystemshave focused almost entuely on how to make use of a large buffer pool [DK084, DeG85, ElB84, Sha86] With memory stzes growing as they am, 1t ISqtute 11kelythat databases,at least for some apphcauons, will eventually fit enurely Thisresearchwasparttallysupportedby soIBM FellowshIp,anIBM Faculty DevelosmentAward,and NattonalScrwceFoundauonGrantNumberDCR84028l-8 PermIssIonto copy wtthout fee all or part of this matenal ISgranted provtded that the copiesare not madeor dtstrtbuted for dnect commerctal advantage,the ACM copynght nottce and the tttle of the pubheatronand its date appear, and nottce ISgrven that copymg 1sby permtsstonof the Associatronfor Computrng Machmery To copy otherwtse,or to repubhsh, reqmresa fee and/or spectfic permtsston 0 1986 ACM 0-89791-191-l/86/0500/0239 $00 75 m mam memory For thoseapphcauons whosestoragereqmrements contmue to exceed memory capacmes, them may sttll be oftenreferencedrelattons that wtll fit m memory, m which casert may pay to pamuon the databaseinto memory resident and disk resident porttons and then use memory-specific techmques for the memory restdent pomon (much hke IMS Fastpath and IMS [Dat81]) In add1uonto tradruonal database appllcattons, there are a number of emerging appl1cattonsfor wluch mam memory sizes will almost certainly be sufficient - appllcat1on.sthat wish to be able to store and access mlaaonal data mostly because the relauonal model and 1ts assoctated operattons provide an attracuve abstracaon for their needs Horwuz and Teltelbaum have proposed using relaaonal storagefor program mformanon 1nlanguage-basededitors, asadding relations and relaaonal operanons to attnbute grammars provides a mce mechamsm for speafy1ng and building such systems [HoT85] Linton hasalso proposedthe useof a databasesystemasthe basisfor constructmg program development envlromnents but841 Snodgrasshas shown that the relauonal model provides a good basis for the development of performance momtonng tools and their interfaces [Sno84] Finally, Warren (and others) have addressedthe relattonsh1pbetween Prolog and mlahonal database systems fJVar81], and having efficient algonthms for telauonal operaaons 1n mam memory could be useful for processing quenes m future logic programming language implementauons Mouvated by theseconsiderations,we are addressingthe quesuon of how to manage large memory res&nr relauonal databases Whereas tradmonal database algonthms are usually designed to muum1zedisk traffic, a main memory databasesystem must employ algonthms that am dnven by other cost factors such asthe number of data compansons and the amount of data movement.
A parallel execution model for a database machine with high performancesSome more general processors have also been proposed, such asDatacycle lLee & Herman 19871,and to some extend Prolog processors. An other trend is the use of associative memories [Chisvin & Duckworth 19891,but most of them are still subject to important limitations such as a uniform record and field length within a relation, one byte words, etc...
"Grammar-like functional rules for representing query optimization alternativesHowever, our rules resemble more the definition of a function in mathematics or a rule in Prolog, in that the ""tokens"" of our grammar may be parametrized and their definition alternatives may have complex conditions."
Managing the user services function., Lotus l-2-3, dBASE III, several word-processing packages, Communicating with the Mainframe, and desktop publishing), minicomputer-related sessions (e.g., UNIX, LISP, PROLOG), mainframe-related sessions (e.g., Job Control language, Working with Tapes, CLI STs, SPF screens, ORACLE), and supercomputer-related sessions (e.g., Introduction to Floating Point Systems Processing, Converting Your FORTRAN Code for FPS Execution).
"Workshop on object-oriented programming ECOOP 1987, Paris, June 18, 1987The inheritance problem can be seen in a frame-like language with message-passing, such as OBJLO G Chouraqui, Marseille], which runs on top of Prolog . For example, consider the formulas : ostrich(x) => bird(x) an d ostrich(x) _> not fly(x ) Now, if we add the formula : ostrich(henry ) then ""fly(henry)"" and ""not fly(henry) "" WORKSHOP are both possible extensions ."
Security and inference in multilevel database and knowledge-base systemsRepresenting Application Semantics We fmd It advantageous to utilize a constramt language to capture the necessary apphcatlon specific knowledge, and we use it for the examples m this paper We also have studied the use of a prolog-like representation [DeMo86] In either case, the concepts and techniques presented m this paper for inference control m databases and knowledgebased systems are relatively independent of the representation Tradltlonally, formal logic 1s used to construct precise derivations of certain obJects from other information -- constramts can serve this purpose too However, constramts also can be partaal, m that they may Just limit the possible values of the data obJects m question Some relevant aspects of our constraznt expression (GE) language are described here briefly (m the mterests of space), before we discuss our algorithms Our constramts express an mvarlant condltlon between two subpaths m the database or KBS schema (universe of discourse) Each subpath 1s described m abbreviated form, and consists of objects and relations from the schema, as we saw earlier So, for example, the constramt MANAGER PROJECT == MANAGER EMPLOYEE PROJECT expresses the fact that for each Manager instance (the anchor), there 1s to be equality of the target sets of ProJects arising from the two subpaths of this CE That, 18, a Manager 1s responsible for a ProJect If and only if one or more of his Employees are assigned to the Project The CE 1s Imphcltly iterated over all Manager mstances m the database, although It would be enforced mcrementally so that no overhead would occur unless a relevant relatlonshlp were updated Some representational capablhtles of our constramt expresslons are not easily captured by predicate calculus wor84a, Mor84b] These include (1) cardmahty-based quantifiers which form a contmuum from 3 (there exists at least one Instance with the speclfled property) to V (for all mstances), and (2) cardmahty-based set mtersectlon with speclflcatlon of lower and upper bounds on the number of common elements In cases where CEs have a predicate calculus equivalent, we have found CEs to be more compact,, and more mtultlve, than the equivalent, but longer, predicate calculus expressions Constramts can mteracf with one another, this will occur when they involve common relatlonshlps As a result, we can express a complex action or Interdependency m terms of modular and simpler constramts At the instance level, the u&era&on of constraints is referred to as constrarnt propagatzon At the symbolic level, the mteractlon IS expressed by constraznt compoertaon [Mor84b], this was illustrated earher by an example regarding proJects, reports, and topics 6.1.
"A formal lexicon in the Meaning-Text Theory: (or how to do lexica with words).): (6) noun(course, crs(X,Y .... ), nil, X:crs, [npobj(in):Y: subject] ). In this Prolog expression, the last argument of the five-place predicate 'noun' indicates that the complement (= NP object) of the lexeme COURSE introduced by the preposition IN (course in ancient history) must be labeled with the semantic feature ""subject""."
Transformational derivation of programs using the focus systemAs the Focus shared language is an expressionoriented language, this is considerably different from Prolog. The simplest quantifier is of the form THE(z : p) which denotes the unique z satisfying the condition p.
Resolving Quasi Logical FormsIn the CLE implementation, a method is the name ofa Prolog predicate that takes an unresolved expression and returns candidate referents in a preference order by backtracking, so the method may succeed zero, one, or several times.
An abstract machine for parallel graph reductionA code sequence is represented as a list within [ and 1, with the Prolog style of using ] to represent the cons operation.
Conception, evolution, and application of functional programming languagesFor example, consider the (Haskell) expression . . . x+x . . . wherex=fa The function application (f a) may be substituted for any free occurrence of x in the 3This situation forms an interesting contrast with the logic programming community, where Prolog is often described as declarative (whereas Lisp is usually not), and there are very few pure logic programming guages (and even fewer implementations). lanscope created by the where expression, such as in the subexpression x+x. Examples include annotations control evaluation order [Burton to 1984, Darlington and While 1987, Sridharan 19851, prioritize tasks, and map processes to processors [Hudak 1986c, Hudak Smith 1986, Keller and Lindstrom and 19851. Similar work has taken place in the Prolog community [Shapiro 19841. In addition, research has resulted in formal operational semantics for such extensions 198613, Hudak and Anderson [Hudak 19871.
The virtual time machineSome work has been performed that uses optimistic synchronization techniques for general purpose parallel computation. ParaTran [18,19] and Cleary's work on PROLOG programs[l] are examples. However, these are strictly software based approaches.
Modeling software tools with ICONBut another factor is that even though Icon programs generally run slower than similar C programs, performance of the Icon runtime system is not as bad as one might expect, and it does not pose the same performance problem as some implementations of SNOBOU, Prolog, or Lisp. In this case, most of the execution time is spent running the automated tests (UNIX shell scripts) rather than running the Buster/Icon execution system. 3.2 Technology Transfer Learning to program Icon is not difficult for experienced programmers.
A procedure and tools for transition engineeringUnfortunately, Darwin is currently oriented toward a Prolog environment and would require transportation for usein other environments.
Decomposition of relational schemata into components defined by both projection and restrictionIndeed, reaearchera at MCC have recently proposed an extension to Prolog m whrch such a hierarchy ir central [Aiia86]. Although vertical decomposition in terms of projections is the dominant mode, there are strong arguments in favor of eetabhahing a systematic theory of horazontal decompo&tons as weli, defined in terms of restrrckom Indeed, In addition to the desirability of such a theory m its own right, aa argued by Smith a decade ago (Smit78), such decompoartione are central to the data dretribution polrclea of many distributed database management systems The Gamma datafiow DBMS [DGKG86] ia but one recent example which expbcrtly rdentrfiez horrzontal partrtronmg of the database aa central to Its storage organuation In our earlier work [Hegn83,Hegn84], we attempted to model all decomposition8 ae reetrictlone, arguing that the horizontal mode of decomposition completely aubaumed the vertical While this approach was techmcaily zolid, it did not 8eemto be conceptually satiefactory Thie shortcoming has been rectified here In Section 2, we outlme a unified approach to reztrrctrve decomposition which encompazzee both the horizontal and vertical mode8 The comer&one of the approach 1s to expbcrtly incorporate null values into the framework by extending the hierarchy of types to have particular varietiee of mcomplete information nullz Prolectlon then amount8 to a reetnctron m which certam attributer must carry null value8 In order to convmcingly demon&rate that the framework developed in Sectron 2 1s useful, it 18 important that we demonstrate that it not only recapture8 but also extend8 the tradltronal reaultz In Section 3, we provide two major classesof results in that direction Fir&, we formabze the notion of bldimensional Jam dependency, which generahzee the classical notion by allowing horizontal decompoeitione acro88 types a~well ae the tradltronal vertical or prolectrve decompositrons It 18 also ehown how such a dependency eupporte the decompoertlon of a echema m a canomcal way.
Expert systems: perils and promiseWe would like to thank Peter Denning and Reid Smith for comments on earlier drafts of this article. 4. 5. 6. 7. 8. Bobrow, DC. If Prolog is the answer. what is the question?, or what it takes to support AI programming paradigms.
LaSSIE—a knowledge-based software information systemThen the structure of the communicate CD would be displayed on the terminal, and user would be prompted to fill in keywords for objects associated with this CD, these would then be matched with stored descriptions to find close matches. The algorithm is implemented in Prolog, the retrieved components are listed in order of closest match, depending on how many keywords matched.
Improving performance of an electrical power expert system with genetic algorithmsThe data which is available are measurements such as battery current and voltages, cell voltages and pressures, and temperatures. The expert system is written in Prolog and is invoked generally by user request but can be activated at detection of a fault.
"A data/knowledge base management testbed and experimental results on data/knowledge base query and update processing-_I P, q - R,vR, , R2 / 81 p2 Figure 3 Chques for rules m Figure I Cliques actually represent a partltmnmg of the sPt of rules mto dls JOd groups, the slgmllcance of this partltmnmg bemg that predicates tn the same clique must be evaluated as a whole usmg the rules m that chque Uro, there must be at least oae exit rule for each chque, to ensure that the evaluation of the predxp'es termmates 2 3 DlKB Quertes and Evalustmn Graph D/KB quenes are also expressed as Horn clauses For example, a typIcal query agamst the rule set m Ftgure 1 1s query(S) - p(X, John ) Evaluatmg the above DjKB query 1s tantamount to evaluatmg the derived predicate Puery,whichmturnmvolvesevaluatmgalltheprehcates reachable rem query The predicates reachable from query are called relevant prcdtctcs, whde the rules deftmug them are called releuant rules Fvaluatrng D/KB queries 1s then tantamount to evaluatmg ihe relevant predicates usmg the relevant rules tmnedAsdescribedmthepreviousseetmn,therelevantrulescanbepwtl- Into chques and from this partltmmng we can construct a new graph, called the evaluatton graph for the query This IS a dlrected graph whose nodes are etther chques or non-recurave derived predicates Chque nodes can be thought of as the strongly connected components of the PCG collapsed Into smgle nodes, whrle non-recursive predicate nodes are the same as those m the PCG gwh (1) f' There are four tjpes of edges m the evaluatmn - C' mdlcates that some predicate m the cb the body of a rule definrng I=, (2) C - f mdlcates that ue C appears m ,b body of a rule deEmrig some predicate of C, (3) P appears m the P, appears 111the body of a rule definmg f',, *ad 4) - P, mdlcates that c - c mdlcates that some predicate of C' r b appears m the body of a r"" e de amg some t d predicate of C, Wxle t e PCG may be a cychr graph, the evaluatmn graph 1s acychc It 1s then posstble to order the nodes in this graph ,a such a way that all predlrates reachable from a predicate p appear as predecessors of p some of these predecessors bemg chque nodes contammg some of the reachable predicates perty the evaluntton order 11.1 ne call the total order with thu pro-The evaluatmn order hst spec15es the order m wLch to evaluate the chques and non recursive derived predicates dormg D/ KB query processmg Figure 4 1s the evaluatmo graph obtamed after we Insert the above query mto the rule set III Figure 1 Lsually. there IS more than one posstble evaluatmn order Iut for a query For example, from the evaluatmn graph m Figure 4, we can obtam two evaluatmn order hsts {C,, C,, 6' query} The chmce of evaluatmn order Yguery } and {Ca, C,, C,, 1st 1s one of the optlmrratmn problems m D/KB query processmg that we have not addressed yet 2 4 Evalustlng Predlcates and Clrques D/KBThereareessentmllytwostrategiesforevaluatmgpredxatesdung query processmg - top down evaluatron and bottomup cwlud~on Bottom-up evaluatmn starts with the base predicates m the body of the relevant rules and keeps combmmg them with other predicates m the body to produce the head prebcater till the predicate query 1s generated Topdown evaluatmn starts wtth query and keeps evaluatmg predntes m the body of the relevant rules by propagatmg the bmdmgr m the head predicatea of these rules Figure 4 An example evaluatma graph In general, some of the relevant predicates ~111 be non-recurs,ve, with the rest bemg partltionad mto cliques as explamed III sectloo 2 2 Bottom-up evaluatmn of non-recurswe pred~cater IS equwaleot to eomputmg a relattonal algebra expressmn On the other hand, bottom-up evalsat&on of a clrque of recurs~e predicates LSeqmvalent to eomputmg the least Bxed pomt (LFP) of a set of recursnre relstlonal algebra equatmnr of the form, 7, = /,(r,, , algebra expressmas tr,),t=l, I n, whare the /, s are relatmnal Examples of topdowa evaluatmo are the Henschen-Naqvl method 15' and Prolog, while natve evaluatmn and sem~~awe evaluatmn [b] are examples of bottom-up evaluatmo a 5 Optrmlsatloa Bottom up strategies are simpler and easy to tmplement, but they compute a lot of useless results, smce they do not uw knowledge about the q""ery (I e constants m the query rule) to restnct the search space as topdown strategies do Several strategtes have been proposed for use with bottom up strategies to Improve performaore, e g ( magc sets 171, supplementarv magtc sets 181, countmg and supplementary countmg [9\ The mam Idea behmd these strategies 1s the use of ardewap ~nformatton pa~s,rrg (alp) to propagate the mformdtum m the query (query constants) and re*- tnct the computatmn to tuple~ that are related to the query Beer! E xam ples of top-dow n e v a Iu a tio n a re th e H ensch en-N aqvi m eth o d (5] and Prolog, w hile n aive e v a Iu a tio n an d sem i-naive e v a Iu a tio n (6| a re exam - ples o f b o tto m -u p e v a Iu atio n . 2 .5 ."
Belief ascription and model generative reasoning: joining two paradigms to a robust parser of messagesViewGen: The basic belief engine A computational model of belief ascription is described in detail elsewhere (Wilks & Bien, 1979, 1983, Ballim, 1987, Wilks & Balfim, 1987, Ballim & Wilks, forthcoming) and is embodied in a program called ViewGen, two versions of which have been written in prolog by Afzal Ballim. The basic algorithm of this model uses the notion of default reasoning to ascribe beliefs to other agents unless there is evidence to prevent the ascription.
Recognizing and responding to plan-oriented misconceptionsThe current version of AQUA is implemented in T (Rees, Adams, and Meehan 1984), using RHAPSODY (Turner and Reeves 1987), a graphical AI tools environment with Prolog-like unification and backtracking capabilities, and runs on an Apollo DN460 workstation.
Resolving lexical ambiguity in a deterministic parserThat thesis presents ROBIE, a deterministic parser that is able to resolve lexical ambiguities and that is fully implemented in PROLOG. ROBIE has two lookahead buffers and does not use Marcus's Attention Shift mechanism.
The correction of ill-formed input using history-based expectation with applications to speech understandingThere is some literature on procedure acquisition such as the LISP synthesis work described in Biermann et al. (1984) and the PROLOG synthesis method of Shapiro (1982). However, the latter methodologies have not been applied to dialogue acquisition. 8 CONCLUSIONS AND AREAS FOR FUTURE RESEARCH We have shown that the ability to use expectation in the form of knowledge about the dialogue being spoken, as with humans, is a tremendous aid to speech recognition by computer.
Toward memory-based reasoningThe AI languages Planner [lo], Micro-Planner [44], and Prolog [18] all embody some variant of heuristic search with backtracking as their central control mechanism.
Minimizing function-free recursive inference rules(The terminology used here follows that of Reiter [ 121.)We use Prolog notation to write these rules. In this paper, with the exception of Section 2.2, we consider only definitions consisting of one linear recursive rule and one nonrecursive initialization rule.
Constrained expressions: toward broad applicability of analysis methods for distributed software systemsWe have implemented a preliminary version of this tool in Prolog interpreted language of a constrained [l]. It generates a string from the expression.
Comprehending monadsIncidentally, the higher-order nature of the solution means that it cannot be applied in firstorder languages such as Prolog or OBJ. It also casts doubt on Goguen's thesis that first-order languages are sufficient for most purposes [Gog88].
A comparative evaluation of object definition techniques for large prototype systemsExamples include such standards as LISP, Smalltalk, PROLOG, and YACC, as well as more recent efforts such as the Cornell Synthesizer Generator [ 111, the SARA Interface Specification Many of these have included System [19], DOSE [6], and others. one or more object definition techniques.
Concurrent dynamic logicATMs have proved to be a very useful tool in complexity theory, and have been followed by several attempts to develop programming tools incorporating this duality, like Harel's and/or programs [7], the language Ind of [9], and, in a way, the new trend of logic programming and Prolog [3, 18, 351. This view of concurrency suggestsa new viable approach toward incorporating concurrency into dynamic logic.
"Program verification: the very ideaMost programs today are written in high-level programming languages, such as Pascal, LISP and Prolog, which simulate""abstract machines,"" whose instructions can be more readily composed than can those of the machines that ultimately execute them."
A logical theory of concurrent objectsThis applies to functional languages -based on a first order or higher order version of equational logicand also to relational languages such as Prolog. This state of affairs poses an unhealthy dualistic dilemma, of a gnostic kind, forcing one to choose between a clean, timeless, world of logic and the dirty material world of change and chaos.
A model-based approach to updating databases with incomplete informationRather, the axioms formalize our intuitions about the behavior of a query and update processor operating on the body of the theory. For example, PROLOG is a query processor that shares our unique name axioms, but has an entirely different closed-world assumption.
Category structuresFor example, the use made of syntactic features in one influential variety of augmented phrase structure grammar, the Prolog-based definite clause grammar (DCG) formalism of Pereira and Warren (1980) closely resembles that of Harman.
Automating program analysisA sample session using the performance compiler. prototyped using Prolog. A sample interaction is shown in Figure 2. Figure 3 shows the unsimplified formulas that are generated by the strict application of the rules defining Kozen's operator KS.
Translation with optimization from relational calculus to relational algebra having aggregate functionsCONSIDERATIONS 7.1 Translation Examples and Optimization is clear from the comprehensive We programmed the proposed translation method in PROLOG and subjected it to about a hundred example queries.
Parallelism in relational data base systems: architectural issues and design approachesThe same phenomenon occurs in interfaces between high level programming languages, such as Prolog, and DBMSs (i.e., data base support for logic programming also has this effect) [Wolf88].
Multikey access methods based on superimposed coding techniquesThese include messagefiles [6], optical disk storage [7], statistical databases [32], filtering methods [3, 181,and Prolog databases [8, 221. Superimposed coding techniques are well suited to hardware implementation [14, 161.
Nonclausal deduction in first-order temporal logicIn a separate work [6], we discuss the use of the system for the development of a PROLOG-likelanguage with temporal operators. The temporal logic we study is only one of the many modal logics important in computer science.
Toward hypertext publishingRestrieted to Avoid General Computation A big issue is whether to allow a pattern language to be powerful enough to support general computation, as in PROLOG or OPS5. An m-gument against this is that the publishing community would have to agree on an implementation approach so that people can predict the computational effort needed to answer their requests, especiaUy if there is a chance of infinite loops.
Interface design issues for advice-giving expert systemsCoombs and Alty [x'] stored prototypical error patterns as a normative user model for users of a Prolog environment. When particular users generated patterns of behavior that matched a stored prototype, relevant corrective advice was produced.
"The 3DIS: an extensible object-oriented information management environmentThis prototype in supporting cooperative work among engi was constructed on a SUN/3 workstation using the SUN Unify database management system as a base, the prototype was written in a mixture of ""C"" and Prolog. This prototype has been utilized to specifically test the 3DIS for use in supporting designers and in particular a collection of collaborating VLSI to test the extensibility and modeling capabilities of the 3DIS."
Cyc: toward programs with common senseMany of these savings are similar to those obtained by Warren-Machine-like [31] compilations of Prolog programs. In particular, each schema has specialized ,j> procedures for: l Recognizing instances of the schema.
Automatic verification of database transaction safetyIn other words, writing programs to be interpreted by sophisticated knowledge-oriented interpreters is even harder than writing programs for interpreters with simpler evaluation ers, Prolog systems, Pascal machines, loops such as LISP interpret or 8086 processors.
Distributed cooperation with action systemsThe problem of finding a good modularization mechanism for action systems is very similar to the corresponding problems for Prolog and production for the modular construction system languages such as OPS5, as well as of Petri nets.
An overview of the SR language and implementationSubsequently, iments relating program structure interpreter and a file system for a SR has been used to program exper and process interaction patterns [7], a highly parallel interpreter for Prolog, and Saguaro's file system [32]. Almost all of the SR compiler, independent C.
What have we learnt from using real parallel machines to solve real problems?I have not studied parallel Iogic programming and in particular concurrent prolog [Taylor 881 which could lead to important new applications with a variety of temporal structures. 16.71 Document Search Connection Machine, Thinking Machines Staff, [Stanfill 861,[Waltz 87a] EP-S One can implement the search of many documents for key phrases very nicely on .the connection machine in a way that exploits the bit arithmetic capability.
Reference identification and reference identification failuresMost of the rules were motivated by the problems illustrated in the protocols. They are written in a PROLOG-like language. Figure 5 illustrates one such linguistic knowledge relaxation rule. 290 Reference Identification and Reference Identification Failures This rule is motivated by the observation that speakers typically add more important information at the end of a description (where it is separated from the main part of the description and, thus, provides more emphasis).
Do-it-yourself type theoryThe best-known example of the former is probably Lisp, but it also includes Prolog, all command languages such as Cshell and text.processing languages like TEX.
Explanation-based learning: a survey of programs and perspectivesPRIEDITIS, A. E., AND MOSTOW, J. 1987. PROLEARN: Towards a Prolog interpreter that learns. In Proceedings of the 6th National Conference on Artificial Intelligence.
Small is beautiful: the next ten years in University computingSadly, the Alvey project staff seem to have been overwhelmed by some very effective canvassing and have equated the use of Prologor Lisp with 'progress' in general, and in particular keeping up with the Japanese Fifth Generation project, itself rather naively founded on simplistic concepts.
Experimental evaluation of a generic abstract interpretation algorithm for PROLOG
Live-structure dataflow analysis for Prolog
Using a Prolog meta-programming approach for a blackboard application
Abstract data type support in Prolog and its relation to parallelism
On the occur-check-free PROLOG programs
Representing calendrical algorithms and data in Prolog and Prolog III languages
Topologies for the parallel backtracking Prolog engine
Modelling Prolog control
Reasoning about Prolog programs: From modes through types to assertions
A prolog space benchmark suite: a new tool to compare prolog implementations
Notes on implementing sets in Prolog
Efficient reordering of C-PROLOG
A versatile module system for Prolog mapped to flat prolog
An integrated Prolog programming environment
An integrated Prolog programming environment
The birth of Prolog
The concurrent language, Shared Prolog
An introduction to Prolog III
CLARE—a Prolog database machine
"Introducing the fuzzy paradigm using PrologThis artificial intelligence project introduces students to an alternative to the traditional ""crisp"" paradigm of computer science through the use of fuzzy sets and linguistic variables for modeling natural language expressions. A fuzzy/linguistic meta-language is built on Prolog. This helps them to explore some of the problems encountered in the human/computer interface of bridging the fuzzy, imprecise symbolic world of natural language and the computer's crisp, numeric world.Introducing the Fuzzy Paradigm Using Prolog Donna M. Kaminski Western Michigan University the aims of the theory of fuzzy seta is the development of This artificial intelligence project introduces to an alternative to the traditional ""crisp"" students a methodology for the formulation and solution of paradigm of problems which are too complex or illdefined to be computer science through the use of fuzzy linguistic variables for modeling natural expressions. A fuzzy/linguistic meta-language sets and susceptible to analysis by conventional techniques"". 10 A language fuzzy approach has been used in many application areas is built on including control systems,s pattern recognition,4 expert Prolog. This helps them to explore some of the problems encountered in the human/computer interface of bridging the fimzy, imprecise symbolic world of natural language and the computer's crisp, numeric world. Students develop a simple metalanguage on top of Prolog. (Several others experimented with a Fuzzy Prolog).3'8 FUZZY SETS fuzzy have The main idea behind fuzzy logic systems is that truth values are not just TRUE and FALSE, rather, there are varying degrees of truth which fall somewhere within the range of TRUE to FALSE."
"A simple model of prolog's performance: extensional predicatesThe efficiency of query execution in Prolog depends on the order in which subgoals are stated. The total cost for a particular ordering can be estimated as the sum of the individual costs of the subgoals, where the cost of each subgoal will depend on the degree of instantiation of its arguments as well as on characteristics of the underlying database.A model of execution for Prolog that can be used to determine estimates of execution costs for any possible query is desirable.A Simple Model of Prolog's Performance - Extensional Predicates Carlos Escalante Department of Computer Scienc e University of Victori a Victoria, British Columbi a The efficiency of query execution in Prolog depend s on the order in which subgoals are stated . For example, given a database with 3000 book titles, 20 different publishers, 45 0 authors, 30 nationalities, and 380 cities worldwide , we observe the costs shown in Table 1 . The figures were obtained using SICStus Prolog version 1 .2 and Stony Brook Prolog (SB-Prolog) version 3 .0 measured on a Sun SPARCstation SLC . All SICStu s Prolog execution times are estimated, according t o the implementation manuals, in ""artificial"" units , whereas SB-Prolog execution times are measured i n milliseconds."
"Instruction-level parallelism in Prolog: analysis and architectural supportThe demand of increasing computation power for symbolic processing has given a strong impulse to the development of ASICs dedicated to the execution of prolog. Unlike past microcoded implementation based on the Warren machine model, novel trends in high performance Prolog processors suggest the implementation of RISC-based processors committed to prolog only through the adoption of a few basic dedicated features, like the Berkeley Abstract Machine (BAM) processor. Following the idea of using a smart compiler for a simple instruction set, the SYMBOL project represents an experiment in applying global compaction techniques and VLIW design philosophy to the static exploitation of instruction-level parallelism in Prolog. This paper presents code analysis results and shows how we can approach the theoretical speed-up limit (about 3) imposed by Amdahl's law on shared memory models, by means of global code optimizations and a suitable architectural support.Instruction-level Parallelism in Prolog: Analysis and Architectural Support Alessandro De Gloria and Paolo Fambsehi Univemit of Genoa Depent of Bimhy$p 1-1614 flg J gin=fing (DIW F Geneva, Italy e-mail: adg@cpsi 7.dibe.ttnige.it The &mand of increasing computatwn power for symbolic processing has given a strong impuke to the development of ASICS dedicated to the aecutwn of Prolog. Unlike past w""crocoded implementation based on the Warren Machine model, novel trends in high performance Prolog processors suggest the implementation of RISC-based processors committed to Prolog only through the adoptwn of a fm basic dedicated features, like the Berkeley Abstract Machine (BAM) processor. In addition, we show implemetatwn details and some preliminary aizta of a VLSI prototype architecture . Keywords: Prolog shared-menwy model, Static kstruction-Level Parallelism, Global Compaction Techniques, VLIW architectures. 1."
Type analysis of Prolog using type graphsType analysis of Prolog is of primary importance for high-performance compilers, since type information may lead to better indexing and to sophisticated specializations of unification and built-in predicates to name a few. The purpose of this paper is to describe a type analysis system for Prolog based on abstract interpretation and type graphs (i.e. disjunctive rational trees) with this functionality.Van Hentenryck Brown University Box 1910 Providence RI 02912 (USA) pvh@cs brown. edu I&trzzt of Prolog Using Type Graphs* A. Cortesi B. Le Charlier University of Venezia University of Namur Via Torino 155 21 rue Grandgagnage 1-30170 Mestre-VE (Italy) B-5000 Namur (Belgium) cortesi@moo. dsi .uni-ve. it bletlinfo .fundp. ac .be information, type analyses must be rather sophisticated and contain disjunctive and recursive types. Consider Type analyis of Prolog is of primary importance high-performance compilers, since type information lead to better indexing and to sophisticated specializa tions of unification and built-in predicates to name few. The purpose of this paper is to describe of inferring insert (E, L,Ln) . expensive in insert (E, tree(L, V, R), tree(L, V,Rn)) :- E > V, insert (E, R,Rn) . a type anal-If compilers are given the information that the first arysis system for Prolog based on abstract interpretation and type graphs (i.e. disjunctive rational trees) with this functionality.
Groundness analysis for Prolog: implementation and evaluation of domain propThe domain Prop [22,8] is a conceptually simple and elegant abstract domain to compute groundness information for Prolog programs. In particular, abstract substitutions are represented by Boolean functions built using the logical connectives ⇔, ∨, ∧.Groundless Analysis for Prolog: Implementation and Evaluation (Extended Abstract) Baudouin Le Charlier of the Domain prop Pascal `Van Hentenryck Institut d'informatique University of Namur 21, rue Grandgagnage B-5000 Namur (Belgium) The domain Prop [22, 8] is a conceptually simple and elegant abstract domain to compute groundless information for Prolog programs. The experimental results indicate that (1) prop is very accurate to infer groundless information, (2) this domain is quite practical in terms of efficiency, although it is the oretically exponential (in the number of clause variables). Introduction Abstract interpretation of Prolog has attracted many re searchers in recent years. This effort is motivated by the need of optimization in Prolog compilers to be competi tive with procedural languages and the declarative nature of the language which makes it more amenable to static analysis.
Implementation-based analysis and testing of Prolog programsIn this paper, we describe the PROTest II (PROlog Test Environment, Version 2) system to test logic programs in an interactive support environment. With this information PROTest II statically checks the types of Prolog programs, generates test cases, executes Prolog programs, and produces reports summarizing results including information about new test coverage metrics. Thus, PROTest II enables both static analysis and dynamic testing uniformly using a Prolog-based test language DTL/1. The strength of PROTest II stems from its idea of defining coverage in real logic programming terms, rather than adapting imperative programming ideas.Belli University Department of Electrical and Testing of Prolog Programs O. Jack of Paderborn and Electronics Engineering Germany In this paper, we describe the PROTest II (PROlog Test Environment, Version 2) system to test logic programs in an interactive support environment. With this in formation PROTest II statically checks the types of Prolog programs, generates test cases, executes Prolog programs, and produces reports summarizing results including infor mation about new test coverage metrics. These investi gations rely on a specification of imperative programs. The view is seeing Prolog as a specification language for imper ative programs.
"Simulation of communications architecture specifications using PrologThe design of the Cara simulator, a Prolog-based simulator for communications architecture specifications, is described. Unlike other Prolog-based simulation methods, the Cara simulator supports ""exploratory simulation"", in which high-level, incomplete specifications may be simulated, and various specification alternatives and elaborations added to the specification during the course of the simulation. Unlike other simulation methods, which construct Prolog procedures whose behavior models that of the specification, our simulator maintains execution traces of simulated protocol behavior and adds to these traces through the application of rules of inference reflecting the protocol behavior.Simulation of Communications Architecture Specifications Using Prolog Wayne Citrin University of Colorado,Boulder Keywords: logic programming, sJ.mulation, communications. Abstract The design of the Cara simulator, a Prolog-based simulatm for commtmicafions architecture specifications, is described. Urdike other Prolog-based simulation methods, the Cera simulator supports ""exploratmy simulafior~"" in which high-leveL incomplete specifications may be simulated, and various specification altenatives and elaborations added to the specification during the course of the simulation."
"Some comments on “a denotational semantics for Prolog”Two independently derived denotational semantics for Prolog are contrasted, Arbab and Berry's for the full language and Nicholson and Foo's for a databaseless language.Semantics for Prolog"" BIJAN ARBAB IBM and DANIEL M. BERRY Technion Two independently derived denotational for the full language and Nicholson suggested by the former, the latter semantics for Prolog are contrasted, Arbab and Berry's and Foo's for a databaseless language. We refer the reader to our article, ""Operational and Denotational Semantics of Prolog"" in the November 1987 issue of the Journal of Logic Programming. In this article, we have given both an operational Prolog, including the database and a denotational semantics of the full operations, assert and retract, that were purposely not covered in Nicholson's We started with an operational Prolog interpreter."
A brief introduction to PrologBecause of its origins in logic and formal grammars, Prolog has a very simple abstract syntax which has been given a variety of different concrete realizations over the years. In this description, I will use the concrete syntax in the current draft IS0 standard for Prolog, and show the correspondence of that syntax to the original Marseille syntax described in The Birth of Prolog. Program Structure A Prolog program is a sequence of clauses. A clause gives a condition under which certain entities, represented by terms are in a certain relation, represented by a predicate.
Dependency unification grammar for PROLOG
Determinacy analysis for full PrologDeterminacy Analysis for Full Prolog Dan Sahlin SICS, Box 1263, S-164 28, Sweden electronic mail: dan@sics.se A method for determinacy analysis for full Prolog, including cut, is described. More details on the treatment of cut in Mixtus can be found in [Sah 190, Srrh 191]. The first partial evaluator for Prolog [Komo 81] did not handle cut, and the complications of cut have usually been passed over in other works, The earliest partial evaluator for Prolog with cut appears to have been Venken's [Venk 84]. As is the case throughout, it is the procedural behavior of the Prolog program that is of interest when counting the number of solutions.
A plea for readable pleas for a readable Prolog programming styleWriting a plea for a readable Prolog programming style is not like writing most pleas. In writing a plea for a readable Prolog programming style in particular, one could possibly bring forth many results. This means that special care must be taken when writing a plea for a readable Prolog programming style. Not only must the plea be readable, it must also be written in such a way as to make clear the process of writing well-styled Prolog programs.Plea writing makes use of a set of rules to specify how a certain task might be accomplished.1.0 Abstract A Plea for Readable Pleas for a Readable Prolog Programming Style Randy M. Kaplan Educational Testing Service Rosedale Road Princeton, NJ 08541 Writing a plea for a readable Prolog programming style is not like writing most pleas. In writing a plea for a readable Prolog programming style in particular, one could possibly bring forth many results. This means that special care must be taken when writing a plea for a readable Prolog programming style. Not only must the plea be readable, it must also be written in such a way as to make clear the process of writing well-styled Prolog programs.
Semantics preserving transformation rules for PrologUnfortunately, those semantics do not capture the termination behaviour of logic programs they are evaluated under the standard when depth-first search strategy of Prolog, which is the basis of most existing implementations of logic programming. As a consequence, the programmer is left with the hard task of checking that the transformation techniques given in the literature, behave conveniently used for Prolog programs. when In the present work we study the applicability of those techniques when logic programs evaluated according to the Prolog depth-first are search strategy, and in particular, we study the correctness of the Unfold/Fold transformations for programs. To copy otherwise, or to republish, requires and/or specific permission. @ 1991 ACM 0-89791-433-3/91 10006 /0274 . ..S1 .5o a fee Rules for Prolog Alberto Pettorossi Electronics Department University of Rome H 00173 Roma, Italy adp@irrniasi.rm. cnr.it We give some syntactical restrictions which ensure that the transformation rules preserve the sequence of answer substitutions semantics, which is one that has been proposed for Prolog [Jones Mycroft 84], We believe that our work is a contribution towards making program transformation a more reliable and effective tool for the automatic development of Prolog programs. 1.
"Finding fixed point combinators using PrologFINDING FIXED POINT COMBINATORS USING PROLOG Rkhard Rankin R@ Wfierson ComputerScience Department,Universityof Mksoun-Rolls pmpcrty) and, assuming the success of this - ge, attempts toestablisht hecxktcnceofthe atrongfixcd point Apowerfdncw atmtcgy, calkdtbckcmcl method, haabeen developed by Laq' Wos and W- McCunc at Argonne National Laboratories, to StUdyvarious tkcd point pmpcrtks within _ classes of applicative systems. We present a v- simpk -log reasoning $y, named JIST, which incorporates both stages of the kernel method into a s""mgk lmiiicd program. Furthermore, the prolog tool has been extended to run within a distriiutcd emimnmcnt using the Linda protocol. The first problem which needed to be addressed was prolog's unsound unification algorithm, which results from the lack of an occurs check in most prolog implementations (including Sicstus Prolog)."
"Generating the minimal model in PrologIn algebra, one first obtain s the elements as formal expressions according to their length, or some othe r complexity measure, and then one makes the necessary identifications . Consequences for a program written in Prolog are generated via queries o r ""Goals"" according to its built-in operational calculus in a deterministi c fashion which, unfortunately, causes Prolog to frequently become entangle d in infinite loops . That is, there are programs which are syntactically sound but for which Prolog cannot find certain logical consequences . A standard example is provided by a :-b . b :-a . b . Putting b . on top of the clauses, would help, but only patch up the problem . This unwanted tendency of Prolog to run into infinite loops is a ver y serious defect of the program ."
Reliability prediction of Prolog programs
OPIUM: a debugging environment for Prolog development and debugging researchOpium is an extensible debugging environment for PROLOG providing high-level debugging facilities for programmers and debugging experts.
A plan-based approach to Prolog recursionPreface A Plan-based Approach to Prolo g Recursio n Jan Newmarc h Information Science and Engineerin g University of Canberra Australia The intent of this paper is to show that by learning a fairly smal l This paper discusses the learning of Prolog recursion, and shows ho w it is made easier by adopting a plan-based approach . Many common Prolog examples are shown to be derivable from simple plans . One of the principal problems in learning a language such as Prolog is the heavy relianc e in the language upon a single technique, recursion [2,3,61 .
Lexical disambiguation using Constraint Handling in Prolog (CHIP)Lexical Disambiguation Using Constraint Handling In Prolog (CHIP) * George C. Demetriou Centre for Computer Analysis of Language And Speech (CCALAS) Artificial Intelligence Division, School of Computer Studies, University of Leeds Leeds, LS2 9JT, United Kingdom 1 Introduction Automatic sense disambiguation has been recognised by the research community as very important for a number of natural language processing applications like information retrieval, machine translation, or speech recognition. Since the problem of finding the word-sense-chain with maximum overlap can be viewed as a specialised example of the class of constraint-based optimisation problems for which Constraint Handling In Prolog (CHIP) was designed, we have chosen to implement our algorithm in CHIP. 2 Background: LDOCE, Word Sense Disambiguation and related work LDOCE's important feature is that its definitions (and examples) are written in a controlled vocabulary of 2187 words. A CHIP compiler is available from International Computers Limited (ICL) as part of its DecisionPower prolog-based toolkit 1. CHIP extends usual Prolog-like logic programming by introducing three new computation domains of finite restricted terms, boolean terms and linear rational terms.
Simulation of communications architecture specifications using PrologSimulation of Communications Architecture Specifications Using Prolog Wayne Citrin Department of Electrical and Computer Engineering University of Colorado, Boulder The design of the Cara sirnufator, a Prolog-based simulator for communications architecture specifications, is described. Unlike other simulation methods, which cons Inrct Prolog procedures whose behavior models that of the spcitication, our simulator maintains execution traces of simulated protocol behavior and adds to these traces through the application of mlcs of inference reflecting the protocol behavior. This, in turn, leads to their being modeled through translation to declarative languages, in the case of the exarnplcs discussed in this paper, to Prolog. A number of systems have been proposed thaL employ Prolog in the specification and simulation of communications architectures, either through directly modeling the specification in Prolog [12, 14, 18], or through translation from another specification method into Prolog [4, 13].
Book review: The Art of Prolog, 2nd edition by Leon Sterling and Ehud Shapiro (MIT Press, 1994)In his 1983 dissertation [1], Ehud Shapiro lamented the lack of literature available on good Prolog programming style. While manuals for the language existed, there was little available to guide a new programmer into the best ways of using the elements of the language to write good programs rather than merely programs that work.literature available on good Prolog programming style. While The Art of Prolog, 2nd edition by Leon Sterling and Ehud Shapiro Cambridge, Massachusetts: MIT Press, 1994 509 pages, $49.95. Sterling and Shapiro have provided the AI community with a guide to good Prolog programming in their book The Art of Prolog. Their text not only describes Prolog's language components but also assists the Prolog programmer in developing good style, writing programs which are clear and efficient, and which extract as much power as possible from the language constructs. The Art of Prolog is written with a graduate student audience in mind, the authors have used it as the textbook for a graduatelevel course in Prolog programming.
Book Review: Symbolic Computing with Lisp and Prolog by Robert A Mueller and Rex L. Page (John Wiley and Sons)
"Review of ""Functional grammar in prolog: an integrated implementation for English, French, and Dutch"" by Simon C. Dik. Mouton de Gruyter 1992.Book Reviews Functional Grammar in Prolog: An Integrated Implementation for English, French, and Dutch Simon C. Hardbound, ISBN 3-11-012979-5, DM 118.00 Reviewed by Patrick Saint-Dizier IRIT-CNRS This book is a detailed description of a program, called ProfGlot, that implements in Prolog the components of the theory of Functional Grammar, as described by Dik (1989). Reading this book and understanding the portions of programs is a difficult exercise, even for a well-trained Prolog programmer (though the reader of this review may think that going into a Prolog program--and probably also into other languages--is almost never an easy task)."
BREL—a Prolog knowledge-based system shell for VLSI CADBREL - A Prolog Knowledge--Based Systerru Shell for VLSI CAD Marwan A. In addition, the results of investigations of the performance of declarative and procedural languages in optimisation [4] supported PROLOG. PROLOG's built-in predicates may be used as primitives in the representation of knowledge. PROLOG's built-in backtracking facilitates the generation of an alternative solution on request.
An architecture for voice dialog systems based on prolog-style theorem provingAn Architecture for Voice Dialog Systems Based on Prolog-Style Theorem Proving Ronnie W. Smith* East Carolina University Alan W. These capabilities include problem solving, natural language input and output, a user model, variable initiative, and the use of expectation for speech error correction and plan recognition. The theory revolves around a Prolog-style theorem-proving model with a variety of special features to accommodate the needs of a dialog system. In typical dialogs, the user modeling system added a net of about 1.2 Prolog-style assertions to the user model per user utterance.
High performance continuation passing style Prolog-to-C mapping
An alternative to constraint logic programming for managing domain arithmetics in Prolog expert systemsAn Alternative to Constraint Logic Programming for Managing Domain Arithmetics in Prolog Expert Systems David Roach Hal Berghel Department of Computer Science University of Arkansas We present a method for including procedural arithmetic knowledge in a declarative rid-base. A way of organizing explanations based on the integrated proof tree is discussed. Prolog is used to illustrate the implementation of the integration strategy. However, in the absence of widely available implementations of CLP languages, it may be useful to determine to what extent arithmetics can be satisfactorily handled by traditional expert systems languages such as Prolog. We begin with the specification of a typical if. then rule and then discuss the modifications necessary to integrstc arithmetic knowledge.
Book review: The Implementation of Prolog By Patrice Boizumault Translated from the original French by Ara M. Djamboulian and Jamal Fattouh (Princeton University Press, 1993)As a programming language, Prolog was designed to reflect conceptual problem-solving methods rather than the architecture of any particular computer, it encourages the programmer to solve problems by describing facts and relationships, instead of trying to fit the problem into a set of memory locations and machine operations on a computer. Prolog is thus, by design, a step farther from the machine than most conventional imperative programming languages.The Implementation of Prolog By Patrice Boizumault Translated from the original French by Ara M. Prolog is thus, by design, a step farther from the machine than most conventional imperative programming languages. Eventually, however, Prolog must be implemented on a computer if it is to be a programming language at all.
"Review of ""Prolog for natural language processing"" by Annie Gal, Guy Lapalme, Patrick Saint-Dizier, and Harold Somers. John Wiley 1991.Prolog for Natural Language Processing Annie Gal, Guy Lapalme, Patrick Saint-Dizier, and Harold Somers (SYSECA S.A., Universit 6 de Montr 4al, Universit 6 Paul Sabatier, and UMIST) Chichester, England: John Wiley (Wiley Professional Computing Series), 1991, XIII + 306 pp. There is currently a glut of general Prolog texts on the market. Happily, the same cannot be said in the more specialized field of Prolog-based NLP, each of the available texts justifies its place on the bookshelf. These are also available on a 5 1/4 inch DOS-format disk, available at a cost of £12.50 or $26.60 from the publisher. Programs are written in C-Prolog. Compatibility files are supplied for use with Edinburgh, BIM, Quintus, and Sixtus Prologs. !"
Ecxpert: exploiting event correlation in telecommunicationsSuccessful implementation of event correlation has increased customer revenue because trouble isolation can be done faster, resulting in quicker restoration of service.The essence of ECXpert is a high level language with which users can specify network events and their correlation with alarms. The system is written in Prolog and C++, a powerful combination which allowed development to occur on time and in budget. It has been deployed in network management centers throughout the U.S. and is currently being marketed overseas. ECXpert is a success story for Prolog within AT&T.It has been deployed, in network managemertt centers throughout the U.S. and is currendy being marketed overseas. ECXpert is a success stray for Prolog within AT&T. Keywerds C.4-1-Integrated Netwerk Menagermmt Techniques Mere-Programming Pmlog Introduction Total Network Management [4],TNM, is a very large product developed by AT&T for domestic md international customers. Although we could have used a combination of asx'ts and abolishes that memy Prologs provide, this would not have beem a clean solution. IF/Prolog allows Prolog to be invoked, run, and ended. When a user changes the correlationrules, Prolog can then be reinitializ in a clean workspnce with the new compiled correlation rules without having m stop or kill the process.
The power of partial tanslation: an experiment with the C-ification of binary PrologTHE POWER OF PARTIAL TRANSLATION: AN EXPERIMENT WITH THE C-IFICATION OF BINARY PROLOG Paul Tarau Bart Demsen Koen De Bosschere Universitk de Moncton Ka.tholieke Universiteit Leuven Universiteit Gent We describe a new language translation framework (partial translation) and the implementation of one of its instances: the C-$cation of Binary Prolog. Keywords: Programming language translation techniques, Compilation of binary Prolog, WAM, Bin WAM, Prolag to C translation The main r&son for translating Prolog to C are 2. portability to multiple architectures, 3. stand alone executables. We have started with the clear objective of partial translation from one of the fastest existing C-emulated Prologs (BinProlog) and to obtain overall performances similar to the best full-translation schemes.
ProFIT: prolog with features, inheritance and templatesProFIT is an extension of Standard Prolog with Features, Inheritance and Templates. ProFIT allows the programmer or grammar developer to declare an inheritance hierarchy, features and templates. Sorted feature terms can be used in ProFIT programs together with Prolog terms to provide a clearer description language for linguistic structures. ProFIT compiles all sorted feature terms into a Prolog term representation, so that the built-in Prolog term unification can be used for the unification of sorted feature structures, and no special unification algorithm is needed.ProFIT: Prolog with Features, Inheritance and Templates Gregor Erbach Universitt des Saarlndes Computerlinguistik D-66041 Saarbrficken, Germany e-mail: erbachcol i.uni-sb, de URL : http ://coli. uni-sb, de/ erbach/ Abstract of ordinary prblog terms. We provide a general tool that brings together these developments by ProFIT is an extension of Standard Prolog with Features, Inheritance and Templates. ProFIT Mlows the programmer or grammar developer to declare an inheritance hierarchy, features and templates. ProFIT compiles all sorted feature terms into a Prolog term representation, so that the built-in Prolog term unification can be used for the unification of sorted feature structures, and no special unification algorithm is needed.
"An expert system for the real time control of the UK telephony networkAn expert system for performing traffic management in BT's UK telephony network is described that is both fast and flexible. The choice of the Prolog as the main implementation language allows us great flexibility in how we represent the problem and for rapid prototyping our solution.In the dm,oa w outline our expcdzacu in developing system and discuss why we chase Prolog as the implemealalim languqe. We tbe.n .look m the furore, end outline ore"" intenfinn to opply new techniques d pa.-, m this @btio td some of the msulls of work already under-k,m in this area. lna.lly we comp]eM the. psp with COlel,,mn,nls have drawn fi'mn our e=q:J'ieax:e.sin dve.hpinsand evalung the ARMS. This could bedue Prolog bPJnoan unlmown quantity IV ova""©ualnmeas that have smnB progrRmnfing experience or due the lack of eWerhwced Prolog develepem Further Work Further work is required on the system, firstly to evMume the new apprmch and w.mndly m see how certain system pm'formanc measures mm be improved. ANN Te.Jm=,,-irJimm. 44. No U-12,1989. 4 ""l'he Craft of Prolog. Rkherd Olofe. MIT Press. 1990. 5 Quintus Pmlog."
Toward integrating imperative and logic programming paradigms: WYSIWYG approach to PROLOG programmingThis paper presents an integration of imperative and logic programming, implemented on a PROLOG interpreter. The idea is to exploit the interpreter's execution model to support a procedural style of coding, and to imcorporate the notion of state by means of the use of the internal database.Toward InteBrati.9 Imperative and L09ic Pr 09rammi.9 Paradi ms:A W /SI #'fG aoor 0aeh-t0 PROLOG Programmi. e Claudio Delrieux (I), Pablo Azero (2) and Fernando Tohm@ (3) (I) Departan'tento de Ingenieria El 4ctrica (2) Departanxento de Maten:ttica (3) Departamento de Jz,cononlIa Universidad Naciona] del Sur Alem 1.253 Bahia Blanca ARGENTINA e-maih protres@unsip@dcfcen .edu .ar This paper presents an integration on a PROLOG interpreter. We can now explain procedurally, following graphically the behavior of the interpreter, some features of the PROLOG as an instance the failure driven loop a', b, programming language. Springer-Yedag, I,. 1884 [6] Procedural Metapredicates for PROLOG Deldeux. C, Azero, P. & Tohm, F. Unpublished Report [8] The Art of PROLOG Slerling L & Slmpiro E Flit Press. 1'4A.198B
OPIUM: a debugging environment for Prolog development and debugging researchOpium is an extensible debugging environment for PROLOG providing high-level debugging facilities for programmers and debugging experts.
DDL: a parallel implementation of Prolog
Andorra I: a parallel Prolog system that transparently exploits both And-and or-parallelismAndorra-I: A Parallel Prolog System that Transparently Exploits both And- and Or-Parallelism Vitor Santos Costa, David Department H. Warren, Rong Yang * of Computer Science University of Bristol Bristol BS8 ITR, U.K. Andorra-I is an experimental parallel Prolog system that transparently exploits both dependent and-parallelism and or-parallelism. This means that Andorra-I not only supports standard Prolog but also provides the capabilities of flat committed-choice languages such as Parlog and GHC.
Partial synthesis of sentences by coroutining: constraints on different levels of well-formednessWe describe the principle of the general coroutining process and the associated Prolog program.We describe the principle of the general coroutining process and the associated Prolog program. KEYWORDS Natural Language Interface, Analysis, Synthesis, Guided Composition, Partial Synthesis, Coroutine, Prolog. 1. Formalisms in which this linguistic knowledge is expressed are independant of any programming language. 4. COROUTINING CONSTRAINTS : THE CORE PROLOG PROGRAM The reversibility of certain Prolog programs is well known. So, in order to facilitate the implementation of a system running both ill analysis and in synthesis, the run time of the ILLICO interface is a Prolog program. Lexical rules (the lexicon), syntactic rules (the grammar) and compositional semantic rules are translated into a Prolog program according to the following schema : Lexical rules Syntactic rules Semantic rules I I I $ Translator $ Prolog Program : entence (D,R) The top call of the Prolog program produced by tim translator is sentence (D, R) .
"Technical correspondence: a correction to the denotational semantics for the Prolog of Nicholson and FooA Correction to the Denotational Semantics for the Prolog of Nicholson ALAN FINLAY and LLOYD ALLISON Monash University In [1] we described the use of Standard ML and Foo [2] to implement and experiment with the denotational semantics implementing the semantics, of Prolog [3] semantics In the process of an error was detected by the Standard ML type system. C = fn: CLAUSE error when it is subsequently used: ((Tv ((Subs (Subs (Subs - Subs))) - (Subs (Subs (Subs Subs))))) (Tv ((Subs (Subs - (Subs - Subs))) (Subs (Subs Subs))))) 1 FINLAY, A., AND ALLISON, L. A prescription for Prolog control features based upon denotational semantics and its implementation Computer Science, Monash Univ., Melbourne , 2 HARPER, R., MILNER, R., AND TOFTE, M. Syst. 11 , 4 ( Oct. 1989 ), A denotational semantics for Prolog . ACM Trans. Program. 650-665 , Received April 1991, accepted September In""Trace-Based Network 1992 Corrigendum Proof Systems: Expressiveness and Completeness"" by Jennifer Widom, David Gries, and F."
Parallel logic programming systemsOne research stream aims at transparent exploitation of parallelism in existing logic programming languages such as Prolog, while the family of concurrent logic languages develops language constructs allowing programmers to express the concurrency-that is, the communication and synchronization between parallel processes-within their algorithms. These solutions have been implemented, and the most efficient parallel logic programming systems reach effective speedups over state-of-the-art sequential Prolog implementations. The article also addresses current and prospective research issues in extending the applicability and the efficiency of existing systems, such as models merging the transparent parallelism and the concurrent logic languages approaches, combination of constraint logic programming with parallelism, and use of highly parallel architectures.One research exploitation of parallelism in existing logic programming languages such as Prolog, language constructs allowing whale the family of concurrent logic languages develops programmers to express the concurrency-that is, the communication and synchronization algorithms. INTRODUCTION Logic programs can be computed multisequential implementation techniques, Prolog, scheduling parallel tasks, static analysis, sent the most promising way to increase the computing power of computers in the sequen- future. INTRODUCTION 2, PARALLELISMS IN LOGIC PROGRAMMING 2.1 Logic Programs `2 2 Sources of Parallehsm m Logic Programs 23 OR-Parallehsm m Prolog 2.4 AND-Parallehsm m Prolog 3. LANGUAGE ISSUES 3.1 Parallehz]ng Prolog 3.2 Delays, Synchronlzatlon, and Concurrency 3.3 Concurrent Logic Languages 34 Umfymg Prolog and Concurrent Languages 4 IMPLEMENTATION ISSUES 41 From Early Models to Multisequential Systems 42 Efficient Sequential Implementation Techniques 43 OR-Parallelism 4.4 AND-Parallehsm 45 Scheduhng of Parallel Tasks 5 SYSTEMS EXPLOITING ONE TYPE OF PARALLELISM 51 Systems Exploiting OR-Parallehsm 2 A System Exploiting Independent AND Parallehsm: &-Prolog 53 Systems Exploiting Dependent AND-Parallelism 54 Performance of Systems Exploiting One Type of Parallelism 6 SYSTEMS COMBINING SEVERAL TYPES OF PARALLELISM 61 Systems Combming Independent AND- With OR-Parallelism 62 Systems Combmmg Dependent AND- With OR-Parallelism 7 CTRRENT RESEARCH AND PERSPECTIVES 7 1 Statw Analysis of Logic Programs 72 Parallelism and Constraint Logic Programming 73 Concurrent Constraint Languages 74 Use of Massively Parallel Multiprocessors ?)
Partial synthesis of sentences by coroutining: constraints on different levels of well-formednessWe describe the principle of the general coroutining process and the associated Prolog program.
On the complexity of dataflow analysis of logic programsFollowing the syntax program consists of a finite set of predicate defini of Edinburgh Prolog, we write the names of variables starting with uppercase letters, predicate) symbols starting with and the names of nonvariable (i. e., function and lowercase letters. Here, G is a Prolog goal, that p is true (respectively, false) if the goal G succeeds with answer substitution {V H t } (respectively, {V # f}). Recall that our immediate G is the goal: A2, Tl), objective Schonfinkel-Bernays formulae to Prolog program PW yields satisfiability information from.
"Efficient dataflow analysis of logic programsD.1.6 [Programming Techniques]: Logic Programming, D.3.4 [Programming Languages]: Processes-compilers, General Terms: Algorithms, Languages, optimization Performance Additional Key Words and Phrases: Program L Introduction Analysis, PROLOG Despite the numerous attractive features offered by logic programming lan guages, they can often be dismayingly rise to a great deal of research in programs (see Section 8). In this paper, we adhere to p may be called from the outside with be more than one entry for a predicate the definite clause as P syntax of Edinburgh Prolog and write a :-ql,..., q,,. read declaratively as ""p if ql uppercase letters, while names symbols begin with lowercase and"""""" and q~"". MELLISH, C. S. Some global 46. optimizations for a Prolog compiler. J. Logic Prog. 2, 1 (Apr. MELLISH, C."
"Cost analysis of logic programsINTRODUCTION (Semi-)automatic cost analysis Complexity, program analysis, PROLOG of programs has been widely studied in the context of functional languages. and functional programs in this A major difference between logic programs regard is that logic programs are nondeterministic in general, and may produce that because failure of execution multiple solutions. A logic program consists of a finite We adhere to the syntax of Edinburgh Prolog and write a definite clause as P:-91>...,9n read declaratively as ""p if ql and. upper case letters, while names symbols begin with lower case . . and q. ."" ACM 18, 9 (Sept.), 528-539. 1988, A type system for logic programs. In Concurrent Prolog: Collected Papers, vol. 2, E. Shapiro, WELSH, D."
LHIP: extended DCGs for configurable robust parsingKeywords: I)CG, head, island parsing, robust parsing, Prolog 1 LHIP Overview This paper describes LIIII' (Left-Ilead corner Island Parser), a parser designed for broadcoverage handling of Imrestricted text. First, we define what constitutes an acceptable LHIP grammar, second, we describe the process of converting such a grammar into Prolog code, and third, we describe the analysis of input with such a grammar. _)) The connectives ',' and , have the same precedence as in Prolog, while '' has the same precedence as '. Parentheses may be used to resolve ambiguities.
Automating the detection of reusable parts in existing softwareWe also describe a toolset called Code Miner that implements part of the model. The toolset uses Prolog as its inference engine. Code Miner is designed to assist the programmer in jinding reusable components in existing software written in C. Keywords: software reuse, reusable components, reengineering, Prolog, experts ystem. 1: Introduction While a great deal of research over the past several years has been devoted to the creation of reusable software components and component libraries, the issue of how to salvage reusable components from existing systems has remained relatively unexplored. Invoke Parser 5. Invoke Prolog Prolog Facts Interpreter 2 / Prolog Rules Figure 3: Code Miner processing sequence coupling, and the concepts of looseness and tightness are difficult to quantify.
"On deductive databases with incomplete informationSuch a query is referred to as a possible query, and the prefix pos is used to denote a possible query. 3.1 The Proof Theory of Incomplete The satisfiability of a Horn system effective systems such as Prolog Deductive Database is decidable, and there exist reasonably to construct a query evaluation system. Both strategies are implemented since the tuple-oriented approach it causes repeated evaluation, by using Prolog. Statistics show that, uses the ""fail-and-backtracking"" technique, hence it is less efficient. The prototype are proposed for such a deductive database implementations of both approaches are given in Prolog and discussed fully CHOLVY , L. AND DEMOLOMBE , R. tional Conference on Expert 365-371. in Kong [1989] and Kong and Williams [1989]. 1986."
Visualizing and querying software structuresKeywords and phrases : software design, software engineering, Prolog, 4Thought, GraphLog, G+ , graphical queries, visual queries, theory-model paradigm . Develop a model for the theory : a. Create a Prolog database describing the specific instance of the problem. GraphLo g queries are graphs whose nodes are labelled a sequence of Prolog variables and constants, and whose arcs are labelled by regular expressions composed of Prolog predicate names .
Using active constraints to parse GPSGsIn this paper, we describe how to use such constraints for parsing ID/LP grammars and propose an implementation in Prolog III.In this paper, we describe how to use Slleh constraints tot parsing ID/LP grammars and propose an inlplenlelmtl, iou in Prolog Ill. Keywords : constraints, syntax, ID/I,P formalism, bottom-up filtering, Prolog IlI 1 Introduction Logic programming is one of the nlost useful tools in computational linguistics. COLING 92, NAN'IIS,23 28 ao(rr 1992 8 1 2 Parsing and deduction IIoth for historical itllll [orlilal reasolls, parsing turn ck)se relalions with logic The birth of Prolog, for example, ws conditioimd by Ihat aud NLP was one of the early applications of this language. The use of this kind of constraint is possible in Chip (ef [Dincbas 88]), but not in Prolog III (cf [ColmerauergO]). tlowever, using this order relation as an actual constraint allowing the reduction of domainvariables is difficult.
Coordination in unification-based grammarsSatisfiability conditions for the connectives in terms of deterministic finite state automata are given, both for the atomic case and for the more complex case. Finally, the Prolog implementation of the connectives is discussed, and it is illustrated how, in the atomic case, and with the use of the freeze/2 predicate of second generation Prologs, the connectives may be implemented.Satisfiability conditions for the connectives in terms of deterministic finite state automata are given, both for the atomic case and for the more complex case. Finally, the Prolog implementation of the connectives is discussed, and it is illustrated how, in the atomic case, and with the use of the freeze/2 predicate of second generation Prologs, the connectives may be implemented. Implementation may be approached by adopting a strict division between the objects of the language and the objects of the described world. According to this approach, and in Prolog, Prolog terms re taken to correspond to the objects in the semantic domain, with Prolog clauses being interpreted much as in the syntax of an equational logic, as constraints on those terms. The freeze/2 predicate of many second generation Prologs provides some help here. For standard aWe assume that the rule licensing coordinate structures unifies all corresponding values (such as the vahies for each SUBCAT attribute) except for the values of the HEAD attributes.
From the Editor-in-ChiefGuest Editor°s Introduction Thc Second Intematinnal Confcnmcc on Practical Applications of Prolog (PAP'94) waa held in London in April, 1994. Thc papcrs included hcrein are zeviscd and canded vminns of thrco papcrs included Tciommunicatiorm and Nworks section. in thc The submissiom wcm invited specifically for this spccial issue of ACR. They dascribe ATMS, an cxpmt systm dcv©lopcd in Prolog for seal-tim© control of traffic flows in thc UK tclcphony nctwork. The conference is sponsored by PMG, the Prolog ManaKmnnt Group which evolved from PVG, the Prolog Vendor's Group.
SPARSE—an expert system for alarm processing and operator assistance in substations control centersThe software organization is presented in figure 4. Our system is mainly written in Prolog, includes a pre-procossing module written in C language and runs on a Decstation 5000/240, under Ultfix. The first two kinds of knowledge are included in the Fact Base, under the form of Prolog facts. The messages are treated by a pre-processing module written in C language. This module converts them into Prolog facts that are transmitted to SPARSE that processes them on-line.
Unification factoring for efficient execution of logic programsThe efficiency of resolution-based logic programming languages, such as Prolog, depends critically on selecting and executing sets of applicable clause heads to resolve against subgoals. A polynomial-time algorithm is given for constructing optimal factoring automata which preserve the clause selection strategy of Prolog. More generally, when the clause selection strategy is not fixed, constructing such an optimal automaton is shown to be NP-complete, solving an open trie minimization problem. Unification factoring is implemented through a source code transformation that preserves the full semantics of Prolog. This transformation is specified in the paper, and using it, several well-known programs show performance improvements of up to 100% across three different systems.Develop ing such techniques is a problem of considerable importance The efficiency of resolution-based logic programming guages, such as Prolog, depends critically on selecting executing sets of applicable clause heads to resolve g lan- for efficient evaluation of logic programs. and Traditionally this optimization is viewed as a two-phase against process. A prot otype of unification factoring is available by anonymous ftp. 1 Introduction In logic progr amming languages, such as Prolog, a predicat e is defined by a sequence of Horn clauses. The number of these operations is reduced by unification factoring. Parallel Prologs such as Andorra have similar expenses so that unification factoring can be expected to provide similar speedups for such systems.
A sequential abstract machine for a distributed logic languageDelta Prolog is a concurrent logic programming language founded on the theoretical model of Distributed Logic and extending the Prolog language in order to allow the specification of concurrent systems. This paper describes Delta Prolog, its operational semantics and a sequential abstract machine (DAM) for the language.Carvalhosa _ent of Computer Science Universidade Nova de Lisboa 2825 Monte da Caparica Portugal jcc@fct,unl.pt, mcv@fct.unl.pt called Distributed Logic [Monteiro, 1983] and extends Horn DeIta Prolog is a concurrent logic programming language founded on the theoretical model of Distributed Logic and extending the Prolog language in order to allow the specification of concurrent systems. This paper describes Delta Prolog, its operational semantics and a sequential abstract machine (DAM) for the language. 1.Introduction The declarative semantics of a logic program allows the user to specify a given problem without References to any operational execution model. A program in Distributed Logic has well defined declarative and refutational semantics, which were proven to be equivalent Ilvfonteiro, 1983] Ilvlonteiro, 1986]. Based on this theory, the Delta Prolog (AP) language was proposed mereti 1984], Fereira, 1988], Delta Prolog extends Prolog with three new kinds of goals (the Delta Prolog goals): fhe split goal, the event goal and the choice goai.
"Enterprise transaction processing on Windows NTGreg Hope, Chief Architect Prologic Corporation 100-3851 Shell Road Richmond, B.C. ` "" - Bill Gates, Fortune, January 16/95. For over 10 years Prologic has been replacing mainframe and mini-computer based enterprise-wide transaction processing systems with distributed networks of PCS, Prologic's customer base includes over 100 installations of line-of-business systems in banking, insurance and inventory control. C., used Prologic's PROBE for DOS-based technology in production."
XSB as an efficient deductive database engineThis paper describes the XSB system, and its use as an in-memory deductive database engine. XSB began from a Prolog foundation, and traditional Prolog systems are known to have serious deficiencies when used as database systems. In addition XSB significantly extends and improves the indexing capabilities over those of standard Prolog. Finally, its syntactic basis in HiLog [2], lends it flexibility for data modelling. The implementation of XSB derives from the WAM [25], the most common Prolog engine. XSB inherits the WAM's efficiency and can take advantage of extensive compiler technology developed for Prolog.This paper describes the XSB system, and its use as an inmemory deductive database engine. XSB began from a Prolog foundation, and traditional Prolog systems are known to have serious deficiencies when used as database systems. In addition XSB significantly extends and improves the indexing capabilities over those of standard Prolog. Finally, its synt attic basis in HILog [2], lends it flexibility y for data modelling. The implementation of XSB derives from the WAM [25], the most common Prolog engine, XSB iuherits the WAM'S efficiency and can take advantage of extensive compiler t ethnology developed for Prolog.
Extending CLOS towards logic programming: a proposalProlog, because of its weakness in describing structured objects, has always benefited from a mixing with an OO paradigm maybe more than other languages. We show how it has been possible to introduce in CLOS a set of new mechanisms which allow the execution of Prolog programs. The paper outlines how the CLOS approach resulted in a very useful and powerful framework to increase flexibility, expressivity and elegance in Prolog design.Extending CLOS towards Logic Programming : A Proposal Vinccr o LOIA 1,2 , lVlid l QUAC 3ETTO 2 1 Dipartimento di Informatica ed Applicazioni Universit/i di Salerno 1-84081 Baronissi 2 Laboratoire d'Informatique Th 4orique et Programmation Institut Blaise Pascal Universit 4 Pierre et Marie Curie, 4 Place Jussieu F-75252 PARIS Internet: {iv,mq}@litp.ibp.fr Abstract Prolog, because of its weakness in describing structured objects, has always benefited from a mixing with an OO paradigm maybe more than other languages. We show how it has been possible to introduce in CLOS a set of new mechanisms which allow the execution of Prolog programs. The paper outlines how the CLOS approach resulted in a very useful and powerful framework to increase flexibility, expressivity and elegance in Prolog design. 1 - Introduction The impact of object-oriented methodology is largely emphatized in software development projects. Here, our goal is to process a prolog program in CLOS. The Prolog program corresponds in CLOS to a set of methods which perform the Prolog demonstration.
Analyzing logic programs with dynamic schedulingTraditional logic programming languages, such as Prolog, use a fixed left-to-right atom scheduling rule.Furthermore, global dataflow analyses used in the compilation of traditional Prologs, such as mode analysis, are not correct with dynamic scheduling. This means that compilers for languages with dynamic scheduling are currently unable to per form optimizations which improve execution speed of traditional Prologs by an order of magnitude [19, 21, 31, 32, 33]. However, it is not simple to extend anal yses for traditional Prologs to languages with dynamic scheduling, as in existing analyses the fixed scheduling is crucial to ensure correctness and termination.
SetLog, a tool for experimenting with new semanticsSetLog is a software system that can be used to experiment on several semantics for extensions of Prolog with sets. A first prototype of SetLog has been implemented including the features of a standard Prolog interpreter and of an interpreter for finite set expressions (SETL).SetLog, a Tool for Experimenting with New Semantics 1 Marco Pellegrini and Raimondo Sepe 2 Department of Computer Science Courmt Institute of Mathematical Sciences New York University Abstract SetLog is a software system that can be used to experiment on several semantics for extensions of Prolog with sets. A first prototype of SetLog has been implemented including the features of a standard Prolog interpreter and of an interpreter for finite set expressions (SETL). A solution for this weakness is to extend the semantics of a logic language, such as Prolog, to include new concepts. Recently several authors proposed the use of sets to enhance the logic paradigm. The pattern matching and the backtracking mechanisms, which contribute most to the power of Prolog, are also present in SETL, but they are not as powerful as in Prolog.
Towards a deductive database for small simple groupsThis particular study investigates the application of Prolog and the associated technology of deductive databases to the realm of modern algebra. The information is very heterogeneous in nature, involving formulae, tables, lists, arbitrary precision integers, character strings, irrational numbers, and rules for deducing information from the given facts.While very much a feasibility study, the work to date demonstrates that the Prolog deductive database technology is appropriate. More primitive data types, such as irrational numbers, infinite precision numbers, and tables would improve the efficiency of Prolog in this domain.Iyer Department of Computer Science University of Sydney Sydney NSW 2006, Australia Abstract This particular study investigates the application of Prolog and the associated technology of deductive databases to the realm of modern algebra. While very much a feasibility study, the work to date demonstrates that the Prolog deductive database technology is appropriate. More primitive data types, such as irrational numbers, infinite precision numbers, and tables would improve the efficiency of Prolog in this domain. This project set out to investigate the appropriateness of Prolog and deductive databases to knowledge-bases for modern algebra.
Practical metaprogrammingMetaprograms are specified in an annotated by-example style accessible to ordinary programmers of the source language. Annotations are in the form of Prolog-like predicates that specify the conditions under which different parts of the source template are to be instantiated. Instantiation of a source component is done by specifying facts about the new application in a database, from which the appropriate instance of the metaprogram is automatically inferred using Prolog-style deduction.This paper describes a practical metaprogramming system being developed as part of the ITRC Software Life Cycle Technology project, which utilizes source transformation to implement all phases of the metaprogramming process. Examples are shown of the use of metaprogramming in automatically deriving C language glue routines that allow Prolog programs to access the GL graphics library.Metaprograms ar e specified in an annotated by-example style accessible to ordinary programmers of the source language . Annotations are in the form of Prolog - like predicates that specify the conditions under which different parts of the source template are to be instantiated . Using a by-example style accessible to programmers of the C and Prolog programming languages, specify metaprogram s to automatically generate the source code for th e glue necessary to make GL available to Prolog programmers . Prolog [Kowalski 74] can be used to program metaprograms for some languages, includin g Prolog itself.
Coordinating rule-based software processes with ESPPoliS extends Linda aiming at the specification and coordination of logically distributed systems. ESP (Extended Shared Prolog) combines the PoliS mechanisms to deal with concurrency and distribution, with the logic-programming language Prolog, to deal with rules and deduction.PoliS extends Linda aiming at the specification and coordination Prolog) combines the PoliS mechanisms logic-programming language Prolog, of logically distributed systems. We introduced elsewhere rule-based software processes, we use of its inferential and relational capabil the parallel logic language Shared Prolog [11], that combines Prolog with sion of Shared Prolog that a Linda-like tuple space. Here, we use an exten is better suited for distributed programming. In fact, Extended Shared Prolog bines the features of PoliS (ESP for short) is a logic language that com for distributed programming with the declarative and inferential capabilities Finally, we show how of Prolog.
ObjVProlog-D: a reflexive object-oriented logic language for distributed computingIt is based on concurrent logic objects interacting through remote logic method calls. It preserves the Prolog don't know nondeterminism by implementing distributed backtracking to search for all solutions to goals. Furthermore, its metaclass and reflexive features improve significantly the use of widespread metaprogramming techniques. ObjVProlog-D is implemented in Quintus Prolog and distributed applications have run on a network of workstations.It is based on concurrent logic objects interacting through remote logic method calls. It preserves the Prolog don't know nondeterminism by implementing distributed backtracking to search for all solutions to goals. Furthermore, its metaclass and reflexive features improve significantly the use of widespread metaprogramming techniques. ObjVProlog-D is implemented in Quintus Prolog and distributcd applications have run on a network of workstations. 1 Introduction Distributed programming languages are designed to provide either specific concurrent constructs and/or a higher level concurrent computation model. The general policy to solve this problem is to grant only one process the right to bind a shared logic variable. Concurrent Prolog, for instance, uses read-only variables which explicitly designate a producer process and a set of consumer processes for each shared logic variable.
Unification based FP interpretersThe language specification provides the framework for the construction of two FP interpreters.An interpreter using an innermost first evaluation strategy, the standard evaluation approach for functional composition, is implemented in Prolog. The rules of the language specification are directly translated into Prolog grammar rules. The message passing and type checking are achieved using the unification of variables in the Prolog grammar rules.The innermost first strategy requires the compilation and evaluation of the subfunctions and functional forms that comprise an FP function.An interpreter using an innermost first evaluation strategy, the standard evaluation approach for functional composition, is implemented in Prolog. The rules of the language specification are directly translated into Prolog grammar rules. The message passing and type checking are achieved using the unification of variables in the Prolog grammar rules. The innermost first strategy requires the compilation and evaluation of the subfunctions and functional forms that comprise an FP function. Section 3 describes the implementation of an innermost first evaluation strategy using Prolog grammar rules with unification used to accomplish the message passing.
Parallel bounded quantification—preliminary resultsWe have extended D. H. D. Warren's abstract machine for sequential Prolog with parallel instructions that implement bounded quantifications, an extension to Prolog proposed by Barklund and Bevemyr.Uppsala University, E-mail: arro©csd, uu. se, j onas©csd, uu. se, bevemyr@csd, uu. se some computations which otherwise would be written as recursive programs can instead be written as Abstract We have extended D. H. D. Warren's abstract machine for sequential Prolog with parallel instructions that implement bounded quantifications, an extension to Prolog proposed by Barklund and Bevemyr. Barklund & Bevemyr (1992) have defined a particular extension of Prolog with bounded quantifications and also defined extensions to D. H. D. Warren's sequential abstract Prolog machine (1983), a.k.a, WAM, that implement this extension.
A concise presentation of ITLITL (Intensional Terminological Language) is a Prolog-based language derived from our previous work on DRL. Like LOGIN, it improves the expressive adequacy of Prolog by the introduction of a separate theory, which represents the sortal structure of the domain.A Concise Presentation of ITL Nicola Guarino LADSEB-CNR National Research Council Corso Staff Uniti 4, 1-35020 Padova, Italy gnarino@ladseb.pd.cnr.it Abstract ITL (Intensional Terminological Language) is a Prolog-based language derived from our previous work on DRL. Like LOGIN, it improves the expressive adequacy of Prolog by the introduction of a separate theory, which represents the sortal structure of the domain. Introduction ITL (Intensional Terminological Language) is a Prolog-based language derived from our previous work on DRL [11-14].
A logic programming view of relational morphologyRelations, whether finite state or not, can be computed using any of several paradigms, and we present a logical reading of a notation for relational morphological rules (similar to that of Koskenniemi's) which can in fact be used to automatically generate Prolog program clauses. Like the finite state implementations, the relation can be computed in either direction, either from the surface to the lexieal level, or vice versa. The morphological rules often compile simply into unification of the arguments in the generated morphology predicate followed by a recursive call of the said predicate. Further speed can be obtained when a Prolog compiler, rather than an interpreter, is used for execution.Relations, whether finite state or not, can be computed using any of several paradigms, and we present a logical reading of a notation for relational morphological rules (similar to that of Koskenniemi's) which can in fact be used to automatically generate Prolog program clauses. Like die finite state implementations, the relation can be computed in either direction, either from the surface to the lexieal level, or vice versa. The morphological rules often compile simply into unification of the arguments in the generated morphology predicate followed by a recursive call of the said predicate. Further speed can be obtained when a Prolog compiler, rather than an interpreter, is used for execution. Prolog compiler indexing mechanisms often make it possible to access the correct clause to be applied in constant time.
An overview of the A architecture for optimisation problems in a logic programming environmentIn this paper we propose a hierarchical architecture using content addressable memory to accelerate the A* algorithm in a Prolog system and remove the associated high memory overheads.An overview of the A* Architecture a logic programming for optimisation problems in environment D.P.Rodohan R.J.Glover Dept of Electrical Engineering and Electronics Brunel University Uxbridge Middlesex UB8 3PH UK email: D.P.Rodohan@brunel.ac.uk Raymond.Glover@brunel.ac.uk Keywords [Prolog, Logic programming, Content Addiessable memory, Parallel computing, A* algorithm] Abstract Search of a state space is a common function in artificial intelligence applications consuming a large proportion of the total processing time. In this paper we propose a hierarchical architecture using content addressable memory to accelerate the A* algorithm in a Prolog system and remove the associated high memory overheads. 1.Introduction The A* algorithm [Ni 180,Pr 184] is commonly used to find the optimal path through a state space and is generally accepted as the best method [Pr 188]. When the A* algorithm is implemented on a sequential Prolog system the memory overheads are high due to the non-destructive assignment of variables, this will be shown in section 3.
"Executing an SECD machine using logic programmingThe SECD abstract machine provides a small but clear description of the operational semantics of the lambda calculus. By implementing the SECD machine in Prolog, we give students a tool for testing specifications and for experimenting with alternate language semantics in an interactive setting.The SECD abstract machine provides a small but clear description of the operational semantics of the lambda calculus. By implementing the SECD machine in Prolog, we give students a tool for testing specifications and for experimenting with alternate language semantics in an interactive setting. SIGCS<""'953@5 Nashville, TN USA @ 1995 ACM 0-89791-893-)d9510003....50.5o how the SECD machine can be implemented in Prolog, thereby giving a more concrete view of the definition and behavior of the SECD machine. The Prolog implementation provides insightinto theformaloperationalmethod and serves as a vehicle for experimenting with the semantics of the lambda calculus."
An abstract machine for CLP(R)The core Constraint Logic Arithmetic Machine (CLAM) extends the Warren Abstract Machine (WAM) for compiling Prolog with facilities for handling real arithmetic constraints.The core Constraint Logic Arithmetic chine (CLAM) extends the Warren Abstract lan Ma Machine (WAM) for compiling Prolog with facilities for handling rea 1 arithmetic constraints. While the WAM made PROLOG practical, global analysis shows the potential of making another major leap. interpreter [5] satisfied criteria in the sense that it executed PROLOG grams at least as efficiently as other PROLOG preters, and handled simple constraints directly out using the constraint solver.
Memoization of coroutined constraintsThis paper shows how constraints can be propagated in a memoizing parser (such as a chart parser) in much the same way that variable bindings are, providing a general treatment of constraint coroutining in memoization. Prolog code for a simple application of our technique to Bouma and van Noord's (1994) categorial grammar analysis of Dutch is provided.This paper shows how constraints can be propagated in a memoizing parser (such as a chart parser) in much the same way that variable bindings are, providing a general treatment of constraint coroutining in memoization. Prolog code for a simple application of our technique to Bouma and van Noord's (1994) categorial grammar analysis of Dutch is provided. 1 Introduction As the examples discussed below show, some linguistic constraints cannot be effectively resolved during parsing at the location in which they are most naturally introduced. Such parsers are particularly easy to implement in extended versions of Prolog (such as ProloglI, SICStus Prolog and Eclipse) which have such coroutining facilities built-in. It is easy to formalize this kind of grammar in pure Prolog. In order to simplify the presentation of the proof procedure interpreter below, we write clauses 100 Marie opzettelijk NP2 Frits ADV NP1 lijkt te VPt/VP.___.__.
Logical objects with constraintsThe operational interpretation defined in the style of natural semantics is simple and clear. The transformation of LOC into Prolog is also explored to indirectly illustrate the descriptive semantics.The operational interpretation defined in the style of natural semantics is simple and clear. The transformation of LOC into Prolog is also explored to indirectly illustrate the descriptive semantics. 1. In section 4, we investigate the transformation of LOC into Prolog. In section 5, we compare our approach with related work. Taking this as a basis, we now discuss the transformation from LOC to Prolog. Suppose that Prolog is slightly modular, where each module is identified by its name, and predicates may be invoked by other modules.
The JaRAP experimental system of Japanese-Russian automatic translationThe system is implemented on IBM PC, MS DOS, in Arity Prolog (analysis and transfer) and Turbo Pascal (synthesis).The system is implemented on IBM PC, MS DOS, in Arity Prolog (analysis and transfer) and Turbo Pascal (synthesis). 1 Theoretical background The development of the Jall.AP experimental system was preceded by a long period of purely theoretic research into various aspects of natural language 'td its functioning in translatiot (see, e.g., (ShalyaplnalO80a,1980b,1988)). It is implemented on IBM PC, MS DOS, its programming tools being Arity Prolog for analysis and traamfer and Turbo Pascal for synthesis. 2 The current version of the JaRAP system At present, the JaRAP system does not go far beyond the ifitial lexico-morphological level of text processing (though some provision has already been made for further stages of its development - see See.3). To speed up (lle-113 tionary search the database is provided with n index organized as a superposition of blanced trees. Ewch entry (presented in the database by Prolog term) constitutes a list of entry zones confined ech to one type of linguistic information.
Multi-Modal Definite Clause GrammarFurther, we have developed MM-DCG translator to transfer rules in MM-DCG into Prolog predicates.The major features of MM-I)CG inch, de eal)ability to handle an arbitrary mlmber of modes and temporal information in grammar rules, l:urther, we have developed MM-DCG translator to transfer rules in MM-DCG into Prolog predicates. 1 Introduction This paper describes tile first reported grammatical fi'amework for a multimodal interface. Multi-modal input processing rules can be written in MM-I)CG simply and effectively. Rules in MM-I)CG are translated into Prolog predicates easily. 2 Multi-Modal Input Processing Consider a query (.' Then, Objl and Obj 2 are compared their values in a Prolog predicate enclosed inside curly brackets { and }.
Integrating logic and object-oriented programmingHowever, methods in a LogiC++ program can be represented by Prolog Horn clauses. In this paper, we describe a compiler that takes a LogiC++ program as input and produces an equivalent C++ program as the output.However, methods in a LogiC++ program can be represented by Prolog Horn clauses. In this paper, we describe a compiler that takes a LogiC++ program as input and produces an equivalent C++ program as the output. Moreover, the notation for expressing classes, objects and methods in Concurrent Prolog can be provided by a preprocessor Vulcan (Kahn, et. al., 1986). Our LogiC++ compiler includes this Prolog compiler as the major additional component to the C++ compiler.
Using higher-order logic programming for semantic interpretation of coordinate constructsThese theories are usually implemented in a language such as Prolog that can simulate λ-term operations with first-order unification.These theories are usually implemented in a language such as Prolog that can simulate A-term operations with first-order unification. The fundamental problem in both cases is that the concept of free and bound occurrences of variables is not supported by Prolog, but instead needs to be implemented by additional programming.
"Query evaluation under the well-founded semanticsSLD resolution with negation as finite failure (or SLDNF) reflects the procedural interpretation of Horn-clause predicate logic as a programming language and forms the computational basis for prolog systems. Despite its advantages in memory management, SLDNF is often not appropriate for query evaluation for three reasons, a) it may not terminate due to infinite positive recursion, b) it may not terminate due to infinite recursion through negation, and c) it may repeatedly evaluate the same clause body literal, leading to unacceptable performance. Thus a system including SLG resolution is naturally upward compatible with Prolog. For all these reasons we believe that SLG resolution will provide the computational basis for the next generation of logic programming systems.Query Evaluation under (Extended Weidong Chen"" Computer Science and Engineering Southern Methodist University Dallas, TX 75275-0122 wchen@seas.smu.edu SLD resolution with negation as finite failure (or SLDNF) re flects the procedural interpretation of Horn-clause predicate logic as a programming language and forms the computa tional baais for Prolog systems. Despite its advantages in memory management, SLDN F is often not appropriate e for query evaluation for three reasons: a) it may not terminate due to infinite positive recursion, b) it may not terminate due to infinite recursion through negation, and c) it may repeatedly evaluate the same clause body literal, leading to unacceptable performance. First, SLG resolution founded from a is upward compatible with existing Prolog systems. A distinction can be made between subgoals that are evaluated using SLG resolution and those that are evaluated in Prolog fashion. Prolog computation can be incorporated into SLG resolution by simply solving Prolog subgoals as in Prolog."
"Converting large on-line valency dictionaries for NLP applications: from proton descriptions to metal framesA linguistically motivated valency dictionary in Prolog is converted into a valency dictionary for a large-scale machine translation system.A linguistically motivated valency dictionary in Prolog is converted into a valency dictionary for a large-scale machine translation system. In the next two subsections, we will show how the two formalisms between which the conversion was made try to provide answers to tile relu'entation questions folmulated here, ill particular lot large ts of French and Dutch verbs. 2.2 PROTON 2.2.1 The PROTON project The Proton (Prolog en taalonderzoek, Prolog and linguistic research) project started in 1986 with as cue of its major ohjectives die COllStrnction of on-line valency dictionaries tor [,reach and Dutch. The output of this pass is ""lispified Prolog"": Prolog chmses are turned into l.isp lists. At the same time, the necessary conversions at the character level arc taken care of: characters that would have a special meaning to the ""Lisp reader"" software (such as a comma or a backquole) are neutralized, and the extended ASCIIcharacter sequences for aecentezl characters are turned into Metal's ISO-8859-1 characters."
Guided sentences composition for disabled peopleWe show how guidance can be achieved by means of the partial synthesis of sentences and describe our approach consisting in separating knowledge that comes under different levels of well-formedness and coroutining their treatment. This approach has led us to develop in Prolog a software, ILLICO, allowing for the conception of natural language interfaces with guided sentences composition.We show how guidance can be achieved by means of the partial synthesis of sentences and describe our approach consisting in separating knowledge that comes under different levels of well-formedness and coroutining their treatment. This approach has led us to develop in Prolog a software, ILLICO, allowing for the conception of natural language interfaces with guided sentences composition. The same system is used for analyzing a given sentence and for synthesizing expected fomulations. Orbis is implemented in Prolog and illustrates in a convincing manner the potential reversibility of certain programs written in that language. The algorithm for coroutining the treatment of the different kinds of knowledge in order to avoid dead ends along the guided composition mode is described in (Milhaud et al., 1992). Our approach has led us to develop in Prolog a software, ILLICO, allowing for the conception of natural language interfaces with guided sentences 205 composition.
"A simple transformation for offline-parsable grammars and its termination propertiesWe present, in easily reproducible terms, a simple transformation for offline-parsable grammars which results in a provably terminating parsing program directly top-down interpretable in Prolog. The transformation consists in two steps: (1) removal of empty-productions, followed by: (2) left-recursion elimination.A Simple Transformation for Oflqine-Parsable Grammars and its Termination Properties Marc Dymetman* Rank Xerox Research Centre 6, chemin de Maupcrtuis Meylan, 38240 Fra,nce dyraetmanOxerox, fr Abstract We present, in easily reproducible terms, a simple transformation for offline-parsable grammars which results in a provably terminating parsing program directly top-down interpretable in Prolog. The transformation consists in two steps: (1) removal of empty-productions, followed by: (2) left-recursion elimination. They represent a direct augmentation of context-free grammars through the use of (term) unification (a fact that tends to be masked by their usual presentation based on the programming language Prolog). It is obviously important to ask wether certain usual methods and algorithms pertaining to CFGs can be adapted to DCGs, and this general question informs much of the work concerning I)CGs, as well as more complex unification grammar formalisms (to cite only a few areas: Earley parsing, LR parsing, left-corner parsing, Greibach Norinal l,'orm). The grammar DCG"" can now be compiled in the standard way---via the adjunetion of two ""differential list"" arguments---into a Prolog program which can bc executed directly. If we started from an oflline-parsable grammar DCGO, this program will enumerate all solutions to the parsing problem and terminate after a finite number of steps. 1° [1] Marc Dymetman."
Logic programming based curriculum for high school students: the use of abstract data typesA special curriculum aimed at teaching concepts of logic programming and AI principles, using Abstract Data Types (ADTs) in Prolog environment was developed in the Weizmann Institute of Science.A special curriculum aimed at teaching concepts of logic programming and AI principles, using Abstract Data Types (ADTs) in Prolog environment was developed in the Weizmann Institute of Science. The curriculum presented in this and previous papers (Scherz, Mailer, Shapiro, 1986, Scherz, Goldberg, Fund, 1990, Haberman, 1991) describes our approach for teaching logic programming and AI topics in Prolog environment as part of high school computer science curriculum. (d) Formalization: Formalizing these relations and rules in Prolog. (e) as facts Programming : Writing a complete Prolog program. (0 Execution and Debugging.
Beyond Turing: a knowledge based model relativistic Cn machineCorresponding to scientific problems, we implement knowledge based heuristically developed Prolog databases for visualizing and symbolically analyzing domains for analytic functions over several complex variables.Corromponding to scientific problems, we implanant knowladgo based hauriatically dovalopad Prolog databaass for vimmlizing and slically analyzing domaina for analytic functions ovm ssvoral COMP1OX variab 19s. Whereas traditional databescs handle large amounts of business related data, WE usc a small Prolog based cupcrdatabasc to deal with a model machine for scientific computation over compkx vanabks using quantum thcoty and in a rclativiatically invariant manner. But the greatest source of claboratenrss comes from employing the first order prcdicatc calculus typs logic rcprcscntatiom of Prolog. That is to say, the Prolog subset of predicate calculus provides a sur flexible type of static database. ( also [Ul].)
Polynomial time inference of a subclass of context-free transformationsThis paper deals with a class of Prolog programs, called context-free term transformations (CTF).Polynomial Time Context-free Hiroki ARIh 4URAt Inference of A Subclass of ansformations Hiroki ISHIZAKA$ * Takeshi SHINOHARAt Department of Artificial Intelligence Kyushu Institute of Technology Kawazu 680-4, Iizuka 820, JAPAN arim@ai.kyutech. ac.jp shino@ai.kyutech .ac.jp This paper deals with a class of Prolog pr grams, called context-free term transformations (CFT). Using this algorithm, we show the consistent and conservative polynomial time identifiability of the class of tree languages defined by CFTFBuni together with tree languages defined by pairs of two tree patterns, both of which are proper subclasses of CFT, in the limit from pmitive data. 1 Introduction The problem considered in this paper is, given an infinite sequence of facts which are true in the unknown model, to identify a Prolog program P that defines the unknown model M in the limit. Since CFTFBUni is a subclass of linear Prolog, the next lemma is immediately derived from Theorem 4.
"Specification, Verification and Prototyping of an Optimized CompilerBased on these theorems, a prototype compiler in Prolog is produced.Based on these theorems, a prototype compiler in Prolog is produced. 1. Introduction The development of computer-based systems can benefit from a formal approach at all levels of abstraction from requirements through to design, compilation and hardware. The example encodings of theorems in this section use ""standard"" pure Prolog [CIM87]. Prolog's logical basis makes the encoding a relatively mechanical process. Proofs of termination and non-violation of the omitted occurs-check in Prolog [KPS93] and the compilation of the Prolog itself [Rus 92] are possible."
Parsing with polymorphismThe decision procedure is shown to be terminating, and correct, and a Prolog implementation of it is described.The decision procedure is shown to be terminating, and correct, and a Prolog implementation of it is described. 1 The Lambek Calculus To begin, I give a brief description of Lambek categorial grammar [Lambek, 1958]. This decision procedure is improved upon somewhat if the rules of the calculus are expressed as a Prolog data base of conditionals concerning a binary predicate seq, holding between a list of categories and a single category. For later reference, let Lain stand for some such Prolog implementation of L(/'\). A grammar, G, in this perspective is an assignment of categories to words.
Layer sharing: an improved structure-sharing frameworkThis mechanism should be of interest for alternative execution models of PROLOG which maintain multiple computation branches and reuse sub-computations in various contexts (computation sharing).This mechanism should be of interest for alternative execution models of PROLOG which maintain multiple compu tation branches and reuse sub-computations in vari ous contexts (computation sharing). Waiting Computation - Computation Jhing Figure 1: Some execution principles In the standard sequential model of PROLOG, stack is used to store alternative waiting computations (choice points). An item can be added if it is not an instance of a previously computed item. 2.2 Copying vs Sharing ? WAM-based PROLOG compilers mix structure copy ing with more or less sophisticated forms of structuresharing.
Distributed last call optimization for portable parallel logic programmingIn this paper, we present an important optimization for portable parallel logic programming, namely distributed last-call optimization, an analog of the tail recursion optimization for sequential Prolog. This scheme has been implemented in the ROLOG compiler, which ports unchanged on several shared memory and nonshared memory machines.In this paper, we present an important namely distributed last-call optirnwation, optimization for portable parallel logic programming, an analog of the tail recursion optimization for sequential Prolog. This scheme has been implemented unchanged on several shared memory and nonshared of this optimization on several OR, AND/OR in the ROLOG compiler, which ports memory machines. In International Conference on Logic Programming (Seattle, Prolog An integration of Prolog and committed choice on Fifth Generation Computer Systems (Tokyo, Nov. K, J. &-Prolog and its performance: exploiting indepen dent and-parallelism.
First experiences with the SB-ONE knowledge representation workbench in natural-language applicationsBesides the SB-ONE language, the workbench comprises three different interfaces, a partition mechanism, a consistency maintenance system for the syntactic well-formedness of SB-ONE knowledge bases, a classifier, a realizer, a pattern matcher, a spreading-activation mechanism, an interpreter and classifier for SB-ONE to SB-ONE translation rules, an integration mechanism for an external frame-based representation, and a connection between SB-ONE and an extended Prolog. These components have been employed by a fairly large number of people in various natural-language applications.Besides the SB-ONE language, the workbench comprises three different interfaces, a partition mechanism, a consistency maintenance system for the syntactic wellformedness of SB-ONE knowledge bases, a classifter, a realizer, a pattern matcher, a spreadingactivation mechanism, an interpreter and classifier for SB-ONE to SB-ONE translation rules, an integration mechanism for an external frame-based representation, and a connection between SB-ONE and an extended Prolog. These components have been employed by a fairly large number of people in various natural-language applications. The TELL language often allows knowledge definitions to be made in a more compact form than is possible with the functional interface, particularly as far as concept definitions are concerned,s The retrieval language ASK has a Prolog-like syntax and is combined with a continuation-based solution generator to simulate a Prolog-like query processing. Moreover, an access to databases (which was required by SB-ONE users) should be considered. 5.6 MOTHOLOG MOTHOLOG [Bartsch et al., 1990] is an extended Prolog interpreter which accepts negation and disjunction both in the antecedent and in the consequent parts of the Prolog rules.
"La resoution d'anaphore a partir d'un lexique-grammaire des verbes anaphoriquesThis paper presents a system which intends to resolve anaphora in the framework of the Discourse Representation Theory, and using a lexicon-grammar of anaphoric verbs, through the application of selection criteria for assignment of a referent to an anaphora.From a semantic representation of text provided by a DRT system implemented in Prolog, the system uses several criteria of selection of referent.From a semantic representation of text provided by a DRT system implemented in Prolog, the system uses several criteria of selection of referent. Le present article decdt une approche de resolution d'anaphore qui repose sur: - la mise en oeuvre de ta DRT pour representer la semantique d'un discours, - I'elaboration d'un lexique-.grammaire des verbes anaphotique@, - un systeme de filtre base stir differents criteres de selection Ce systeme illustte la resolution automatique de certaines anaphores en partant de la representation semantique d'un texte obtenue d'apres la DRT los ptonoms que nous avons etudies font partie d'un type d'anaphore qui represente une relation pouvant s'etablir entre deux phrases saris mettre forcement en jeu une regle syntaxique (le pronom pout identifier un referent dans le discours precedent): Jean croit que Mane IU/ offre un //we Cet article est divise en cinq parties: introduction notre travail, presentation de la DRT, puis de son implementation en Prolog, description des lexique-grammaires et leur extension aux proprietes anaphoriques, presentation generale de I'architecture de notre systeme de resolution, et enfin perspectives de creation systematique d'un lexique-grammaire. 2. 2.2 Imp.. mentation de la DRT Notre analyseur semantique demane avec des arbres syntaxiques resultant d'une grammaire de type GPSG, programmee en Prolog La grammaire semantique est base sur les memes principes: unification de structures, augmentation de listes ordonnees, presentee sous forme de regles de reecriture suivies de contraintes, de type: ph -> gn gv = = = = = Ceci donne, 8 partir de regles DCG issues de la compilation des precedentes: traduire(ph(GN, G V),P) :- 'aduire(G V,P2), traduire(GN, PI), imerge(P,[courante],Pl,[courante), imerge(P l, [suite], F2,[courente]), tmerge(Pl, [arg], P2,[arg sujet], imerge(P,[arg sujet], P2,[erg_sulet), tmerge(P, [arg_objet], P2,[arg_objet]) soit la formule semantique: drs (arg sujet(Xl),arg objet(X2), cour(cond( [imp(drs(cond([camion(X l)]), univ([X1])), drs(cond( [charge(X2), transporte(X l, X2)]),univ([X2])) )] )) ). correspondant la phrase ""tout camion ffansporfe une charge""."
"The dual structure of ordered treesInterfaces with the ""outer world"" - e.g. word processors, or LISP and PROLOG can become easy to build with the help of this simple concept of duality.Interfaces with the ""outer world"" - e.g. word processors, or LISP and PROLOG can become easy to build with the help of this simple concept of duality. The pure character form is rather suitable to create ASCII files used by LISP or PROLOG programs (most of the time, blanks simply need to be replaced by commas - parentheses are already there). Langlet , "" Paritons and Cognitons, towards a new Theory of Information "", APL-CAM Journa 2 (Belgium). VO1. 13* 2, (April 1991 ). 3 A. Colmerauer, Prolog 3 (in press). 4 R. Jernigan, ""Logic programing in no."
Book review: Knowledge-Based Systems Analysis and Design-A KADS Developer's Handbook by Stewart W. Tansley and Clive C. Hayball (Prentice Hall 1993)The authors' objective is to convince their target readers (practising computer professionals already well acquainted with the basic concepts of artificial intelligence) to adopt and use KADS. Note that although Prolog is the favored language in Europe, as well as that used by the developers of KADS, it is not used in this book, which simplifies the task of LISP users in applying the methods proposed.These background sections and the book's list of References have been expanded in the second edition to reflect more recent Prolog literature. Most sections also end with some programming or paper-and-pencil exercises, extra exercises have been added in the second edition. The Art of Prolog is an important volume in the Prolog programmer's library. This second edition brings a classic text up to date, incorporating seven years of new developments in Prolog and new insights into the art of logic programming. [12] Shapiro, E., Algorithmic Program Debugging, MITPress, Cambridge, Massachusetts, 1983.
Translating GraphLog to SQLTherefore Hy+ has used various deductive database systems (Prolog, LDL*, CORAL*) to compute GraphLog queries.With large or legacy databases, however, it is desirable to use relational databases like IBM* DB2* for AIX* to perform the computations involved in answering a GraphLog query, largely because such mature relational systems are heavily optimized, widely available, and natively support a client-server style.The forthcoming Version 2 of DB2 for AIX will include features that allow a translation of a large class of GraphLog queries into a list of extended-SQL statements that can be efficiently executed by the database engine.Therefore Hy has used various deductive database systems (Prolog, LDL, CORAL) to compute GraphLog queries. With large or legacy databases, however, it is desirable to use relational databases like IBM DB2 for AIX to perform the computations involved in answering a GraphLog query, largely because such mature relational systems are heavily optimized, widely available, and natively support a clientserver style. Since GraphLog has superior expressive power compared with relational algebra, its implementation in Hy has until recently relied on various deductive or logic databases such as the CORAL [14] and LDL [12] research prototypes, or programs in the Prolog language [2] into which the GraphLog queries can be translated [6, 7]. The algorithm reflects the logic database background of Hy+, in that the term/predicate syntax of Prolog is adopted for labels in hygraphs. This limits the generality of the system since the SQL data types which do not exist in Prolog (e.g., DATE, TIMESTAMP) are only represented as strings.
A tour advisory system using a logic programming approachAlthough a logic programming approach is suitable and valuable for the formulation of combinatorial search problems, conventional Prolog systems fail to cope with them efficiently. PETINA has been implemented in the ElipSys language, which is a parallel logic programming system extended with various porwerful mechanisms to allow efficient execution.Although a logic programming approach is suitable and valuable for the formulation of combinatorial search problems, conventional Prolog systems fail to cope with them efficiently. PETINA has been implemented in the ElipSys language, which is a parallel logic programming system extended with various powerful mechanisms to allow efficient execution. The declarative formulation of this method can be achieved in a logic programming environmenL via the Prolog language [3, 19]. However, due to the inefficiency of the exhaustive search of Prolog, real-life problems cannot be solved in this basic framework. These features consist of the introduction of a data driven computation rule on top of the usual depth-first left-to-right execution strategy of Prolog and the incorporation of constraint satisfaction techniques over finite domains into the language.
Backtracking without trailing in CLP (ℜLin)Existing CLP languages support backtracking by generalizing traditional Prolog implementations: modifications to the constraint system are trailed and restored on backtracking.PASCAL VAN HENTENRYCK Brown university Existing CLP languages support and VISWANATH RAMACHANDRAN backtracking by generalizing traditonal Prolog impementatmns: modifications totheconstrant system and efficent,, trailing may be very aretrailed and restoredon backtracking. Existing CXJP languages support implementations: modifications issue for an in.q,ance of the LP scheme over consists of linear equations. inequalities, and Such a constraint solver is included in several e al. 1988, Van Hentenryck and Graf 1992], al. l!W2a: 1992 b\, and Prolog HI lolmerauer backtracking by generalizing traditional Prolog to the constraint system are trailed (i. e., saved on a speciai stack which contains In addition: techniques such pairs (address, {Ja! R). 2.2 The CLP Scheme At least from a conceptual part of Prolog III [Colmerauer 1990] standpoint, the operational semantics of the CLP scheme is a simple generalization of the semantics of logic programming.
"The Boyer benchmark meets linear logicOf the Gabriel Lisp Benchmarks, the Boyer Benchmark (""Boyer"") is the most representative of real AI applications, because it performs Prolog-like rule-directed rewriting, and because it relies heavily on garbage collection (GC) for the recovery of storage.Of the Gabriel Lisp Benchmarks, the Boyer Benchmark CBoyer"") is the most representative of real AI applications, because it performs Prolog-like rule-directed rewriting, and because it relies heavily on garbage collection (GC) for the recovery of storage. This rewriting is analogous to the operation of a Prolog system in which the rules act as Prolog predicates and the initial formula acts as the initial form to be ""evaluated"". If all of the rules which are indexed to a particular function symbol are compiled together, then the optimizations familiar to any Prolog implementor can be achieved. Our rule compiler compiles each rule separately, and does not therefore take advantage of important inter-rule optimizations."
"A generalized Greibach Normal Form for definite clause grammarsOffline-parsability of the original grammar is reflected in an elementary textual property of the transformed grammar. When this property holds, a direct (top-down) Prolog implementation of the normalized grammar solves the parsing problem: all solutions are enumerated on backtracking and execution terminates.When specialized to the simpler case of context-free grammars, the GGNF provides a variant to the GNF, where the transformed context-free grammar not only generates the same strings as the original grammar, but also preserves their degrees of ambiguity (this last property does not hold for the GNF).The GGNF seems to be the first normal form result for DCGs.Offline-parsability of the original grammar is reflected in an elementary textual property of the transformed grammar. When this property holds, a direct (top-down) Prolog implementation of the normalized grammar solves the parsing problem: all solutions are enumerated on backtracking and execution terminates. The reason is simple: if the auxiliary predicates are defined through an unrestricted Prolog program, there is no means of guaranteeing that calling some auxilly predicate will not result in nontexmination, for reasons quite independent from the structure of the grammar under consideration. Most parsing algorithms are not strongly stables, a notable exception being the ""Earley deduction"" algorithm [7], once modified according to the proposals in [10].4 Top-down implementations--and in particular the standard Prolog implementation of a DCG---are especially fragile in this respect, for they fail to terminate as soon as the grammar contains a left-recursive rule such as: vp(VP2) vp(VPt),pp(PP), {combine(V P1, P P, V P2)}."
Constructor specializationThe discussion is centered around a small subset of Standard ML, but the idea applies equally well to other languages having user defined constructors, e.g. Haskell and Prolog.The discussion is centered around a small subset of Standard ML, but the idea applies equally well to other languages having user defined constructors, e.g. Haskell and Prolog. 1 Motivation It is usually considered bad practice if all residual programs for a given initial program share some syntactic limits with the original program, when these limits are not present in the language as a whole. Prolog has two properties that can cause problems: it is untyped and it allows unification of terms cent aining unbound ables. Bondorf. Logimix: self-applicable partial evaluator for Prolog. K.-K. Lau and T. Clement, editors, LOPSTR 92.
A strategy for dynamic interpretation: a fragment and an implementationThe implementation consists of a syntax module which outputs parse trees, a semantic module mapping parse trees to DPL representations, a representation processor which determines truth conditions, falsity conditions and presupposition failure conditions, and an evaluator of these conditions in a database model.The implementation uses the logic programming language Gödel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics.The implementation uses the logic programming language GSdel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics. 1 The Idea of Dynamic Interpretation Recent developments in Natural Language semantics have witnessed a shift away from static representation languages towards representation languages with a dynamic flavour. Note that 'is' is treated as in Montague grammar [8]. 5 Experiences with the GSdel Implementation Language The declarative semantics of GSdel improves on the semantics of Prolog: extra-logical Predicates (such as vat, nonvar, assert, retract, !.... ) are avoided and sometimes replaced by declarative counterparts. Like Lambda Prolog [7], GSdel is a typed language: it is necessary to declare the type and domain of all functions and predicates (polymorphism is allowed, however).
VLIW compilation techniques in a superscalar environmentWe have designed a set of new algorithms for reducing pathlength and removing stalls due to branches, namely speculative load-store motion out of loops, unspeculation, limited combining, basic block expansion, and prolog tailoring. These algorithms were implemented in a prototype version of the IBM RS/6000 xlc compiler and have shown significant improvement in SPEC integer benchmarks on the IBM POWER machines.We have designed a set of new algorithms for reducing pathlength and removing stalls due to branches, namely speculative load-store motion out of loops, unspeculation, limited combining, basic block expansion, and prolog tailoring. These algorithms were implemented in a prototype version of the IBM RS/6000 XIC compiler and have shown significant improvement in SPEC integer benchmarks on the IBM POWER machines. We have developed a number of original pathlength reduction techniques, including speculative load-store motion out of loops, unspeculation, limited combining, expansion of basic blocks, and prolog tailoring, which result in good performance improvements, which we present in this paper. In the following page we show an example of the application of prolog tailoring. The prolog tailoring algorithm has the following stages: 1.
Resolving anaphora in a portable natural language front end to databasesAn analysis of the evolution of Natural Language front ends in the last three decades shows that the growth in portability brought, as a side effect, the narrowing of the provided coverage of contextually based linguistic phenomena, such as anaphora and ellipsis.This paper presents the design and state of development of a computational mechanism which provides pronominal Anaphora Resolution within the environment of a highly portable Natural Language front end to databases, SQUIRREL' Simple cases of Ellipsis are also treated by the proposed model.An Overview of SQUIRREL is presented, followed by a description of the Discourse Module and the results achieved so far. The prototype is implemented in C-Prolog.An Overview of SQUIRREL is presented, followed by a description of the Discourse Module and the results achieved so far. The prototype is implemented in C-Prolog. 1 Introduction The development of Natural Language (NL) systems for data retrieval has been a central issue in NL Processing research for the last three decades, motivated by the aim of helping non-expert database users.
Backtracking without trailing in CLP (RLin)Existing CLP languages support backtracking by generalizing traditional Prolog implementations: modifications to the constraint system are trailed and restored on backtracking.Existing CLP languages support backtrack ing by generalizing traditional Prolog implementations: modifications to the constraint system are trailed and rest ored on backtracking. Existing CLP languages support backtracking by generalizing traditional Prolog imple mentations: modifications to the constraint system are trailed (i.e. saved on a special stack which contains pairs (address, value)) and restored on backtracking. The second set con of opera tions corresponds to the traditional or-level of WAM-based implementations of Prolog nals the creation of a choice point, Retry instructions [11].
Toward tools to support the Gries/Dijkstra design processWe have constructed a prototype implementation in Prolog and used it to generate a number of example designs.We have constmcted a prototy 1 implementation in Prolog and used it to generate a number of example designs. 1. On the other hand using ISLET, cliche application is reasonably easy and is performed repeatedly by the programmer during development. A prototype implementation has been written in Prolog and used to generate complete designs for several small examples including Kemmerer's Library Problem.
"SEMANTIC SYNTAX at workSchotel has implemented the rule system for English in Prolog.Schotel has implemented the rule system for English in Prolog. The following diagram shows the place of SeSyn in the wider context of a cognitive (""text-level"") discourse-semantics: K on N Incrementation w rules e d DD g eb a / Discourse SemanticAnalysis eS / Domain Parser --I r I' Grammar Surface Structure The generation of English sentences will be demonstrated, with emphasis on the auxiliary system, (including tense, adverb placement, negation, the modals) and the complementation system."
An algorithm for pronominal anaphora resolutionLike the parser, the algorithm is implemented in Prolog. The authors have tested it extensively on computer manual texts and conducted a blind test on manual text containing 360 pronoun occurrences.Like the parser, the algorithm is implemented in Prolog. The authors have tested it extensively on computer manual texts and conducted a blind test on manual text containing 360 pronoun occurrences. RAP applies to the syntactic structures of McCord's (1990, 1993, in press) Slot Grammar parser, and like the parser, it is implemented in Prolog. It relies on measures of salience derived from syntactic structure and a simple dynamic model of attentional state to select the antecedent noun phrase (NP) of a pronoun from a list of candidates. The clausal representation consists of a set of Prolog unit clauses that provide information on the head-argument and head-adjunct relations of the phrase structure that the Slot Grammar assigns to a sentence (phrase).
A simple computational model for nonmonotonic and adversarial legal reasoningIn the following page, a model for reasoning with ordered defaults, interpreted as unidirectional inference rules, is proposed: a language for representing (possibly) contradictory rules is introduced, a notion of argument is defined, and types of arguments are distinguished. A simple interpreter in Prolog able to develop those arguments is also illustrated.In the following pages, a model for reasoning with ordered defaults, interpreted as unidirectional inference rules, is proposed: a language for representing (possibly) contradictory rules is introduced, a notion of argument is defined, and types of arguments are distinguished. A simple interpreter in Prolog able to develop those arguments is also illustrated. This model is especially inspired to Prakken (1991a, 1991b, 1992), but is characterised by the following features: - Thanks to a limitation of the language (corresponding to logic programming approaches) a simple and effective notion of argument is obtained and translated into inferential procedures (par. 2 and 3) implemented into an interpreter in Prolog (par. 5). - The language can express exceptions concerning specific rules (par. 4). - Arguments concerning preference relations between norms can be imbedded into the reasoning in which the legal qualification established by those norms are derived (par. 7.2). 2. A3 directly defeats the subargument {r2(mark, applicable(r2(mar salel)) } of AZ. 5. A SIMPLE INTERPRETER IN PROLOG by the +- salel ): Let us now develop an interpreter for our language. rules are represented by unit clauses of the form: n:po+pl A...
Generalized algorithmic debugging and testingThe original form of algorithmic debugging, introduced by Shapiro, was however limited to small Prolog programs without side-effects, but has later been generalized to concurrent logic programming languages.The original form of algorithmic debugging, limited to small Prolog programs without side-effects, but has later been generalized to concurrent original method is the large number logic programming languages. The target and implementation language for the algorithms presented by Shapiro Drabent et al. [1988] suggest is Prolog. a generalization of the language used to communicate with the debugger. assertions are allowed. Cogito Ltd., Szeged, TAKEUCHI, A. 1987. Algorithmic In Concurrent Prolog: Collected TOCZKI, J., KOCSIS, F., GVIMOTHY, development tool.
A Datalog interface for SQL (abstract)Datalog is a logic based declarative language, a version of Prolog, suitable for database systems. The Datalog considered here does not support function symbols in logical rules.Datalog is a logic based declarative language, a version of Prolog, suitable for database systems. The Datalog considered here does not support function symbols in logical rules.
A logic programming view of relational morphologyRelations, whether finite state or not, can be computed using any of several paradigms, and we present a logical reading of a notation for relational morphological rules (similar to that of Koskenniemi's) which can in fact be used to automatically generate Prolog program clauses. Like the finite state implementations, the relation can be computed in either direction, either from the surface to the lexieal level, or vice versa. The morphological rules often compile simply into unification of the arguments in the generated morphology predicate followed by a recursive call of the said predicate. Further speed can be obtained when a Prolog compiler, rather than an interpreter, is used for execution.
Testability analysis of hierarchical finite state machinesFormal operators determine the controllable and observable functional parts of the modules of the hierarchy, several kinds of functional redundancies are deduced and their causes are diagnosed. A prototype written in Prolog validates these concepts.
Self-Assessment Procedure XXIII: programming languagesSome of the corresponding features of functional languages like Lisp, logic programming languages like Prolog, and ohject-oriented programming languages like C++ and Smalltalk, are reviewed. The language used most often in the questions is Pascal, with Ada, Lisp, and Prolog also featured prominently. A glossary is included which defines some of the terms used in the procedure.
La resoution d'anaphore a partir d'un lexique-grammaire des verbes anaphoriquesThis paper presents a system which intends to resolve anaphora in the framework of the Discourse Representation Theory, and using a lexicon-grammar of anaphoric verbs, through the application of selection criteria for assignment of a referent to an anaphora.From a semantic representation of text provided by a DRT system implemented in Prolog, the system uses several criteria of selection of referent.
"A 100% portable inline-debuggerThis code can be put at the end o f the routine's C code, after the user code section, using a label fo r access . In the routine prolog we test for a certain fla g (""dbg_definertn_flag"") and if this flag is defined, we immediatel y jump to the section that defines the routine to the debugger . We must do the following for these cases : Call : Since we don't know that the next instruction is a call an d we don't know where it will go, we set a special single-step flag . Upon entry of each routine (in the routine prolog), we check for this flag and flood this routine's BPA if it is set (or just set a temporary breakpoint on the first executable source line) . #define dbg_RTN_DEFS trcstrT trcstr , static char *staticprte=NULL , static char *slbp a \ //*** ROUTINE PROLOG for debugging : Always set routine name (so we at leas t // have that for library routines) ."
"An improved storage management scheme for block structured languagesThe actual programs analyzed are described grader A Pascal program sac A syntax analyzer grammar for below. used to process student grade files [81. generator which accepts an annotated LL(1) a language and generates a program that produces abstract syntax trees given source programs in the language [221. pal spell map fp cliff make gprof prolog pc An interpreter for an applicative language very similar to SASL [251. An execution profiler designed to incorporate information about a program's call graph in the profile data it produces [111. An interpreter for the Prolog language [20]. The Pascal compiler provided with the Berkeley Unix system [26]. Table I program name procedures grader 66 sac 54 fp 79 pal 47 map 69 spell 24 prolog 113 cliff 37 make 49 gprof 61 pc 257 apparently recursive recursive program procedures procedures name (%) (%) grader 2 sac 4 fp 25 pal 36 map 50 spell 61 74 prolog 12 67 cliff o 81 make 7 91 gprof 3 75 pc 23 83 we have included show that source source calls files language made 1 Pascal 5415 1 Pascal 220466 1 Pascal 231347 1 Pascal 106753 1 Pascal 127618 1 c 13331 10 c 642204 4 c 1450 6 c 2190 8 c 29154 53 c 62264 Table II cutset entry cutset allocations size calls calls eliminated storage (%) (%) (%) (%) ratio it is indeed very difficult to identify nonrecursive procedures in a translator that The ""cutset size"" figure is included in the cutset on which procedures included in the supports separate compilation. the percentage of the procedures that were allocation decisions were based, excluding cutset only because they were called from a separately compiled module ""entry calls"" columns show breaking this information as described in Section 2."
Epikit: a library of subroutines supporting declarative representations and reasoningThe prologx subroutine is able to find a grandparent of Ca] and a grandchild of Art. And the prologs subroutine is able to find all of the grandchildren of Art. User: (prologx '$I '(= $I (eval '(knowns '$z '(gp art $z))))) Lisp: 'NIL User: (prologx '$i '(= $i (eval '(prologs'$z '(gp art Sz))))) Lisp: '(CAL COE) So far, we have concentrated exclusively on relations. (It is also used in evaluating the arguments to equations within calls to prolog, prologp, prologx, and prologs) User: (proval '(length (children bob))) Lisp: 2 Sometimes, it is desirable to intermix functional and relational concepts.
The CLP( ℛ ) language and systemOne approach is local propagation. arithmetic constraints in the work including MU-Prolog [27] and This is the sole method for solving of Steele [35, 34], in PROLOG systems IWJ-Prolog [39], and elsewhere. The primary new PROLOG-III is the existence in programs of are a distinguished set of predicates over the From a theoretical point of view, the relationship between these PROLOGs CLP Scheme. Further, it is not possible to argue, as is done for most pathological events and so the problem Thrashing behavior when backtracking. can lead to long binding chains which, behavior when backtracking takes program loop(o). loop(1) : - 1>0, P> Ioop(l- 1). ?- IooP(N). PROLOGs, that cyclic bindings are can be ignored. The use of arithmetic bindings in turn, can cause a thrashing-like place.
Partial evaluation of pattern matching in constraint logic programming languagesIn particular, string the the in do we give examples that demonstrate how the same idea is appli cable to the derivation of efficient pattern matchers finite trees (Prolog terms with variables), for for Boolean algebra, and for finite sets. Pat tern matching then becomes pattern unification, using the logic programming language CLP(fT), Prolog with universally quantified disequality constraints. The inputs to theorem dif is, we pattern a pattern matcher are a ground pattern string p = (P1, . . . . pm) and a ground text string t = (tl,....tn).Typically alphabet for the pattern and text strings is assumed be finite. For pattern matching in Prologs which port logical disequality (dif ), we can relax this the to sup finite ness assumption.
"Search in concurrent logic languagesThe concurrent logic programming languages [23] introduce efficient concurrency in the logic programming paradigm by replacing the built-in backtracking of Prolog with an indeterministic committed-choice model. Ironically, one of the strongest attacks on automated backtracking as a language feature [29] came in the very year that Prolog was first defined [7,8], directed at the language PLANNER, which in many ways was a precursor to Prolog [IO]. CONCLUSIONS The history of the concurrent logic languages has been characterisedby the gradual dropping of features inherited from their original attempt to be ""concurrent Prologs"" WI, reaching a limit in Strand [I I] whose promotersdeliberately dropped logic programming terminology in marketing it, feeling that the links with logic had negative connotations for the practical parallel programmersthey hoped would use the language."
Circular scheduling: a new technique to perform software pipeliningFor a loop that has been circled k times, are k prologs and k epilogs. The loop there body is executed N - k times. The prolog an(i combined, cx ecut e one full it crat ion. 4.4. `his by nloling instructions thtit are afrcady This wili k.wd to the creation of 2 prologs is done circled. and 2 epilogs. Since the input (o the scheduler u nrolkd loops. it has II(N been neccssn!
Call forwarding: a simple interprocedural optimization technique for dynamically typed languages., see [15]), logic programming languages such as Prolog [4], GHC [17] and Janus [11, 13], imperative languages such as SETL [14], and object-oriented languages such as Smalltalk [10] and SELF [6]. To illustrate the fact that this optimization is not limited to code for type checking, we consider here a realization of this function in Prolog. As in other logic programming languages, unification between variables in Prolog can set up chains of pointers, and loading the value of a variable requires dereferencing such chains. Table 3 puts these numbers in perspective by comparing the performance of j c to Quintus and Sicstus Prologs, two widely used commercial Prolog On comparing the performance numbers from systems.
"Compositional analysis of modular logic programsThis is not a matter of purely theoretical est: in most Prolog systems currently available, inter e.g., BIM and Sicstus Prologs [3, 6], there are no a pm""ori restrictions on the dependencies between the differ ent modules in a program (a module A depends on a module B if a procedure defined in A calls a procedure defined in B), and it is entirely possible to have a set of modules mutually dependent on each other. Symmetric Composition: Analysis of General Modules As mentioned earlier, existing Prolog implementations allow arbitrary inter-module dependencies. The following example considers the pub lic domain tokenizer for Prolog written by Richard O'Keefe. Example 12 Consider a program consisting of the following modules: pok : Defines a tokenizer for Prolog."
"Logical foundations of object-oriented and frame-based languagesFor control primitives that give considerations often force different paradigms to instance, Prolog [Clocksin and Mellish 1981] has it procedural flavor. For instance, stzdent[alg aLgGrade @ year * grade] may both be legal invocations (say, the first implicitly assuming the current year). Arity-polymorphism is very popular Prolog. However, unlike Prolog, arity signatures, just as any other kind in logic programming languages, such as polymorphism in F-logic is controlled via of polymorphism. Examples in this way. verifying (36) becomes a simple, of this kind of proofs can be found in Wu [1992] and Chen et al. [1993]. u The idea that object-based logics can be encoded in classical predicate logic first appeared in Chen and Warren known in the Prolog community Prologs provide syntactic sugar that, what we earlier called ""complex [1989], but embedding of this sort were for quite some time, For instance, some roughly, amounts to the incorporation of values. "" A similar transformation was also used in McCabe [1992] to extend The reader whose faith Prolog with object-style syntax. was shaken by the fact that F-logic is, in a sense, equivalent to predicate calculus, First. semantics-by-encoding, may find comfort in the following arguments. as in Theorem 18.1, is inadequate, as it is indirect and provides no insight to the user when it comes to understanding the meaning of a program."
Mixed integer programming methods for computing nonmonotonic deductive databasesThe experiments indi cate that the mixed integer linear programming techniques presented here perform favorably when compared logical features are required for clauses within a program, to standard Prologs. Furthermore, no nonour system. In particular, the ordering of and the ordering of Iiterals in the body of a clause do not affect the outcome. Also queries asked to our system will always terminate. (Prolog queries do not always programs.) The organization of the paper definitions. As an aside, the use of linear goes back to Boole. Using it compares favorably with Prolog even when programming techniques for logical deduction as a basis for automated deduction was first suggested by Anil Nerode to his student, R.
"Equal rights for functional objects or, the more things change, the more they are the sameSince most Prologs are ""pure""--no side-effects to data structures--the proper definition of object identity has never been an issue. However, recent attempts to integrate Prolog-like mechanisms into (impure) Lisp [Robinson 82] and Scheme [Ruf 89] require a more precise notion of object identity, e.g., [Ruf 89] incorrectly uses eq? Warren, D.H.D., Pureira, L.M., and Pereira, F. ""Prolog--the language and its implementation compared with Lisp""."
A review of exploitation of AND-parallelism and combined AND/OR-parallelism in logic programsAs an example, consider the following simple program <- p(X). p(Y) :- q(Y), r(Y). q(a). q(b). r(b). In sequential Prolog (Figure la), when p is called, the subgoals 1q and r are evaluated from left to fight. Other systems exploit AND-parallelism implicitly from the programs written in standard Prolog. The latter approach is a subject of this review. The RAP-WAM was later used as the basis of a logic language, called &-Prolog, which subsumes Prolog. 2.3. &-Prolog With &-Prolog [26], the programmer can either use standard Prolog and let the compiler take care of detecting parallelism, or use explicit language constructs to express parallelism [26].
Temporal and modal logic programming: an annotated bibliographyMany implementations of temporal and modal languages are built on top of Prolog, either with some modifications on the unification algorithm, or with some extra rules for temporal and modal operators. The languages such as Templog, Gabbay's Temporal Prolog, Sakuragawa's Temporal Prolog, and Chronolog directly extend logic programming with temporal operators. Hrycej [1993] claimed that one of the potential application areas of Temporal Prolog is qualitative physics. 3.5 Temporal Prolog (Sakuragawa) T.
"Automated interface code generation from Ada specificationsFigure 7 . Prolog-style ASCII rulebase and query . An Ada package specification for a hypothetical Ada-to-Prolog mapping is show n in Figure 6 . The fundamental role of the ICG in this example is to map the Ada defined dat a structures to the Prolog interpreted environment . This means that the Prolog functors ""belongs. Note that because of Prolog's binding rules, IN OUT parameters are not allowe d in interface procedure specifications, with the OUT parameters representing Prolog variable (capitalized ASCII) symbols ."
An approach to executable specifications, based on formal source_to_source conversionIn fact, the specification in NCSL will be source to source converted into a PROLOG program. The parameter L1 in the parentheses on line 1 is the initial data, and L2 is the result of execution. NCSL specification Rules Conversion rules Parsing table CAST generator Syntax rules CAST 4,I Converter from tree to program in PROLOG program in PROLOG Fig, i Rule processor: Its functionality is to input both the syntax rules of the specification language NCSL and the conversion rules syntax rules are described in the BNF notation, and from NCSL to PROLOG. The flowchart about the control program of the converter is shown in Fig. 2. A program in PROLOG should be a formative one for the sake of reading easily.
Memoing for logic programsAlthough there are other languages and approaches, in this article we concentrate on logic programs based on Horn clauses, which include Prolog and all its variants. The proof method used in Prolog is SLD refutation applied to Horn clauses. One complication is that, in Prolog programs, a procedure may have multiple definitions which are interpreted as alternate definitions of the procedure. Thus procedurally, Prolog is a nondeterministic language and execution carries out a depth-first search through the tree of possible alternative executions.
Launching the new eraChikayama was chief architect and chief programmer of all the software systems developed at ICOT, including ESP (ICOT's object-oriented version of Prolog), SIMPOS (the operating system and programming environment of ICOT's Prolog workstation, their main workhorse during most of the project), KL1 (the kernel programming language for PIM), and PIMOS (the PIM operating system). Evan Tick's Ph.D. dissertation was on the design and performance evaluation of Prolog architectures. Tick was the first U.S. postdoctoral participant at ICOT, visiting under the ICOT-NSF exchange agreement. Tick investigated shared-memory implementations of both Prolog and FGHC while at ICOT. Following his postdoctoral work at ICOT, Tick spent another year in Japan as a faculty member of Tokyo University, still maintaining close contacts with ICOT.
A deductive database of the groups of order dividing 128Ley Department of Computer Science University of Sydney Sydney NSW7 2006 Australia This paper describes the design and illplenclltticll a deductive database for the 2668 groups of oN.Icr 2'1, (n < 7). The system was implemented in NU-Prolog, a Prolog system with built-in functions for creating and using deductive databases. This ena.blcs database users to access the data using a simpler and more familiar set-theoretic syntax than that provided by the Prolog interpreter. Introduction The work described here is a feasibility st,ucly of the application of deductive database technology to nla.thematical information for eventual integration with a col Nputer algebra system. Prolog Prolog The project is implemented in NU-Prolog (Thom and Zobels, 1987, Thorn and Naish, 1983) because of its deductive database facilities, its availability, and our contact with its authors at the University of Melbourne.
"Extending a parallel CLP language to support the development of multi-agent systemsThe flow of information among the agents is carried out, at the lower layer, through Stream sockets over a TCP/IP network. Various Prolog systems, such as SICStus Prolog [11], Quintus Prolog [10], ECL'PS ""- [5] etc., provide the socket facility. IC Prolog [I is a multi-threaded Prolog system which includes also a Parlog subsystem, high-level communication primitives and an object-oriented extension. However, these languages as well as others with similar features, such as Delta Prolog, CSProlog, PMS-Prolos, Multi-Prolog and Linda Prolog, do not provide the necessary facilities to tackle combinatorial problems in a diswibuted environment, as the extended ElipSys language does."
SAMPLE: new programming technology and AI languageThe procedure of matching samples is more general than the unification procedure in Prolog and related to the syntax matching in Refal language/2/, a pair of samples may match in several different ways. The underline structure constrains matching analogously to the term structure in Prolog: the nesting underline structures of matched samples must match. The last possibility have no analogy in Prolog. In our first experiments, all Sample clauses were stored in the Prolog Database with the same Prolog predicate name (sample).
Implementing denotational semantics with logic programmingDenotational specifications of programming Implementing Denotational Semantics with Logic Programming Ken Slonneger The University of Iowa Iowa City, Iowa 52242 slonnegr@cs.uiowa.edu Several authors have suggested expressing a denotational definition of a programming language as a program in an languages imperative language such as Pascal or Algo 168 to create are translated into Prolog, which provides a mechanism for parsing languages. Denotational semantic functions arc expressed as Prolog relations, providing an executable specification that can be used as a prototyping tool in the study of programming language design. Furthermore, the semantic equations of a denotational definition are readily converted to perspicuous relations in Prolog. Using Prolog to define or to implement a programming language has been suggested before 4'5.
Laboratory activities for studying the formal semantics of programming languagesThe laborato activities are based on logic programming in Prolog, including definite clause grammars, the Synthesizer Generator development system, and functional programming in Lisp. The prerequisite in program language structure covered course the fundamentals of Lisp and Prolog. The Synthesizer-Generator was a new topic for all students. Students appreciated the use of definite clause grammars in Prolog. They were able to use DCGS with minimal knowledge of Prolog itself and with no knowledge of how DCGS are translated into standard Prolog.
An exercise in denotational semanticsBy having the students translate semantic equations directly into Prolog clauses thereby constructing an interpreter, this exercise makes denotational semantics more tangible and practical, After a brief description of the course, the two parts of the exercise are presented and illustrated by an example. Figure 2 contains a BNF specification of its syntax. Source Program Figure 1: List of Tokens (a Prolog List) Abstract Syntax Tree (a Prolog structure) output After a brief introduction (or review) Prolog, students are given a short problem of to solve in Prolog, for example, defining string processing predicates. Numerals (nonnegative integers) are Prolog integers. 3. Single character (+, <, etc.) and double character (:=, c=, etc.) tokens are translated into Prolog literal atoms. 4.
Storage and access of temporal information for the management of complex systemsWe will &scribe how temporaI information in the historical database can be represented and retrieved in Prolog. First we explain how two different types of temporal intervals, a convex temporal interval and a non-convez ternporaf interval, and their relations and operators can be implemented in Prolog. Second we show how queries to a historical database can be supported in Prolog and finally we present Prolog rules with which we can infer system states that are not explicitly stored in a historical database using the hktory of events which have caused chamges in those states. Section 3 presents our approach for representing and handling temporal intends for the analysis and planning in C-Prolog. Section 4 describes how the historical database query language can be irnplemestted in C-Prolog.
First specialize, then generalize: introduction(Actually the last example provides an intuitive procedural view of resolution as used in Prolog.) The operation of unification is akin to that of pattern matching, which is ubiquitous in computer science. To motivate its importance, it is worthwhile to review the relationship between the Prolog inference mechanism and parsing as used in compilers. Prolog interpreters often use backtracking to implement non-deterministic situations. • Cut--an annotation used in Prolog programs to bypass certain non-deterministic computations. • Depth-First--a method for traversing trees in which the leftmost branches are considered first.
A general framework for bidirectional translation between abstract and pictorial dataIn contrast data are predefined VSR data is also represented as a set of Prolog to ASR predicates, which are user-defined, VSR as special predicates in the system corresponding to graphical objects and relations. Synthesizer `pp''c, (Created for each type of data) Abstract Structure Representation (asserted predicates in Prolog) Inverse Visual Visual Mapping `l_R1 P Mapping (Prolog) (Prolog) [kamada 89, 74 Visual Structure Representation (asserted predicates in Prolog) Spatial Parser (Objective-C) ? VSR data by the visual mapper written in Prolog. ASR data and mapping the visual mapper is invoked.
An analysis of dynamic scheduling techniques for symbolic applicationsIn particular, we have chosen the logic programming paradigm, and Prolog as the target language, since it represents an interesting alternative way to approach a symbolic problem. As recent studies have shown [6,13], the performance of sequential Prolog is getting closer to imperative languages. From thii standpoint, there is a renewal of interest in using Prolog for non-numerical applications. The instruction set implements a general purpose loadstore architecture, and, as Prolog is a tagged language, incorporates the basic functions for efficient management of tagged data [2, 6, 131.
Tutorial on specialisation of logic programsThk approach seems preferable to a survey of the state oft he art, which would be more objective but less systematic. 1.4 Logic Programming versus Prolog A good deal of research in logic program specialisation dealt with ways to handle the various idiosyncrasies has of Prolog, such as the cut, non-logicaJ primitives and side-effects. On the other hand a body of results has been obtained for declarative logic programs, that is, programs which are first order logic formulas (normal clauses). While research on Prolog is of obvious value (because there are already so many Prolog programs written) this tutorial does not consider the non-logical aspects of Prolog. As a generaf remark it may be said that whatever results are obtained for declarative logic programs are weakened when applied to Prolog, and therefore specialisation of Prolog programs is less effective.
"Executing the formal definition of AdaThis can be obtained by applying the operational rules (defined meaning of the transition system. This translating into Prolog such rules. The interaction with the user by the ""Concurrent Algebra"") that give the application can be effectively achieved by is translation and act as interpreters for mediated by Prolog goals which query such the Ada program. Its formal definition can as well be translated in Prolog, as suggested in [4], but the first step can be effectively, and more efficiently, achieved by traditional compiling commenting the performance of the techniques, therefore, we are not interested in first step Prolog programs. The SMoLCS algebraic definitions of the transition meaning of the inference rules defining the transitions. the concurrent algebra, these inference rules system also have the intuitive In the Prolog translation of become Prolog clauses defining a predicate that gives the possible moves of a behaviour."
Situated planning and resources in the design of an intelligent tutorialMoreover, Smalltalk/V integratesProlog/V and Pascal/V EBarril91], for executing and interactively debugging Prolog or Pascal source code under SmalltalkN. While the Prolog interpreter has been extended to a declarative programming environment, Pascal, on the contrary, was designed as a pedagogical environment and is the teaching language. Thesetypesof pedagogicalknowledge are combined by the author into tutoring strategies. They are described with Prolog clauses. The embedding of Prolog in Smalltalk uses several classes,for instance : - Prolog - the Prolog part of the interpreter. - Logic - the Smalltalk part of the interpreter, - Pdidacfor tutoring strategies. All these have led us to use Prolog syntax for the textual input of tutoring rules by an author. 5.
"A modular architecture for constraint logic programmingINTRODUCTION Nearly two decades after its first appearance, the first logic programming language Prolog has won its popularity. Prolog is now used in many domains ranging from academic research to industrial applications. Traditional methods to solve CSPs concern essentially problem-oriented solvers. Prolog is a good candidate for CSP formulation. Many CSPs can be expressed very elegantly in logic programs thanks to the declarativity and expressive power of the language. This is because the brute-force ""generate and test"" solving mechanism of Prolog-like systems tends to search blindly the solutions in a very large search space leading rapidly to combinatorial explosion."
Visualizing and querying software structuresKeywords and phrases: software design, software engineering, Prolog, 4Thought, Graph Log, G+, graphical queries, visual queries, theory-model paradigm. Develop a model for the theory: a. Create a Prolog database describing the spe cific instance of the protdcm. GraphLog queries are graphs whose nodes are labelled a sequence of Prolog variables and constants, and whose arcs are labelled by regular expressions composed of Prolog predicate names.
"Review of ""The logic of typed feature structures"" by Bob Carpenter. Cambridge University Press 1992.Those algorithms require far heavier data structures and constant factors than Prolog's unification, they do not interface well with Prolog's backtracking control regime, and, most importantly, they are linear on the sum of the sizes of the terms involved. The best rational term unification algorithms are almost linear in all cases, and may be linear on the size of the smaller term in the same cases as Prolog's algorithm. However, the data structure complexity and constant factors are still higher than in Prolog's algorithm, and the interaction with backtracking is less straightforward. 3. On page 130, first sentence, the reference must be to ""Prolog II and Prolog III"", not to ""Prolog II and Prolog II."""
"Glue-Nail: a deductive database systemAlthough Glue assignment stat ements look a lot like Prolog rules, the control flow may is com pletely different. The Prolog control strategy at a time"" with backtracking. At present Aditi-Prolog can be used interactively, although there are plans to embed Aditi-Prolog queries in Nu-Prolog or C."
Implementing deductive databases by linear programmingMore and past specifically, we present here an algorithm for computing generations of Prolog systems have left deduction run-time, and this may account for the poor time performance of such systems. At of these paradigms have been implemented: approach affect our algorithm. The technique also avoids Prolog's that has problem of infinite looping. Beeri, least two We also propose a query processing system based on the LDL linear programming compilation. Thus, the figures presented below for Prolog include only the times when Prolog terminates.
Architecture of the XL C++ browserA interpreter based query language would also simplify th e task of forming queries . This too supports Prolog as our database and query language resolution systems. These are omitted for the brevity. 4 Sample Query All queries are expressed in Prolog and are interpreted. A Prolog compiler would certainly increase the query resolution time by a constant factor. For this we [3 ] introduced the `tuple' type in Prolog . This type has only a head as its data structure .
Functional dependencies in Horn clause queriesSome of this work or future database systems with a Horn clause component, another to take a widely available approach, and the one we pursue here, is simply logic programming system, such as PROLOG [51, and try to use it for database clear that there are many access without any further modification. To copy otherwise, or to republish, requires a fee and/or specific permission. @ 1991 ACM 0362-5915/91/0300-0031 $01.50 available language such as PROLOG makes for systems that are easy to build and maintain and easy to port. However, as Warren reported PROLOG is inadequate even for tions. The logic programming [19], the rigid backtracking behavior of relatively undemanding database applica community is well aware of this problem and several proposals for selective PROLOG systems provide backtracking exist [3, 8, 12].
Compiling dataflow analysis of logic programsFor a subset of benchmark programs in [15], it significantly improves the performance by a factor of over 150 on the average. 1 Introduction Like many conventional languages, the performance of the logic programming language Prolog has been significantly improved through compilation [21]. In particular, the WAM (Warren Abstract Machine) [22] is a virtual machine that has emerged as the de facto standard for the compilation and implementation of Prolog. The benefits of the WAM basically rest on local optimizations through a simple intra-procedural (clause-level) program analysis. As a comparison, the technique of compilation improved the performance of Prolog by a factor of about 30 in Warren's original work [21].
Logic programming as the integrator of the Fifth Generation Computer Systems projectThe other was a softwareoriented proposal aimed at redesigning programming languages and building a new software culture based on the new languages, where Prolog was thoroughly investigated as the potential base for such programming languages. This was done by extending the term structure of Prolog to allow partially specified terms with indefinite arity [22]. In contrast to Prolog, most concurrent logic programming languages (except Concurrent Prolog) restrict head unification to one-way unification (which is often called matching).
Book review: Parallel Logic Programming By Evan Tick (MIT Press, 1991)An early chapter reveals the first important lesson, it uses the classic Prolog example Reverse to show that some serial algorithms cannot be made parallel. The next 9 chapters present logic problems, each with a solution in Prolog and one or greater parallel solutions. Solutions are typically developed for OR-Parallel Prolog and a type of AND-Parallel Prolog called Flat Guarded Horn Clauses (FGHC). Difference lists: these are the most important data structure in Prolog and FGHCs. The Quick Sort example uses difference lists in the recursive call to qsort.
A declarative laboratory approach for discrete structures, logic, and computabilityThus when predicate calculus is discussed , students can see Prolog as an automated predicat e calculus . Similarly, when resolution is discussed, students already have seen its use in th e Prolog computation rule . Now ask the following question : I ?- e(u, t) . 1. Why does this prolog experiment verify the si x line proof of symmetry ? Consider the following proof of transitivity : 1 . t=u P 2 . u=v P 3 . u=vAt=u--t=V EE Axio m 4 . u=vnt=u 1,2,Conj 5 . t=v 3,4,MP 6 . tunu=V -9 t=V 1,2,5,C P QED . a. Construct a Prolog experiment to verify this proof. b. Explain how your prolog experiment veri fies the transitivity proof.
Viewing instruction set design as an optimization problemTo illus trate our technique, optimal instruction sets are derived for data structure creation in Prolog. 1 Introduction Instruction sets are a necessary and convenient encod ing of the operations required to execute application programs. Initial versions of the results given in this section helped us decide on the final instruction set support. 4.1 Benchmark Programs The hypothetical example in Figure Prolog creates data structures. The 3 illustrates how Prolog execution model maintains several stacks in memory. McGeer, and A. 1984. M. De spain. An advanced silicon compiler in Prolog. Proceedings of ICCAD, 1987. 6 D. Clifford and A.
Combined use of languages in object-oriented software constructionWe conclude with plans for further research and enhancements of the transformational approach. 2 THE OBJECT-ORIENTED LANGUAGE - AMORE AMORE, (A Method, Object, Rule Environment), is a programming language that provides object-oriented extensions to Prolog [Palaskas et al 89]. The integration of the two approaches offers a flexible environment for the development of advanced information systems applications, in which Logic Programming (Prolog) is used for reasoning and Object-orientation provides facilities for structuring the domain, maintaining consistency of the modelled concepts and activating general reasoning mechanisms. A method definition is equivalent to a clause definition in Prolog and can have a variable number of arguments, and also it can be distributed to more than one clause. Leibrandt, V., Schnupp, P. (1984) An evaluation of Prolog as a Prototyping System, in Budde, R. (ed.) Approaches to Prototyping, Springer-Verlag, 1984 Palaskas, Z., Loucopoulos, P. (1989) AMORE- Object-Oriented Extensions to Prolog, Proceedings of TOOLS '89, Paris-France, 1989.
"Exploring dataflow testing of arraysProlog can express facts about programs and executions in a database fashion, and Prolog can query those facts interactively. The declarative Prolog programming style lends itself to describing software analysis. This information is the program's control linkages, and variable-usage data. Prolog ""facts"" are the medium. Flow of control is recorded in a Prolog database as a edge fact."
Book review: The AI Workbench BABYLON: An open and portable development environment for expert systems by: T Christaller, F Di Primio, U Schnepf and A Voss (ed) (Academic Press)The Babylon implementation described in the book provides four different KR paradigms: objects (or frames), pro-SIGART Bulletin, Vol. 4, No. 2 16 duction rules, Prolog and constraints. There is a fifth one called free-text, but that is hardly a KR paradigm. What is worse is that there is no motivation provided for most of the options or specialisations of the various commands provided in the system. The Prolog module offers its own syntax for Prolog. Most of the Prolog implementations and libraries now available follow a standard syntax. Hence, it is difficult to justify the choice of a Lisp-like syntax for writing Prolog code. Anyone wanting to use any existing code has to re-write such code in the new style.
Shortest path by approximation in logic programsCategories and Subject Descriptors: D. 1.6 [Programming General Terms: Algorithms Additional Key Words and Phrases: Approximation, Techniques]: Logic Programming dynamic programming, shortest paths 1, INTRODUCTION Logic programming invites (Programming in Logic) the specification of declarative programs. Prolog is the realization of a logic programming language. The choices made in Prolog's Prolog to be incomplete. implementation for efficiency, however, cause Prolog's evaluation of a (recursive) declarative specification that has finite an infinite path, and fail programs as declarative solutions may enter an infinite loop, by searching to find all the answers. However, instead of identifying duplicates as identical subsumption of Prolog terms tuples, the extension table algorithms use the to identify redundant tuples.
XSB as a deductive databaseXSB fundamentally extends that can q Allows for declaration of tabled predicates either Database automatically by the system or manually by the user. the stanq Provides standard tabling predicates which can be dard functionality of Prolog to include implementations of SLG resolution (tabling or memoing), and of HiLog. SLG also provides a solution to the practical problem of Prolog's tendency to redundantly recompute subcomputations. In addition, version 1.4 of XSB includes indexing capabilities greatly improved over those of standard Prolog systems. Users are offered the choice of Prolog-style hash-based indexing, or transformational indexing.
A methodology for managing hard constraints in CLP systemsIn other words, directionality is eliminated. 2.2 Delay Mechanisms in PROLOG In PROLOG, the notion of delaying has been mainly applied to goals (procedure calls), and im plemented by the use of a dynamically changeable atom selection rule. There are similarities between implementing delay in PROLOG and im plementing a data flow system, except in one fun damental aspect: temporal backtracking. Another kind of annotation is applied to relations. For example, the wait declarations MU-PROLOG [10] and the when declarations NU-PROLOG [13] cause all calls to a procedure delay until some instantiation condition is met. of of to Carlsson [3] describes an implementation tech nique for freeze (X, G).
An expert system for the application of import and export regulationsVenken BIM, Kwikstraat 4, B-3078 Everberg Belgium ity and the evolution of the European regulations and other procedures, the current systems are unable to tackle the Thh paper presents a Prolog based expert system for the applicatwn of regulations which is currently developed by BIA4 for the Belgian Ministry of Economic Affairs. During the first three months of the project a prototype was developed in Prolog: an application of 40 pages of regulations. The corresponding knowledge base consists of 330 if-then rules, 170 Prolog clauses and 120 concepts. The main advantage of the domain dependent syntax of the if then rules on Prolog clauses is to prowde a way of repre senting knowledge in a more readable form for non-Prolog experts.
KL1 and the early days of the FGCS projectHe had completed a design of a subset of his programmin g language Concurrent Prolog (CP), implemented an interpreter for it in Prolog-10 on their DEC 2060 , and tested several CP programs [Shapiro 1983a] . However, Thesauru s supported Prolog (albeit with some Pascal-like restrictions) . 2. Also, the projec t called for a machine that could perform between 100 and 1000 million LIPS (Logical Inferences Pe r Second) . The fastest Prolog at that time was Prolog-10 which could run at 30K LIPS .
Test case generation by means of learning techniquesExept for this approximation, the system produces ade quate test sets with respect to any finite class of programs 7. 3.1 Set of alternative programs and Prolog Because of the induction techniques that we use, the set P has to be specified with a syntax close to Prolog. More precisely, we must provide a set C of Prolog clauses, and the possible programs will simply be sets of such clauses, i.e. ? must be described as a set of Prolog However, clauses for our implement ation. As P is often based on the program to be tested, it helps if this is also done in Prolog.
"A brief survey of benchmark usage in the architecture communitySwensen & Patt, ""Fast Temporary Storage for Serial and Parallel Execution"" Wond & Franklin, ""Performance Analysis and Design of a Logic Simulation..."" Abe, et al., ""High Performance Integrated Prolog Processor IPP"" Fagin & Despain, ""Performance studies of a Parallel Prolog Architecture"" Civera, et al., ""An Experimental VLSI Prolog Interpreter"" Cheung, et al., ""Organization and Analysis of a... Time Warp"" Tick, ""Data Buffer Performance for Sequential Prolog Architectures"" ISCA 16, 1989 Murakami, et al., ""SIMP: A Novel High-Speed Single-Processor Architecture"" Przybylski, et al., ""Characteristics of Performance-Optinaal Multi-level Cache..."" Kessler, et al., ""Inexpensive Implementation of Set-Associativity"" Benker, el al., ""'KCM: A Knowledge Crunching Machine"" Singhal & Patt, ""A High Performance Prolog Processor..."" Morioka, et al,, ""Evaluation of Memory System for Integrated Prolog Processor"" Wong& Williams, ""A Type Driven Hardware Engine for Prolog Claus..."""
Concepts and implementation of a rule-based process engineSpeaking in PROLOG terms, the goal txecuteob for the software developer who wants to login has to b satisfied. As several tit rules exist (one for each supported role), the PROLOG backtracking mechanism is used to select one specific rule tusk to be executed. These approaches define an extended query language for data bases using PROLOG primhives rather than enabling a PROLOG pro gram to manage its whole knowledge base externally.
Transparent running and contextual help to learn and to teach an imperative languageThe author (who can be the teacher himself) can finally introduce his own view of the matter through the definition in Prolog 2 of dynamic contextual help [Brette 94b]. 1 Object Format for Educational Knowledge Representation. 2 A version of Prolog, PROLOG/V, is integrated in SMALLTALKfV. The data inspection windows are linked to their environment level, which 3 This choice was also at the origin of the Transparent Prolog Machine [Eisenstadt 87] that was showing dynamically unification trees in Prolog. [Eisenstadt 87] Eisenstadt M., Brayshaw M. - An interpreted textbook, video and software environment for novice and expert Prolog programmers. International Conference of the Prolog Education Group (PEG'87), Exeter, July 8-12, 1987.
"A three paradigm first course for CS majorsAim Become fmiliar with the working environment laboratory. Week 2 PROLOG. Introduction (study and modify Family Data Base) Aim of our a Become familiar with Prolog programs and the use of Quintus Prolog System. Week 3 PROLOG. Database Problem (students write a piece each and TA helps to construct a common database for the whole class). Aim Make students aware of importance of specification and design or the pieces do not fit.. Week 4 PROLOG. Adventure Game (study and modify and extend a logic program) Aim Learn how to handle ""state"" in logic programs Week 5 PROLOG."
"A general framework for Bi-directional translation between abstract and pictorial data.----"" Synthesizer Analyzer (Created for each (Created for each type of data) type of data) t JI Abstract Structure Representation (asserted predicates in Prolog) Visual Structure Representation (asserted predicates in Prolog) Spatial Parser (Objective-C) r b picture Data (objects in Objective-C) L+ Interaction Module (on NextStep) Figure 2: Th(> '11{11'2 Sys[II] I I The interaction modlde whic]t allofvs the manipulate tfle pictnlcs dircctl, ! Edit the picture in a fl,ehaud n)atl]]cr. 2 MacDraw is a tradcln ark ol ('iaris, II),-, 3SB-Prolog versif-n] J.], (:(lj)yllgll( ((') t!ls(> <,( St<)llv 19S7 University cf Arizun These ate our undergoing research topics.e Another way of extending TRIP2 is to use a constraint (logic) programming language, such as PROLOG 111[4] and CLP(R)[9]. The numerical constraint solver in TRIP2 is ex ternal to the Prolog in the current implementation."
Implementation of an automated E.M.S. optimization program using an embedded expert systemThis module is responsible for processing roof spray site suwey information and for making energy saving reeommendations based on it. As an illustrative example of the Prolog based implementation of the expert system, pseudocode for the roof spray module, corresponding to a flow diagram provided, is included. The source code for AEMSOP was, however, written entirely in Prolog and is comprised of 12 modules and more than 10,000 lines of code. To provide an example of Prolog code, the following predicate, was extracted from the source code for AEMSOP. same predicate is also shown in pseudocode form.
"Using constraint logic programming for model-based diagnosis: the MODIC systemThii program will translate the system model into Prolog assertions and put them into a file called linearized. Then the program genDIAG is used in conjunction with the Prolog interpreter to create a diagnostic session. This process involves the creation of four files. They are Im - which describes the system model in CLP(R) code, loglcal_sentences - which contains Prolog assertions (which constitute the qualitative mode) corresponding to the schemas of logical sentences A LO-J and BJ+l.OOU, genL - Prolog code which contains the predicate ""gen_L"" to generate the logical sentence L based on the user input values of the system observable, goDIAG - Prolog code which initiates the diagnostic procedure by querying the user for the values of the system observable."
Inside a software design team: knowledge acquisition, sharing, and integrationHe requested that others read his documentation, examine the D7 code, and work with the prototype in order to determine if an extension of the prototype could satisfy the specifications. Few of the designers were familiar with Prolog and were reluctant to commit to implementing the object server in Prolog. Thus, the issue of whether the object server should be written in Prolog or some other language remained unresolved. The meeting ended with a request for D4 to provide team members with a tutorial on Prolog. One of the issues discussed by the group concerned the paging of Prolog facts between primary and secondary storage. • Expert: Paging is done by the host operating system, it's not a Prolog-controlled paging. • D4: You could have Prolog write its own facts out. • Expert: Right, you could have communication between Prolog and some database system. • D4: That's the way I imagined doing it.
"A successful case of computer aided translationThese clauses can be seen as the usual translation of Definite-Clause Grammar (DCG) rules into Prolog but for the order of the arguments. For the sake of efficiency in searching the dictionary for rules that can be applied at each step, we take the ""string"" arguments of the translation of a DCG non-terminal to be the first arguments of the corresponding Prolog predicate. As these arguments are lists, and the indexing mechanism of the Prolog compiler we use, YAP (Damas et al., 1988), looks at the first element of lists, this results in a speed-up by a factor of 2 or 3. The third program, the translation tool, implements the method described in the previous section. It was written as a DCG in Prolog with some fragments of Prolog to deal with special situations, like the fact that the dictionary rules are implemented as above. 5 The Translation What I am about to describe was done by Jorge Almeida, the author and translator of the book."
Human cognition research laboratory: the Open University (U.K.)Representative activities involving extensive HCI work are deseribed below. The Transparent Prolog Machine (TPM) (Mike Brayshaw, Marc Eisenstadt, Paul Mulholland): TPM is a medium for visualizing and animating the execution of Prolog programs [3]. Conceived as a tool for use by novice and expert Prolog programmers alike, TPM provides a faithful (slow-motion) representation of the inner workings of the Prolog interpreter, yet allows a high-speed visual overview of execution for rapidly homing in on buggy code. Brayshaw, M. and Eisenstadt, M.. A Practical Graphical Tracer for Prolog. International Journal of Man-Machine Studies, 1991, 35 (5), pp. 597-631. 4.
MetateM: An introductionHrycej [Hry 88, Hry 93] describes a completely different Temporal Prolog from Gabbay's (see above), which is based upon interval temporal logic. He extends Prolog Using a form of Allen's interval temporal logic [Al 184] and applies it to temporal knowledge representation and temporal planning problems. In addition to the basic Prolog execution mechanism, such a system requires a constraint solver for temporal constraints (not unlike constraint logic programming [JaL87]), though this itself might be implemented in Prolog.
PETINA—tour generation using the ElipSys inference systemAlthough the expressive power of logic programming is profitable for the development of PETINA, standard Prolog systems lack of facilities that are vital for the PETINA application to work. The declarative formulation of this method can be achieved in a logic programming environment, via the Prolog language [2, 16]. However, due to the inefficiency of the exhaustive search of Prolog, real-life problems cannot be solved in this basic framework. Thus, although it profits from the expressive power of Prolog, it requires additional mechanisms that standard Prolog systems lack of.
IQ: towards incremental query processing in non-deterministic concurrent constraint logic programmingFor addition of constraints or goals, if a given increment cannot be solved in the current context, the sys-Van Emden's incremental queries addresses the inadequacy of current Prolog-yle querying mechanism for interactive problem-solving. Of course, a user can still use Prolog as a pseudo-interactive language by entering a new and improvised query at each problem-solving step. Van Emden proposes incremental queries 1 [19], a new querying framework'for Prolog. According to this framework, users can enter a query by increments, which consist of one or more goals.
Computer-assisted microanalysis of parallel programsThere are several (1) Prolog has already proved its ers and interpreters. (2) Metalevel interpretation is provides a convenient in Prolog except for XGView, which is reasons for this choice: effectiveness in the development of compil readily accomplished in the language and approach to implementing the simulation of parallel processes. (3) Prolog provides an ideal high-level query language for analyzing the execution trace of a program. The first, egg_tdlp EGG nested metalevel interpreters, as de (C/, E), simulates the execution of programs written in an extension of Prolog, (TDLP), which provides facilities ing, parallel processes. G,, AND LAPALME, G ment of Informatics, Umverslty Process-oriented simulation m Prolog. Rep 604, Depart of Montreal, Canada 24 WARREN, D H.
"Applying and improving the restriction grammar approach for Dutch patient discharge summaries""the latter are stored uudeL the form of a closed Prolog-list while tile tirmer arc entered as open eaded Prolog-lists. For reasons af space limitations, only a restricted set of grammar rules was shown. Tile complete grammar as well as the full Prolog code can be found in (Spyns 1991). Adriaens G., & M. Hirschman L. & K. Puder (1986): Restriction Grammar: A Prolog Implementation, in Logic Proc,rammin, and its Annlications M. van Caneghem and D.H.D."
The design, implementation, and use of DSTutor: a tutoring system for denotational semanticsThe X Window System provides powerful tools for the development of a user interface with a familiar look and feel. Prolog provides a flexible and relatively easy way to implement a domain expert. Language parsing is handled by a definite clause grammar in Prolog. DSTutor currently works with one mini-Ianguage, a simple imperative language, and is being adapted to a second mini-language that supports program blocks, procedures with parameters, and recursion. Since the denotational semantics expert is written in Prolog with a generic interface, other language experts could be substituted.
Notes on LR parser designThe design principles, though, are applicable to a large class of unification-based grammars where the constraints are realized as Prolog terms and applied monotonically through instantiation, where there is no right movement, and where left movement is handled by gap threading. The lookahead symbols, on the other hand, are ground Prolog terms. Firstly, this means that they can be computed e[llciently in the LAI,I{. case. L 91, pp. 69 -74. [6] Pereira, l?ernando C. N., and Stuart M. Shieber (1987). Prolog a,M Natural Language Analgsis, CSLI Le(:ture Note 1O. [7] Plotkht, (,ordon 1). (1970).
Combinations of abstract domains for logic programmingThe use of abstract interpretation has led to dramatic improvements in Prolog compiler technology [27, 29]. Moreover, substantial work (e.g. [2, 10, 12, 14, 15, 18, 19]) has been devoted to produce efficient generic fixpoint algorithms and systems like GAIA1 [19] have been shown to yield efficient and accurate analyses. It is interesting to note that Pat (OProp@OOHode@OPS) and Pat (Type ) are some of the most complicated domains ever implemented for Prolog, yet their requirements on the designer are minimal. Experimen tal Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. ACM Tmnsactions gmmming Languages and Systems.
A computational framework for dialectical reasoningFollowing execution scheme, the system builds arguments the Prolog that can defeat one another depending on information represented priority rules. Thus we designed a programming language that is an extension of Prolog, and a runtime support system. Only the core of the language is described in this paper. The object Level Rules At the object level the rules are like pure Prolog clauses augmented by contexts and explicit negation.
Can computers handle adverbs?Jackendoff, for example, classifies adverbs as subject-oriented, speaker-oriented (sentence), and manner adverbs, and represents the meaning structures of these adverbs in essentially prolog form as follows: ACRESDECOLING-92, NANTES,23-28 notW 1992 Adverb class: Sentence Prolog-like formula: ADJ(f(Np 1,... Clumsily, Fred dropped the book. Adverb class: Manner Prolog-like formula: [f/ADV](Np 1,...,NPn) Example: [RAN/QUICKLY](SUE,HOME) Sue quickly ran home. Figure 1. Huang uses similar prolog-like formulas to represent the semantic structure of adverbs.
PPIG-7: the seventh annual workshop of the Psychology of Programming Interest GroupThese roles and strategies are from structured to object-oriented techbased on her field studies of four design niques. Continuing his work in Prolog, teams in the USA and Europe. The roles Paul Mulholland (Open University, UK, span internal and external organizational p.mulholland@open.ac.uk) reported on boundaries, as well as task, discipline, perhis most recent study that evaluated the sonal and multiple boundaries, and help effectiveness of debugging Prolog using a filter and translate information among non Byrd Box model, e.g., a choice-point design participants from different model, of execution for students. Condomains as they come to an understandtinuing to discuss Prolog, Tom Ormerod ing of how the artifact will support the (Lancaster University, UK, T.Ormerod@ user. Roast (both from SheFfieldHalam University) titled Aninvestigation into strategies employed in solving a programming task using Prolog.' Their work discussed the effects of changing from a procedural to a declarative approach in programming.
Integrating logic programming into a data base course: views as rules in deductive relational data bases., SQL) , and the theo - rem-proving capabilities of the artificial intelligence tools (e.g. , Prolog). Currently, there is no commercial ly available logic-based system for data bases. For data bases, duplicating facts in notation in the virtual memory reside large Prolog is, if not impossible, at least impractical, Also , unlike a DBMS, Prolog has ability to optimize queries, does permit concurrent access to facts, does not provide security and recovery. no not and To alleviate these shortcomings, sions of Prolog to render it more cient for data base processing been proposed [2]. The major lem with such extensions is that exten effi have logic data them is Prolog prob they all entail development of new DBMSS.
Foundations of 4ThoughtFirst, it suggests a representation o f models as Prolog databases : entity sets become 'unary predicates and n-ary relation - ship sets become n-ary predicates . Third, it suggests how to partially verify models : the database integrity constraints have straight-forward definitions as computationally manageable Prolog rules . Any additional logical constraints can then b e readily expressed using the powerful inferencing capability of Prolog, either as direct Prolog translations, or through an intermediate language such as GraphLog . In this framework, Prolog is used to verify that models satisfy the constraints of the theory .
"Paradigms and laboratories in the core computer science curriculum: an overviewExamples are ""linear recursion"" and 'divide-and-conquer'. Newmarch makes plans operational using Prolog. A small number of plans support a large number of different programs and algorithms. Simple assignments are described to experiment with laws of logic (using Prolog). Other assignments support learning about functions and function composition (using FP) and learning about types (using SML). ACM SIGCSE bulletin, 22(1). [4] D. Crookes. Using Prolog to present abstract machines. ACM SIGCSE bulletin, 20(3):8--12, Sep 1988. [5] B."
"Undergraduate AI and its non-imperative prerequisiteOther schools transfer the responsibility of learning Lisp or Prolog to the AI course itself. This confuses AI with the means of implementation. While Lisp and Prolog (and, for that matter, object-oriented programming) have their roots in AI, they are no longer considered ""AI Languages"". In most first courses in AI, some students start out with an elementary knowledge of Lisp or Prolog. But many do not, many have never seen a single non-imperative language."
A strategy for transforming generate and test logic programsA Strategy for Transforming Programs Khaled Bsales Generate and Test Logic Centre de Recherche en Informatique de Nancy (CNRS) and INRIA-Lorraine Our generaI objective is the construction and the assisted transformation of Prolog programs. In this paper we are concerned with the problem of using properties in order to improve the efficiency of logic programs. It is well known that the evaluation of a query of a given Prolog program depends on the position of atoms in the body of clauses. Mycroft and R.A. O'Keefe. A polymorphic type system for prolog. A rtijicial 1984(23):295-307, 1984, Intelligence, A.
"OBSERV—a prototyping language and environmentAt a lower either upon entry to a state level, activities that occur within objects, or in transition between states, are described with the logic programming allowing a nonprocedural for many rapid prototyping language are well-known"" The advantages of using paradigm, which is essentially Prolog code, thus description. Prolog has also been used as the basis systems and its ""relative values as a prototyping [24]. a logic programming language as a specification language result from programs procedural one. -oiler, adust, (send (get_current-speed (urrentSpeed) ) , send(integer: desired_speed, retrieve (DeslredSpeed) ) , prolog((Dlff IS Deslred 3peed-urrentSpeed+ 2)) , (prolog((Diff> 0)), send (set_thr(Diff) ) ,pIolog( (Diff= We activities. Prolog may be seen as a as implementation. Although it is implementation using Prolog, one can also use Prolog (due to its dual semantics) to specify the semantics, namely procedural and declarative results of a certain procedure without deciding on its implementation."
Combining objects and relationsOOLog is prototype based and extends the logic oriented language Prolog [C1M87]. It is used because of its simplicity and flexibility. Objects communicate by message sending expressed by Object <- Mes s age. Messages are ordinary Prolog goals. Sending a message means a request to the receiver to solve the corresponding goal. [BDG88] D.G.Bobrow, L.G.DeMichiel, R.P.Gabriel, S.E.Keene, G.Kiczales, D.A.Moon Common Lisp Object System Specification X3J13 document 88-002R in SIGPLAN Notices, Vol.23, special issue, Sept.1988 [C1M871 W.F.Clocksin, C.S.Mellish Programming in Prolog Springer, New York, 1987 [FuH86] K.Fukunaga, S.Hirose Art Experience with a Prolog-based Object-Oriented Language OOPSLA'86 Proceedings, Sept.1986 [Ga 186] H.Gallaire Merging Objects and Logic Programming: Relational Semantics Proc. of AAAI'86, Philadelphia, USA, 1986 [GeG85] M.R.Genesereth, M.L.Ginsberg Logic Programming CACM Vol.28, Nr.9, 1985 [Ki 191] M.F.Kilian A Note on Type Composition and Reusability OOPS Messenger Vol.2, Nr.3, July 1991 [Kos 87] Y.Koseki Amalgamating Multiple Programming Paradigms in Prolog IJCAI'87 Proceedings, 1987 [Lie 86] H.Lieberman Using Prototypical Objects to Implement Shared Behavior in OO-Systems OOPSLA'86 Proceedings, Sept.1986 [LMN89] L.Leonardi, P.Mello, A.Natali Prototypes in Prolog JOOP, Vol. 2, Nr. 3, Sept.
EpilogueICOT, Tokyo, pp. 166-190. 16. Shapiro, E.Y., Ed. Concurrent Prolog: Collected Papers, vol. 1,2. MIT Press, Cambridge, Mass., 1987. 17. High-performance logic programming with the Aquarius Prolog compiler. IEEE Comput. Mag. (Jan. 1992), 54-68. 24. Some researchers believe a better way to realize Fuchi's vision is through systems that exploit parallelism automatically in Prolog or other logic programming languages which preserve its essential attributes.
Logic and logic programmingSterling and E. Shapiro (MIT Press, 1986), • Prolog Programming for Artificial Intelligence by I. Bratko (second edition, Addison-Wesley, 1990), • The Craft of Prolog by R. Whether your task is / advanced exploratory research, or the development of complex production systems, the ALS Prolog compiler is the Itool of choice. Develop with one ALS Prolog compiler, and you re developing with them all. ALS is committed to a uniform implementation on all platforms, yet you get access to all the facilities of each platform, including each native win- . / dowing system. You can couple your Prolog programsto C programs via a very broad C interface which allows Prolog to manipulate C data, and allows C to \/call into Prolog.
A general framework for visualizing abstract objects and relationsThe conceptual model of visual mapping is presented in [31]. We realize this model by using Prolog and COOL. An abstract object is represented by a Prolog term or rule (predicate). An abstract relation is represented by a Prolog rule. These rules are asserted in the Prolog database as a result of the analysis' phase. In the current implementation, the is invoked after the Prolog program completely terminates, which means there is no feedback Prolog.
Modularity, parallelism, and licensing in a principle-based parser for GermanJohnson's project is to forntalize linguistics in some suitable subset of first-order logic, arid use this formalization as inpnt for an antomatic theorem prover, such as Prolog, without any intervening recoding. This proposal, however, suffers from some well-known difficulties, such as undecidability, left-recursion (in Prolog), and a tendency to produce generate-and-test algo-2 The reader is referred to [Se 185] for a short introduction.For a detaileddiussion, see one of the standardtexu%e.g. Johnson proposes to cope with the difficulty about indeterminacy by using the freeze-construct (known, e.g. from Prolog-II) to achieve pseudo-parallel execution of generators and tests. The entire system has been programmed on an IBM RT in Quintus-Prolog 2.4 under Unix/AIX. As Quintus does not have afreeze predicate, a recta-interpreter has been implemented to provide one.
"Analogy by generalization—and the quest of the grailIntroducing or not a new variable is a matter of practical significance in the Prolog programming language. Accordingly, Wi/son's msg program [WM, pg. 211] refines Plotkin's algorithm so as to retain variables in the situation above. Frame unification and frame generalization are also provided. The program, written in IBM Prolog [WM], is followed by example goals. 107 4. Further research and concluding remarks In [Kn], unification over structures of greater complexity than frames is discussed, e.g. parse trees corresponding to natural language sentences. - in Arthurian Interpretations - Memphis State University (accepted for publication). [JK] C. Jay and R. K. Knaus - Frames in Prolog, part 2 ."" unification - in AI Expert, May (1989) 19-24."
CRL/NMSU and Brandeis: description of the MucBruce system as used for MUC-4There are separate relevant and non-relevant lists of word s used to determine each template type . The result is a vector represented as a Prolog fact which determines whether the texts will be allowed t o generate templates of a particular type . The template construction program is written in Prolog and was compiled to run stand-alone usin g Quintus Prolog . These parsing rules are individually pre-compiled into compact Prolog code (each a small expressio n matching machine) before being included into the template constructor .
"Declarative programming of graphical interfaces by visual examplesThe Prolog database contains the ASR data represented as Prolog clauses (i.e., database such as organlzatlon(hogan, [heinlein, herbert]) in this example. When facts) clarke, the rule organizationmle is applied, Prolog interpreter unijles line (1)with afactthat rnatchesthisline. that capitalized letters such as X represent first (Note variables and square brackets, i.e., "" and ""]"", represent structures.) For example, line (2) generates a VSR H clause horizontal( [hogan, heinlein]) as aresultofunification, representing a geometrical relationship the two objects. Line(5) invokes the backtrack nism of Prolog and forces enumeration of all ASR clauses to be converted to VSR clauses."
Integrating ILP and EBLGeneralize: Determine a set of sufficient conditions under which the explanation structure holds, stated in terms of the operationality criterion. Standard Prolog deduction is generally used to construct explanations. In one test, FORTE was used to automatically debug Prolog programs written by undergraduates for an assignment in a class on programming languages. Program Formation Rules SpecinllzaUon Figure 2: Learning Clause Selection Heuristics A framework for control-rule learning in Prolog programs is illustrated in Figure 2. The input to the learning system is a Prolog program and a set of training examples, which are fully instantiated examples of the top-level program goal.
"Towards creating specialised integrity checks through partial evaluation of meta-interpretersIn [23] we presented a partial evaluation scheme for a ""real However life"" subset of Prolog, cent aining first-order built-in's, sim- be viable for ple side-effects and the operational predicate if-then-else. stance Prolog In this paper we apply this scheme to specialise integrity [23] Towards Creating Specialised Integrity Checks Through Partial Evaluation of Meta-Interpreters Michael Leuschel"" and Danny De Schreyet Department of Computer Science, K.U. PEPM '95 La Jolla, CA USA 0 1995 ACM 0-89791 -720-019510006 . ..$3.50 cally usable subset of Prolog encompassing first-orderz built in's, like var/ 1, nonvsr/ 1 and =. . /2, simple side-effects, like print /1, and the operational if-then-else construct. The if-then-else contains a local cut and is usually written as (If -> Then , Else). The following informal Prolog clauses can be used to define the if-then-else: (If-> Then ,Else) :- If, !"
A logic-based approach to system modellingTo copy other wise, or to republish, requires a fee snd/or specific permission. 01991 ACM 089791-429-5/91/0005/0084 $1.50 build it. We assume the reader is familiar with Prolog [Clocksin 84], the examples in this paper are written in art extension to Prolog called LOGIN (LOGic and Inheritance) [Ait-Kaci 86]. LOGIN from Prolog terms in several ways. and assert terms differ 1. Identical tags in different unrelated. terms are 3. Prolog's anonymous variable, written as an underscore, is denoted by the vahte @ (pronounced any) in LOGIN.
Efficient collaborative discourse: a theory and its implementationThe basic operation of the architecture is illustrated in Figure 1 where problem-solving is to achieve top level goal G. Prolog-style theorem proving proceeds in the usual way and ff G can be proven from available information there will be no interaction with the user. The transmitted information between the participants is in the form of Prolog-style predicates since the machines gain nothing through a translation to natural language. Their system maintains and AND-OR tree much like our Prolog tree and engages in dialogue similarly to try to achieve subgoals.
Head corner parsing for discontinuous constituencyIn the current grammar string/2 is defined as follows: 41n Prolog this predicate may he defined as follows: subset([],P,P). subset([HIT],P0,P):- selectchk(H, P0,Pl), subset(T, PI,P). select.chk (El, [El IP] ,P) :- !. The algorithm as it is defined is sound (assuming the Prolog interpreter is sound), and complete in the usual Prolog sense. Miyoshi, and H. Yasukawa. BUP: a bottom up parser embedded in Prolog. New Generation Computing, 1(2), 1983. Carl Pollard.
An approach to the programming languages courseLast fall, however, we replaced Prolog with Scheme, so students now get a taste of functional programming. 5. Since then, Prolog has lost momentum, it now seems likely to remain a cult language. Prolog's declarative nature is more of a shock than Scheme's functional nature. 6.
Computations at infinity: a nonstandard approachWe wiU also briefly discuss the procedural incompleteness of Prolog km a nonstandard angle. Nonstandard methods have been used before in logic programming, most notable by H. To enforce backtracking at infinity is a naive idea which can be made precise through nonstandard analysis. Because Prolog programs are finite, and because we do not want to change the way Prolog works, it is necessary to have some syntactic transformation of the program available in order to incorporate desired backtracking. The transformation which enforces stratification is routine and could actually be part of the Prolog implementation. For thisand related work see [3] and [6].
IXM2: a parallel associative processorProgramming for IXM2 is performed with the knowledge representation language IXL, a superset of Prolog, so that IXM2 can be utilized as aback-end to AI workstations. 1 Introduction Network structured data is extremely difficult for sequential computers to handle when the network is large, because com putation time increases drastically with the size of the network. The knowledge representation language IXL is provided as the host language. IXL is a superset of Prolog and contains the special predicates for semantic network processing, the predicates are functionally distributed from the host to IXM2. The IXL interpreter on the host is written in Quintus-Prolog so that Prolog programs can be executed by the interpreter.
"Stream driven query processing in a databaseSection 4 esents otha examples of query processing and wmparea the present approach with an earfier approach based on a Or-prmllel Prolog system. Section 5 gives a brief ovemiew of the derivation of the ""base"" routines (i.e., the C routines which ultimately interact with the actual database relations) from those routines provided in the GNU dbm library. In an earlier paper (see [3]), the same database was considered in an investigation of Prolog's abiiity to implemen and query, a relational database. This same qtses'yexpeaaed m ?hepreviously mentioned Or-parsJleI Prolog system required 26 seconds when executed with 4 pocessors."
Type analysis of logic programs in the presence of type definitionsAliasing information is used to improve the precision of type analysis. 1 Introduction Prolog is a type-free language. `The programmer does not have to specify the types of variables, functions and precli cates. However, it also makes it diflicult to debug programs be cause type errors cannot be detected by Prolog systems. A type error will manifest itself in the form of a wrong re sult or a missing result rather than an indication of a type violation. There have been many efforts to auglnent Prolog with type systems in the forms of type checkia% s.vstenis [2, 1 I , 27] and type anafysis systems.
Inheritance and constraint-based grammar formalismsFor example, the value of a variable should be independent from its position within the scope of its declaration. This is true for PROLOG variables inside a clause, but not for PASCAL or LIsP variables that make use of assignment. A higher level example is the meaning of a procedure: it is not transparent if the procedure makes use of global variables that are set by some other procedure. Similarly, the meaning of a PROLOG predicate should be transparent because there is no global variable, but a predicate definition might be modified during execution by imperative predicates such as assert and retract, thus destroying the referential transparency of pure PROLOG. Although this strategy is not complete (a complete breadth-first search strategy could be used for debugging purposes), the use of the outermost rule has favorable termination 10 Conditions do not change this general scheme (they are evaluated using the same rewriting mechanism) and are omitted from the presentation here for the sake of simplicity.See for example Dershowitz and Plaisted (1988)and Klop (1990)for a survey on rewriting. 169 Computational Linguistics Volume 18, Number 2 properties when compared to PROLOG'S leftmost rule: there are problems where a TFS computation will terminate when the corresponding logic program implemented in PROLOG will not, for example, for left-recursive rules in naive PROLOG implementations of DCGs. 3.
"Review of ""Formal semantics and pragmatics for natural language querying"" by James Clifford. Cambridge University Press 1990.Implementation of such rich databases would be prohibitively expensive, as much of the inherent data redundancy cannot be avoided. But a small fragment has been implemented in Prolog by Clifford, as a pilot study, along the lines of Friedman and Warren (1978). Other related research that also deserves mention in this context is Engdahl's (1986) theory of interrogatives in situation semantics, work on hypothetical reasoning in Prolog by, among others, Bonner (1988) and Gabbay (1985), and the event-based PTQ-inspired temporal semantics for Prolog by Richards and Bethke (1989). 233 Computational Linguistics Volume 17,.Number 2 Clifford's excellent book is a beautiful example of a foundationally sound and intrinsically interesting computational application of Montague semantics, presented in all requisite detail and with much enlightened discussion of the results obtained, their advantages, disadvantages, and essential limitations. Linguistics and Philosophy, 2, 347-372. Gabbay, Dov (1985). ""N-Prolog: An extension of Prolog with hypothetical implications."""
Selected aspects of component modelingWith a new approach (Figure) we develop the generator in PROLOG, which transforms specifications of catalog data of standard cells (SC's) into corresponding VHDL source code, which is flexible, easy *to maintain and ortable.. Model attributes are directl measured by functions implemented in PROLOG. ,hese functions are used in the proposed hierarchical quality. model suitable for control and evaluation of quantltatwe features of VHDL descriptions. Each VHDL model consti@tes an input for a PROLOG Darser. For each descrlDtlon the Darser writes a fixed record to a database.'
Indian central civil service pension rules: a case study in logic programming applied to regulationsSeveral of the GIDs in the CCS Pension Rules stress the importance of making proper entries in iL The demonstrator system we have implemented has two separate components: G the pension calculator, which is a set of rules qualifying service and pension entitlements in assertions about employees' service histories, defining terms of q a data entry program (in Prolog) for transcribing the information in the `service book' into a set of assertions stored as a (Prolog) database. The rules defining pension entitlements but in are exeeuted by a Prolog system which provides a `Query-the-User' (QtU) mechanism [Sergot 1983]. In this application, a very simple version of QtU is adequate and can be implemented in just a few lines of Prolog code.) A note on methodology The use of a QtU mechanism in this application might seem to be redundant.
Deductive databases in actionAnother set of experiments concentrated coupling Prolog and relational database on systems. [Jark 86,Kuni 84,Li 84,Ceri 87]. Several [Bocc 86,Lefe 89] support the coupling servers and Prolog and feature methods of these of SQL for ex ecuting recursive queries. These attempts motivated by the immediate availability were of both the Prolog and SQL technologies, and their bination stiers from a number of com drawbacks.
Determinacy testing for nondeterminate logic programming languagesAny clause with a nonfailing head and guard can be reduced (as in PROLOG). and output variables at this stage: There is no distinction between input The goal is unified with the clause heads until one is satisfied. The procedures utilize Kernel syntax: The wait operator, procedural semantics, a small example is code: Andorra PROLOG [Haridi and Janson 1990] :, signifies don't know, whereas the standard commit operator, I , signifies query: ? The Andorra-I preprocessor: Supporting Znternattonai Conference on Logic Programming. Prolog-An integration of Prolog and committed Conference on Fifth Generation Computer Systems (Tokyo, Japan, Nov.).
"Abstract interpretation and low-level code optimizationIn general, variable-variable unifications during the execution of a Prolog program can cause pointer chains to be set up, and these need to be dereferenced be fore the value of a variable can be accessed. At first glance it might appear that such an approach is practical only in languages, such as Prolog and Lisp, where it is easy to create program fragments ""on the fly"" and execute them. A. Taylor, High Performance Prolog Implementa tion, Ph.D. thesis, University of Sidney, Australia, 1991."
Proof theory and a validation condition generator for VHDLBreuer Luis S6nchez Fernkdez Carlos Delgado Kloos Departamento de Ingenieria de Sistemas TelemAticos Universidad Politkcnica de Madrid, ETSI Telecomunicaci6n <{ptb,lsanchez,cdk}Qdit.upm.es> We present a Hoar-e-styli: programming logic for VHDL together with a succinct PROLOG implementation which acts as a validation condition generator. We present the logic for the first time here together with a succinct PROLOG implementation which acts as a validation condition generator for VHDL descriptions. The PROLOG program transforms logical assertions to their prerequisite hypotheses.
"Pragmatic parsing in Common Lisp, or, putting defmacro on steroidsliterature on post-Prolog ""committed choice"" languages [Maher 87] [Shapiro 89]. Finally, many networking protocols require extensive (and often excessive) syntax analysis, slow protocol parsing is typically the chief cause of poor network performance. Prolog programmers, however, find parsing tasks trivial,2 and the ease of programming parsing tasks has been one of the selling points of Prolog to unsophisticated programmers. Lisp is a language-building language par excellence, and it can therefore easily emulate those Prolog capabilities that make parsing simple. Furthermore, since our emulation will include only those features we need, we will be able to parse much more quickly than a Prolog system."
A verification helper for task specificationsFor the example specification, the only inference rule is about the queue data structure. The HeIper is implemented in Prolog. The i/o automata model and all inference rules must be provided in Prolog form. We chose to rep.** x)) Producem Figure 2: The 1/0 Queue Consumer Automata of Producers_Consumer Specification resent the specification assertions as Prolog structures as shown in Figure 3. Type information is not encoded. To use the Helper for a verification example, the assertions of the specification are converted to the Prolog form, as shown earlier. Next, any necessary inference rules are determined and converted to the Prolog form, as show above.
Improving abstract interpretations by combining domainsThe combined analyses have been implemented in the context of the &-Prolog com piler [14, 18, 20] by reusing components of previously defined analyses. The anal yses have been carried out within the framework of the &-Prolog compiler. This framework, implemented in Prolog, is based on the abstract interpretation framework of Bruynooghe described in [2], optimized with the specialized domain-independent fixpoint algorithm defined in [20]. Tick), Prolog Bench peephole SB-Prolog's Peephole optimizer, and ann a simplified version of &-Prolog's parallelizing notator. an Size measures include: the number of clauses in the program, the number of clauses after preprocessing and the number of variables in the program Example 8 The following illustrates the output from 3. the reduced product analysis (P*S) for one clause serialize program. arrange ([X IL] ,tree(Tl, X,T2)) :- !!
Aggregation in the NL-generator of the Visual and Natural language Specification ToolThe VINST system is a ready usable prototype which has been demonstrated and tested on various sites in the world (Engstedt 1991, Preifelt & Engstedt 1992). The VINST prototype is implemented in AAIS-Prolog and SuperCard on Macintosh. The Prolog is used for the NL-system and the SuperCard for the VL-part and for the user interaction of the system. 2. CLE is a bidirectional, unification and feature-based grammar written in Prolog. CLE uses Quasi Logical Form (QLF) as linguistic representation for the parsed NL-string. The syntax of the IGF is described by showing the Prolog predicate int_genform/3 and its content. int_gen_form(REFNR, TYPE(FEATURELIST), USED_WORD_LIST).
"Data structures and algorithms for disjoint set union problemsThe question,""Is there anything John and Mary both like?"" is phrased in Prolog follows: ?- likes(mary, X), likes(john, X). Prolog answers this question by first attempting to unify the first term of the query with some assertion in the database. This can be unified with the third assertion in the database and Prolog notifies the user with the answer X = wine. Consequently, the execution of a Prolog program without function symbols can be seen as a sequence of unifications and deunifications. CLOCKSIN, W. F., AND MELLISH, C. S. 1981. gramming in Prolog. Springer-Verlag, Pro-Berhn. DOYLE, J., AND RIVEST, R. 1976."
Unification: A case-study in data refinementIt is a fundamental operation of automatic theorem proving, and has a special place in Prolog, where unification is the pattern-matching process by which the clauses of a program are used to solve queries. In a second phase of development, the representation of substitutions commonly used in Prolog implementations is studied. It is related to the abstract model by a step of data refinement, with the abstraction invariant expressed as a relation, rather than as a function from concrete to abstract states. The other (less honourable) approach is the one taken by most Prolog implementations: simply replace the test by False and risk the consequences.
Abstracts of current literatureMoreover, for specific implementations of logic programming, e.g. PROLOG, the notion of deduction strategy is also important. In this thesis, we provide semantics for two types of logic programming languages and develop applications of these semantics. First, we propose a semantics of PROLOG programs that we use as the basis of a proof method for termination properties of PROLOG programs. These equations are taken as axioms in a first-order theory in which various program properties, especially termination or nontermination properties, can be proven. The method extends to PROLOG programs with extra-logical features such as cut.
"Minimizing branch misprediction penalties for superpipelined processorsThis superpipelined processor not only supports generic RISC-like instructions, but also a powerful instruction set for efficiently performing logic programming as in Prolog [7]. VLSI-SLAM has an one-cycle delay for load instruction followed by any instruction using the loaded data and a three-cycle delay for a branch (conditional jump). These benchmark programs, seleeted from the Aquarius benchmark suite [6], are com piled by optimizing Prolog compiler frontend Aquarius Compiler [14] and compiler backend Super-reorderer [11], Execution cycles for these benchmark programs ranges from thousands to millions of cycles. Despain,""High-Performance Logic Programming with the Aquarius Prolog Compiler,"" Computer, January 1992."
"Review of ""Functional grammar and the computer"" by John H. Connolly and Simon C. Dik. Foris 1989.Samuelsdorff presents program examples written in PROLOG2, whereas all of the other authors who provide program examples use standard Edinburgh PROLOG. Sentence generation is achieved by applying expression rules to predications. 104 Book Reviews Section 3 (""On Parsing"") consists of four papers by Janssen, Gatward, Kwee, and Dignum. It presents a superficial overview of AI and a brief and confusing attempt to describe the process of grammar writing in terms of knowledge engineering. The presentation of a few lines of PROLOG code seems to be designed to show that it is possible to encode FG rules in a programming language. The papers are inadequately cross-referenced and display many needless inconsistencies of style (e.g., ""PROLOG"" vs. ""Prolog', endnotes vs. footnotes). The papers build very few bridges between computational FG and what is going on in the rest of NLP."
Constraint projection: an efficient treatment of disjunctive feature descriptionsThis method, however, is inefficient. Since Prolog chooses one definition clause when multiple definition clauses are available, it must repeat a procedure many times. Constraint (23) is not transformed because it is already modular (idea (b)). Prolog would exploit the definition clauses of r and expend unnecessary computation time. We also implemented three CYK parsers that adopt Prolog, CU, and CP as the disjunctive unification mechanism.
A tool for processor instruction set designTo illustrate the use of the new technique, an instruction set is generatedfor the execution of compiled Prolog programs. 1 Introduction Even though somemaysaythatthecurrentinstruction set architecturesare sufficient for almost all application needs (both general and specialpurpose),therehasbeenno lack of recentintroduction of new instruction setsor revisions to current instruction sets. In Section3 thetechniqueis appliedto thedesign of aninstruction setspecializedfor Prolog. Conclusionsand future researchareoutlined in the final section. 2 Automatic generation of instruction sets The newtechniquefor instruction setdesignis composed of threemajor steps.First, thebenchmarksaretransformed into a setof codesegmentsweightedby dynamicexecution frequency. M. Despain, J. M. Pendleton, and T. Dobry. Fast Prolog with an extended general purpose architecture.
Parsing as tree traversalfurther to take advtlltage of the first argument and predicate name indexing used in Prolog. parsers are described in terms of pairs c)f op(wations such a.s expand/ma(,c]l, shift/reduce or sprout/nlatch, l{tlt it is enl, irely unclear wha.(, expa.nding and matching has to do with shifting, reducing or sprouting. The Craft of straints, i.e., the phrase structure rules. Prolog. MIT Press, Cambridge, What I have shown here, is that the de-Mass, 1990. cision as to where to fold in the con-Fernando C. Matsumoto, H. tIirakawa., I{ Miyoshi, and 11 Yasukawa. Bup: A bottom-up parser embedded in prolog. New Ceneration Comptling, 1(2):145-158, 11983.
"Review of ""Principle-based parsing: computation and psycholinguistics"" by Robert C. Berwick, Steven P. Abney, and Carol Tenny. Kluwer Academic Publishers 1991.., the work on ID/LP format and liberation schemata), in the schema on page 165 and elsewhere in Dorr's paper (153-183), coded in Prolog throughout Stabler's paper (199-237), and in pages 262ff of Abney's paper (a straightforward piece of deterministic context-free LR parsing). Stabler's paper, for example, is a small but serious contribution to Prolog-based computational linguistics -- though I find absolutely nothing in it that refers to GB concepts or PBP. Johnson's is a clear statement of a simple if not particularly original idea (that using Prolog, parsing can be simply a process of deduction in the logical sense -- an idea that seemed to be apparent to Prolog enthusiasts in Europe over a decade ago) and an exploration of a few (five) different control structures that a GB parser might use, and Correa's work on attribute grammars, as noted above, might repay the reader's attention."
The term retrieval abstract machineThe Feature Term Data Model (FTDM) supported LILOG-DB and its deductive user interface lan of by are direct outcomes of the analysis of the LILOG requirements. The complex objects stored in LILOG-DB are Prolog-Iike terms composed of atoms (integers, reals, symbols), functors, lists, sets and feature tuples. The 7-operator evaluation procedures have not to deal with the internal schema because our main memory term representation is self-identifying like in most Prolog or Lisp systems. Only the term translation procedures have to know the disk representation and to interpret the internal schema. He shows, that there is a very natural way to derive the Warren Abstract Machine [36, 1], the standard target architecture for Prolog compilation. The idea is to specialize an abstract Prolog interpreter together with a set of Prolog programs to be interpreted by partial evaluation [11, 31].
"A unification-based semantic interpretation for coordinate constructs[P,X] succeeds if D is unifiable with P(X). 7One implementation-dependent reason is that the Prolog requires at least one of the two variables V and Fred to be already instantiated for the univ to work. Gopalan Nadathur & Dale Miller[1988], ""An Overview of A-Prolog,"" Proceedingsof the Fifth International Logic Programming Conference. Fernando C.N. Pereira & Stuart M. Shieber [1987], Prolog and NaturM-Language Ananlysis, CSLI Lecture Notes Number 10."
The functional side of logic programmingLogic programs will be considered executed with leftmost selection rule and depth-first as search rule, that is the standard way in which logic is implemented (for example, in Prolog). With indicate a most general unifier of two terms programming rngu(s, t) we s and t. The languages employed are the commercial compiler Sicstus Prolog v2. 1 (cf. [1]), and Concurrent Clean vO.8.4 (cf. [20, 22]), a public domain non-strict functional language (that can also be used as a strict language on request). Prentice-Hall, Englewood Cliffs, New Jersey, 1986. [26] L. Sterling and E. Shapiro. The Art of Prolog. MIT Press, 1986.
Design and implementation of the glue-nail database systemThe new language must offer significant advantages over existing languages (such as C, C++ , and Prolog). Glue [14] was designed to offer such advantages by reducing the impedance mismatch problem with Nail. Glue is much closer in semantics and syntax to Nail than C++ is. Glue has one advantage over Prolog, notably that both Glue and Nail are set-oriented, whereas Prolog is tuple-oriented. The Glue compiler is implemented a combination of C, C++ , and Prolog. Nailog semantics were particularly difficult to efficiently, because in general the predicate to which subgoal refers can only be determined at run and the using handle a Glue time.
"An implementation of Eisner v. MacomberThese problems have been remedied not suf central formal by subse quent work, and the present paper describes plementation (in PROLOG) of the original an im theory. A study of the implemented system provides reconstruction of the arguments of Justice a rational Pitney and Justice Brandeis in this seminal corporate tax 1 Introduction case. This a standard PROLOG coding trick which allows hi has is us to use ordinary PROLOG unification to simulate tion in an order-sorted logic. The translation from the""internal"" LLD syntax to the true internal PROLOG syntax is straightforward, and fully automatic."
A software tool for modular database designA first [10] extended with APES prototype of the tool, written in micro-PROLOG [20], is fully operational. It offers a user-friendly interface that guides the designer through the various stages of the creation of a new module or through modules. The prototype stores user can freely query using the process of changing objects of existing the description of a schema as clauses that the the facilities of micro-PROLOG, It also incorpo rates, in clause form, a description the modularization discipline, which new expertise about database design. DAYAL, U., AND BERNSTEIN, P. A, relational views. ACM Trans. Micro-PROLOG: Programming zn Logic. Prentice-Hall, On the correct translation of update operations on Database Syst. 7, 3 (1982), 381-416. 12.
Probabilistic Datalog—a logic for powerful retrieval methodsRetrieving documents dealing with both of these topics now can be accomplished by means of the the rule (as usual in Prolog or Datalog, va riables start with capital letters and constants with lower-case letters) ql (x) :- indterm(X, ir) & indterm (X, db) . (al A term is either a constant or a variable. Note that as a major difference to Prolog, Datalog does not allow fimctions in terms. Thus, a ground term in Datalog only be a constant, and the Herbrand Universe for can of a Datalog program is the set of constants occurring in it. So failing negated goals are processed in the same way as in Prolog. Special difficulties arise when the interpreter runs into cycles during the inference process.
An efficient directory system for document retrievalA user may need all documents with the index term `Prolog'. attribute value `Prolog' would The be passed to the RETRIEVE algorithm. Starting at the root (node following the path to the leaf, node 4 is reached. The pointer related to the attribute `Prolog' is 9, which is the root 1) and the leaf address value of the desired lower tree. Consider again the file and M- B-T directory of figure 1, and a request to retrieve all documents with index term `Prolog' such that the weight of the term is not less than .7.
Processing language with logical types and active constraintsGiinthner (Gtinthner 88) within the framework of Prolog III, we will here concentrate on the three last types of constraints, which are quite different in nature from the two first ones. This machine is based on the procedural semantics of Prolog but it resembles a push-down tree automaton whose stack is updated each time a subtype is modified. Our description language has now being fully implemented in Prolog on a SUN workstation following the abstract machine description given above.
LogC: a language and environment for embedded rule based systemsAs the features described above in the LogC design and implementation, LogC could support heuristic inferencesexclusively more efficient than other AI languages like PROLOG. This is illustrated by the following figures. Table I gives the result of efficiency comparison between LogC and PROLOG to solve the eight-puzzle problem, here LOGCE is the LogC interpreter,while LOGCC is the LogC complier. The symbol '--' in Table 2 represents that itneeds too long time to compute it. 30 Initial LOGCE Data Execute Time Space (1 / 60see) 012 345 576 678 876 543 659 210 4 1 3 6 0 5 1947 827 023 1 4 6 47 758 216 4 0 8 3056 753 Initial ,, rank in all Data approximate Space solution possible routes 7(city 71) [2140.7507 1/360 7(city 72) 2825.2915 2/360 8(city 81) 3013.8308 15/2520 8(city 82) 2855.0226 3 / 2520 8(city 83) 2817. 9683 I / 2520 10(cityl0) 26906. 706 1 / 181440 20(city 20) 4440. 8425 - 30(city 30) 5465. 1640 . C-PROLOG l LOGCC Turbo--PROLOG Execute Time Execute Time Execute Time (I / 60see) (I / 60see) (1 / 60see) 12 X 12 x 34 184 13 x 55 Table I LogC C LOGCE LOGCC optimum C error rate Execute Time Execute Time Execute Time (%) solution (1 / 60see) (1 / 60see) (I / 60see) 0 40 3 2140.7507 194 8.6462 39 4 2600. 4511 162 11.8018 67 6 2695.6901 1009 1. 3622 67 6 2816. 6556 935 0 64 6 28 17. 9683 756 0 161 15 26906. 7064 4314 2412 263 >45 minute 11424 1401 Table 2 THE ENVIRONMENT LogC is also an integrated environment.
"Logic activities in EuropeIn logic programming the most striking recent development is the creation of a new logic programming language, GOdel, by Hill in Leeds and Lloyd in Bristol . It has about the same expressive power as Prolog but seems to be much cleaner from the point of view of logic . The gap between pure logic programming of theoretical papers on one side, and Prolog and othe r existing logic programming languages on the other side is troubling . ""The theoretical logic programming community loses interest in Prolog , Prolog acquires the same status that Lisp has in the functional programming community,"" say Egon Barger an d Dean Rosenzweig, whose paper [Borger and Rosenzweig 1992a], addressing the practical issues o f Prolog, will appear in The Science of Computer Programming rather than in a logic programmin g journal ."
Rapid development of morphological descriptions for full language processing systemsThe system described is a component of the Core Language Engine (CLE, AIshawi, 1992), a general-purpose language analyser and generator implemented in Prolog which supports both a built-in lexicon and access to large external lexical databases. Run-time speeds are quite adequate for full NLP, and reflect the fact that the system is implemented in Prolog rather than (say) C and that full syntactico-semantic analyses of sentences, rather than just morpheme sequences or acceptability judgments, are produced. Because of the separation between lexical and morphological representations, these timings are essentially unaffected by in-core lexicon size, as full advantage is taken of Prolog's built-in indexing. Development times are at least as important as computation times.
Generating instruction sets and microarchitectures from applicationsIf the design process decides to encode the instruction operands by unifying the register specifiers R2=R3=R4, then this instruction becomes push(R1,R4,Immed) which is used in Prolog compilation [19]. This unification saves two register operand fields in the instruction. Three symbolic applications were selected from the Prolog benchmark suite [11]. hanoi_8 is the `hanoi' problem solver. con1 concatenates two strings into one string. nreverse reverses the order of the given string. We have presented experimental results with three Prolog applications. Limitations of the method are shown, and possible improvements are discussed.
Multi-pass execution of functional logic programsProgram is turns out to be non-ground, two solutions are possible. The for first solution, applied e.g. by Prolog's arithmetic facilities, The is to abort the execution and report a runtime error. The phase partition erated by static analysis where data dependencies tracted for the functional elements of the program. method guarantees that all the functional terms SLD- NUE-Prolog, is to delay the call until the arguments become (multi- fully instantiated. LeFun non- The functional elements of a program are expressed as junc-BA- tional terms that are assumed to represent calls to external [ALN87], functions.1 NUE-Prolog [Nai 91]). The non-deterministic approach is general but computational and conceptual problems.
Artificial intelligence can improve hypermedia instructional technologies for learningThese considerations of the led the author to introduce AI techniques in the design and implementation of a hypermedia instructional system for learning logic programming and the Prolog guage. To allow the students to carry real, not just simulated, laboratory lan out activity and thus instill the required capacity for effort and synthesis, the system embodies the Prolog environment. cludes a tutoring component that, though it allows learners to decide own learning paths, is able to follow actions continually, to control also It in altheir their and evaluate their performance in a transparent fashion, and to reconfigure the accessible material dynamically in order them within suitable learning to contain paths. SYSTEM ARCHITECTURE The architecture of the system the following main functional really stu includes blocks: (1) domain representation, encoded in a hypertext network that implements semantic networks, the nodes contain exercises and may graphic form, with animation sound, (2) the student model, constituted data relative to the students' tions, which are continually grated with the knowledge system already has about may be in and by acinte the them, (3) the student interface, based use of menus, navigational on the tools typical of hypertext systems, such as buttons, keywords, and the like, a series of functions of help type, (4) and the laboratory module, represented by the Prolog environment, grated in a transparent fashion, inteand (5) the tutor module, which operates on the current student model to determine the direction or next node to which to suggest access. The difference continued to be significant when the logic programming concepts and Prolog syntactic rules (t(58df) = 3.51, p < .001) and the programming exercises (t(58df) = 3.50, p < .001) were analyzed separately.
Three new-generation software environmentsHowever, we saw that attempts to build dedicated Prolog hardware as well as use Prolog as a single basic programming language for the next generation of computm6 une 1991/Vo 1.34,No.6/GOMMUNIGATIONSOFTHEAGM PPojeol:, START ing were not successful. This language combines the basic features of Smalltalk (objects and classes), UTOPIST (propositional logic programming) and Prolog (Horn clause logic programming). The viability of combining various knowledge representations into a single knowledge-based system was demonstrated earlier by a software product called ExpertPRIZ. In the case of Prolog the same information is represented by an atomic formula of which the following is an ,example: Q(x,y).
"Employing databases for large scale reuse of simulation modelsTo sup(3Link `tiab'e `F Relationship multiplicity: AOrl o n Figure 3: ""Meta"" ER-Model unit port this, derivation rules are simply coded in Prolog and entered as character strings into the data base. When the system is about to derive virtual relationships, these rules together with Prolog facts corresponding to the ""Relationship"" relation of the current data base are fed into a Prolog interpreter which is used as an inference machine. For standard rules of this type, the user need not specify the Prolog code proper, but must only provide some addi tional database entries."
A dialog control algorithm and its performanceThe algorithm becomes understandable if an example is followed through in full detail. Assume that the following database of Prolog-like rules are contained in the system knowledge base. This contrasts with traditional theorem proving approaches (e.g. Prolog) which simply engage in backtracking when a missing axiom is encountered. linguistic interface - This consists of the generation and recognition modules. The users are restricted to a 125 word vocabulary in the connected speech system. 1Quintus Prolog is a trademark of Quintus Computer Systems, Incorporated 2DECtalk is a trademark of Digital Equipment Corporation.
"Searching for semanticsThe latter is reminiscent of Prolog's ""backwards"" implication `: -' and improves readability of some Elf programs. Instead of searching for a proof of a formula P (ss done in Prolog) we are searching for a (closed) object M of a type A. Instead of Prolog's first-order unification, Elf solves constraints given as dependently typed functional equations."
"A spreadsheet based on constraintsFigure 9: Linear programming PLEX, is based on m earlier idea of Van Emden et al. [6] and Krivaszek [7] who propose the grid layout of spreadsheets as a flexible user-interface to an interactive programming tool based on Prolog. Spreadsheet cells can be seen as Prolog variables and can be related through Prolog predicates. TR-144, Ott 1985 [71 F. Kriwaszek,""LogiCalc - A PROLOG Spreadsheet"", in B. Kowalski, F. Kriwaszek,""Logic Programming"", pp. 105-117, also in: D. Yap, ""The CLP(R) Language and System"", Proceedings of the 4th ICLP, 1987 [91 A. Colmerauer, ""An Introduction to Prolog III"", Conummications of the ACM, Vol. 33, No. ?"
Unisys: description of the Unisys system used for MUC-3Th e antecedents and consequents of KBIRD rules can include arbitrary Prolog goals just as in Definite Claus e Grammars [5] . A is in the same region as B . KBIRD rules are compiled into a combination of Prolog backward chaining rules and forward chainin g rules in Pfc [1] . This phase produces text input of the following sort to the Prolog portion of the system, including default (header) information about the dat e and location .
Retrieval from hierarchical texts by partial patternsThe language allows any substructures of the database to be accessed in a We uniform manner. describe a query language for retrieving information collections of hierarchical text. The language from We present a Prolog-like query language based on is based on the tree inclusion primitive. We present some complexity results and discuss applying indices and Prolog-like optimizations to a the evaluation of the queries. Warren. Computing with Logic - Logic Programming with Prolog. The Benjamin/Cummings Publishing Company, Inc., 1988. [25] V.
The concurrent object-oriented language braidINTRODUCTION Despite the efforts to promote them of the JapaneseFifth Generation Project, which gave them a central role 1201.the concurrent logic languages [16.17] have not achieved widespread use, falling between two stools: logic programmers have rejected them for lacking the full unification and backtracking search capacity of Prolog, programmers in other paradigms have tended to see them simply as variants of Prolog rather than as concurrent languagesin their own right, and therefore suitable only for those domains already dominated by Prolog. The basis of the languages in logic gives them a declarative syntax (in fact a rather cleaner one than Prolog, since unlike Prolog there is no gulf between a formal logical version of the language which the theories talk about, and the dirty feature-ridden version which is what programmersuse in practice), enabling formal treatmentof programs written in them in a variety of ways, but also means that there is a large amount of coding redundancy. Note the use of = as a quoting operator on the left-hand side of Braid clauses makes the Prolog convention of upper-case initials for variables and lower-case for constants unnecessary - in Braid it is always possible to distinguish which is meant by context.
Algorithm 709: testing algorithm implementationsConsiderable scope is given for each user to tailor AT to his or her own needs and computing is to use a PROLOG file, which is read and which may contain those commands particular installation or test algorithm Problem specification. It specific names in the file is convenient to predefine all user PROLOG. The setting of NM ETH is demonstrated in Fig-m-e 1 and in Section User routines. It is likely problems. This may be done DEFNS, or dynamically. in the PROLOG file define the set of test II in the paper [9].
"Morphology with a null-interfaceThe iml)hmentati(m of typed feature structures in our system makes use of the CLP facilities provided by this enhanced Prolog system. Feature structures are imlflemented by the attril)ute daughter is the concatenation of the phrase's SUBCATllst with tile list (in order of increLslngobliqueness) of SYNSEM values of the COml)hmlent daughters.""(Pollard & .gag in I)ress) 41)MC,AI CLP is au enhanced version of SICStus Prolog, awdlahle by anonymous ftp from f tp. ai.univie, ac. at 143 :fs (Type, Dag, Goals), where Dag is a list of featurevalue pairs (which is empty in case of atomic types) or a marker indicating uninstantiatedness of the substructure (feature structures are instantiated lazily). Second, the right hand part of the conditional is not restricted to feature logical expressions, but instead can contain arbitrary Prolog goals. In this way constraints involving relational dependencies (such as the Subcategorization Principle and the morl>hological relation between a lexical and a surface string) can be expressed within the feature fornmlism and there is no need for external devices controllhg this interaction."
Book Reviews: Logic for Applications by Anil Nerode and Richard A. Shore.This chapter also covers resolution refinement, in particular linear resolution which specializes to Horn clauses, thus forming a basis for logic programming in PROLOG. Predicate logic with its syntax and semantics is presented in Chapter II (102 pages). Basic concepts of Horn clauses and foundations of logic programming, explained in Chapter I, are elaborated for predicate logic in Chapter III (62 pages}. Although the main emphasis is on PROLOG, this chapter covers common topics in logic programming such as negation (as failure), equality, searching, and backtracking. The visually pleasing format of illustrations and PROLOG code segments save the textbook from the boring characteristics of some classical logic books.
The metric based compiler: a current requirementMarkusz and Kaposi ([16]) defined a metric for the complexity of PROLOG programs in the following way. A PROLOG program was divided in partitions. The global complexity was defined as unweighted sum of the local complexities, i.e. g = (1) i 31 and li was executed by (2) , where is the number of new data entities in the positive atom of the partition, i.e. in the problem to be solved by the partition, P2 is the number of negative atoms in the partition, i.e. the number of subproblems into which the problem divides, P3 is the measure of the complexity of the relations between negative atoms, the choosen value of this parameter was initially 0, adding 2 for each recursive call, P4 is the number of new data entities in the negative atoms, i.e. the number of local variables linking the subproblems. Markusz classified PROLOG programs in trivial (l < 3), simple (4 < l < 7), complex (8 < l < 17) and very complex (l > 18). For practical use a thorough validation of this metric is necessary with the use of several experiences in PROLOG programming. 2.3 Code metrics for functional programming languages Programs in a functional programming language are defined in a top down form of an algorithm in the naturally (recursively) mathematical way.
Graph-based retrieval of information in hypertext systemsA DCG converter transforms these DCG rules into Prolog [2] rules that are then executed by the parser. Figure 4: DCGRules converted into Prolog Rules The parser generates only parse trees that follow the patterns defined in the DCG grammar. Common words, such as of, to, and, . . . , are ignored. GKR is written in Prolog. Prolog was chosen because of its built-in inference engine and because conceptual graphs can easily be represented in predicate calculus.
Retargetable self-test program generation using constraint logic programmingTest program generation relies heavily on backtracking and the use of symbolic variables. Hence, logic programming languages such as Prolog provide a higher level of abstraction for implementing tools. Unfortunately, the execution mechanism of standard Prolog results in a lot of backtracking and long execution times. For example, it is possible to take advantage of the bidirectionality of clauses and simulate logic gates in both directions. In contrast to pure Prolog, no backtracking is required for forward simulation.
"Usenet NuggetsOnly one of these cycles is a delay slot and can be filled with a useful instruction. This will slow down our compiled Prolog programs by a factor of 1.5, as every third instruction is a branch instruction and most branches are taken• Rewriting it so that more of the branches are not-taken would help. It would be nice if the compiler could do that for you, perhaps it does if you use pixie. I suppose that one might be able to modify a Prolog compiler to generate code with fewer branches, but I'm not sure (I am not expert on compiling logic programming languages). Secondl.y, the number of times the pointer comparxson succeeds is high (Prolog programs are typically written so they ""proceed to the solution"" rather than get involved in lots of failure/backtracking)."
Online partial deduction of logic programsMixed Computation Programs. [35] pp.119-141. [6] of Prolog Y. Futamura. Partial Computation of Programs. E. To PE or not to PE. [38] pp.218-228. [15] A. Lakhotia, L. Sterling. ProMiX: a Prolog uation System. The Practice of Prolog, MIT [16] Partial Eval Press 1991. Bondorf. A Self-Applicable Partial Evaluator for Prolog. [39]. [21] 3.Owen. Issues in the Partial Evaluation of Meta [nterpreters.
Towards lazy evaluation, sharing, and non-determinism in resolution based functional logic languagesThe can at a pro existing approaches to the integration of functional and logic languages can, in general, be divided into two classes: clause logic programming equipped with equahty Horn [1] [8] and functional programming argumented with logic capabilities [4] [13] [10]. In the first class, languages have Prolog-like syntax, functions are introduced by equahty. As a result, most implementations class of languages can make good use of the extensive rience available from the sequential and parallel is based of this expe Prolog implementations, in particular, the Warren Abstract (WAM). Cm}. Like a Horn clause in Prolog, a clause LEAF is of the form: A :- Bl, B2, . .. .
Using a high level knowledge representation for expert systems knowledge acquisition and prototypingThe fmt one is based on a system for non-monotonic reasoning, the `ftteorist system [5] [6], which runs on the top of a Prolog system. The second ideaistote wtualcodefor a commercial shell (Nexpert Object). (d E H y V(d -W) E A) explain w where w is a well formed formula, explanations of 3w. prolog p gives all the where p is an atomic symbol, means any Theorist call top should be proven in Prolog. In Theoris& d@ulrs are the formulas which are takem as possible hypobsis, then the predicates of the form Cis HP and R + SHi are transbd to d@dts with names (to make the explanation easier to understand), since they are the predicates that model the system behavior, it means they represemt the possible causes of an event to happen When the pdicata which represent symptoms could be written in Prolog, and their evaluation becomes easier, they will be modeled through the prolog command and the -.
Abductive explanation of dialogue misunderstandingsPoole's Theorist implements a full first-order clausal theorem prover in Prolog. It extends Prolog with a true negation symbol and the contrapositive forms of each clause. The reasoning algorithm uses model elimination [Loveland, 1978, Stickel, 1989, Umrigar and Pitchumani, 1985] as its proof strategy. Like Prolog, it is a resolution-based procedure that chains backward from goals to subgoals, using rules of the form goal 4-- subgoall A... Reidel Publishing Company, Dordrecht, 1972. [Stickel, 1989] M. E. Stickel. A Prolog technology theorem prover. Journal of Automated Reasoning, 4:353-360, 1989.
"The maintenance of intermediate values in goal-directed evaluationApplying yields VI, V2, and V3 as the intermediate for liveness analysis of Prolog programs evaluation also creates implicit loops. One difference is that a Prolog clause is a linear sequence of calls that does not need to be ""linearized by construction intermediate values in Prolog Prolog variable has a lifetime a postfix tree. F., AND MELLISH, 1981. 1985. C. S. Programming in Prolog. Springer-Verlagj New York , 5 GRISWOLD , R. E. , AND GRISWOLD , M."
Multiparadigm research: a new direction of language designHowever, in the world of first order predicate calculus expressions represented by Prolog, the primary entities of the problem domain (matrices) cannot be based directly on the entities assumed to exist by the programming paradigm (relations). [Full 86] Fukunaga, Koichi and Shin-ichi Hirose. An Experience with a Prolog-basedObjectOriented Language. OOPSLA '86:Special Issue of SIGPLAN Notices, 21,11, November 1986, pp. 224-231. IEEE Software 3,1, January 1986, pp. 2. Sterling, L. and E. Shapiro. The Art of Prolog. MIT Press, 1986. Subrahmanyam, P. A. and J. You.
Bottom-up Earley deductionConsider the following simple definition of an HPSG, with the recursive definition of the predicate sign/I. 4 2This rule is called combine by Earley, and is also referred to as the flmdamental rule in the literature on chart parsing. aThc chart differs from the state of [10] in that clauses in the chart arc indexed (cf. section 2.2). 4We use feature terms in dcfinitc clauses in addition to Prolog terms, f:X denotes a feature structure where X is the value of h:ature f, and X Y denotes the conjunction sign(X) <- phrasal_sign(X). sign(X) <- lexical sign(X). phrasal sign(X dtrs:(head dtr:RD & comp_dtr:CD) ) <- sign(RD), sign(CD), principles(X,HD,CD). principles(X,HD,CD) <- constituent_order_principle(X,HD,CD), head_featureprinciple(X,RD), constituent order principle(phon:X_Ph, phon:HD_Ph, phon:CD_Ph) <- sequence_union(CD_Ph,HD_Ph,X_Ph). That depth-first search), x-corner goals (which combine bottomup and top-down processing like left-corner or head-corner algorithms), Prolog goals (which are directly executed by Prolog for efficiency or side-effects), and chart goals which create a new, independent chart for the proof of the goal. SThere are also other methods for mssigningpriorities to items. 4 Implementation The bottom-up Earley deduction algorithm described here has been implemented in Quintus Prolog as part of the GeLD system. GeLD (GeneraJized Linguistic Deduction) is an extension of Prolog which provides typed feature descriptions and preference values as additions to the expressivity of the language, and partial evaluation, topdown, head-driven, and bottom-up Barley deduction as processing strategies.
Conjugating polynomials on finite ringsComputational Approaches Initial computational investigations into explicitly computing the polynomials over Z. were done in Prolog, due in part, to its rapid prototyping capabilities. However, while successful in constructing a proof of concept program, it was very inefficient, due largely to the computational quirks of Prolog. As a result, only very small examples, i.e., Z 4 , could be effectively studied in a reasonable amount of time. For example we would look at a 3-dimensional space such that the shape or form of the space is 3 by 3 by 3. Similar to the Prolog and Lisp computational model, we viewed the constant and identity polynomials as n-mples, i.e., in Z3 we have 3-tuples.
"Handling controlEach subgoal decides whether the subgoals following it should be tried or not. subgoal g succeeds, its handier tries the conjunction If a of the remaining goals, g2, etc., but after noting that if these fail, g`s own backtrack point should be retried. g fails, its handler should signal overall failure, without trying g`s successors. 4.4 The cut The above implements ""pure"" Prolog. Often, either If for efficiency or a procedural style, we need to prune backtracking possibilities: Prolog's method is the the cut (""!""). I thank Matthias Felleisen and Bruce Duba for helpful discussions. 1 W.F. Clocksin and C.S. Mellish . Programming in Prolog . Springer-Verlag , 1981 . [2] 0. Danvy and A. Digital Press, second edition, 1990. [24] L. Sterling and E. Shapiro. The Art of Prolog. The MIT Press, 1986. [25] J.E. Stoy and C. Strachey. 0S6: An Operating System for a Small Computer."
Abstract interpretation of logic programs: an abstract domain for groundness, sharing, freeness and compoundness analysisStarting in the early 80's with the work of Mellish [Men 81] many researchers studied its application to logic programming and Prolog [JoS@n 87, Bruy 88, Debr 89, HerR 89, MaSon 89] and more recently to concurrent constraint logic languages [MaS@n 90, Codo 90, COFM 90]. These two properties have been heavily studied because they can support important optimizations in the code produced by a Prolog compiler. When the groundless property is verified, matching can be substituted to uni fication [Tayl 89, Men 81, Debr 89]. A property that is also useful for optimizing for Prolog programs is that of compoundness: the code a variable x of A is compound w.r.t.
Partitioning the statement per iteration space using non-singular matricesFigure 6 shows the skeleton of the target S1S and the expressions boundaries for each of the spaces considered. of the In generaJ, the code has three parts, namely prolog, core and epilog parts. The prolog and epilog parts tare defined as the part of the cover not included in the core that is executed before or after the core part, respectively. 31 ( j,, ucovelr)) ENDDO For instiance, the compiler can recognize that just one iteration is executed in the prolog and epilog parts due to the values of the atignment components. IFor the same reason, the compiler can recognize that statement S1 is never executed in the prolog part and statement S:2 is never executed in the epilog part. 5.
The role of natural language in a multimodal interfaceImplementation Remarks and Shoptalk is written in Quintus Prolog and C and runs on Sun Microsystems' workstations. Graphics in Prolog, using an SRI-proprietary declarative are done graphics package, PIView, that interfaces Prolog to SunView. Final] y, in addition to tbe complementarily principle guiding interface integration, we have also tried here to the following implementation integration ciples: q All components share the same knowledge to ad prin representation (here, in Prolog). For example, the objects and predicates manipulated by, for example, mantic interpreter to satisfy selectional the se restrictions on English verbs are drawn from the same knowledge representation used by the simulation and graphics components. q All actions by the user or simulator are recorded in the Prolog database.
Applications of inductive logic programmingFor the triazine drugs chemical structure is represented in the form: struc 3(d217, CI, absent). struc 4(d217, (CH2)4, substl4). subst(substl 4, S02F, C1). This is the Prolog representation of the drug 217 - 3-C1, 4-(CH2)C6H3-4'-CI, 3'-S02F. An example of a rule for the pyrimidine data as a Prolog clause is: great(A, B) :- struc (A, Pos_a3, Pos_a4, _), struc (B ..... h), h_donor (Pos_a3 ,h_donO), pi_accept or (Pos_a3,pi_accO), polar(Pos_a3,Pol_a3), greatO_polar(Pol_a3), size (Pos_a3, Siz_a3), less 3_size (Siz_a3), polar (Pos_a4,_). Fortunately it was possible to formalise the criteria for distinguishing useful rules from the others. These criteria were implemented as a short Prolog program (Dolak 1991) for postprocessing the rules generated by GOLEM.
Schema translation using structural transformationThe only practical di culty is that, unlike other models, the ER model has no standard DDL for expressing schemas. Our solution to this problem is to use a Prolog factbase (i.e., sequence of predicates) to represent ER schemas as lists of facts about entities and their relationships. The translation is implemented as a TXL program which takes a relational schema written in the SQL data de nition language 2] as input and produces the corresponding ER schema represented as a Prolog factbase as output. The general strategy of the transformation is The main transformation rule of this TXL program is shown in Figure 2. The two include statements begin the program with grammars describing the syntactic forms of the input SQL data de nition language and the output Prolog factbase. To allow the TXL program to transform from one to the other, the new syntactic type program combines these two grammars into one syntactic form de ned as a sequence of relation de nitions (that is, a relational schema) followed by a sequence of Prolog predicates (that is, a factbase representing the corresponding ER schema).
"15th July 1972: a significant moment for logic programmingIt was only then that Jacqueline Roussel pointed to the words on the banner: 'Save Rutland Wood: The Wildlife Society is Pro-Log'. At that moment, Prolog was born, and a picture in the Wednesday 19th July 1972 issue of the Rutland Gazette proves it [Rutland Gazette 1972]. 59 Boyer, R.S., and Moore, J.S. 1972. Cohen J. 1988. ""A view of the origins and development of Prolog"", Comm. of the ACM, Vol. 31, No. l, January, pp.26-36. ""Definition et traitment de l'egalit@ formelle en d4monstration automatique"", Thesis, Facult 4 des Sciences, Univ. d'Aix-Marseille, Luminy, France. Roussel, P. 1975. ""Prolog: Manuel de r4.fdrence et d'utilisation"", Groupe d'Intelligence Artificielle', Univ. d'Aix-Marseille, Luminy, France."
"Denotational abstract interpretation of logic programsThe major impetus analyses that can improve code generation gramming languages are based has gained considerable currency has been the quest for data-flow in Prolog compilers. Logic-pro on a principle of ""separation of logic and control,"" which is desirable from a semantical point of view, but which also causes severe problems for implementation. K., AND MISHRA, P, 1988. Denotatlonal and operational semantics for Prolog. J. Logzc Program. 5, 1 (Mar,), 61-91. DEBRAY, S. JONES, N. D., AND S@NDERGAARD,H. interpretation of Prolog. In Abstract C. Hankin, Eds. Ellis Horwood, 1987."
"Intellectual archeologyAnd failing to distinguish history from fundamentals is a way to teach our students to identify the subject with its losers. 5 Language du Jour Many current textbooks are based on some programming language, typically LISP or PROLOG. Such texts tend to move from a brief, vague introductory chapter titled something like, ""What Is AI?"" or ""The Nature of Intelligence,"" directly into a first course in LISP or PROLOG programming, and then develop the subjects in parallel, using more and more complex examples of programming in order to explain more advanced AI ideas and more sophisticated programming techniques. Many CS graduates who have taken one course in AI are convinced that AI and LISP (or PROLOG) programming are more or less synonymous, a misconception which leads them to classify any system which has been developed to modern commercial standards as not being AI simply because it is written in C++ and thoroughly debugged."
"Proving functionally difficult problems through model generationAbstraot Proving Functionally Difficult Problems through Model Generation Richard Rakin, Ralph Wilkerson Department of Computer Science University of Missouri-Rolls Rolls, MO 65401 Satchmo [MASS] ia a theorem prover implemented in Prolog which attempts to provide aatisfitillity checking through model generation. V ara re-written aa trus - Ll,L2,...,, whare `,' ia the disjunction operator in Prolog. Clausea consisting of entirely nagative Iiterala. [MAS8] Manthey, R. and F. Bry, ""SATCHMO: a Theorem Prover Implemented in Prolog"", ecture notae in ComDuter Science Vol. 310, E."
Fast phylogenetic analysis on a massively parallel machineOne of them we developed was baaed on the A* nlgorithm [17] and extended to parallel execution by using an OR-parallel Prolog with a priority control mechanism on :Sequent Symmetry [18, 19]. This work was supported in part by the Japan Ministry of Education, Science and Culture under Grant in Aid for Scientific Research 04235103 and 05254209. Control System for OR-Parallel Prolog and Its Performance Evaluation, Parallel Symbolic Computing: Languages, Systems, and Applications, Lecture Notes in Computer Science, ed. Vol. 748, 19 Matsuda, H. and Kaneda, Y. 1994. An Application an OR-Parallel Prolog System to Phylogenetic of Analy sis, Lisp and Symbolic Computation, Kluwer Publishers (in press).
Trace & Unification GrammarThe first compilation step that is common to generation and parsing transforms the attribute-value-pair structure to (PROLOG) term structure. This transformation makes use of the type definitions. For usage in that parser the result of the transformation to PROLOG further undergoes several transformations (expansion of head nlovement rules, transformation of argument movement rules, elimination of empty productions, conversion to LR. -tI. Chen, l.-P. Lin, and C.-P. Wu. A new design of prolog-based bottom-up parsing system with government-binding theory.
Integrated interfaces for decision-support with simulation*teherz eutlAwl la-i Figure 1: Factory floor window to examine alternative factory scenarios by running an event-based discrete event simulator. ulator is programmed in Prolog, and thus a theorem-prover for determining the truth plex conditions over a database of facts. In response to such queries or to graphically invoked actions, data would be retrieved from a Prolog database created by a simulation. For actual operations, such data can be obtained from the main factory computer(s). Fortunate y, it is a simple matter to translate Prolog into various query lan guages, such as the industry-standard SQL IIanguage, to retrieve data from relational databases.
Separating world and regulation knowledge: where is the logicFor instance, in TRACS the regulat ions are represented as Prolog clauses, but not used as such. It will be hard to prove anything from this apparently incoherent list of facts. Each situation could then be viewed as a Prolog query. However, to be able to do this we had to import kinds of stuctures that were world knowledge, i.e. all we were reinventing an JXD. By stripping the clauses to what was stated in the regulations, their status rather a data structure format than theorems. over, we did not need the `negation-by-failure' is now More mechanism of Prolog, because it is easy to handle negation a highly typed and structured world.
"An undergraduate research program in multi-paradigm software designThird, the students were introduced to the logic-oriented paradigm and the programming language of PROLOG. Finally, toward the end of the week, individual interviews were scheduled so that the faculty could divide the students into two research OUPS -- one logic-orientecl and the other object-oriented. To keep the students experiencing either the Smalltalk or the PROLOG programming language, each group was given a programming problem. Tran's was ""Designing with Fuzziness"", and Ms.Wiltz's was ""Graphical Representations of PROLOG Programs"". The faculty felt strongly that the students should go beyond what was required and encouraged them to submit their work to professional journals, to write grant proposals, and to present at conferences."
CRL/Brandeis: the Diderot system<\organ> ,J {type ( [ [entity_type, 'COMPANY' ]] )} <\endorgan> <\time> {type ( [[date_adverb, alter], [dat e, '850 I' ] ] )} <\endtime> <\organ> P k {type ( [ lent ity_type, 'COMPANY' ]] )} <\endorgan> <\gZs> b' {type( ['T ',v] )} <\endgls> Just as for the English system this is then converted into the form of Prolog facts ready to be read into the merging phase. This attaches the Penn Treebank parts of speech to the text. The output is converted to Prolog facts. The Japanese text is segmented with part-of-speech information by the JUMAN program, which was developed by Kyoto University. Segmentation programs POST (BBN) : 24 Megabytes JUMAN (KYOTO/MCC version) : 8 Megabytes 3. Programming languages Quintus Prolog : Release 3.1.1, Megabytes of disk space. C requires 64 CMU Common Lisp : 16 Megabytes of memory and 25 Megabytes of disk space are recommended. 4.
The introductory undergraduate AI course as observed on WWW., Logic (aN) search [Lisp] [Lisp] Millersville Search Prolog (Various) Purdue Lisp Search (w) [Lisp] Rensselaer Lisp Search (RK) [Lisp] SW Missouri Search ATP (RK) [Prolog] [Lisp] UC Berkeley Lisp Agents, (RN) Search [Lisp] UC Irvine Lisp state space, (RK) search[Lisp] U Wales AI Search (RK) Processes [Lisp or C] U Washington Lisp Predicate (DAA) Calculus U Wisconsin 94 Lisp Pred Calc, (LS) Know Rep U Wisconsin 95 Lisp Logic, (DAA) ATP A3 I A4 I A5 A6 Search, Theorem Planning Pred. logic Proving [Lisp] Domain Design Learning for [UCPOP] [Lisp] Lisp with Theorem Garnet Proving [Lisp] Research Project Backward Demp-Shafer Frame Agent Chain. Nearly all the courses either teach LISP, or expect students to learn it on their own. LISP is almost universally preferred to Prolog, C or C++ as the programming language for assignments.
A CLP(R) system for solving partial differential equationsThis means that arithmetic constraints are interpreted declaratively in the same marmer as any Prolog predicate. Solvability of arithmetic constraints is included in the concept of unification. As a result, the CLP(R) intmpreter incurs overhead proportional to the constraints being solved, and should be nemly as efficiemt as Prolog in handling logic programs without constnints [8]. Parmd Dffeaatl York 1982, John Wiley & Sons, Inc. . . , New 10. Leon Sterling and Eimd Shapiro, The Art of Prolog Cambridge, M& 1986, The MIT Press, pp. 256-265. 11.
The future of programming languagesIf you are studying AI, you will learn LISP unless you are in Japan and must study PROLOG. Almost everyone must learn COBOL unless you are working on micros, in which case you will learn FOXBASE or dBASEx or some such. C does that very well, although it is expense of features at the often considered essential like typechecking and clarity expression. ACM 30th Annual Southeast Conference of If PROLOG succeeds, it will be because Japan wants to dominate technology, and has dictated its language of choice. With that and current trends in mind, it looks i ike PLI, MODULA-2, PROLOG, APL, ALGOL, FORTH, AND RPG will be SNOBOL, goners by the year 2000, with FORTRAN on their heels.
A general framework for semantics-based bottom-up abstract interpretation of logic programsOur present interest is to define a program analysis technique that captures computation rule and the search to enhance a given (Prolog) some Prolog peculiarities, as the left-to-right strategy based on backtracking. New Gener, Berhn, 1991, pp. 1-19. Specialization of Prolog and FCP programs Compat, 6, 2-3 (1988), 159-186. 28. MELLISH, C. Abstract interpretation of Amsterdam, 1989. a Prolog Compiler. J. Logic Prog. 2, (1985), Prolog programs.
The concept assignment problem in program understandingLet us say our user forms a query using DESIRE's Prolog-based facility to look for the functions that use these global variables. Therefore, our user brings up the cluster analysis tool and chooses to run analysis on mdebug. A Prolog program a cluster from the library runs and attempts to form a cohesive cluster with mdebug the dominant function. There is much intelligence required in the chunking process. q Internally, information exchange between the various tools (e.g., Germ, Prolog, and the Slicer) and their associated views is sometimes more clumsy than we would like.
Equate: an object-oriented constraint solverConstraints are recursively decomposed using definite-clause backward chaining, the search technique used in logic programming languages [Llo87] of which Prolog is the best-known example. 4.1 Rewrite Rules The search for solutions is guided by rewrite rules provided by object classes. PRESS [BW81] is an equation solver implemented in Prolog that controls its algebraic manipulations with metalevel inference rules. Communications of the ACM, 33(7):52-68, July 1990. A. Colmerauer. An introduction to Prolog III. Communications of the ACM, 33(7):69-90, July 1990.
An integrated model for anaphora resolution(verb) phrase wiaich is not the center P(AIHy) would be the apriori probability (PN). of the symptom A being observed with a noun (verb) phrase which is the center Following our preliminary results, wc can (we will henceforth refer to this factor as write in Prolog notation: Py). By analogy P(AIHN) is the probability of the symptom being center (object, 25, [sylnptoln (verb_set, observed with a phrase which is not the 40, 3), symptom (subject set, 40,2), center (henceforth referred to as PN). If this NP is also the head of not the object. the section, the probability is increased further. If the NP occurs more than once The above Prolog facts are part of a in the discourse segment, the probability sublanguage knowledge base. gets even higher. Initially, our program works with manual inputs. The local knowledge base can be represented as Prolog facts in the following way: observcd(lmadlinc). observed(domailLconccl)O. obsmvcd(repeated).
Improving abstract interpretations by combining domainsSection 4 provides an approach. The combined analyses have been imple &-Prolog compiler [Bueno et al. 1994, Hermenegildo and Hermenegildo 1991, 1992] by reusing compo analyses. A semantic-based framework for the abstract in terpretation of Prolog. In Abstract and C. Hankin, Eds. Ellis Horwood, LE CHARLIER, B. AND VAN HENTRNRYCK, interpretation algorithm for prolog. MUTHUKUMAR, K. AND HERMENEGILDO, dency using abstract interpretation.
"Review fo ""The logical approach to syntax: foundations, specifications, and implementations of theories of government and binding"" by Edward P. Stabler. The MIT Press 1992.Three appendices containing formal derivations, listings of the first-order formalization of Barriers, and Prolog code of the formalization complete the book. 151 Computational Linguistics 3. Although the breadth of coverage is extensive, touching on several different disciplines, the book is not a linguistics, mathematical logic, or Prolog text. The background required to appreciate and use Stabler's research limits the readership to those who are familiar with logical systems, proof methods, and the principles of GB theory. Robert J. Kuhns has developed GB-based parsers in Prolog and Parlog and is interested in embedding GB kernels within text processing applications."
Formalization of information hiding design methodsEncoding the design rules in a machine processable form . We use Prolog. Only in the last of these stages do we require a completely formal representation of the design theory, that is, one with a well-defined syntax and semantics . To validate our theory, we had to • Specialize our design theory for Turin g Plus . • Create a database representing the TX L design . • Encode the specialized theory in Prolog . 4.1 Turing Specializatio n Turing [6] is a modular imperative language designed at the University of Toronto . Thus, for example , we cannot extract secrets for each module i n this way. 4.3 Prolog Encodin g Encoding the theory in Prolog used the sam e methods as earlier design theories [10], so we do not discuss details here .
Synthesis of instruction sets for pipelined microprocessorsWe have implemented the algorithm and its supporting tools into our design system ASIA (Automatic Synthesis of Instruction-set Architectures). It consists of about 5000 lines of Prolog code. In the following section we examine how the tools perform. 6. In the two right most columns we also list the run time and memory usage of our algorithm, which show that our tools were able to synthesize instructions for application benchmarks within reasonable time and consume a modest amount of memory In Table 6 we compared the synthesized 32-bit instruction sets with the BAM instruction set [13], which was designed for efficient execution of Prolog programs. The programs were compiled with the Aquarius Prolog Compiler, with the post-phase optimization phase turned off2. This experiment shows that ASIA is capable of 2. The post-phase optimization of the Aquarius Prolog Compiler alters the classic definition of the basic block.
"Review of ""Semantic processing for finite domains"" by Martha Stone Palmer. Cambridge University Press 1990.Much of the implementation is captured in the lexical entries for the verbs, which are defined as Prolog Horn clauses. Given a syntactic analysis, the verb's definition 243 Computational Linguistics Volume 17, Number 2 is then ""proven,"" which sometimes requires pragmatic information to provide missing information. The semantics are formal, but not maddeningly so. All 244 Book Reviews examples are given in Prolog notation, and this is convenient for the Prologqiterate. The entire system, as rendered in the appendices, appears to be about 100 statements of Prolog. This alone is enough to make a book tempting."
"Building visual language parsersStat echarts use topological relationships to capture states and their substates, network relationships to repre sent the transitions between states, and geometric proximity to attach labels to arcs. Visual Prolog Kahn and Saraswat [11] introduced ""visual Janus"" which is a visual syntax for Janus, a concurrent logic programming language. An almost identical visual language may be used to represent pure Prolog. For example, the diagram below represents the associ ated append program. o append( nil, X, X) . append( U.X, Y, U.Z) :- append( x, Y, z). Visual Prolog uses topological relationships, such as ""inside"" and ""touching"", and network relation ships to connect variables and to represent procedure calls, Our parser will parse this Visual Prolog diagram and produce the append program abovel, 1caveat: of course the predicate names synthesized by the parser may not be meaningful as this information is not avail able in the diagram. basic features AND paper supply XOR Figure 2: Statechart 3 Constrained Set Grammars The key issue of visual language parsing is how to extract the meaning of a diagram."
"HYKIS—an information retrieval system based on a Hybrid Knowledge baseBut in HYKIS, if the expert puts this tic in the clause ""def-depth(information retrieval, him this heuris l)"" in the Dbase, the documents related to""data or""chemical structure search"" are not found, the query evaluation limits the search of retrieval"" because ""information retrieval"" by the depth one, 4 Analysis of HYKIS HYKIS has been implemented in Sicstus Prolog, because the query evaluation resembles the resolution in Prolog. mainly SLD Ibase and Dbases are made into databases sist of Prolog clauses and are loaded into when a seeker wants them. Conceptually, that con the system Ibase forms a DAG (Directed Acyclic Graph), while each node and edge are represented as Prolog facts in the database. We conducted an experiment with the CACM data set that is able to measure the performance of HYKIS. It, first, retrieves all related documents and takes highest ranked ones by Rada's algorithm. We implemented HYKIS in Sixtus Prolog and demon strated that it worked well as we predicted."
The ASTOOT approach to testing object-oriented programsProtest, which is a program written in Prolog, executes test cases by calling the operations in the implementation plied by the user. Gaudel's group has also built the theory of testing contexts. dialect of Prolog, and, based a tool for testing data abstractions based on The tool inputs a specification written in a on some definition of the complexity of se quences, uses a Prolog interpreter given complexities, sometimes proach might provide a useful quences for our simplifier. JALOTE, P. 1989. Testing the 1991. Automated module testing in Prolog. IEEE Trans. completeness of specifications. IEEE Trans.
"Towards a legal analogical reasoning system: knowledge representation and reasoning methodsFor instance, LES [7] performs deductive reasoning der a set of legal rules encoded as Horn clauses. system is therefore implemented in resolution-based un The de ductive engine, especially in Prolog. On the other hand, generalization has been studied in the field of machine learning, and various computational operators for generaUzation have been proposed by many researchers. The predicate good-faith is defined as follows: good-f aith"" ([agt : Agt, obj : Content) + not(kmow([agt : Agt, obj : Comtent]) where not is the standard Prolog's not cate, and the predicate know is defined know(Agt, Content) succeeds iff the relation Content is proved under the set of facts Agt We use an auxiliary predicate know-fact, knowJact(Agt, Id) means that Agt knows of the in spite predi so that instance knows. where a relation indexed by an identifier Id. Hence we first make the following goal to be explained: cannot_set.up([agt : pa, goa : p=, obj : id 7]) (1) where id 7 is the identifier of the registration of passage of title of C. Since our system is basically an extension of Prolog interpreter with some additional reasoning functions, it tries to resolve the goal with some rules as well as facts."
Book review: Exploration and Innovation in Design: Towards a Computational Model By D. Navinchandra (Springer Verlag, 1991)Parallel Logic PogmmmbTgby Evan Tick provides a series of benchmarks gathered from the project. The book is unique because it applies parallel Prolog techniques tO many classic logic programming problems. Without sacrificing the declarative nature of Prolog and modularity and clean semantics of the language, the text stresses performance and real world concerns of space/time trade-offs. An early chapter reveals the first important lesson, it uses the classic Prolog example Reverse to show that some serial algo
Making DATR work for speech: lexicon compilation in SUNDIALThe resulting entries are encoded in two ways: for the full lexicon via Prolog term encoding and for the acceptance lexicon via bit coding (Section 5). 3. Implementation and Coverage DIALEX is implemented in Quintus Prolog, benchmark tests indicate that compilation time is linear in the size of the lexicon. Gazdar, Gerald, and Mellish, Chris. (1989). Natural Language Processing in Prolog. Addison Wesley. Hudson, Richard A. (1990). English Word Grammar.
Denotational semantics of a goal-directed languagePredicate logic does not specify the order allow for the programmer in which clauses will be unified and does not to impose an order. But the implementation of Prolog uses a resolution algorithm that evaluates clauses in a goaldirected manner [161, and this language. Goal-directed programming, alternatives will be tried, underlying strategy has influenced the Prolog on the other hand, specifies the order in which and this allows for a rich set of control structures to alter the evaluation order. Prolog's cut instruction is a very simple example of a control structure for goal-directed The functional paradigm evaluation. is characterized simply by the fact that expres sions produce results.
Generating contextually appropriate intonationFor 1°The alert reader will note that the notation for constants, variables, and functional application is slightly changed in these sections, to correspond to the Prolog implementation. 11This is a simplification, but a harmless one for the simplified query domains that we are dealing with here. a wh-question, the semantic representation corresponds to a lambda expression in one or more variables ranging over individuals in the database, and has the structure of a Prolog query which we can evaluate to determine the possible instantiations of the open proposition. First, it does not rely on a specific semantic representation, and requires only that the semantics be compositional and representable in Prolog. Thus the generating procedure is independent of the particular grammar. This modular character of the system has been very useful in developing the competence grammar proposed in the preceding section, and offers a basis for proving the completeness of the implementation with respect to the competence theory. The tactical generation program is written in Prolog, and works as follows. Starting with a syntactic constituent (initially s) and a semantic formula, we utilize the CCG reduction rules to determine possible subconstituents that can combine to yield the original constituent, invoking the generator recursively to generate the proposed subconstituents.
"Deriving database queries from logical forms by abductive definition expansionThe structure of the top loop in the definition-expansion process is 6 roughly that of a Prolog meta-interpreter, whose clauses correspond to the ""expansion-schemas"" described in section 2. For the project resource management domain, which currently has 165 equivalence rules, the time taken for query derivation from LF is typically between 1 and 10 seconds under Quintus Prolog on a Sun Sparcstation 2. 9 A Full Example In this section, we will present a more elaborate illustration of CLARE's current capabilities in this area, showing how the process of definition expansion works for the sentence (S1). McCord, M.C. 1987. ""Natural Language Processing in Prolog"". In A. Walker (ed.) Knowledge Systems and Prolog."
Algorithms, Problem Solving, and Data Structures with C++While the chapters on the compilation of functional, logic and object-oriented programming languages each contain a long introduction to the concepts of these language classes, it is advisable to learn a modern functional language, Prolog and Smalltalk, Eiffel or C++, for a better understanding of the corresponding chapters. In addition, the reader will profit from a good grounding in the theory of formal languages and automata, although the theory needed is always presented in full, 48 1 4 5 6 7 Table of Contents (Abridged) Introduction 1 1.1 High-level programming languages 2 / 1.2 The implementation of programming languages 3 Compilation of imperative programming languages 7 2.1 Language constructs and their compilation 8 / 2.2 The architecture of the P machine 9 / 2.3 Assignments and expressions 10 / 2.4 Conditional and iterative statements, sequences of statements 13 / 2.5 Memory allocation for variables of simple type 18 / 2.6 Memory allocation for arrays 19 / 2.7 Memory allocation ibr records 27 / 2.8 Pointers and dynamic memory allocation 28 / 2.9 Procedures 32 / 2.10 Main program 56 / 2.11 Exercises 57 / 2.Literature61 Compilation of functional programming languages 63 3.1 Language type and introductory example 64 / 3.2 LaMa, a simple functional programming language 72 / 3.3 Introduction to the compilation of LaMa 77 / 3.4 Environments and bindings 81 / 3.5 The MaMa architecture 83 / 3.6 Stack management and addressing 87 / 3.7 Instruction set and compilation 90 / 3.8 Implementation of lists 104 / 3.9 Exercises 109 / 3.Literature111 Compilation of logic programming languages 113 4.1 Logic programming languages 114 / 4.2 Logical foundations 118 / 4.3 Unification 120 / 4.4 Execution of logic programs 124 / 4.5 Prolog 132 / 4.6 Abstract Prolog machine 138 / 4.7 Compilation of Prolog 142 / 4.8 Efficiency improvements 161 / 4.9 Exercises 167 / 4.Literature169 Compilation of object-oriented languages 171 5.1 Concepts of object-oriented languages 172 / 5.2 The compilation of methods 180 / 5.3 Schemes for compilation of inheritance 182 / 5.4 Genericity 207 / 5.5 Exercises 214 / 5.6 The structure of compilers 221 6.1 Compiler subtasks 222 / 6.2 Lexical analysis 223 / 6.3 Scanning 225 / 6.4 Syntax analysis 225 / 6.5 Semantic analysis 226 / 6.6 Machine-independent optimization 228 / 6.7 Address assignment 229 / 6.8 Generation of the target program 230 / 6.9 Machine-dependent code improvement 231 / 6.10 Real compiler structures 231 / 6.11 Formal specification and generation of compiler modules 232 / 6.Literature233 Lexical analysis 235 7.1 The task of lexica] aualysis 236 / 7.2 Theoretical foundations 236 / 7.3 A language for specifying the lexical aalysis 248 / 7.4 The generation of a scanner 251 / 7.5 The screener 256 / 7.6 Flex, a scanner generator under UNIX 259 / 7.7 Exercises 261 / 7.Literature 263 49 8 Syntax analysis 265 8.1 The task of syntax analysis 266 / 8.2 Theoretical foundations 269 / 8.3 Top-down syntax analysis 300 / 8.4 Bottom-up syntax analysis 339 / 8.5 Bison, an LALR(1) parser generator 375 / 8.6 Exercises 377 / 8.Literature382 9 Semantic analysis 355 9.1 Task of the semantic analysis 386 / 9.2 Attribute grammars 405 / 9.3 Fxamples of attribute grammars 410 / 9.4 The generation of attribute evaluators 417 / 9.5 Exercises 453 / 9.Literature456 10 Abstract interpretation 457 10.1 Introduction 458 / 10.2 Abstract interpretation based on denotational semantics 462 / 10.3 Abstract interpretation based on operational semantics 484 / 10.4 Exercises 506 / 10.Literature510 11 Trees: pattern matching and parsing 513 11.1 Program transformations 514 / 11.2 Code selection 519 / 11.3 The pattern-matching problem 523 / 11.4 The tree-parsing problem 526 / 11.5 Finite tree automata 529 / 11.6 Generation of pattern matchers 531 / 11.7 Generation of tree parsers 535 / 11.8 Tree automata with costs 537 / 11.9 Implementation 542 / 11.10 Exercises 544 / 11.Literature 545 12 Code generation 547 12.1 Abstract and real machines 548 / 12.2 Classification of architectures 554 / 12.3 Program representations 558 / 12.4 Code generation, integrated methods 561 / 12.5 Register allocation by graph colouring 568 / 12.6 Instruction scheduling 570 / 12.7 Exercises 588 / 12.Literature590 50
Using a computer conferencing system to support writing and research skill developmentThe experiments were required to be conducted o n the METAGAME system, a Prolog-based testbe d for analyzing and evaluating computer game - playing algorithms [PE93] . In addition, user-defined players can be added in Prolog, and the syste m can generate novel games for analysis . He justified the usefulness of thi s code by pointing out that present and futur e members of the course did not necessarily hav e sufficient mastery of Prolog, METAGAME' s implementation language, to create their ow n game players .
Process and measurement support in SEEsThis system explores the possibility of using the blackboard metaphor (problem-solving model) for enacting processes. Processes are specified using extended, shared prolog (ESP) and are each represented in the system as agents. Classification facets for the Oikos system are user scale: individual, process scale: code, guidance type: rule-based, process support: variable, measurement support: none, execution paradigm: Prolog rules. MELMAC. Deiters and Gruhn describe the MELMAC system in [DG90, DG92]. Process aspects such as roles, binding of users to roles, object definitions, and user responsibilities are expressed using Prolog-style rules. An inference engine uses forward and backward-chaining techniques to execute the rules and guide multiple users in their work.
Unification using a distributed representationRepresentatives of the classical symbolic AI paradigm (as exemplified by rulebased systems written in Prolog or Lisp which perform operations on symbols which are not distributed) such as [1] and [2] argue that systems using a distributed representation do not have the compositionality required to perform structure-sensitive logical tasks, and that these tasks can only be performed by composing symbols into complex symbol structures, and decomposing these structures into simpler structures. Some connectionist researchers [3] have begun to generate evidence that this may not be true, and to provide further evidence to counter this claim we have investigated performing complex reasoning tasks using a distributed representation by using a neural network to perform unification. 2 Unification Unification is a complex pattern-matching process which is an essential part of the resolution-based proof procedure used by AI languages such as Prolog. Abstractly, the Unification Problem is this: Given two descriptions of an object x and an object y can we find an object z that fits both descriptions? For example, consider the two terms f(X,Y) and f(g(Y,a),h(a)), they are said to 5 be unifiable since binding the variables X to g(h(a),a) and Y to h(a) will make both terms look like f(g(h(a),a),h(a)). Logic programming languages such as Prolog perform unification by using an algorithm called the Unification Algorithm [4], which operates on discrete symbol structures.
"The Pan language-based editing systemTypol [19, 34], the semantic based on natural semantics. inference rules. The general description into PROLOG proved into a PROLOG goal, description language used in Centaur [10], is A Typol description is a collection of axioms and evaluation strategy is to compile the rules of the rules and the resulting single equation to be Natural semantics and Typol nism for many kinds of contextual implementation, however, was alone provide an elegant descriptive mecha constraints. The original PROLOG-based inefficient since it was not incremental. In particular, in an LCG differs from their use in PROLOG. LCG for a language that requires that each is used, Names are defined by either declarations or importation, names are used in generic ""uses"" and in procedure calls."
"Heuristics for broad-coverage natural language parsing""Using Slots and Modifiers in Logic Grammars for Natural Language,"" Artificial Intelligence, vol. 18, 1982, pp. 327-367. 12. McCord, M. C. ""Natural Language Processing in Prolog,"" in Walker, A. (Ed.), McCord, M., Sowa, J. F., and Wilson, W. G., Knowledge Systemsand Prolog: A Logical Approach to Expert Systems and Natural Language Processing, Addison-Wesley, Reading, Mass., 1987. 13. Watson Research Center, Yorktown Heights, NY. 14. McCord, M. C. ""Design of LMT: A Prolog-based Machine Translation System,"" ComputationalLinguistics, 15, 1989, pp. 33-52. 15."
"Semantic query processing in object-oriented databases using deductive approachIn a deductive database, there is one advantage: facts, deduction rules and queries can be written in a uniform database language typically based on a first-order logic. A rule has the form(Prolog-like notation[4, 15]) a : -61, bz, bm m O where a is an atomic formula and bi's are Iiterals. Jarke et al. [10] describe a graph-theoretic ap proach to semantic query simplication implemented in Prolog. Similarly, Shenoy and Ozsoyoglu[l 7] suggest a graph-theoretic approach to achieve semantic query optimization by identifying redundant conditions and eliminating them from the query graph. S. , ,"" Semantic Query Optimization in Expert Systems and Database Systems "", Proceedings of Ist International Workshop on Ezpert Database Systems , 1988 4 Cloksin, W .F. and MeHish, C. S., Programming Prolog, Springer-Verlag, New York, 1984 5 Freytag, J. etal, Quey Processing For Advanced in Database Systems, Morgan Kaufmann Publishers, 1994 on Han, J, ""Constraint-based remomng in deductive databases"", Proceedings of 7'th Data Eng:neerrng Conference, 1991 10 Jark , M. ,"" External Semantic Query Simplification: A Graph- Theoretic Approach and Its Implementation in Prolog "", Proceedings of Ist International Workshop on Ezpert Database Systems , 1986 11 Kim, Won, Introducizon to Obect-Oraented Databases, MIT Press, 1990 12 King, J., Semantic Query Optimization, Ph.D."
Visual web surfing with Hy+Figure 4: HTML documents viewed as blobs 4 Hy+ queries The information that is communicated by Mosaic to Hy+ has the form of prolog facts. Every time a document is fetched, its URL, title, and all contained anchors are communicated to Hy+. Note that, although tr was introduced as having four arguments (two URLs, one label and one incremental number), when tr is displayed as an edge (in the query as well as in all visualizations), it has only two arguments (the label and the number). This is the convention in Hy+: when the Prolog fact p(X 1 , X 2 , X 3 , X 4 ) is visualized as a graph edge, the edge goes from a node labeled X 1 to a node labeled X 2 and it is labeled p(X 3 , X 4 ). Also note that, the ntr edge in this query does not specify any arguments in it, but rather uses an underscore, which in Prolog-like languages is used to denote an anonymous variable.
Hierarchies of programming concepts: abstraction, generality, and beyondLogic programming . at least (Olen judged by the practically most popular, albeit not the purest logic prograllllning language Prolog, is surprisingly weak in language constructs for abstracting and generalizing . O f course . we still keep in wind that solely by being a declarative language . Prolog offers considerably highe r level of abstraction . Nu inheritance to support generalizing is provided . On the other hand . Prolog strongl y supports nietaprogrannimiug . which is becoming an in - herein part of this programming paradigm .
MOSAICO—a system for conceptual modeling and rapid prototyping of object-oriented database applicationThe language is characterized by all the main features of Object-Oriented technology (such as typing, inherit ante, object identity, message passing), but avoids all the technical details required by existing development languages. 2 Implementation Issues A first prototype of Mosaico has been developed on a SUN workstation, using BIM-Prolog. Current version generates prototypes in the form of Prolog code.
Paramax Systems Corporation: MUC-4 test results and analysisThe Paramax MUC-3 system was implemented using a forward-chaining engine called Pfc, whic h is written in Prolog . Although the Pfc rule formalism has a number of interesting properties, includin g in particular a mechanism for easily escaping to Prolog in order to use Prolog's built-in factbase and t o reason in a backward-chaining fashion, the system as a whole was inefficient .
Fixpoint computation for polyvariant static analyses of higher-order applicative programsThe second, cps-A, is a continuation-passing-style third is a Prolog interpreter (Prolog) is an interpreter for a subset of Algol remaining four programs pattern version of that same interpreter. Le Charlier et al. [1991] describe Both of these strategies an algorithm for analyzing Prolog programs. reanalyze equations by need as does ours. AND IWOO, S. C. 1991. Semantics-directed generation of a Prolog compder. In F'LILP'91, 3rd International Symposium LOgLCProgrammmg.
"Preliminary Ideas of a Conceptual Programming LanguageWhy can't the user write the program using these concepts directly? Even in logic programming language like Prolog, there still is the same problem. The statement ""man is an animal"" is represented as animal(X):-man(X). Man is an animal. 2). John is a man. Their representations in Prolog are: 3). animal(X) :-man(X). 4). man(John). Both statements can be represented in CONPL as isa(man, animal). isa(John, man). Syntax The top syntax of CONPL is quite similar to that of Prolog. < program> ::= < assertion-list> < query> < assertion-list> ::= I< assertion> . < assertion-list> < assertion> ::= < relation-name> (< term-list> ) < term-list> ::= e I< term> , < term-list> < query> ::= < judge-query> k attr-query> < judge-query> ::= ??"
Book review: Knowledge Representation: An Approach to Artificial Intelligence By T.J.M. Bench-Capon (Academic Press, London, 1990)I found the exposition refreshingly clear, except for the sections dealing with the difficult topics of resolution, unification, and skolemization, which were too abrupt for ready comprehension. Chapter 8 is devoted to PROLOG,which is discussed not only as a concrete example of logic programming, but as an illustration of the compromises necessary in a practical language. PROLOG's extra-logical features in the areas of input-output, database update, and program control recceive particular attention.
"Active rules in deductive databasesIn the prototype situation monitor, the action predicates represent database pro cedures and are implemented using Prolog. 6 Optimization In this section, optimizations are described that improve the efficiency of the event detector. Informally, a sip implements the deci sion as to how bindings will be utilized during each step of query evaluation. In our prototype, which is imple mented in Prolog, the different sip's are implemented by reordering the subgoals appearing in the Prolog queries. Lakhotia, A. and Sterling, L., Munich, ""ProMiX: a Prolog Partial Evaluation System"", The Practice of Prolog, Sterling, In L."
Automatic deduction of temporal informationTO enhance readability, rules is able to find out the admissibility interval for are given in the format: conclusions premises where premises and conclusions translation into Prolog rules are written in a Prolog-like syntax. The is thus immediate. A set of about time points belonging to related holds in case TP1 belongs to an interval belonging to T12:2 tp-belongs-to ( TP1, T12 ) = span (T12, TP3, + M), span T11 + T12, TP1 + TP2, tp-belon.gs-to (TP1, TI1), (T11, TP2, + K), (R4) tp-belongs-to (TP2, T12 ) z The equality operator = is defined as in Prolog. In (R4 ), the arguments of the T11, T12 = TIset. ' tp-belongs-to predicate are TP1, TP.2 e TPset, TPS Example. Allen shows that the time by Allen [1] and by Barbie and Maiocchi complexity of the best algorithms solving the problem is exponential in the number chi [7] introduce a set of heuristics polynomial time. TSOS has been implemented in both Prolog is the possibility of directly of assertions, while Barbie and Maioc able to find suboptimal solutions in Prolog and C [31].
Sniff (abstract): a pragmatic approach to a C++ programming environmentThe example used during the demonstration is a tiny Prolog interpreter. We show how we derive the needed Prolog terms by extending a predefined class of first order terms. Then the Prolog machinery is sketched. The state of this machinery is represented by a new kind of terms. This allows us to use a structural and graphical term-editor that monitors the Prolog execution elegantly. Lapidary: An Interactive Design Tool Brad Vander Zanden University of Tennessee Lapidary is an interactive design tool that allows designers to specify all graphical aspects of an application, including both the objects that control an application, such as menus, scroll bars, and buttons, as well as the application-specific graphics themselves, such as boxes and arrows, game boards and pieces, and pictorial images of data structures.
"Attribute grammar paradigms—a high-level methodology in language implementationDCGS are a logic counterpart text-free grammars such that to con nonterminals can be augmented with arguments, and productions can be augmented arbitrary code in Prolog. When with considering the arguments as ""attribute and the embedded Prolog ""semantic rules,"" DCGS match with attribute grammars. DCGS ful because they are provided Prolog implementations. These include as a requisite a DCG values"" code as closely are usein many systems preprocessor that translates the grammar part of the program into ordinary Prolog. generated program acts as a The parserdriven processor for the language fied in the DCG and can be executed by the Prolog system. speci directly Note that the underlying linear execution Prolog makes DCGS operationally to L-attributed grammars (see 1.3). Rapid of programming language semantics prototyping using Prolog. In proceedings of IEEE COMPSAC (Orlando, F1.)."
Management information systems curricula in the United States and the Republic of China: a comparative studyOther languages offered are C Programming (87.5%), BASIC (75%), Prolog (50%), and Assembler (37.5%). Clearly, the Chinese have a more technically program than the U.S. schools. Language Percentage Percentage COBOL 9?.3% 100,0% Pmcal 61.5% c 38.5% BASIC 25.070 Prolog 3.0% Assembler 30.8% FORTRAN 23.070 PLI 1 7.7% LISP 7.7VC 100.O9ZO 87.090 75.oo 50.0% 37.5% 25.070 0.0'%0 lQ.590 Results of the survey afso indicated that the MIS programs in the R.O. The strong emphasis put on teaching programming languages in the R.O.C. is also illustrated by required courses in the following C Programming (R.O.C. 87.5%, U.S. 38.5%), BASIC (R.O.C. 75%, U.S. 25%), Prolog (R.O.C. 500, U.S. 23%), and Assembler (R.O.C. 37.5%, U.S. 30.8%).
Identification of implicit legal requirements with legal abstract knowledgeBased on the analysis of lawyer's understanding process, a knowledge acquisition support system is proposed. 1 Introduction In order to redlze a legal expert system, we must translate legal texts into machine executable forms. If legal rules are translated into rules like Prolog program, a legal knowledge-base can be constructed. A CPF is a rule, which can be interpreted by a deductive reasoning engine like a Prolog interpreter. A legal rule can be represented by a CPF as follows: legal requirements legal effect - p + ri represents a legal requirement and e represents a legal effect. ri and e are called compound predicate terms. Since a ilat CPF is a function free Horn Clause, it can be executed directly by a Prolog interpreter. If the predicate is not referred from other ptedicate, its identifier is omitted, too.
"A logic base tool set for real-time Ada software developmentOur approach to combining SADT with the real-time schedulability principles has been to represent SADT modeling primitives and the real-time with logical relationships. The PROLOG both the constraints language was selected as the media for a deep structure representation. Custom queries are relatively straight forward uses of PROLOG. For example, an Engineer may wish to know the set of all activities conducted by a particuhu person (say a pilot) in a man in the loop system. A custom query for this would be something like this: activity(ACTIVITY, _, _), mechanism(pilot,ACTIVITY), wnte('k The pilot does "",ACTIVITY), fail. Those who understand PROLOG will recognize the FAIL as a method for forcing backtracking so that all solutions will be reported."
Recursion: beyond factorialSome programming languages don't support recursion at all, such as COBOL and FORTRAN. In others, such as Lisp, Prolog and pure functional languages, recursion is the favored or even only control mechanism for repitition. A short recursive predicate in P=:olog very elegantly solves the transitive closure problem: given a data base of employees, for example, return a list of all who supervise, directly or indirectly, a given employee. Just about any LISP or Prolog text will discuss the Append function or the transitive closure problem.
Analysis of Or-parallel execution modelsTR-90-04, Dept. of Computer Science, Univ. 4 BORGWARDT, P. Parallel Prolog using stack segments on shared Proceedings of the 1984 International Symposium on Logic N.J.). D., CLDERWOOD, A., SZEREDI, F., iTAIULII, S., BRAND, F., CIEPIELEWSKI, Aurora or-Prolog system. New Gen. Comput. 7, 2-3 (1990), A., AND HAUSMAN, n. WARREN, D. H. D. Or-parallel for or-parallel execution of Prolog-Abstract design and International Symposmm in Logtc Programming (San 1987, 92-102. execution models of Prolog.
Defining context-dependent syntax without using contextsOne possibility is to try in parallel. This breath-first ity test. Another strategy, Prolog programs, tries the according to their evaluation strategy of rule to prove both of the possible premises P and Q strategy gives us a sound and complete conform which corresponds to the usual evaluation of premises P and Q in sequence. PROLOG is syntax definition, since its computation domain, a free term algebra, is already quite similar to a derivation tree, and since predicates can model facts and conditions tax is conveniently expressed with naturally. Context-free syn some syntactic sugaring in the form of definite clause grammars [26]. The Horn clauses that make up a PROLOG program are less expressive more, they lack the capability than the predicates used in CADET.
Spreadsheets: a research agendaOne of the problems we have explored is one that is usually solved using a logi c programming language like Prolog . The problem involves transporting a collection o f objects (farmer, fax, goose and cabbage) across a river, subject to various constraint s (such as that the fox will eat the goose . This sort of feature - searching for a solution - is very similar to the behaviour of declarative programs (i n Prolog for example) or in the iterative solution of simultaneous equations .
Defeasible reasoning with conceptual graphs (abstract and references only)The response in these eases will be 'YES' or 'NO' -- sentences returning solutions Examples : 'what did john open', 'who opened the door', ... 2) Defeasible Reasoning Using Conceptual graphs In this section, we deal with how to do non-monotonic reasoning using conceptual graphs in Prolog. In order to do defeasible reasoning using conceptual graphs, we assume that every horn sentence is defeasible. 2.1) The Basic Defeasible Inference Engine The defeasible inference engine ([1]) will be built around a special predicate @. YES. 1) Covington, M.A., Nute, D., and Vellino, A., Prolog Programming in Depth, Scott, Foresmann and Company, London, 1988. 2) McDermott, D. and Doyle, J., 1980, Non-monotonic Logic I, Artificial Intelligence 13, pp. 41 - 72. 3) Sowa , J.F., 1984, Conceptual Structures : Information Processing in mind and machine, Addison - Wesley.
Parsing and case analysis in TANKATANKA (Text ANalysis for Knowledge Acquisition) is implemented in Quintus Prolog on Sun workstations. THE DIPETT PARSER TANKA requires a broad-coverage parser because it uses a limited semantic model based on Case relations, and domain-specific knowledge is not available to it a priori. A note stores a substring, its type and its syntactic structure produced by the parser. Corresponding DCG rules contain Prolog assertions invoked if the user has activated the memorizer or the helper. Testing and fine-tuning a complex parser can be difficult. Prolog debugging facilities are often cumbersome for logic grammars where it is only interesting to know what rule is being examined by the parser, for which part of the input string, and what has been successfully recognized.
Preference-based decision making for cooperative knowledge-based systemsThe knowledge base of every agent 1990] and is partitioned into concurrently. The functions is written predominantly in Prolog [Bratko four knowledge modules that can be run of these modules are briefly described as follows: -The base-level knowledge module models two things: (1) the local agent's expertise, pReferences, and inference and properties of the building rules and (2) the physical components structure to be designed. English translation by A. De Grazla. BRATO, I. 1990. PROLOG-Programmmg Wesley, Reading, Mass , Ch, 20. CARNAP, R. 1962. Princeton University Pressj Princeton, 1989. Explaining Prolog based expert systems using a layered metainterpreter.
"Occurrences in debugger specificationsFor exam ple, the logic formula p t- u : N + u' : R can be rep resented by the prolog predicate evcd(p, u, N, u', R), and the rule m(stibstP) is translated into the follow ing clause: eval(cons(p, triple(x, Un, cios(N, p'))), u, z, u', R) : - eval(p', Un, N, u', R). The rule Step' obtained after these manipulations has the following form : pl-u:P4u':P', p' p'tu', P' *p"" pt-u:P *p"" When translating this rule into a Prolog clause, we can add procedure call, as we did for the rules de scribing the functional programming language. The translation of the rule step thus becomes the following prolog clause: ezec(p, u, P, p') : - contro(step, ezec(p, u, P, p'), v), onei!"
Self-monitoring with reversible grammarsFor each of these utterances it is easy to check whether it is ambiguous or not, by counting the results the parser delivers for that utterance. Ina Prolog implementation this simple solution can be detincd as follows. By instantiating the resulting set as a set with exactly one element, we implement the idea that the utterance should be un-ambiguous (in that case there is only one parse result). Given Prolog's search strategy this definition implies that the generator generates solutions until an unambiguous utterance is generated. In our examples each sign sign(LF,Str,Syn,D) is specified for its corresponding derivation tree D. In Prolog such a tree is represented with terms of the form t,(Label,Ds,M) where Label is the node name (the unique name of a rule) and Ds is a list of Daughter trees.
Discovering and proving logic program propertiesAi l Intuitively, the idea is to avoid redundancy computation when the program is executed under the Prolog interpreter (depth first strategy). The evaluation of A, supposes that the atoms AI, A>,... and Ai-1 have been already evaluated. The system SPES is also coupled with a theorem prover(4], for proving the formulas proposed by the strategy described in this paper. 5 The theorem prover The theorem prover used follows from the work of Kanamori and Seki for the verification of Prolog programs using an extension of execution [5]. This prover is able to prove by induction some formulae of the form A 4~ A. PhD thesis, UniversitC de Nancy I, Novembre 1993. T. Kanamori and H. Seki. Verification of Prolog Programs Using an Extension of Execution. In Syd ZCLP, LNCS 225,1986.
"Computational reflection in software process modeling: the SLANG approachThe problem of producing a program that the by is able to ""reason"" about its structure has been largely discussed within the programming languages community. Languages such as LISP and Prolog allow programs to be manipulated as data (for example a Lisp program is a list that can be executed using the eval function, and the assert and retract rules in Prolog al low modification of the program while it is running). In some existing systems, this is achieved by building the process model as a rule-based system, where powerful mechanisms are provided to add, mod ify, or retract rules during the evaluation of a program, using mechanisms quite similar to those provided LISP and Prolog. However, as we will discuss by in Sec tion 5, rule-based systems suffer from other problems that may adversely affect other aspects of process actment. MERLIN [19, 11] is a rule-based language a cen support ing forward and backward chaining, and specific mand to alter the set of rules and facts being com inter preted by the MERLIN executor, using a mechanism similar to Prolog assert and retract rules. the From available published literature, however, it is not clear how dynamic changes of the process model can be accommodated and managed when multiple users access and/or execute the same process rule set. 6 Conclusions In this paper we have presented the basic features provided by SLANG to support the enactment and, in particular, dynamic evolution of a process model."
Reversible grammars and natural language processingIf this is the case it will return (through the function return) a resuhant list which is L1 appended to L2. The PROLOG relation on the other hand has three arguments and will do (essentially) what LISP does if the first two arguments are instantiated. First we could abandon the control structure of the PROLOG interpreter (i.e., top down, depth firs and left to right) in favor of an instantiation driven CaMrol strategy. Part of the solution requires making a somewhat novel use of the simple member function described in many textbooks on PROLOG. member(X,[Xl_l). memlwr(X,lTl) :- member(X,T).
Software/modelware application requirements (panel)Future simulation systems should be built on a more flexible underlying computational framework than FORTRAN or even objectaiented languages, namely upon Prolog. Prolog offers both an object and a retation-oriented view of simulation (Rotbenberg, 198@ Narain, 1991), and is suitable for parallel simulations (Cleary, Unger and Li, 19S8). Moreover, it incorporates a database, which can be mapped to industry-standard relational databases. The challenge is to build Prolog-based simulation systems that offer and improve upon the efficiency of presentday simulations, but that record history and allow for exploration and also problem-solving.
Never mind the paradigm, what about multiparadigm languages?The function eq determines the equality of defined const variables, or provides a binding that can be undone using a reversible assignment operator if the first argument to eq is unbound. Prolog [CM87] is one of the most popular logic programming languages. Addison-Wesley, Wokingham, England, 1994. [Bob 84] Daniel G. Bobrow. If PROLOG is the answer, what is the question? In Proceedings o] the International Conference on Fifth Generation Computer Systems 198,, pages 138-148, Tokyo, Japan, November 1984. [CM87] W. F. Clocksin and C. S. Me.Uish. Programming in Prolog. Springer-Verlag, New York, third, revised and extended edition, 1987.
"The promise of multiparadigm languages as pedagogical toolsThe logic paradigm includes among other things computation with relations, the existence of an underlying mechanism to search through the values of relations, an incremental rule-based program structure, and the binding of variables by the intersection of constraints. Prolog is a language that supports the logic paradigm. Rule-forms can be used with GED relations to form logical rules similar to those found in the language Prolog. An example of the paternal grandfather rule is given below that illustrates the use of rule-forms in GED. Fukunaga, Koichi and Shin-ichi Hirose. ""An Experience with a Prolog-based Object-Oriented Language"", OOPSLA '86: Special Issue of SIGPLAN Notices, 21, il."
The evolution of the programming languages courseGenerally accepted paradigms include the imperative or procedural paradigm (of which Pascal is an example), the concurrent or distributed paradigm (CSP), the database paradigm (SQL), the functional or applicative paradigm (Lisp), the logic programming paradigm (Prolog), and the object-oriented paradigm (Smalltalk). The languages most likely to be covered in a programming languages text are Ada (because of its many features), Pascal (because of its pularity and historical significance), and Lisp and Prolog (as representatives of the functional and logic programming paradigms, respectively). The tnble also shows Ten Hor Pra Sch Language 81 84 84 84 Ada Algol 60 Algol 68 APL Basic BCPL c c++ Clu Cobol Euclid Fortran FP Hope Lisp Logo ML Modula Modula-2 Object Pascal occam Pascal PLII Prolog sad Scheme Setl Simula Smalltalk Snobol SQL Val Tuc Ghe Mac Mar Wil Seb Set Der Kam App Fri J(u Led Cla J@ 86 87 87 87 88 89 89 90 90 91 91 Y = extensive coverage (an overview of the entire language or coverage of numerous eral sections in different chapters), # = some coverage (often a detailed discussion features, often occupying an entire chapter or sev of a small number of language features).
"Experiments in reusability of grammatical resourcesThe ETS formalism is ""badly behaved"" in that it contains a rich array of devices additional to the structure-building or B-rules, many of which are non-monotonic, and which apply at runtime (they are mainly output filters and various types of feature percolation rules). We have written an automatic compiler in Prolog which calculates a very simple type system and automatically migrates the structure rules and lexical descriptions. Our automatic migration experiment started from grammars written for the latter system. We have written a Prolog program that translates automatically from an LFG notation that is very close to the original specification in [Bresnan 1982] into ALEP. It is, however, capable of detecting those cases reliably, and generates warnings where the fully automatic translation fails. 6 Examples for typical rules from the source grammar are shown in figure 3. 7 The translation of the rule format illustrated in figure 3 into a PROLOG readable form is performed by a subcomponent of the CHARON system."
"CRL/Brandeis: description of the Diderot system as used for MUC-5<\organ> **7 ±XX k {type(C[entity_type,'COMPANY ']]) } <\endorgan> i <\time> -Pe A 1 s [date, '8501']]) } {type( [[date_adverb ,after] , <\endtime> <\organ> ]""il :* {type([[entity_type,'COMPANY']]) } <\endorgan> <\gls> t I # l LT {type([' 4 '$' i' ,v]) } <\endgls > Just as for the English system this is then converted into the form of Prolog facts ready to be rea d into the merging phase . This attaches the Penn Treeban k parts of speech to the text . The output is converted to Prolog facts . The Japanese text is segmente d with part-of-speech information by the JUMAN program, which was developed by Kyoto University . The partial grammar is derived from the tuned GLS entries . Prolog Definite Clause Grammar rules are produced automatically from the patterns given in the GLS cospecification ."
Precise and efficient groundness analysis for logic programsJONES, N. D., AND S@NDERGAARD, H. interpretation of Prolog. In Abstract Chichester, U.K., 123-142. 1987. A semantics-based framework for the abstract Interretation of Deckm-atiue Languages. Rep. 93/8, Dept. of Computer 1993. Groundless analysis for Prolog: Implementa-In Proceedings of the ACM Symposium on Partial Manipulation (Copenhagen, Denmark) ACM, New On propagation-based analysis of logic programs. Denotational abstract interpretation Syst. To be published. for a Prolog compiler. J. Logic Program. 2, 1, 43-66. NILSSON, U. 1991.
Selection criteria for expert system shells: a socio-technical frameworkES applications could be coded using AI languages (e.g., Lisp, PROLOG) or even conventional third-generation languages. However, writing an expert system from scratch in Lisp or PROLOG would be roughly equivalent to developing your own spreadsheet or word processing software. The latter choice may require extra costs to cover the training of conventional programmers in Lisp or PROLOG, or for the hiring of (relatively scarce) AI professionals.
"Memoization in top-down parsingFor example, the Earley deduction proof procedure is essentially a memoizing version of the top-down selected literal deletion (SLD) proof procedure employed by Prolog. Pereira and Warren (1983) showed that the steps of the Earley Deduction proof procedure proving the well-formedness of a string S from the standard 'top-down' definite clause grammar (DCG) axiomatization of a contextfree grammar (CFG) G correspond directly to those of Earley's algorithm recognizing S using G. These could be formalized as the CPS function defined in (21). (20) VP --+ V NP (21) (define (VP continuation pos) (begin VP --+ V S (V (lambda (posl) (NP continuation posl)) pos) (V (lambda (posl) (S continuation posl)) pos))) 6 Tailrecursion optimization prevents the procedure call stack from growing unboundedly. 7 This CPS formalization of CFGs is closely related to the 'downward success passing' method of translating Prolog into Lisp discussed by Kahn and Carlsson (1984). 411 Computational Linguistics Volume 21, Number 3 In this example V, NP, and S are assumed to have CPS definitions. Kahn, K. M., and Carlsson, M. (1984). ""How to implement Prolog on a Lisp machine."" In Implementations of Prolog, edited by J."
"Communicating control knowledge to a deductive database systemIn deductive database logic programming languages, like Prolog, systems and in the following approaches have been pursued for affecting part of a ""database algorithm"": q the control Add control directives to the rules of the deductive database. Examples for this sort of control are the cut in Pro log [CIM87], annotations [Vap 85], guarded Horn clauses [Ued 86], and the choice operator in LDL [KrN88]. q Write an application-specific meta-interpreter used instead of the builin interpreter. which is Usuafly the meta-interpreter is again defined by rules and these rules are interpreted by the builin interpreter. and [Bry 89] contain examples for this approach. q Apply partial evaluation techniques to a interpreter yielding a rewritten program. h [BoK82] meta example for this approach is the Magic Set Method (see [BMSU86], [BeR87]) which - w has been shown in [Bry 89] - is the result of partiidly evaluating up meta-interpreter. a bottom In our opinion the first approach does not clearly separate logic and control since the user needs some knowledge about the operational semantics of the control component to understand the semantics of the logic part. For example, to understand the meaning of a Prolog program containing a cut, the user has to understand what an SLD-tree is and how it is used by the Prolog interpreter. The second approach (meta-interpretation without partial evaluation) has originally been used for logic programming languages, like Prolog, that use a top-down approach. In Bry 89], however, it has been shown that meta-interpretation also fits to the framework of deductive database systems, yielding a -called bottomup meta-interpretation."
Unification with lazy non-redundant copyingThis technique resembles the last call optimization technique of some Prolog ira• plementations, e.g. for the WAM [Warren 83]. The last alternative continues destructively, resembling the last cMl optimization technique of Prolog implemelitations, yielding n DG representations, one for each alternative. Chicago University Press, Chicago, 1986. [Warren 83] David H. D. Warren. An Abstract Prolog Instruction Set. Technical Note 309, SRI International, Menlo Park, CA, 1983.
Prediction in chart parsing algorithms for Categorial Unification GrammarA chart-parser scans a sentence from left to right, while entering items, representing (partial) derivations, in a chart. Assume that items are represented as Prolog terms of the form item(Begin, End, LH S, Parsed, ToParse), where LHS is a feature-structure and Parsed and ToParse contain lists of feature-structures. Note, however, that although 11n these and following definitions, we assume, unless other'wise indicated, that feature-structures denoted by identical prolog variables are unified by means of feature-unificatiom bottom-up parsing is certainly attractive for CUG, there are also a number of potential inefficiencies: In many cases useless items will be predicted. Yasukawa, 1983, BUP : A Bottom-Up Parser embedded in Prolog. New Generation Computing, vol 1, 145-158. Pereira, F., & S.
Extracting legal knowledge by means of a multilayer neural network application to municipal jurisprudenceIn NEUROLEX, we select key elements such as the legal domain, the invoked legal and factual standards, the controversial mayoral decision and the judge's solution. l%ae elements will be the variable of our network. 2.2 KNOWLEDGE EXTRACTION IN THE MAIRILOG PROJECT MAHULOG is a set of expett systems and legal decisional aids intended to help mayors in decision-making : it consists of legal knowledge bases, data fdes, statistical files, text editors, banks of legal texts and dictionaries. Originally written in PROLOG, a version in TURBO PASCAL is commercially available. However, researchers continue their work on the PROLOG version (5). The knowledge base was constituted through traditional analysis methods, with computers used to help determine the structure and basis of normative texts. Up to the present, AI research in the field of law has dealt with two kinds of knowledge: rule-based knowledge and case-based knowledge. A significant example of a rule-based PROLOG representation of the British Nationality This representation is well adapted to structured model is the Act (10). and deftned domains which can be expressed in terms of necessary sufficient conditions.
"Semantic models and abstract interpretation techniques for inductive data structures and pointersMulkers et al. [58, 59] have devised an existential alias analysis for Prolog which derives aliasing assertions appar ently semantically equivalent to pairs of regular expressions, for instance X.tl* .M Y. tl"" .M. Alias analysis in Prolog does not require the ability to analyze destructive updates, contrary to imperative languages. 3.2 General relational methods Cousot & Cousot [12] present the first general interproce dural technique for existential alias analysis with pointer data structures. Conf. on Logic Pro gramming, MIT Press, 1990, pp. 747-762. [59]-, Live-structure dataflow analysis for Prolog, ACM Trans. Prog. Lang. Syst., 16 (1994), pp. 205-258. [60] F NIELSON, Two-level semantics and abstract inte?"
Representation and interpretation of fuzzy informationThe evaluatorofour system performs the tasks ofapproximate unification and fuzzy resolution by using the formulas and the order given in Section 2, in com bination with Prolog's resolution procedure. The core of the evaluator is given below, in which the procedure funify performs thetask of fuzzy unification, and the procedure fminrealises the order . 20 24 30 Figure 1 :- op(500,xfx,#). eval(true,l) :- !. Theproof islong and tedious, anti is therefore omitted. We note that the soundness of standard Prolog's M(A) s C. evaluation procedure is a special case of the above theorem. 0 1993 ACM 0-89791-626-3/93/0011 . . ..$1.50 736 737
A unification-based adaptive parserIf the procedurereturns `true,' the equation succeeds. Since our prototype is written in Prolog [5], the procedurewill be a user-defined Prolog goal to satisfy. During parsing, the value for semantics is passed as an argument to the Prolog goal named hour, which is shown below. This equation thus enforcesthe constraint that the actual number usedin a time of day phraseshould be one of the numbersfrom 1to 12. hour(X) :- X >O,X < 13. l Required constituents: A constituent marked with a `&' meansthe constituent is required: it must be presentin the input being parseby the grammarrule in order to satisfy the rule.
"A rule-based and object-oriented AI programming languageHowever, the rules and facts of traditional logical programming languages such as PROLOG, OPS -- 83, etc. are mutually isolated and therefore can not represent practical problems very well. • The inference engine of ROOP is a function which can be either one defined by ROOP system (standard inference engine ) or one redefined by user himself. However, it is very difficult for programmers to redefine inference engine in traditional logical languages such as PROLOG, OPS--83, ..., etc. • In a word, ROOP is a multiple paradigm A1 programming language which combines rule based, procedure, logic and object-oriented programming techniques. 2. Gueguen, ""Smalltalk--80"", 1987. [7] Dan Sharer, ""Advanced Turbo Prolog Programming"", 1987. [8] S. Fickas, ""Design Issues in a Rule-Based System "", ACM, 1985. [9] Huaichen Li, ""An Artificial intelligence Language-- OPS 83"", the Ele."
A process algebra interpretation of a verification oriented overlanguage of VHDLThanks to Labelled Predicate/ Transition Nets, and a Prolog engine, the EVAL tool can be used for high abstract level modeling, particularly suitable for the case of global system and software [LlAV, 901. The places are defined as predicates. The condition PROVIDED, expressed in Prolog, may specify typing, database, logical conditions or processing. This onecanbegenericon the baseof the formal modelof the protocol. Prolog predicatesimul computesoutput variables (blocking, val-out, new fife) depending on input ones(channel, valjn, fife) in the following manner.
Visualizing object oriented software in three dimensionsAside from this there is a file I/O module to transfer data into and out of the system, and two modules relating to system visualization and layout respectively . C++ source Database source code code Prolog Cflow database database tabase to GD conversion progr File I/O Hand controlled Interactive 13D widgets) 'Constraints! In the case of C+ + code, we plan to use the IBM compiler for th e RISC System 6000 which constructs an interna l Prolog data base containing extensiv e information about the code structure (Jarvey et al , 1992). We will extract the information we need by means of Prolog queries and transform the results into GDL. In order to visualize another application, hypertext for example, it will be necessary to transform the data structure into th e GDL .
An algorithm for plan recognition in collaborative discourseSyntactically, this language is very similar to Prolog, except that constraints on realvalued variables may be intermixed with literals in rules and goals. Semantically, CLP() is a generalization of Prolog in which unifiability is replaced by solvability of constraints. For example, in Prolog, the predicate X < 3 fails if X is uninstantiated.
Structure-driven generation from separate semantic representationsKEEPING SEMANTICS SEPARATE FROM SYNTAX The integrated-semantics approach is often illustrated in a Prolog-like notation using DCG rules. The infix function symbol '/' is used in each category to separate tile syntactic from the semantic part. It is part of the Berlin MT system and runs on both an IBM 4381 under VM/SP in Waterloo Core Prolog and a PC XT/AT in Arity Prolog. Compared to algorithms based on an integrated semantics the separate-semantics approach pursued here is promising if the generator has to be adapted to the SRL of some application system.
"Using expectation to enable spoken variable initiative dialogThe new parser may be viewed as having been constructed from three components: q Syntax-directed tmntdation [1] is used to translate the utterance into a Prolog predicate which encapsulates the user's intended meaning. 9 Finally, dialog expectation is used to resolve ellipsis and anaphora and to provide dialog context to disambiguate an otherwise ambiguous utterance. In the implementation, the output language happens to consist of r+ class of Prolog structures which are understood by the dialog controUer. The semantic and linguistic expectations can provide the necessary text as shown below: con z the ument system matching can be considered to be equivalent to Prolog unification, but other matchhg are possible. (a) algorithms the referent of pronouns (in the implemented system the only pronoun is ""it"") - The parser leaves the slot for the referent of ""it"" unspecified in its interpretation."
Performance specification using attributed grammarsList operators are transformed to function calls whose parameters are the completely instantiated lists. 7 PDL Implementation The first im lamentation of PDL was in Prolog followed % y another in VHDL. Both these languages have their advantages and disadvantages. Prolog's advantages are: a) Its backtracking mechanisms and logical variables are excel`7Primitive $ltrih*' Figure 3: PDL Execution environment lent for implementing global queries and projections, and b) It also allows rapid prototyp ing. The PDL com iler generates an intermediate format that is su \ se uentl converted by the backend to generate eier ,HDL or Prolog code. We are currently involved in upgrading the language and the environment to support the following features: 1.
Type-raising and directionality in combinatory grammarThe above argument translates directly into unification-based frameworks such as PATR or Prolog. A small Prolog program, shown in an appendix, can be used to exemplify and check the argument.4 The program makes no claim to practicality or efficiency as a CCG parser, a question on which the reader is refered to [7]. Proceedings of COLING 90, Helsinld, 145-150. [4] Pereira, Fernando, and Smart Shieber: 1987, Prolog and Natural Language Analysis, CSLIAJniv. of Chicago Press. [5] Steedman, Mark: 1987.
"Applying program understanding technology to IBM product documentationThe tags for this document begin something like 7]: :userdoc ibmcopyr='1993'. :prolog. :title.C Set ++: HeapView Debugger User's Guide :topic.HeapView Debugger User's Guide :version.Version 2.1 :etitle. Its syntax is reminiscent of Lisp, but it also includes Prolog-like rules and support for set manipulation. Some of the key aspects of the REFINE language are: A library of tree operations such as copy, compare, traverse, and substitute A exible object base that provides version control, inheritance, and constraints Support for mathematical operations, including logic and set operations Program templates for patternmatching against program trees A transformation for specifying modi cations to source code. Here is a part of the BookMaster grammar we have built: grammar BookMaster file-classes doc-object productions identifier ::= doc-name] builds identifier, front-body ::="":frontm"" front-seq * "".""] builds front-body, preface ::="":preface"" doc-object-label "".""] builds preface, abstract ::="":abstract"" doc-object-label "".""] builds abstract, title-page ::="":prolog"" doc-object-label "":eprolog""] builds title-page, content ::="":toc"" doc-object-label "".""] builds content, Once we have used the domain model and grammar to parse a BookMaster document, REFINE rules will be used to display structural aspects the subject document. 6 Conclusions At this stage we feel that both Rigi and REFINE o er opportunities for better understanding the structure of product documentation."
Overview of natural language processing of captions for retrieving multimedia dataCaption-ids with match scores exceeding a fine-grain match threshold are presented to the user. 3 Implementation Status The majority of the system is written in Quintus Prolog. with the type hierarchy being developed using the Elsa-Lap object-oriented Prolog tool.
Branch with masked squashing in superpipelined processors. - Mwt f ompare-branch delay = Z [ Figure 1: SLAM pipeline structure and delay slots 3 Methodology We consider experiments using a computer architecture evaluation system for SLAM which consists of a compiler front-end, an optimizing compiler backend, parametrized instruction simulator, and a trace profiler. a The benchmark programs are compiled through the Aquarius Prolog compiler front-end into an intermediate representation (BAM code) [16]. The instruction set of the BAM code is designed in a way such that a Prolog gram can be optimally compiled by the Aquarius pro Prolog compiler front-end, and platform for a new target machine can easily be generated. In this section, we experiment with the branch strategies on a superpipelined Prolog processor with various numbers of branch delay slots.
"A look at multipolicy research today and some proposed directions for tomorrow: a panel paper for the ACM SIGSAC workshop on data management security and privacy standards, San Antonio, TX, December 3, 1991Rule-based specification and synthesis of policies appears to offer promise. Languages such as Prolog may offer potential to accurately specify policy relationships and to derive hybrids. (2) Examine the applicability of the object-oriented design concepts of inheritance and multiple inheritance [17] as another way to describe policy hierarchies, interrelationships, and properties. Formal specification alternatives such as using ""Z"" or Prolog could be compared. Lastly, candidate run-time enforcement platforms could be studied for performance and applicability. 15 IV."
Object-oriented AI: a commercial perspectiveIn successive, overlapping waves, expert system tool vendors modified their products so they: (1) would run on Unix workstations and PCs rather than Lisp machines, (2) were written in conventional languages rather than in Lisp or Prolog, (3) could access data stored in conventional and relational databases, and (4) could run effectively on mainframes. In fact, it is only when a developer uses both objects and produc-OO Operating Systems OO Languages and Class Libraries OO Networks and Middleware Components and Frameworks OO Application Development Environments and Tools for Rapid Prototyping Application Development Environments and Tools for OO CASE OO Methodologies OO Databases OO Tools for special types of applications Business Objects and OO Applications OO operating systems are incorporating intelligent agents and smart checking and indexing components. Neither CLOS nor Object Prolog are very popular OOLs, but they provide features that other OOL vendors are incorporating. Most of the vendors who have chosen to position themselves as purveyors of OO 4GL tools have encountered difficulty. First, they have relied on proprietary Prolog or Lisplike internal scripting languages. These languages give the tools their power and flexibility, but are not standard OO languages.
"Improving semi-static branch prediction by code replicationThe programs are: abalone a board game employing alpha-beta c-compiler search the Icc compiler front end of Fraser & Han son compress a file compression utility (SPEC) ghostview an X postscript previewer predict our profiling and trace tool prolog the minivip Prolog interpreter scheduler an instruction scheduler doduc hydrocode simulation (floating (SPEC) These benchmark programs have been compiled the C or Fortran compilers with optimization point) with enabled. Code Size misprediction rate code size 1 Figure 7: c-compiler rnisprediction rate 15%L 10% code size 1 1 I I I Figure 8: compress misprediction rate 15%t'----- 15% 10% 5% 1 code size 1.25 1.75 Figure 6: abalone I 5%Lize Figure 9: ghostview rnisprediction rate 10% 1 ""kize Figure 10: predict rnisprediction rate I 15% 4 rnisprediction rate I I 10% `""'b====== i 5% Figure 11: prolog rnisprediction rate 15% / `""'L 5% Figure 12: scheduler code size Figure code size 13: doduc code size 97 98 99 100 101 I n7 103 104 105 106"
Knowledge-based security administration in a distributed environmentThis has turne d out to be a serious source of error . 4.0 Knowledge-Base d Security Management 4.1 Knowledge-Based Programmin g The main advantage of using logic programming languages such as PROLOG, concept description languages lik e KL-ONE, or other knowledge-representation languages, is the simple way of dealing with declarative statements, a s well as the small set of syntactic constructs that form the language, becaus e there is no need to worry about the flow of control explicitly . The defined predicates will be specifie d by axioms that can be divided into tw o classes, namely facts and rules . The fact s state, as in PROLOG, that the specified relation holds for the given parameter values . axiom Miller-fsl l has access (su :MILLER , ob :File_Server_11 , and :read-write) . The means to organiz e the knowledge, which are present i n knowledge-representation languages with sorts, far exceed the constructs availabl e in standard logic programming language s like PROLOG. The application of knowledge-base d techniques is most rewarding in comple x situations with frequent dynami c changes .
Reading source codeIn addition to the overt text, the online version of this document als o contains embedded Prolog rules which express a variety of relationships between fragments of th e document, such as necessary header files an d callable or called functions . The programmer can read the document in this window, or can choose to follow one of the Prolog links . This is done by pointing to the link , the software then consults the database to find th e target of the link, and brings up the relevant par t of the document in the bottom righthand window . The second type o f database is a simple flat file database tha t manages n-ary relationships, including th e embedded Prolog facts, the information stored in the traversal history list (Figure 2) and the search result list (Figure 3) .
"On the portability of complex constraint-based grammarsType ltierarchy i 'rl's I t c/31,"" I I ixplici l)edicated (Jontol Lazy Host l'arsr _ Morphology l)etermiued Evaluation Language globally yes Common Lisp globally yes Common Lisp yes llO [al,U A yes _y( _ IlO locally yes l'rolog yes locally no Prolog Table 1: A checklist of tile signiticant properties of the sample implementations 2 Formalisms In our experiments to explore the portability of complex constraint-ba.qed grammars we have considered a sample of four imt)lemented formalisms: . Our objective here is slightly different than in the last two cmes, since all the formalisms support lists and most even supply the same, Prolog-style, notation. There is however a more subtie difference between uB and the more strongly typed forrnalisms, since in all the other formalisms the list notation is purely syntactic and masks a typed feature structure that is either atomic or has two attributes. The crude characterisation of this distinction is that some formalisms permit the grammar writer to influence the local processing strategy, either in the good, old-fashioned Prolog manner of ordering clauses, as in ALE, or by providing additional control information, such as delay statements in CUF."
Concurrency & object-oriented programmingO-CPU [Me 188] combines logic and object-based programming in a concurrent language. Objects (called P-units) are expressedas Prolog databases (i.e., as a collection of Horn clauses). Methods are represented as collections of Prolog clauses. P-units activate 'demonstration processes' to solve goals, and they can activate parallel demonstration processes when needed. Both synchronous and asynchronous message passing, as well as future style messages, are supported. The knowledge part is essentially a Prolog-like collection of firstorder predicate logic relations.
NES: the behavioral model for the formal semantics of a hardware design language UDL/IS:izl(X) is a set of event sequences obtained from set of even.t sequences X given a.5an input stimulus to M. 3.3 Description of Behavior of Modules We can consider many ways of describing the set of states, the set of initial states and state transition function of the abstract machine. In this paper, we use prolog for this purpose. In the following discussion, event (p, w) is described as term p(v). (ii) 3.5 Simulation of the Abstract Machine The semantics of description of abstract machines can be also described as a prolog program. It is possible, therefore, to simulate the abstract machine described in prolog.
Database research at WisconsinCORAL significantly extends the expressiveness of standard database query languages such as SQL, and differs from logic programming languages such as Prolog in supporting a modular and non-operational semantics. While the range of features is extensive, the most important difference with respect to other deductive/logic programming systems is an emphasis on providing users with a number of ways to control the execution, x The range of evaluation methods that are supported -- and that can be selected by the user explicitly or by the system using defaults -- goes from Prolog-style top-down backtracking to bottom-up fixpoint evaluation with a number of refinements. First, it can be used by invoking the CORAL shell, by typing coral at the Unix prompt, this is similar in many respects to using the Prolog interface. In this mode, the user can create one or more modules, compile them, load them, execute them, etc. from the CORAL 1COB.ALstands for COntrol, Relations And Logic.
"Suspension analyses for concurrent logic programsHence the deadlock does not deadlock. 7.2 Floundering Analysis Traditional sequential Prolog's have However, this is a severe limitation in a clean, declarative style may analysis sketched above will show that s a fixed left-to-right computation rule. because it means that programs written be inefficient, only terminate when certain inputs are ground, and (if negation is used) produce wrong results. For this reason there has been widespread interest in a class logic programming languages, such as IC-Prolog, Prolog-II, and SEPIA, which allow more flexible of ""second-generation"" MU-Prolog, NU-Prolog, computation rules in which calls are dynamically ""delayed"" efficiently. This works well in our setting of concurrent logic languages, since goals Prolog programs, however, rather than sets. APPENDIX can be treated as sets."
Four Dimensions of programming-language independenceExamples of languages designed with this method in mind are PROLOG,19 SETL,71 Lucid,77 and YACC.46 (YACC's grammars are declarative, but most YACC programs rely on support from another nondeclarative language, C). It is the goal of some researchers to support declarative programming within traditional programming languages.67,11 It is also the goal of designers of successors of Prolog to increase Prolog's problemsolving power by incorporating imperative features. Clocksin, William F. and Mellish, Christopher S., Programming in Prolog, Third, Revised and Extended Edition. Springer-Verlag, Berlin (1987). 20.
A functional logic for higher level reasoning about computationThis notation is capable of formalisation, and has been formalised in the logic programming language Qu-Prolog [Pall 90, SRE90, SRP88], but the issues involved are beyond the scope of this paper. J. and Ellis, G. R. : Persistent Variables in Qu-Prolog. Australian Computer Science Communications, 13, 362-369 (1990). A., Hagen, R. A., Craddock, A. J. and Wallis, P. C. : Qu-Prolog - an Extended Prolog for Meta Level Programming.
"On determining the consistency of partial descriptions of treesBoth algorithms take as input a description and an integer indicating the number of nodenames constrained by the description. In the Prolog implementations that follow, the description is expected to be a list of constraints in normal order, that is, with the first argument lexicographically less than or equal to the second. The roots of these sub-proofs can be combined using LV until we eventually build up the input description on the left, proving F0-', as in Figure 5. The following fragment of a Prolog implementation of max_extension/3 can be seen as implementing a backwards chaining search for such a ""RA-LV"" proof. Information Sciences 7: 95-132. O'Keefe, Richard A. 1990. The Craft of Prolog. Cambridge, MA: MIT Press. Rogers, 3ames & K. Vijay-Shanker. 1992."
"The impact of logic programming on databasesDuring the second time period, 1969-1978, the concept of logic programming was proposed and then implemented in the language Prolog. Also, the foundations of logic programming were developed by van Emden and Kowalski [45]. The inefficiency of SLD-resolution is due partly to its tuple at a time approach. The Prolog evaluation method is based on SLD-resolution, but its depth-first approach can lead to infinite loops. Plenum, 1978, 293-322. 11. Colmerauer, A. ""Theoretical Model of Prolog II"". In Logic Programming and its Application, M."
"Review of ""Grammaires d'unification à traits et contrôle des infinitives en français: unification grammars with features and control of infinitives in French"" by Karine Baschung. Éditions Adosa 1991.However, it seems to be only a mechanism whose details have no direct relevance except for a Prolog implementation of this particular approach. On the other hand, the remark (p. 258) that erasing should not be treated as a rule, since that would be equivalent to the hidden creation of lexical entries, but rather as a filter to check the well-formedness of signs, deserves further study. Since the unification operation over sets is not defined in Prolog, this procedure gives a definition for it that allows the expression of the linguistic phenomena to be accounted for."
"Talisman: un systeme multi-agents gouverne par des lois linguistiques pour le traitement de la langue naturelleUne loi d'attente intervient : send ($YNT, [interro 0ative,""est-ce...programmes""l,_) -> deliver (SYNT, attente, _) La loi bloque le travail des autres agents momentan 6ment car il est inutile que l'agent expert en morphologie traite un debut de phrase (est-ce que) qui peut gen6rer inutilement certames ambiguit 6s alors 3 Nous utiliserons la syntaxe de Prolog. 4 La semmttique de ce pr 6dicat est defmie par rutilisateur. 4 9 4 PRec. La structure d'accueil et les agents sont impl 6ment 6s en Prolog Bim (version 3.0) sur station SUN4. Les modules du logiciel CRISSTAL sont crits en C, et en Prolog."
"A needed narrowing strategyTechniques for rewriting ""terms"" with shared subterms go under the name of term graph rewriting [47] and adapting them to narrowing, for the systems we are considering, poses no major problem [4]. 6 Related work There are three research topics related to our work: (1) the concept of need as the foundation of laziness, (2) strategies for using narrowing in programming, and (3) implement ations of narrowing in Prolog. 6.1 Narrowing and need Seminal studies on the concept of need in rewriting ap pear in [24, 39]. To summarize, the distinguishing features of our strat egy are the following: with respect to eager strategies, completeness for non-terminating rewrite systems, with respect to the so-called lazy strategies, a sharp char acterization of laziness, with respect to any strategy, optimality and ease of computation. 6.3 Narrowing in Prolog Implementations of narrowing in Prolog [2, 8, 26, 32] are proposed as a prototypical and portable integration of functional and logic languages. Efficient implementation of lazy narrowing into PROLOG. In LOPSTR '92, 1993. Previous version: Some Techniques for the Effi cient Implement ation of Lazy Narrowing, Technical Report -FIM.75/LyS/92, Facultad de Informatica, Universidad Politecnica de Madrid, 1992. 27] J."
Communication as fair distribution of knowledgeWe currently have a toy interpreter for the language, written in Prolog (with coroutining facilities to simulate concurrency). Brogi and P. Ciancarini. The concurrent language shared prolog. ACM Transactions on Programming Languages and Systems, To appear, 1991. Technical report, Xerox Part, Palo Alto, U.S.A., 1990. [2G] E. Shapiro. A subset of concurrent prolog and its interpreter. Technical report, Institute for New Generation Computer Technology, Tokyo, Japan, 1983. [27] E.
Reverse queries in DATRIn: Cornp. Ling. Vol. 18, No. 3, pages 245-267. 5A prolog implementation of the algorithm described in this paper is freely available as a DOS executable program. [Gibbon 1993] Dafydd Gibbon: Generalised DATR for flexible access: Prolog specification. English/Linguistics Occasional Papers 8. [Jenkins 1990] Elizabeth A. Jenkins: Enhancements to tbe Sussex Prolog DATR hnplemeutation. In: Evans & Gazdar [eds.] [1990], pp. 41-61.
"The role of testing methodologies in open systems standards: a POSIX experience reportThe Protest system is a domain independent set of Prolog programs which support the development of Prolog scripts capable of automatically testing modules implemented in C [14]. Hoffman and P. Strooper, ""Automated Module Testing in Prolog"", IEEE Transactions on Software Engineering, Vol. 17, No. 9, September 1991. [15] J."
Abstract filters: improving bottom-up execution of logic programs by two-phase abstract interpretationIt guarantees logical completeness which strict top-down approaches sacrifice in favor of implementational efficiency as in Prolog. In particular, if the number of all possible facts is finite, the bottom-up evaluation terminates while strict top-down one like Prolog may not. Eng., 1988, pp. 922-935. [9] Lloyd, J.W., Foundation of Logic Programming, Springer-Verlag, 1984. [10] Ramakrishnan, R., Magic Templates: A spellbinding approach to logic programs, Proc. of the 1988 International Conference and Symposium on Logic Programming (Seattle), 1988, pp.140-159. [11] Sato, T., and Tamaki, H., Enumeration of success patterns in logic programs, Theoretical Computer Science, 34:227-240 (1984). [12] Sterling, L., and Shapiro, E., The art of Prolog. The MIT Press, 1986. 393
Book review: Handbook of Logic in Artificial Intelligence and Logic Programming. Volume 1. Logical Foundations. Edited by Dov M. Gabbay, C. J. Hogger, and J. A. Robinson (Claredon Press, Oxford, 1993 )For these formulas it is possible to find deduction faster than for the general ones, these methods form the basis of Prolog compilers. On the other hand, Horn formulas are sufficiently general to represent an arbitrary recursive function and to encode first order logic. In particular, this paper describes (1) when we come up with a correct answer irrespective of the order of transformations (this is called ChurchRosser property), (2) how to transform equations into rules (it is called Knuth-Bendix algorithm, and (3) how to incorporate term rewriting into Prolog. How to formalize reasoning about proofs In addition to describing traditional logical and mathematical reasoning, we may want to formalize reasoning about mathematical proofs and logical constructions.
APL futures workshop '95 at MinnowbrookHe listed them as: • Imperative procedural: Fortran, Cobol, Algol, C, Modula, and Turing. • List processing: Lisp and Prolog • Functional: FP, Miranda, MI, and Haspel • Array: APL, APL2, Nial,J, K, Madab • Object Oriented: Smalhalk, Loops, and C++ • Logic Programming: Prolog and Euler.
Legal expert systems as simulation toolsHe published several papers and books and directed the development of T-PROLOG and CS-PROLOG systems. JOZSEF VARKONYI finished his studies at the Budapest University of Economic Sciences in 1973.
Accenting and deaccenting: a declarative approachThe following definitions are used to implement accenting: 4 accented(X) :- X:accent === true. 3Even though metrical trees are strictly binarybranching, nnflti-branehing are accommodated by allowing rules such as S (NP/(Infl/VP)). 4The notation has been borrowed from Gazdar & Mellish 1989, '=--=' is the unification operator, and Node:Attr indicates a path in a graph (or a field iu a record). We assume negation by failure as in standard Prolog implementations. ACRESDECOLING-92,NANTES,23-28^olr 1992 8 6 6 PRec. oF COLING-92. Gazdar, G. & C. Mellish (1989), Natural language processing in prolog: an introduction to computational linguistics.
"How to forget the past without repeating itOne of the key advantages of these bottom-up strategies over common top-down approaches (such as Prolog) is that by storing all intermediate the recomputation of a fact results, bottom-up evaluation is able to replace by a simple lookup. The standard algorithm quence can be expressed program appears in Section of 13irchberg [1975] for the longest common subse simpIy and elegantly using Prolog notation (the 5 of this paper). Unfortunately, on strings of length n, the time complexity of Prolog is exponential in and grows is both 0(( ]) and 0((', ]). For example, if H = 20, we have that ( ) > 275 X 10g, if n == 100, we have (z~"") > 1.8 X 105Y. Clearly, the Prolog evaluation strategy shortest of strings. If we take the bottom-up cannot be used on this program for any but the approach for rewriting by Magic Templates [Ramakrishnan 1988] followed Bancilhon [1985]) the running improvement, unfortunately, by Seminaive bottom-up evaluation (e.g., time is reduced to O(n )."
Using resolution for extending KL-ONE-type languagesThis is in sharp contr=t to using fulf first-order logic or non-decidable sublanguages like Horn clauses (the basis of PROLOG), where nonsucceasfttl queries do not, as a rule, terminate. The user of the language can describe his concepts in the T-box, write down known facts in the A-box, and ask queries from the system, much fike is done in PROLOG. The crucial difference from PROLOG is that the language is decidable - any query must get either a positive or a negative answer.
Automatically processing amendments to legislation. + NLP module amending Acts Figure 1: Architecture An ATN parser can be easily implemented in the gramming language Prolog using the top-down, frames * text processing module versions new versions of Acts of Acts 4 database of Acts and versions of the Amendment Processing System pro- 4 NLP sub-networks left-to right solver and unification that is built guage [15, 25]. All of these forms can be handled by th existing of parser which produces a separate frame for each amend ing action as with the amending sections. 5 Conclusion and further work The NLP processor has been constructed in NU Prolog [19] and tested on a relatively small set of exam ple Federal Acts (including the Grape Research Levy Act 1986 and the States Grants (Schools Assistance) Act 1989 and the Acts which amend them - a total of 10 Acts) which were selected because they are rel atively small and recent Acts that provide a rich vari et y of amendment types. Computers and legislation. Al [19] J. A. Thorn and J. Z. (Eds). NU-Prolog Appendix: Example output of the Below is a representation of some output from a fictitious Amending Act derived from various (Cth) No 1 and then we list the resulting output States Grants Amendment Act 1990< l Jan 1991 l NLP module the NLP module.
A visual software process languageA group of researchers in Japan is modeling software processes using an enhanced version of Prolog called C-Prolog [8]. Software Process Machines [2] use finite state automata to drive the IPSE. S1GPlan Notices, Proceedings of the Third ACM S1GSoft/SIGPlan Software Engineering Symposium on Practical Software Development Environments (Nov. 1988), pp. 235-247. 8. Ohki, A. et al. Process programming with Prolog. In Proceedings of the Fourth International Software Process Workshop (May 1988), pp. 118-121. 9.
Deriving modular designs from formal specificationsA partial implementation of the analysis described in Section 2.1 has been undertaken Prolog [17]. The prototype requires the state process aa using Nu and opera tion schemaa of the Z specification to be translated Prolog facts. The prototype per forms the analysis to compute the global relationships based on the schema inclusions and expressions ing schema operators. Methods for automating translation into Prolog are under investigation. prototypes for the synthesis phase have been involv the Various developed which use the cross-reference table generated analysis phase.
AP1000+: architectural support of PUT/GET interface for parallelizing compiler. * * , AP1OOO model # APIOOO+ model : # # computation SPARC the com # computation SuperSPARC computat ion. factor 1.00 computation-f act or * * * ---- network ---- * ---- network ---- network-prolog-t ime 0.16 netiiork-prolog-t ime network-delay-time 0.16 network-delay-t ime * # # ---- PUT/GET ---- * ---- PUT/GZT ---- a # put -prolog-t ime 20.0 put -prolog-t ime put-epilog-t ime 15.0 put-epilog-t ime put -Meg-t ime 0.05 putJ88g_t ime put-dmset-time 15.0 put -alma-set -t ime put-meg-post -time 0.04 put_msg-post-time # # int r-rtc-t ime 20.0 intr-rtc-time recv-msg-flush-t irne 0.04 recv-meg-f lush-time recv-dma-set.t ime 15.0 recv-dma_set. time Figure 6: Some MLSim parameters 5.1 PUT Communication Model 0.125 0.16 0.16 Figure 7 shows the PUT communication model for MLSimon the AP1OOO based on interrupts.
Python: a GUI development toolA number of Tk-aware intetpreted lan guages, such as Mod&-3, Ezi$el, Se& Prolog, Scheme, Per& and Python, are current4 available. In fact Tel, is just one of a host of programming languages that have access to the Tk toolkit. There are now interfaces to Tk from C, Prolog, Modula-3, Eiffel, Se16 Scheme, Perls, and Python.
"Dynamic crossword slot table implementationBerghcl (1987) recast the problem within a logical framework and succcssfuIly implemented the algorithms in Prolog for arbitrary puzzle grids. Baghel end Y1 (1989) extended this approach by developing a gertersd-pwpose cmnpiler-contpiler which converted graphical input (puzzle grid) into a Prolog program, complete with heuristics, based upon a %@-st priority neighborhood"" sesmh algorithm."
Exploiting implicit parallelism of logic languages with the SAMA complete analysis should also take into account the performance of other logic languages, like the relational based ones, such as prolog: it is encouraging that lots of cases where Prolog need recursion, even not amenable to last call optimization, in SEL are simply treated taking advantage of implicit iteration without any need of recursion at all, such as for the cartesian product of two collection: the Prolog version is: cartProd( [1 , Cl, [1 ). cartProd( [Hi IT1], [H21T2] ,X) :- append([pair(Hl ,H2)] ,Y, Z), cartProd( [Hi IT1] ,T2,Z), cartProd(Tl, [H21T2] ,U), append(Z, U, X). while the SEL version (already given above) is simply: cartProd({xl_}, {yl .}) contains {pair(x, with no recursion at all, Abstract Analysis Abstract analyzers play an important y)}. role in the process of building an efficient implementation language: their aim is to infer important of a logic properties of programs analyzing them without executing.
Experience with formal methods in protocol developmentNumerous problems were also discovered i n the specifications of military standards for TCP [BS84] and IP [Sid 85] . A technique based on Prolog was used to create executable specifications of protocol s [Sid 83, SC88, Sid 87] . The executable protocol specifications were then analyzed using th e Prolog interpreter for logical errors such as incompleteness errors, deadlocks, etc . [Sid 87] D . P. Sidhu . Protocol verification using Prolog . Submitted for publication, 1987 . [Sid 90] D .
LogicBase: a deductive database system prototypeObviously, this is quite different from the implementations of Prolog [24] which perform no systematic rule compilation and query analysis, and therefore, cannot judge termination, enforce sophisticated constraints, determine appropriate rule/predicate ordering, nor derive efficient query evaluation plans. Recent studies on constraint logic programming, such as [28, 16], enforce more constraints than Prolog but still mainly confine the program evaluation ordering to those given by programmers. Verg Large Data Bases, Dublin, Ireland, August 1993. [24] L. Sterling and E. Shapiro. The Art of Prolog. The MIT Press, 1986. [25] L. A. Taylor and R.
Generalized algorithmic debugging and testingThe original form of algorith mic debugging, introduced by Shapiro [Shapiro-83], is how ever limited to small Prolog programs without side-effects. Another drawback of the original method is the large number of interactions with the user during bug localization. However Shapiro's model cannot handle side-effects or loops, and has only been applied to Prolog programs. This restriction prevents the system from being practically useful for programs written in imperative languages. The tar get and implementation languages for the algorithms sented by Shapiro is Prolog. pre [Drabent, et a1-88] suggest a generalization of the language used to communicate with the debugger.
"Expert simulation system based on a relational databaseAdelsberger and Neumann [1985] explored the use of PROLOG as a simulation language. ROSS developed at the RAND Corporation [Klahr 1984] and KBS developed at Carnegie-Mellon [Reddy et al. 1985], are examples of simulation languages based upon AI concepts. in Ketcham and Harhen [1986] who proposed an integrated network Use of AI techniques for simulation environments can be found of expert systems to handle the decision making process in simulation studies. Neumann (1985), ""Goal Oriented Simulation Modeling Using PROLOG,"" In Proceedings of the 1985 SCS Conference on Modeling and Simulation on MicroComputers, San Diego, CA, 42-47."
An NF2 relational interface for document retrieval, restructuring and aggregationIn this paper we introduce such a query language. Its prototype was implemented in Prolog. The key idea is that the user spcci - fies the structure of the result, with aggregation information, declaratively, without specifying the derivation process. The implementation architecture The interface is fully implemented in Prolog. by the filwith atand The maximum size of databases depends on the size of the available memory and query selectivity, but is generally small. main However, the basic database retrieval component can be implemented with existing DBMSS or IR systems. Another direction is the development of probabilistic ranking of results. Our main-memory oriented Prolog implementation system facilitates prototype development but of the is unsuitable with large databases.
Analyzing stores and references in a parallel symbolic languageIn particular, there has been much on this facili to syn man the tar analysis success in applying optimizations derived via static analysis to expres sive symbolic programming languages such as Scheme Prolog [11], Self [4], or ML [1]. There has also been much work in building concurrent logues of such languages (e.g., MultiLisp [15], CML ML Threads [25], Concurrent Smalltalk [16], [7], ana [28], Concurrent Prolog [29], etc. ). In Proceedings of the SIGPLAN'91 Conference on Programmmg Language Design and Implementation, pages 293-306, June 1991. [29] Ehud Shapiro, editor. Concurrent Prolog : Collected Papers, MIT Press, 1987. Volumes 1 and 2, [30] Olin Shivers, Data-flow Analysis and Type Recovery in Scheme.
The automatic element routine generator: an automatic programming tool for functional simulator design., Research & DeveloDment Division, Palo Alto, CA 94304 x4 User interfaces using natural terms in the domain, truth tables, and circuit diagrams Element routine generation in both PROLOG andC Model verification and performance evaluation within the system Primitive element routine optimization using McCluskey's algorithm Four times speedperformance improvement of optimized element routine code over unoptimized code 2 The AERG system The AERG systemhas capabilities for signal modeling, primitive modeling, and functional modeling. As afeasibility study, an early prototype of the AERG systemwas developed which generated PROLOG element routine code. This prototype was used to analyze and validate the transformation process.For reasonsof performance and portability, it wasdecided that the next version of the systemshould utilize more standard languagesand systemfunctions.
An axiomatic basis for general discrete-event modelingAn implementation of both DMOD models and the reasoning framework is shown using the logic of definite clauses (Kowalski 1979, Llclyd 1984), the basis of the widely used language Prolog. This logic has high expressive power and simple deductive properties. Baudinet, M. [1988]. Proving Termination ties of Prolog Programs: A Semantic Proper Ap proach. Proceedings of IEEE Symposium Logic in Computer Science. on Cameron, E., Lin, Y. Lecture Notes in Information Science, 103, Springer Verlag. Kanamori, T., Seki, H. [1986]. Verification of Prolog Programs Using an Extension of Execution. Proceedings of Third International Confer ence OJ1Logic Programming, London.
Data conversion, aggregation and deduction for advanced retrieval from the heterogeneous fact databasesTherefore we also show how these techniques are integrated into a powerful query language which has been implemented in Prolog in a workstation environment. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantaga, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. All the operations presented have been implemented in Prolog in a workstation environment. Details of the operations are given in [6] [8] [11] [12] [13]. 1 Chen, C. & Hernon, P. Tampere: U. of Tampere, Dept of Computer Sci., Rep. A-1990-2, 199CL Niemi, T. & Jarvelin, K. Prolog-Based Metarules for Relational Database Representation and Manipulation.
"Conjunction as compositionThese rules are conveniently Thus, there are three expressed in pure Prolog. reasons for decomposing this specification: (1) Different portions are more (2) One portion is new while conveniently written in different languages, the other is an old specification reused, and (3) There are two modules encapsulating different portions of the state (the state of a virtual telephone telephone). The ""Lexical here being applied to describe Analysis"" partial specification is Figure 12, the text of Hamlet. ""Token Identity"" is written in pure Prolog. Its purpose is to define when two tokens are to be considered capitalization is irrelevant. word_ equal([], []), equal for purposes of the concordance word_ equal([PIQ], [PISI) .-word _equal(Q, S). word _equal([PIQ], [RIS]) :- case_ pair(P, R), word_ equal(Q, S). case_ palr('{a"", ""A""), case_ pair(''A"", `(a""). case_ pair(''b"",""B""), case_ palr(''B"",""b""). . . . The Prolog program is concerned semantics, we need a predicate list(1) application of the program, all lists will list(1) is renamed as Hamlet-tohen(t with lists of characters."
"An efficient approach to computing fixpoints for complex program analysisDe moen, ""Abstract interpretation: Towward the globaJ optimization of Prolog programs,"" in Proceedings of the 1987 Symposium on Logic Programming, 1987. [25] B. Van Hentenryck, ""Experimental evaluation of a generic abstract interpretation for Prolog, "" in Proceedings of the IEEE Fourth International Conference on Computer Languages, 1992. [26] B. Van Hen tenryck, ""Optimization techniques for Igeneral purpose fixpoint algorithms: practical efficiency for the abst ract interpret ation of Prolog,"" in Proceedings of the IEEE Fourth international Conference on Computer Languages, Lecture Notes in Computer Science 72.4, (New York), Springer-Verlag, 1993. [27] N."
Semantics of constraint logic programs with optimizationThese restrictions are not severe, resembling those used in most Prolog implementations. 7. RELATED WORK The declarative semantics negation by Kunen [1987] Of course, the implementation is still sound. is based on completion semantics developed for for logic programs, and extended to constraint logic programs by Stuckey [1991]. proposed by Naish [1986] Our operational semantics is related to that for negation and aggregation, in that optimization subgoals must delay until their global variables have a fixed value. Rep. 1989-21, CIS Dept., Brooklyn NAISH, L. 1986. Negation and Control in Prolog. Springer-Verlag, New York. SIMONIS, H., AND DINCBAS, M. 1987. Lecture Notes in Computer Science, vol. 238. an extended Prolog for digital circuit design. In the IEEE International Workshop York, 165-188. on AI Applications to CAD Systems for Electronics.
Hy+: a Hygraph-based query and visualization systemCurrently, there are three back-end query processors which are part of the DB Backends componenh LDL [NT89], Coral [Ram 92], and a previously developed GraphLog interpreter implemented in Prolog [Fuk 91]. Hygraph Layout The result of the query described in the previous section is displayed in Figure 4. PhD Thesis Proposal, 1992. Milan Fukar. Translating GraphLog into Prolog. Technical report, Center for Advanced Studies IBM Canada Limited, October 1991.
Teaching AI: a breadth-first approachThese are: History of AI Programming in (Common) Lisp Knowledge Representation Pattern Matching Search Strategies Language Understanding image Understandhg Logic and Inference Expert Systems Problem Solving Robot Systems Learning Paradigms Programming in Prolog Special Architectures Philosophical and Social Issues Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. Until the early 1980s, most of these were in the area of such as: Newell and Simon's General Problem Solver GPS (1957), McCarthy and others implementation of LISP (1958), Samuel's Checker Playing program (1963), Feigenbanm's work on DENDRAL and the creation of expert systems (1965), the development of Prolog and Smalltalk (1972), Lenat's Automated Mathematician (1982), the Hillis Connection architecture (1985), and Lenat's Cyc encyclopedia (1992).
"Review of ""Computational phonology: a constraint-based approach"" by Steven Bird. Cambridge University Press 1995.C is used for the construction of models to satisfy the constraint system and Prolog is used to drive the search for solutions, this strategy is becoming more popular with the need for coroutining constraints, and will be further facilitated by SICStus Prolog 3.0, which builds in the architecture described by Bird."
Summary of ACM/ONR workshop on parallel and distributed debuggingDARTS traces events at runtime, collects the traces after execution into a Prolog fact database including real-time time-stamps, and supports analysis via Prolog queries. Bill Weihl asked about the size of the event traces and the performance of Prolog, and Frank replied that Prolog was indeed slow (five minutes is typical), that they had not yet spent effort on reducing trace sizes, and that currently they were generating two megabytes of trace per minute.
Teaching introductory AI from first principlesSeveral options have been tried in developing the programming component of the course: no programming at all, the rudiments of both Lisp and Prolog, Prolog only, and Lisp only. The class has had access to a variety of IBM-compatible PC's, Apple, and Macintosh computers.
An undergraduate research and mentoring program in computer scienceBranch considered projects in this area written in both C and Prolog in order to understand various approaches. Nakesha Gully's research focused on Software Engineering and Fuzzy Set Theory. Moore was able to physically work on a pole and cart system at Notre Dame University. Ms. Gully learned Prolog at her summer research internship at Loyola University well before she would have experienced it as an undergraduate.
DATR as a lexical component for PATRNevertheless, DATR theories like (4) may themselves reflect different evaluation strategies (just as different search strategies may be implemented in pure PROLOG, independently of the particular PROLOG implementation).
A constraint-driven system for contract assemblyThe following is an example of the representation of the generic document based on the model-form contract outlined ezrlier [IEE 1988]: generic ( ` IEE MF/2 ` ) . document_parameters ( ` IEE MF/2 ` , [ $Engineer] ) part( `IEE MF/2' , `Definitions and Interpretations' , c ) part ( `IEE MF12' , `Assignment and Sub-Contracting' , o) part( `IEE MF/2' , `Time for Completion' , c) section( `IEE MF12' , `Time for Completion' , `Extension of Time for Completion', 1, [1). section ('IEE MF/2' , `Time for Completion' , `Delays by Sub-Contractors', 2, [1). text_file('IEE MF/2', sect( 'Time for Completion' , `Extension of Time for Completion'), 1,[], tfl). text_file('IEE MF/2', sect( 'Time for Completion' , `Extension of Time for Completion'), 2,[], tf 2). (This is standard Prolog syntax. The layout is simply to aid readability). (Notice that this simple language is quite expressive already specification of constraints may be subject conditions, expressed by Prolog clauses of the form: f orces(DocType, A, B) :- and likewise for incompatible and exclusive_or.) AN EXAMPLE OF A DRAFTING SESSION This section provides a sample session of the drafting program and illustrates how the representations are used. The program is implemented in MacProlog: Prolog allows for efficient prototyping and is ideal for implementing the constraint checking component.
Modular acyclicity and tail recursion in logic programsIn Section 3, we consider cases where top-down without memoing beats magic set bottom-up meth ods because intermediate predicates are not fully computed. In some cases, top-down Prolog-style evaluation effectively applies tail-recursion elimina tion. So far, the examples where savings sets are achieved have been right grams, so that right-linear optimization NRSU89a, Ul 189b] could have been magic tem over magic linear pro [NRSU89b, applied. In fact, it is noted in [Ul 189b] that Prolog applies tail-recursion optimization for programs. In Proceedings of the Sixth International Conference on Logic Programming, 1989. P. Cholak. Post correspondence problem and prolog programs. manuscript, Dept. of Mathematics, University of Wisconsin, 1988.
Efficient top-down induction of logic programsThese clauses are extended forms of function-free Horn clauses in that the body literals may be negated, where the meaning of negation accords with the Prolog convention. There is an option to exclude such negated literals if the user wishes. As the evaluation involves determining the extensions of each tuple, it is straightforward (with the Prolog meaning of negation) to evaluate the negated form of a fiteral while evaluating the unnegated form. In Proceedings of the Third International Workshop on Inductive Logic Programming: 1LP'93, pages 1-10. J.Stefan Institute, 1993. [3] I. Bratko. Prolog Programming for Artificial Intelligence. Addison-Wesley, 1986. [4] R.M.
"Rule-based process servers for software development environmentsFor example, MARVEL' S backward chaining i s nonbacktracking, but we expect to be able to implement Prolog-style backtracking [11] as an alternative backward chaining type . This would raise questions about the generality of ou r ""assembly language"", because Prolog's chaining model involves backtracking and the MS L chaining model, although it includes backward chaining, has no backtracking . This effect should be filtered out of the evaluations that we have discussed. [13] [14] [15] [16] [17] [18] [19] [20] [21] Programming in Prolog . Springer-Verlag, Berlin, 1981 . Wolfgang Deiters and Volker Gmhn ."
An OBJ3 functional specification for boundary representationFinally, uea double the embedding of simple edges if necessary. prototype in Prolog and programmed. Transformations are carefully done with systematic rules. A kernel of about 250 hierarchized principal operations is algebraicly specified and prototype in Prolog [11] and 0BJ3. The development is done in C language with very simple data structures, pointers for darts and G-maps, and sequential files for back-up, on a Silicon Graphics 4D workstation. We are now carrying on this way with a project of B-rep geometric 3D modeler, where do interact algebraic specifications, rapid prototyping in 0BJ3, Prolog, and programming in C [3]. From the mo deiing point of view, the algebraic specification techniques are quite able to formalize, abstract, build and prove.
Termination detection in logic programs using argument sizes (extended abstract)The question of whether a set of logic program rules, when executed in a top-down, left-to-right fashion (the Prolog algorithm), is sure to terminate haa received considerable study. Appendices address various technical points. with other We assume familiarity with the view of a knowledge base as a relational database, together with a collection of logical rules with a Prolog-like syntax. The collection of all rules for a predicate p is called the logic procedure for p. Most of the implementation for termination detection is already done in Prolog. The required imported feasibilt y constraints are taken as input, but are not automated, there is still much work to be done in this area.
Interfaces and extended MLThis module system can be adapted for use with a wide varietyof programming languages, for example, see [SW92] for an SML-inspired module system for Prolog. In a similar way, it is possible to adapt EML for use with differentprogramming languages. Wallen. A calculus for the construction of modular Prolog programs. Journal of Logic Programming 12:147-177 (1992).
Dynamic specialization in extended functional language with monotone objectsThese works may be considered as dealing particular cases of monotone objects. Logical evalu with variables in Prolog are implicit monotone objects. Concurrent Prolog [Shapiro 1986 ] is, in fact, a functional with the same data. language The paper [Gifford & Lucassen 1986] suggests, bridizing functional and imperative conceptes hy in one programming language, to mark subroutines ing to one of the four sublanguages ranging functional to full-scale imperative one and as belonfrom pure to check statically sublanguage invariantes, in particular, idempotency. Huges Springer-Verlag, pp. 157-169. [Shapiro 1986] E. Shapiro. Concurrent Prolog: gress report. Computer 18, 8 (August 1986), 58. eds., a propp.44- [Stepanov 1981a] A.
Toward automation of generating incremental computation mechanismsUPDATE The implementation running time complexity measure is given as a function T which given a computation program and an input returns an integer representing the running time such as PROLOG logical inferences or the computer CPU's clocks. The worst case occurs when an input update makes a totally di erent input to compute. 3 Datalog Programs In this section, the incremental computation schema is used to analyze Datalog programs 7]. Syntactically Datalog programs are Prolog programs whose clause arguments are restricted to constants and variables only.
"Review of ""Computational linguistics and formal semantics"" by Michael Rosner and Roderick Johnson. Cambridge University Press 1992.""Unification"" by Martin Kay is a Iucid introduction to feature-based linguistic description, with Prolog examples included. It is additionally interesting for Kay's history of unification-based theories, which he traces not to the use of feature-based linguistic theories but rather to the difficulties of using a single grammatical specification for parsing and generation in ATNs. The theorem prover is put to use in a question-answering system, but the report on the nonsemantic details of the system (morphology, parser, generator) unfortunately leaves little room for the development of a number of intriguing points on the potential and implementation of situation theory for computational semantics. 131 Computational Linguistics Volume 20, Number 1 These concern the Prolog implementation of partial logics, the treatment of quantifiers and questions, and how complete and partial information may be integrated."
Knowledge acquisition and knowledge base refinement problems in developing the KBS legal expert systemThe explanation facilities developd to be used with the KIN System provides a reduced inference chain for the user, and also a display of the jurisprudential concerning the case. 2 The KBS Expert System 2.1 An Overview of the System We will now give a brief overview of KBS system, and then describe its design and operation, includes the explanation facilitities developed for it. expert which The KBS expert system tries to model the legal expert reasoning when it decides under which conditions the Venezuelan Criminal Law should be adjudged to in certain cases. It was implemented in Prolog, specifically Prologm from Borland International Inc. compounded by a file which contains a Prolog Turbo It is program called the KBS.PRO.
Caching transitive closuresTransitive closures can be easily expressed in a logic programming language like Prolog. Each of the following rule sets defines the transitive closure of a graph. Specifically, if the evaluator of the rules has as input the set of pairs satisfying the predicate edge, it can compute and output the set of pairs satisfying the predicate transitive_closure. A Prolog interpreter is one such evaluator. The database community has explored other evaluators, among which are naive and semi-naive evaluation [Banci 1985a].
Communication with directed logic variablesLanguages with atomic unification such as Flat Concur rent Prolog [19], FCP(l, 1) [23], Atomic Herbrand [24], and FCP(: ,?) North American Conference Logic Programming, MIT Press, 1990. [26] A on Shapiro, E., A Subset of Concurrent Prolog, nical Report CS83-06, Weizmann Institute ence, 1983. [27] Tech of Sci Shapiro, E. (Editor), Concurrent Prolog: Papers, Vol. 1 & 2, MIT Press, 1987. [28] Shapiro, E., The Family of Concurrent gramming Languages, ACM Computing 21:3, pp. 412-510, 1989. [29] Strom, R.
An external state management system for optimistic parallel simulationFailure due to a transient of memory would destroy determinism. lack Other possible SMS include: an optimistic 1/0 system with read and write routines which seek backwards truncate a file on rollback, and a data and structure maintenance system that works in a forward and reverse sense. The latter could include data bases, prolog interpreters, in memory hash tables, trees or heaps. Cleary's interests include the application of optimistic synchronization methods to parallel electronic circuit simulation, telecom network simulation parallel logic programming. He is and currently implementing a parallel Prolog called Starlog for use in distributed simulation using the TimeWarp mechanism.
Development and evaluation of an application in a deductive environmentThe programming language interface is a full implementation of PROLOG extended with arrays and global variables and with an integrated set of relational operations. The incorporation of the garbage collector ftdfils a requirement that is fundamental to database systems -continuous operation- which is however not normally supported by PROLOG systems. The efficiency of the system is claimed to be of the same order as that of current commercial relational systems, for the same class of relational operations. In this case the handling of values becomes difficult because a default value -'null' for example- will be treated as a constant by MegaLog (and not as a special kind of value as is the case in relational problems, because PROLOG will match the variables with anything. This means that this `incomplete' insert will be followed by an update (which essentially is a delete and an insert operation) and not by another insertion for the previously unknown values.
"Case studies on testing object-oriented programsGaudel her colleagues [15, 16] have developed a system and in which the specification is written in a dialect of Prolog, a com plexity measure is defined for sequences of operations, and the Prolog interpreter is used to generate of operations of given complexities, sometimes to additional constraints. Kemmerer, cd.), 102, ACM Press, Dec. 1989. 15 N. Choquet, ""Test data generation using pp. 97- a prolog with constrains ,"" in Proceedings of Workshop Sofiware Testing, pp. 132-141, IEEE Computer ciety, 1986. 16 M. on So-Gaudel and B."
Memory, control and communications synthesis for scheduled algorithmsLIMITS OF THIS WORK The schedule on which data-path synthesis depe.nds, is passed to the tool as a database of Edinburgh-Prolog facts, which defines a directed (a)cyclic graph, as well as information about the hardware constraints in force. The synthesis system has been coded in Edinburgh-Prolog, running on a Sun 3/60 workstation. I UllJ --I-- c&b I , Wave 18 Filter (14, 2to1 14 I8 17 29 35 muxes) Ditto: 360 I-I& [g] 26 NA 12 47 (including scheduling) Ditto: Splicer [6] 43 NA NA NA 55 I FDCT I 53 I 31 / 121 33 1 NA 1 180 I Results for Wave filter and FDCT examples 9.
"Diagnosis of power plant faults using qualitative models and heuristic rulesThe model of the EFW supply system is expressed by means of the PROLOG language. The individual components' behaviour is described by the following clauses: % description of one-way directional valve valve(X), ok(X), val( state(X), open), val(pressure(portl(X)), IV) + vaf(pressure(por~2(X)), W). % description of ""t""-connection (there are four such t-connections located at the common header output) Lconn(X), ok(X), val(presszlre(portl(X)), Wl) -3 vaf(press2lre(port2(X)), Wl). tmnn(X), ok(X), vcd(pressure(port2(X)), Wl) --+ vuf(pressu7-e(port3(X)), Wl). tJ2onn(X), ok(X), vul(presswe(port3(X)), Wl) + vul(pessure(portl(X)), Wl). 3A detailed definition of the entropy function can also be found in [.5]. % description of pump P~vw,o~(w, vaf(pressure(port_in(X)), W3) + vul(pressure(port-out(X)), W3). % description of tank tank(X), ok(X) -+ vul(p7~essure(porl_ou.tl(X)), +`). tank(X), ok(X) + vaf(pressu~e(port_out'L(S)),' -I-`). In the current state of the algorithm, the diagnoses process ends when we enter `I', i.e. correct operation, at a measurement point. 5 Conclusion In this paper we have briefly discussed the basic features of a mechanism for representing and using deep knowledge of qualitative nature in the diagnosis of a complex system such as a NPP. The proposed approach has been implemented in PROLOG and is running on a SUN-386 workstation. The program is still in an interactive stage, i.e. the system suggests the next measurement point and we specify the value (`1' or `0', i.e."
Vector prefetchingOriginally, these extensions were targeted towards improving the execution of functional and logic progranuning languages such as Prolog [KP92], but it soon occurred to us that the results obtained therewith could equally well be applied to speed up list and vector processing [GP93]. The overall performance increase of the Livermore kernels shows the significant speedup possible by reducing memory latency. 10 Acknowledgment The original Prolog instruction set extensions which inspired this work were defined by Andreas Kxall.
A new perspective on rule support for object-oriented databasesIt is likely that the environments used by these two systems (C++ and PROLOG, respectively) have been a factor for the approaches. 1.1 Cent ributions In this paper, we take the view that the two approaches outlined above represent two end points of a spectrum, individually, neither approach fully meets the functionality and seamless 1 requirements of rule support 00 database. O& Inmmai Inm.cq an=, Rdadw, No No 1, $& c++ I-9 Plia, m, WIN cot ADAM Illtmnl Iwa-.abj am m W, Yw I Yw PROLOG r Figure 11: Comparison of Active 00DBMS Features. ports complex events, it cannot express this event since it spans two classes. Detection of events is accomplished by using a finite automata. ADAM [DPG91] is an active 00DB implemented PROLOG. Both events and rules are treated in as first class objects.
Introducing undergraduates to object orientation using the Turing languageOur course is actually titled Principles of Programming Languages, but its real pse is to acquaint students with paradigms such as loglc programmi ng (PROLOG), functional programming (LISP), concurrency, etc. The students are required to enhance this program in various ways, for example, so it outputs PROLOG facts cmresponding to the relations among the 00T program's classes.
"Modeling manufacturing systems: an information-based approachSeveral simulation languages based upon AI methodologies have been developed. Adelsberger 111explored the use of PROLOG as a simulation language. ROSS 1111 and KBS ([141, 11511 are examples of simulation languages based upon AI concepts. Several variations of the same type of model, i.e. several simulation models of the same system, and types of models i.e. analytical techniques as well as simulation can be supported. q Supports Use of Existing Software in -- - Modeling Efforts: ISME incorporates simulation languages, commercial data base management systems, and analytical tools to support new modeling procedures, thus, avoiding ""reinventing the wheel."" 111 Adelsberger , H. H. ( 1984 1, ""PROLOG as a Simulation Language ,"" Proceedings of the 1984 WSC, S."
Automated synthesis of interface adapters for reusable classesUnfortunately, unlike (Obj< ), the equality rule cannot be used in a syntax-dlre,ted way (like a Prolog clause) in subtyping proofs. Amadio and Cardelli have worked out an ingenious way to avoid this problem. Another interesting aspect of the Amadio-Cardelli system is that their subtyping algorii$hm is given in the form of a set of deterministic syntax-directed inference rules that are meant to be used like a Prolog program. For instance, the following set of rules constitutes such an algorithm for recursive function types (assuming some atomic types occur as free variables). The rules are meant to be used as a backward-chaining Prolog-like program. deterministic. However, the nondeterministic Unlike the algorithm in [AC91], some of the rules below are not rules are nonrecursive and there is only a finite number of possible matches.
Detection of similarities in student programs: YAP'ing may be preferable to plague'ingPlague is currently applicable to programs written in Pascal, Prolog, Bourne Shell and Llama (a Pascal translator generator), writing versions for each new language requires considerable effort, starting with the construction of a parser for the target language and the selection of distance metrics for use in the second phase. 2. Changing the order of independent statements The example given is rearranging Prolog clauses or reordering goals: Interpreted as rearranging the clauses (i.e. tes) - within a - cond expressi&t `m LISP or rearranging if . . . e 1s e i f ahematives in C or Pascal, this is a problem for YAP and can result in significant differences.
Laboratory projects for promoting hands-on learning in a computer security course. - An interpreted textbook, video and software environment for novice and expert Prolog programmers. International Conference of the Prolog Education Group (PEG'87), Exeter, July 8-12, 1987.
A repository that supports teaching and cooperation in the introductory AI courseThe course covers a diverse and loosely connected array of topic areas, many of which assume that students have facility in mathematics and logic, In addition, students must master new programming paradigms when they learn Lisp or Prolog, as typically - This research has been supported in part through the Educ* tionsl Infrastructmv Program of the National Science Foundation (Grant #CDA-9115254). t Ernail: ingwgiolcis.t emple.edu Permission to copy without fee all or part of this material is granted provided that the copies ara not made or distributed for dirsct commercial advantaga, the ACM copyright notica and tha title of the publication and ita date appear, and notice la givan that copying is by permission of the Association for Computing Machinery. The FLAIR system is available to the stu dents in their laboratory sessions, along with the pro gramming languages Lisp and Prolog. Remote access us ing the X-Windows protocol will be available to Drexel University students in the undergraduate AI course.
"GELEM (version 1.1): a multilingual lexicons management systemsThe proprieties treea associated to the elementary sentence are represented below (Fig. 3) : /\ Oblgatory NG q the standati multilingual vocabulary whose ele ments are part of the system, these are the basic elements of any language: N1 A Obligatory hTG s tax A Determiner N2 Figure 3: Proprieties treea Consequently, o grammar-lezicon ia the ezhandive lid of elementary uentences with the proprieties trees of each its lem""cal enira""es, provided that for a giwen lezical entry, ita OCV ia not reduced to [verb] onlg. We represent a grammar-lexicon by a string of PROLOG predicate, such as: proprieti-tree(Ph(NO ,Nl,... This is why PRA GB contains as many pragmatic dictionaries as fields and languages prvcesaed by the GELEM system. So, a pragmatic dictionary is a setof PROLOG predicates such as: pragmaticntry(bi , pi , si , PI). in which a prngmatic entry is a lexical entry of a pragmatic dictionary."
Processing complex noun phrases in a natural language interface to a statistical databaseA successful parse corresponds to an edge that spans the entire input sentence. The performance of the Prolog parser on sentences (1)-(4) are summarized in Table 1. The tests were performed on a SUN SPARCstation 1 running Quintus Prolog 3.0. 5 Discussion Natural language interfaces to statistical databases are still rare but, with the growing interest in Executive Information Systems and increasing needs of executives to have immediate access to summary (i.e., statistical) 5 0 PROC.OFCOLING-92,NANTI'S,AUG.23-28, 1992
Compiling HPSG type constraints into definite clause programsWe believe that this view would not simplify the overall picture, however. 89 4.3 Implementation and Extensions The compiler as described in the last section has been fully implemented under Quintus Prolog. Our interpreter at the moment is a simple left to right backtracking interpreter. That means that any structure subsumed by a solution is also a solution (as in Prolog, for example). Quite the opposite is the case in Carpenter's approach, where solutions are not guaranteed to have more specific extensions.
The LILOG knowledge representation systemE.g. the following axiom is generated for the declaration of milan: axiom sort_ax_t status (milan) =rogionaX_ tapir a3. 5 Conclusion and Prospect The LILOG knowledge representation system discussed above has been imllemented in Quintus Prolog 4 on a PS/2 system under AIX . We are currently in a status to have a stable version of the entire system so that detailed analyses of the inference behaviour of can be started. Center for the Study of La.nguage and Infirmati,,n, Stanford University, 1986. Quintus Prolog is a trademark of Quintus Computer Systems, Incorporated sAIX is a trademark of International Business Macines, Incorporated 27 SIGART Bulletin Vol. 2, No. 3
Types in Functional Unification GrammarsNote that contrary to structural unification (SU, as used in Prolog for example), FU is not based on order and length. As suggested by the definition of FDs, two types of data-structures can be used to internally represent FDs: a fiat list of equations (which is more appropriate for a language like Prolog) and a structured representation (which is more natural for a language like Lisp).
"The repair of speech act misunderstandings by abductive inferenceThe language lacks explicit quantification, as in Prolog, variable names are understood to be universally quantified. U D i-1 that satisfies the priority constraints and is inconsistent with D i. 16 Poole's Theorist implements a full first-order clausal theorem prover in Prolog. Like Prolog, it applies a resolution-based procedure, reducing goals to their subgoals using rules of the form goal *--- subgoall A • • • A subgoaln. Doctoral dissertation, Department of Computer Science, University of Waterloo. Stickel, Mark E. (1989). ""A Prolog technology theorem prover."" Journal of Automated Reasoning, 4, 353-360."
Rule validation based on logical deductionA rule validation system using the proposed technique has been implemented in Prolog. Key Words: knowledge-based systems, knowledge base design, logical deduction, resolution principle and theorem proving, rule validation. 1 Introduction In recent years, there has been a considerable amount of research on knowledge-based systems having both database functionalities and deduction capabilities. A rule validation algorithm based on SLD-resolution (which is commonly used in Prolog language) has the same problems as the ones mentioned above because SLDresolution is a special case of linear resolution. In selecting a particular resolution method for a rule validation algorithm, the trade-off between the algorithm's efficiency and its completeness must be considered. 6 Implementation Based on the technique described in this paper, we have implemented a rule base validation system in Prolog. The implemented system performs the following tasks: (1) translate all rules in a rule base into the clausal form, (2) perform logical deductions on the clauses using the resolution principle, and (3) detect rule inconsistencies by informing the user whether the rule base is inconsistent, which rules are involved in deriving a contradiction, and what input facts can cause the contradiction.
GENOA: a customizable language- and front-end independent code analyzerIn addition to a CFG parser-generator (or syntax-directed editor-generator), they provide ways of implementing semantic processing. The Pan system uses a PROLOG-like rule based method for propagating semantics (type information etc), the CENTAUR system has two methods, one based on a tree manipulation language (VTP) and the other based on a naturaldeduction style semantic specification (TYPOL), the Synthesizer Generator uses attribute grammars, while GANDALF uses a special-purpose language called ARL to manipulate abstract syntax trees. In a paper in this conference [8], Consens et al describe an application where they use Graphlog, a graphical database query language, for querying a Prolog database containing information about software. Of course, first a parse tree would have to be translated into a Prolog databaseg. We are currently analyzing the exact relationship between Graphlog and GENOA.
"Staging transformations for abstract machinesFinally, the task of mechanically defining an abstract machine has also been considered for Prolog [l 01. This work""L, uses partial evaluation to simplify a Prolog interpreter (writ ten in Prolog) in which operations such as unification have been made explicit."
"Bidirectional incremental generation and analysis with Categorial Grammar and indexed quasi-logical formOur QLF contains the same kind of information as this, encoded in a ""flat"" representation comprising a set of first order Prolog terms. The flat QLF notation means that the planner need not 'know' about the syntactic form of feature structures as defined by a particular grammar, but simply decide which grammatical constraints hold of each logical element's realisation. The top-level procedure is stated as follows in Prolog: generate (--Syntax: Semantics, Text ) :- abolish(edge, i), generate lex lookup(Semantics,Word,Syn,Sem), acceptable (Sem, Semantics, Compl ), add_edge (Syn: [Word IR ]: R: Sem: Compl, Word). generate (Syntax :-semantics, Text ) :- ede(Sntax:Text: []:_: [] )."
CLOS: integrating object-oriented and functional programmingPattern-Directed Invocation Tradition The pattern-directed invocation tradition is characteristic of backward chaining rule languages, such as Prolog [5]. Pattern-directed invocation provides a means for the programmer to describe the arguments on which a particular clause of a definition is to operate. PlGURII S Object-Oriented Symbolic Differentiation Dimensions of Object-Oriented Languages message-centrlc operatlon-centrlc class/type-centric Smalltalk C++ virtuals (::LOS Fortran/C++ overloads object-centric Self Prolog Actors Data-driven COMMUNICATIONSOFTHEACM/September 1991/Vo 1.34,No.9 31 The first dimension is whether the selection of the implementation occurs at compile time or at run time. Surv. 17 (4), 1985, pp. 471-522. 5. Clocksin W.F. and Mellish, C.S. Programming in Prolog, Third Ed., Springer-Verlag, 1987. 6. Ducournau, R. and Habib, M.
Inversion and metacomputationIt becomes even more evident when a program is in tended to be an object for manipulation. As far as I know, only cut-free subsets of Prolog were considered .asobjects for partial evaluation uller,Abramsky 88, Kursawe 88]. Thk algorithm was called Urzi versal Resolving Algorithm (URA) [Turchin 72]. In Prolog like terminology, this is a breadth-first search in the compu tation tree. Shomam,D.V.McDermott. Directed Relations and Inversion of Prolog Progr
End-user knowledge manipulation systems: the speech knowledge interfaceSKI provides a method for the graphical description of features of spectrograms, and for constructing rules which may then be tested and refined. The features and rules are translated into a Prolog representation which is hidden from the user. Our implementation of EUKMS represents an environment for the acquisition and refinement of phonetics expertise by the use of graphical interface techniques whereby the domain expert of figure 1 is embled to be her own KE, and there is an interface to the knowledge base and control strategies. Conjunctions and disjunctions of statements are possible and complicated logical structures may bc created. Rules are compiled into an internal Prolog representation for execution. A limited number of semantic checks at this stage protects the user from errors arising from badly formed rules by refusing to parse the rule, and indicating the probable cause of the problem.
Towards situation-oriented programming languagesIt is a declarative language in which both programs and data are just sets of declarative elements. This feature makes PROSIT akin to PROLOG, but PROSIT is based on situation theory [1, 2, 6] instead of Horn clauses. One can assert infons and make queries about them. Unlike PROLOG, all infons are local to situations. For example, to sert the infon mentioned above in situation sitl the following expression is used: (! Functional languages are motivated by A-calculus (e.g., LISP), logical languages are based on first-order logic (e.g., PROLOG), and object-oriented languages are mainly 35 built upon the concept of inheritance (e.g., Smalltalk).
Bridging the gulf between code and behavior in programmingA notable exception has been the Open University in England, which has long been a source of innovative programming environments. The Transparent Prolog Machine [5] provides an innovative graphical view of program execution, and an interface carefully designed with Prolog's more complex execution model in mind.
Gemini: a natural language system for spoken-language understandingSorts are located in a conceptual hierarchy and are implemented as Prolog terms such that more general sorts subsume more specific sorts [16]. Many systems [4],[9],[20], [22] have added robustness 1Gemini is implemented primarily in Quintus Prolog version 3.1.1. All timing numbers given in this paper were run on a lightly loaded Sun Spaxcstation 2 with at least 48MB of memory.
Comparing two grammar-based generation algorithms: a case studyThe resulting parser or generator is TD but not LR with respect to the original grammar, however, the new grammar is evaluated TD and LR (i.e., using a standard Prolog interpreter). As a part of the node reordering process EAA calculates the minimal sets of essential arguments (msea's) for all literals ha the grammar, which in turn will allow to project an optimal evaluation order. [GM89] GAZDAR, G., and MELLISH, C. 1989. Natural£zmguage Processing in Prolog. Addison-Wesley, Reading, MA. [K90] KAY, M. 1990.
"Teaching some modern functional programming concepts: an approach based on an extended FP-like languageThis is quite true and i t explains why students, already attended an ""Artificial Intelligence"" course (wit h extensive use of Lisp and Prolog) find i t easier to get acquainted with the element s of FP* and to write simple programs . This is not the case i n purely descriptive languages as FP* . Mos t of the dialects of Lisp and Prolog , however, include imperative primitives an d often tracing the operational behaviour o f a program is the only way to understan d and debug it ."
Book Review: DLP- A Language for Distributed Logic Programming by A. Eliens: (John Wiley and Sons, 1992)The first provides motivation for the choice of constructs, the second is theoretical and specifies the language semantics, the third contains a Prolog interpreter for DLP. The book fulfills its purpose, but it is of interest mostly to specialists.
Integration of an expert system for analogue layout synthesis into a commercial CAD frameworkWhen constraintsand/or specifications are not met, it establishescorrectiveactionsto be taken by the managerand layout agents. The systemhas beenimplementedin Prolog and interfaced to the CADENCE framework, all necessaryfunctionality for assessingthe standardtools is implemented in the interfaceto the CAD framework as a set of proceduresin SKILL (the CADENCE interfacelanguage).
Constraint-based Categorial GrammarTo implement this delayed evaluation strategy, we used the block facilityof Sicstus Prolog. For each recursive constraint, a block declaration defines what the conditions are under which it may be evaluated. Fernando C.N. Pereira and Stuart M. Shieber. 1987. Prolog and Natural Language Analysis. Center for the Study of Language and Information Stanford.
Off-line optimization for Earley-style HPSG processingThe Automatic Generation of Mode Declarations for Prolog Programs. In Proceedings of the Workshop on Logic Programming and Intelligent Systems, Los Angeles, California, USA. In New Generation Computing, volume 13, number 2. Pereira, Fernando and Stuart Shieber. 1987. Prolog and Natural Language Analysis. CSLILecture Notes, number 10.
Systemic classification and its efficiencyUnfortunately the only generally applicable mapping that Mellish is able to offer has unpleasant properties, producing large terms whose internal structure has little in common with the structure of relationships between the descriptive feature labels used in the network. 4 Although the terms produced by the brute force mapping are spectacularly large, our main objection to 3 For most purposes this latticeis the same as the recursivelydefinedspace of terms used by PROLOG, but for a technicalintroduction see (Reynolds 1970). 4 The terms produced representclassesof objectsby a technique little differentfrom exhaustive enumeration. 383 Computational Linguistics Volume 17, Number 4 this approach is the loss of transparency associated with the mapping. The parsing system adopts a different, but in essence equivalent, approach, building PROLOG terms as the output of the first stage, then compiling the alias rules into clauses of a procedure that attempts to find a consistent substitution for generated features. Pereira, Fernando A., and Shieber, Stuart M. 408 Volume 17, Number 4 (1987). Prolog and Natural Language Analysis. CSLI Lecture Notes No. 10.
The RHET systemRHET runs on Symbolic Lisp machines and in Allegro Common Lisp on SUN workstations At first glance, RHET is a horn-clause based system. In fact, one could encode and run any basic PROLOG program in RHET. While this may be the way the system is used on occasion, and it does provide the user with considerable flexibility in designing their own representation style, the typical RHET application spends much of its time in the specialized reasoners rather than doing backward chaining. RHET provides three different control strategies that may be mixed as desired: • Backward Chaining: RHET will operate just as a standard topdown backtracking PROLOG interpreter, • Forward Chaining: RHET may use the horn clauses to specify the equivalent of antecedent theorems.
A common query interface for multilingual document retrieval from databases of the European Community Institutions (abstract)Gregory & Chun Sheng Li University of Huddersfield, England Henrik Zangenberg Prolog Development Center A/S, Denmmk The move to a single market for the membm of the European Community has provided a focus for effon.s that w intended to ovemome the barriem of language, especially in the workings of the European Community Institutions.
The LyriC language: querying constraint objectsExisting DBMS do not deal with and manipulate con straints as stored data. Constraint Logic Programming [JaL87, CHIP, Prolog 3] on the other hand was not de signed to deal with large amounts of stored data, and support spatio-temporal features. (A preliminary [KKS92] [KLW90] [KS93] [LMA] [LS92] [MFPR] [OrM88] [Prolog 3] [Sch 86] [Sri 92] [SrR92] [SRR94] version appeared in Proc. 9th PODS, 299- 313, 1990.) Manola, PROBE spatial data modeling and query processing in an image database application, IEEE Trans. on Software Engineering 14, 5, pp. 611-629, 1988. A. Colmerauer, An Introduction to Prolog 3, (7ACM, 33:7:69-90,1990. A. Schrijver, Theory of Linear and Integer Programming, Wiley 1986.
Validation: the key concept in maintenance of legal KBSIn order to prevent any more mistakes being made fkom this stage on (while pqyarnming), a Prolog-code generator is used. This yields the source code, which in combination with the shell of D. This kind of validation was done before the system was genemted. Making the Prolog-code and a new executable file is a matter of minutes.
Towards computer-aided linguistic engineering.): LIFE subsumes the two main programming paradigms (logic programming, as in PROLOG, and functional programming, as in LISP or ML). In generating NLP parsers or NLP generators, the user will have to choose between a functional control structure (as in ML) or a relational control structure. as in PROLOG. For the latter, additional choices have to be made, such as the ordering of clauses, the introduction of cuts, etc.
"Translation by Quasi Logical Form transferFor short sentences typical of the car hire domain, median total processing times for analysis, transfer and generation are around ten seconds when running under Quintus Prolog on a SUN SPARCsttion 2. We are currently investigating a different QLF representation of Iense, aspect and modality which should increase the transfer compositionality for the operator cases we have discussed in this paper, as well as allowing more flexible resolution of temporal relations in applications other than translation. McCord, Michael C. (1988) '% Multi-Target Machine Translation System"", Proceedings of the International Conference on Fifth Generation Computer Systems, Tokyo, pp. 1141-1149. McCord, Michael C. (1989) ""Design of LMT: a Prolog-based Machine Translation System"", Computational Linguistics, Vol. 15, pp. 33-52."
"On finding the closest bitwise matches in a fixed setIt is important that we This work was sponsored in Arpa order 4871, monitored part by the Defense Advanced Research Projects Agency (DoD), by Space and Naval Warfare Systems Command under contract NOO039-84-C-O089, and in part Additional support was provided by the National Science Foundation under grant CCR-8812843. by an equipment grant from IBM, and matchmg funds were provided by the State of California's Authors' address: Department MICRO program under grant 88-059. of Electrical Engineering Computer Science, Umversity of Cali fornia at Berkeley, Calif. 94720, Permission to copy without fee all or part not made or distributed for direct of this material is granted provided that the copies are commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. specific permission @ 1991 ACM 0098-3500/91/0300-0088 To copy otherwise, or to republish, requires a fee and/or $01.50 can narrow down the likely match candidates accurately this table-lookup method viable. 1.1 Similar Algorithms There are algorithms for similar types of data query. fundamentally dleal with bit-vectors, since any given and rapidly to keep Many such algorithms datum in a database is ultimately represented and database may ccmtain facts manipulated as such. For instance, a Prolog such as ""father(john, mary)"" and ""mother(mary, joe). "" These may be represented ment, directly as ASCII strings, as ""father(john, -)"", where the partial-match query, and many answering partial-match queries. target vector fcw a partial-match don't-care bits. .A query type as bit-vectors, whether by symbol intern or some other means. A Prolog query [6] such ""- "" is a variable to be filled in, is called a data structures exist to solve the problem of This problem differs from ours in that the query consists of exact-match bits and which is more closely related is the pure best match query, which looks for all the distance less than some given bit-vectors in T that have a Hamming Hamming distance d, and is related to error correcting codes."
Integrating the heterogeneous control properties of software modulesWhereas earlier we demon strated how the producer and consumer modules could be modified manually to interface to an underlying message-passing environment, these would be packaged by our system via the command Ceres polyf ile. c1 round-robin .p which causes information to be extracted from polyf ile. c1 and roundxobin. p and to be rewritten as prolog rules. These prolog rules are input into a pro log inference engine that decides what the structure of the application should be and where stubs will be nec essary.
Gemini: a natural language system for spoken-language understandingSorts are located in a conceptual hierarchy and are implemented as Prolog terms such that more general sorts subsume more specific sorts (Mellish, 1988). Table 2 contains average edge counts and parse timing statistics 1 for the 5875-utterance training set. 1Gemini is implemented primarily in Quintus Prolog version 3.1.1. All timing numbers given in this paper were run on a lightly loaded Sun SPARCstation 2 with at least 48 MB of memory.
Paramax Systems Corporation: description of the Paramax system used for MUC-4Total processing time including non-CLIPS processing (PERL preprocessing and PROLOG template generation) is 3 2 hours for the TST3 data set . 6 We did not remember to actually write down the date we started . Except for the template generator, which is written in Prolog, the Paramax MUC-4 system has bee n built using freeware (PERL and CLIPS) .
"The BACK system—an overviewFor a better use of this language interface tools on a Hypercard basis have been developed which support constructing complex language expressions in an easy way. a° The direct mapping of queries simply put together in a ""clicking"" environment onto a complex BACK query, and the mapping of the BACK query onto a quite complex SQL query is a nice example of how the goal of a practical use of BACK has been approached. 3.3 Implementation The current implementation of BACK consists of about 20000 lines of PROLOG code. The use of this programming language has mainly historical reasons, but there have also been advantages in terms of rapid prototyping and portability. One reason for this is the lack of destructive assignment in PROLOG, and the fact that searches are often performed where simple lookups (via pointers or arrays) would suffice."
Operational semantics-directed compilers and machine architecturesUsing our compilers and executors are guaran operational semantics. defining an abstract machine has also been considered for Prolog [Kursawe 1987, Nilsson 1993]. These works use partial evaluation and similar (written in Prolog) in which explicit. To reduce the size techniques to simplify a Prolog interpreter operations such as unification have been made of the residual interpreter new instructions or predicates are manually in the interpreter. Realistzc Compiler NIELSON, H. R. AND NIELSON, F. a prolog machine. New Gen. Comput. 5, 1,97-114. evaluation of expressions.
A language based multidatabase systemDesigned for the multidatabase arena, it aims to make the interoperation of legacy systems possible, providing at the same time high level programming and the declarative style associated with Prolog. Influenced by the Flex Transaction Model [1], the VPL system provides transactions on world- wide shared objects, termed communication vari ables, at the language level.
Quantifier scope and constituencyThen we give a brief analysis of available readings (§3), a generalization of the analysis (§4), and finally describe a computational implementation in Prolog (5). 2 Traditional Approaches All three paradigms of grammar formalisms introduced earlier share similar linguistic judgments for their grammaticality analyses. An implementation of the theory for an English fragment has been written in Prolog, simulating the 2nd order properties. There is a question of how the non-standard surface structures of CCG are compatible with wellknown conditions on binding and control (including crossover).
Higher-order linear logic programming of categorial deductionThe first order case, naturally, corresponds to Prolog. Let us assume a set ATO./t4 of atomic formulas, 0-ary, 1-ary, etc., formula constructors {' A... The treatments for the calculi above and their multimodal generalisations have been implemented in Prolog (Morrill, 1994a). van Benthem, Johan: 1983, 'The Semantics of Variety in Categorial Grammar', leport 83-29, Department of Mathenlatics, Simon Fraser University, also in Buszkowski, W., W.
Communications approaches for simulation-AI interactionsIn addition, a graphical interface is provided. 2.1.2 Using AI to Build Simulation Environments Implementing modeling and simulation with AI includes: 1)Developing generalmodeling and simulation tools using concepts and languagesfrom AI. ROSS, KBS, SimKit, TS-Prolog, STEM are well-known examples ( Wang and Bell, 1992 ), 2)Developing special-purpose modeling and simulation tools using concepts and languagesfrom AI. For example, Wang and Bell developed a system to help users model and simulate flexible manufacturing systems ( Wang and Bell, 1992 ), 3) Implementing simulation languages using AI languages and systems. Radiya and Sargent used PROLOG to implement their LOgic Programming Processor for Simulation ( LOPPS ) ( Radiya and Sargent, 1987).
Parallelizing algorithms for symbolic computation using MAPLEAfter the the test mo dify part we may (like in the well known Concurrent implementation of the Sieve of Eratosthenes [Shapiro, append some of the tested values to our set in order Prolog 1987]) to use it for testing the rest of the input. [Shapiro, 1987] Ehud Shapiro, editor. Concurrent Prolog, Collected Papers, Volumes 1 and 2. MIT Press, Cam bridge, Massachusetts, 1987.
“Dynamic” inferencing with generalized resolutionBINARY RESOLUTION Binary resolution, in onc of its myriad forms, is at the hcwt of most modem inference enginca and logic programming translators (e.g., Prolog, Parlog,ctc.). In ita simpkst form, binary resolution relies upon a single rule of inference - a genemlization of the law of disjunctive syllogism (from formulas of the form A v B and -A we may conclude B), the geneml form of which is: AvB1v... vBkAvCjvjv C1.vC1 ----._-- Bl v... vBv C,v... vCl for atomic formulas A, Bi,Cj, 1 Sisk and 1 Automatsd resolution was fmt suggested by Robiison later incorporated into the kernel of the high-kvel [8] and programming language Prolog by Colmcrauer and Kowalski discussion, see [SJ.
TACITUS: research in text understandingInferential Pragmatics Processing: An inference component, based on the Prolog Technology Theorem Prover (PTTP) has been developed and refined.
Literal movement grammarsUnification is an expensive operation, and pinpointing its precise role in NLP may give access to more efficient treatment of language than in most (Prolog-based) scientific applications known today. The second motivation is the desire to apply popular computer-science paradigms, such as the theory of attribute grammars and modular equational specification, to problems in linguistics. These formal specification techniques, far exceeding the popular Prolog in declarativity, may give new insight into the formal properties of natural language, and facilitate prototyping for large language applications in the same way as they are currently being used to facilitate prototyping of programming language tools.
Horn extended feature structures: fast unification with negation and limited disjunctionIndeed, they form the basis for the programming language Prolog (Sterling and Shapiro, 1986) and the database language Datalog (Ceri et ai., 1989). Sterling, Leon and Shapiro, Ehud (1986), The Art o] Prolog, MIT Press. Wedekind, Jfirgen (1990), A survey of linguistically motivated extensions to unification-based formalisms, Deliverable R3,1.A, DYANA. 38
Query evaluation in deductive databases with alternating fixpoint semanticsCONCLUSION Allowing first-order formulas in in C using a Prolog-C interface [Ramesh should be further explored for query logic programs makes it easier and more natural to express rules and queries. AND TOPOR, R. 1985, (July), 93-1o9. LLOYD, J. AND TOPOR, R. 1986. 55-67. Making Prolog more expressive. J. Logic Program. 1, 3 (Oct.), A basis for deductive database systems. Controlling the search in bottom on Logic Programmmg, 273-287. of integrating SLG resolution into Prolog systems. In International Logic Programming Symposwm (Nov.).
"Integrating ""free"" word order syntax and information structureThe context-appropriate use of ""free"" word order is of considerable importance in developing practical applications in natural language generation, machine translation, and machine-assisted translation. I have implemented a database query system in Prolog, described in (Hoffman, 1994), which uses Multiset CCG to interpret and gen: crate Turkish sentences with context-appropriate word orders. The formalism has been implemented within a database query task in Quintus Prolog, to interpret and generate simple and complex sentences with context-appropriate word orders."
An alternative conception of tree-adjoining derivationAs a proof of concept, the parsing algorithm just described was implemented in Prolog on top of a simple, general-purpose, agenda-based inference engine. Encodings of explicit inference rules are essentially interpreted by the inference engine. The Prolog database is used as the chart, items not already subsumed by a previously generated item are asserted to the database as the parser runs.
CoLa: a coordination language for massive parallelismCorrespondents are defined logi cally, sets of correspondents can be computed during runtime of an application using PRoLoG-like declara tive rules. The expressiveness of the rules can be uti lized to define abstract communication topologies Ii&e rings, trees or hyper-cubes.
The use of meta-rules in rule based legal computer systemsImplementational Details: The approach described above has been implemented in Prolog in a system running on a PC. The system consists of (1) A rule-base, (2) a meta-rule base,(3) a solution engine, (4) a legal reasoning engine, and (5) a common-sense knowledge-base, The use of Prolog is extremely convenient, as both rules and meta-rules may be expressed in the same manner and applied at the same level, i.e., use the same theorem prover (see &lowen 82]).
Generation from under- and overspecified structuresAs it turned ont, even for ulediuul sized grallllnars it Call beconle quite dill)cult for a linguist to debug the grammar if there is only a debugger available which had been develolled for the generM l)urpnse programming language the system is inq)lemented ill, e.g. prolog. 3 Terminology The alger)tirol has been devehlped for grammars written in the Ll.' It has been shown, that the algorithm provides information which allows in ease of failure to produce debugging information in terms of the target grammar, rather than in terms of the programming language the algorithm is iml)lemented in. The algorithm is implemented in PROLOG in the edinburgh syntax. Currently the implemention of the delmgging meehmfisms is incomplete.
The Ada mandate as a threat to national securityAda is as obscure as niche languages such as Lisp, Prolog, Forth, and Smalltalk - even less so if Mandated sales are not counted.
State abstraction and modular software developmentWe have tested a wide variety of C implementations, using drivers written in C [10] and Prolog [13]. Recent work uses a testgraph-a simplified version of the full MSM-to generate inputs and provide the test oracle [14, 15]. - 8 Conclusions We have presented the state-abstraction lattice (SAL), and shown that it provides a good mathematical model. Hoffman and P.A. Strooper. Automated module testing in Prolog. IEEE Trans. SOB. Eng., 17(9):933-942, September 1991. [14] D.M.
Widening the representation bottleneck: a functional implementation of relational programmingForexarnple, perm could be defied more conciselyas the fold right (foldrin Figure 9)ofnon-deterministic insert: I perm = (insert ,{3 ,Jfoldr j A more substantial example is the Drusilla solution to the 8-queens problem presented in Figure 12. 4.4 Logic Aspects of Drusilla In Prolog relationships between objects are expressed using predicate calculus (a form of relational cab.dus)andande of inference deduces new relationships from existing ones. The conceptual feature rather than is the ability to express relationships between objects at a high while relying upon the system to assimilate them. level The inferencerule is just one assimilation technique for establishing whether relationships hold, while reduction, Dmsilla, is another. as used by Relation level negation in Drusilla is not negation-asfailure aa found in Prolog. Instead the complement of a relation, like the inverse, maybe represented as a characteristic function.
Personal perspectivesKoichi Furukawa, when returning in 1977 from a sabbatical at SRI to Fuchi's group at ETL, brought with him the Prolog interpreter developed by Colmerauer and his group at the University of Marseille-Aix.
Relating complexity to practical performance in parsing with wide-coverage unification grammarsThe through-Although the ANLT parser is implemented in Common Lisp and the CLE parser in Prolog, comparing parse times is a valid exercise since current compiler and run-time support technologies for both languages are quite well-developed, and in fact the CLE parser takes advantage of Prolog's built-in unification operation which will have been very tightly coded. 7The ANLT's speed advantage over CLARE is less pronounced if the time for morphological analysis and creation of logical forms is taken into account, probably because the systems use different processing techniques in these modules. put of this configuration was only one fiftieth of that of the BU-LC parser.
High level synthesis of pipelined instruction set processors and back-end compilersSynthesis example and comparison In thii section we present a synthesis example for an instrr 3c-tion set processor sml. Its ISA specification in Prolog [14] is shown in Figure 7. It is an accumulator-based processor eight instructions. Mar-v. D-i AC_nalb ACA. Figure 7 ISA specification in Prolog: sml 41 1 M 2 2.533-5445S53 6 `r==Y Figure 8 costs of data path and conkol path for sml !
Aslantest: a symbolic execution tool for testing Aslan formal specificationsThe EZ system [VN 91] is an example of the translation approach that can be used to test a subset of the Z language. It compiles Z specifications into C-Prolog prototypes, and the user can run various test cases on the prototype. With this system the user provides a start state and a result state, and the Prolog prototype attempts to use the operations defined in the specification to determine if the result state is accessible from the detined stsrt state.
Integrating information retrieval and domain specific approaches for browsing and retrieval in object-oriented class librariesOur current implement.ation stores informa,tion about cla.sses as a Prolog database, which can be accessed via logical rules which capture the importa,nt relationships between program entities. Currently, the various retrieval and browsing components, are implement.ed in C, C++, Prolog, and Interviews on an RS/6000, but as yet, are not fully integrated with each other and wit.h other tools such as class browsers.
A compiler approach to scalable concurrent-program designThe basic run-time techniques implementation of our fine-grain process model were developed in early 1989] and Strand [Foster work on Flat Concurrent Prolog (FCP) [Taylor et al. 1991, Foster and Taylor 1989] and, for the most part, were copied directly into PCN [Chandy and Taylor 1991]. CLOCSINj W., AND MELLISH, C. 1981. Programming in Prolog. Springer-Verlag, New York. COHEN, J, 1981. Garbage collection 341-367. A sequential abstract machme for Flat Concurrent Prolog. Institute, Rehovot, Israel. KELLY, P. 1989, Functional Programming Cambridge, Mass. for Loosely Coupled Mtdtlprocessors, MIT Press, KESSELMAN, C. 1991.
Dynamic two-connectivity with backtrackingFor example, maintaining 2-vertex connected components (with backtracking) has been proposed as a way to improve search in Prolog [19]. Furthermore, dynamic graphs with backtracking suffice for many interactive system applications like, e.g., CAD/CAM systems and VLSI layout. Union-Find with backtracking is a central problem in the implementation of unification and backtracking search in the logic programming language Prolog. Mannila and Ukkonen [17,18] first formalized and studied this problem and proposed several algorithms which Westbrook and Tarjan[25] subsequently analyzed: each operation can be performed in O(logn/ loglogn) time.
Deductive database support for data visualizationThe current version of the Hy + system, under development at the University of Toronto, implement s GraphLog by mapping visual GraphLog querie s to Horn clauses which are compiled and execute d by one of several deductive back-ends, includin g Prolog, LDL, and CORAL . The rest of the paper is organized as follows . In GraphLog, a term is a one of a constant, a variable, an anonymous variable (as in Prolog) , an aggregate function f E { MAX, MIN, COUNT, SUM, AVG} applied to a variable, or a functio n f applied to a number of terms .
Object-oriented computer architectures for new generation of applicationsIn order to reduce the semantic-gap some researchers tried to build computers based on programming languages such as Lisp[l,7,8], and Prolog[14]. Some computer applications such as simulation[9,10,15] have proven to run very efficiently on dedicated machines. ,Murad, A.H, Jang, K., Atallah, G.C., Karne, R.K., and Campenella, S.L, Object-oriented Hybrid Network Simulation, Technology 2004. [5] Cartel 1, R.G., What are Next Generation Database Systems, Communications of ACM, October 1991, Vol. 34, No.10, p31-p33. [6] Desmonde William H, Computers and Their Uses, 1971. [7] Gene Mathews, et el., Single chip processor runs Lisp environment, Computer Design, May 1987. [8] Hayashi, H., Hattori, A., and Akimato, H., ALPHA: A High Performance Lisp Machine equipped with new stack structure and garbage collection system, 1983 Conference Proeedings on Computer Architecture. [9] Karne, R.K., and Seed, A.K., Feasibility Study: Massively parallel Architecture for Time-based Simulation, Transactions of the Society for Computer Simulation, December 1994, Vol. 11, No. 4, p245-p272. [10] Karne, R.K., and Seed, A.K., PARS: A Parallel Architecture for Rule-based Simulation, Transactions of the Society for Computer Simulation, June 1992, Vol. 9, No. 2, p59-p85. m18m [II] Leland, M.D.P., and Roome, W., The Silicon Database Machine: Rationale, Design, and Results, Database Machines and Knowledge-base Machines, edited by Masaru Kitsuregowa and Hidehiko Tanaka, Kluwer Academic Publishers, 1988, p31 I-p324. [12] Mattison, R., An Object Lesson in MANAGEMENT, Datamation, July 1, 1995, p5 I-p55. [13] Myers, G.J., Advanced Computer Architecture, John Wiley & Sons, 1982, p17. [14] Nakazaki, R., et al., Design of high speed prolog machine (HPM), The 12th Annual International Symposium Architecture, June 1985, p191. on Computer [15] Pfister, G.F., The IBM Yorktown Simulation Engine, Proceedings of rite IEEE, VoI. 74, No. 6, June 1986, p850-p860. [16] Rine, D.C., and Bhargava, B., Objectoriented Computing, Computer, October 1992.
DOODLE: a visual language for object-oriented databasesThe user specifies the layout by giving a set of Prolog terms. Prolog functors represent pre-defined predicates between graphical objects.
Next generation object-oriented programming languages: extending the paradigmMultiple paradigm integration Constraints and dependencies Frames Access orientation Rule-based systems Logic/PROLOG Fuzzy sets Knowledge-based systems Contexts and scenarios Open object-oriented paradigm Extended type systems Meta-classes Notification Dynamic inheritance Flexible inheritance Unified object model High-level objects Concurrent processing Building Systems Environment vs. language Intellectual property rights Re-use Specifications Mega-programming Although the issues outlined above provide some definition of the sub-topics, the group understanding of the definitions was shaped by the discussion and the interests of the participants.
Constraint programming and database languages: a tutorialPerhaps one of the most important advances in constraint programming in the 1980's has been the development of Constraint Logic Programming (CLP) as a general-purpose framework for computations, e.g., in CLP(3?) [46], in Prolog 111 [26], and in CHIP [31, 86]. For more information on CLP see the surveys in [25, 62], and the proceedings of recent workshops on the subject, e.g., [12, 52]. Constraint Logic Programming CACM, 33:7:52-68, 1990. [26] A. Colmerauer. An Introduction to Prolog [27] G.E. Collins. Quantifier Elimination for Languages. 111.
"Towards developing reusable NLP dictionariesThe TFS-compiler is similar to the systems described by [Carpenter, 1990], [Emele and Zajac, 1990], and [I,'ranz, 1990], and like these it constitutes a generalpurpose constraint-based formalism which can be used for a wide variety of tasks, including parsing, translation and generation. Our prototype is implemented on top of Sicstus Prolog, and is used primarily for selection and conversion of data. This has been checked using several Eurotra transfer dictionaries. 9'I'hl 8 program was first hnplentented in Prolog for the Ndict system ([Bloksma et el., 1990]) itnd modified for a Frotetra research group on ""ll.cversibie Transfer""."
Dynamic change in office automation: modeling and analysisTo exploit the pattern matching and backtracking capability provided in Prolog, this prototype is implemented in Turbo Prolog on IBM PC.
Implementing TelosThe features of the language which were proved important in this application were the ability to cxpress structural descriptions of an application domain, the deductive capabilities and the ability to represent and reason with temporal information. A Prolog prototype implementation was developed and demonstrated in the LOKI project. Recently, Telos has been used to express knowledge atxmt software in the logical design of a software information base (S1B) designed to support software reusability as part of the ESPRIT [I project ITHACA [CJM89]. All of the above applications are based on Prolog implementations of substantial portions of the language.
Monological reason-based logic: a low level integration of rule-based reasoning and case-based reasoningThe description of MRBL this paper is informal and necessarily open-ended it focuses on the aspects of legal reasoning that can be modeled in MRBL. The appendix contains a prolog-implementation of a theorem-prover that works according to the rules of MRBL. The research for this paper was partly financed by the Foundation for Knowledge Based Systems (SKBS), which seeks to improve the level of expertise in the Netherlands in the field of knowledge based systems, and to promote the transfer of knowledge in this field between universities and business companies. APPENDIX The following contains a commented Prolog implementation of the classical example of Tweety the penguin that cannot fly although it is a bird.
"Safety and translation of relational calculusIn particular, quantification over subformulas, languages such as Prolog with rela more important that relational query range of relational calculus formulas disjunction, negation, and universal which are excluded from the class of con jurzctiue queries [26], should be available. In the following section, those classes of queries that Evaluation of relational lation into a set of clauses translation into a relational we describe previous attempts to characterize can be answered sensibly. calculus queries can be performed either by trans suitable for a Prolog interpreter [14, 23, 51 or by algebra expression. Taking another approach, Aylamazan that are not domain independent with presented finitely, provided the database involves forming a Dom + relation any range restricted formula into an for Prolog-style ""tuple at a time"" et al. have shown that even queries potentially infinite answers can be relations are finite [21."
Computational situation theoryPROSIT's computational power is due to an ability to draw inferences via rules of inference which are actually constraints of some type. There is an inference engine similar to a Prolog interpreter [57]. PROSIT offers a treatment of partial objects, such as situations and parameters. There have been only a few proposals [17, 33, 40, 46, 52, 59] in this direction, with varying degrees of divergence from the ontology of situation theory. ASTL [17] and PROSIT [52] mainly offer a Prolog- or Lisp-like programming language while BABY-SIT [59] provides a programming environment incorporating situationtheoretic constructs. Common Lisp: The Language, Second Edition, Bedford, MA: Digital Press, 1990. [57] L. Sterling and E. Shapiro. The Art of Prolog: Advanced Programming Techniques, Cambridge, MA: MIT Press, 1986. [58] S.
Mechanisms for generic process supportThis selection was made for mainly rather than technical. reasons q Their formalism satisfied OUI minimum ments. while, we by Peiwei Project at pragmatic, require q They responded promptl (and afirmativel our request for cooperation 3The process community has long recognized that cess formalim should incorporate reflection, a ) to the pro la LISP, PROLOG [1] , etc., to provide a base for process change. cicfentally, it is easier to support genenc processes enactment with such languages. 4 Our process formalism, described in [6, 7], is extension of the AP5. q Not min and partial basically au Finally, their geographical proximity made local expertise readily available. The proposed architecture quite general in its applicability, and can be used with a variety of process formalisms that do not themselves have generic process capability 1 Jf' Clocksiu and C. hlelllsh P7'oyram In 2ng is 211 PROLOG. Springer-Verlag, 1984. [4] hf. Dowson and C. Fernstrom Towards triggers. 1989. require ments for enactment mechaulsms.
A decision-based configuration process modelFig. 6-1: Browsing an implementation model of CMS and available sourcesin CMS 6 Case Study: The Creation of ConceptBaseP The initial version of ConceptBase was implemented in BIM-Prolog and SUNView on SUN workstations. ConceptBasepis a variant running under VMS on a microVAX. The portation of the system seemedto be a suitable casestudy for our approachdue to the following characteristics: l ConceptBaseconsistsof about 130modules with dozens of versions each (the size of an executable configuration is approximately 2 MB of Prolog code). l It exists in several conceptual versions (with or without integrated time calculus, integrity constraint compiler, sourcemanagementfacilities, or argumentationfacilities). l Both versions evolve dynamically and consistently through activities by a teamof about 15persons.
Connecting software components with declarative glueOur glue language, SGL, is a logical language similar to Prolog. It ex presses derived relations in terms of base rela tions. In addition, a procedure would be required to translate changes of the view to changes of the underlying data. Deductive databases [20] use Prolog or DAT ALOG (a simpler logical language) to provide a powerful view definition facility.
Head-driven parsing for lexicalist grammars: experimental resultsBefore discussing the experiment, however, we first discuss the two head-driven parsers used in the experiment, and how they relate to standard parsing algorithms. 2 Two Head-driven Parsers In this section we present two head-driven parsing algorithms. Prolog code for simplifications of the algorithms is included in the appendix. In this compiled version first-order terms were used, rather than feature structures. Furthermore, we used ordinary Prolog unification on such terms rather than the previously mentioned feature unification including occurs check.
"Metapolicies IConference on Economics and Artial Intelligence,Pergamon Press,Oxford, England, 1991. 26 Jay, Chris, ""A BNF Compiler For prolog (Bsc,kus Nanr Form description of programmuqg languages), AI Expert Vol V6, Ju 1991 2'7L.apadula.L J. ""A Multipolicy Model: A Working Paper"", Proceedings of the Fourth RADC Workshop Database Systems, Little Compton, Rhode Jay, Chris, ""A BNF Compiler on Multilevel Secure Island, June 1991. For Prolog description of programming languages), 1991 LaPadula, L.J."
The systematization of legal meta-inferenceThe inference function of meta-level inference itself does not differ from that of the original level infer ence. 1 would like to show the abstract listing of the legal meta-inference engine written in Prolog below. 1 demo(A) :-Jact(A). 2 demo(not(A)):-not(demo(A)). 3 demo(A&13):-demo@), demo(13). 4 demo@ ,B):-demo(A),demo(B). 5 demo(A):- 6 rule(R,[A<-B]), 7 demo(B), 11 get_time_of_event(A, T2), 12 demo@e_valid(_, [ohj:R,goa:A,tim: T2j)). My final target is to formalize the total system of legal rules from a constitution through stat ues to contracts logically, in terms of the validity of rules. Acknowledgment Sequential Prolog) on PSI-II, both of which are developed by ICOT (Institute for the New Generation Computer Technology).
Coordination languages and their significanceGiven some C programmers, Scheme programmers and Prolog programmers, all of whom need to develop parallel applications, we could recommend three independent, tailor-made parallel variants of these languages-for example Concurrent C [16], Multilisp [19] and Parlog [26]. Given this observation, we can outfit all three groups in essentially the same way: we supply them with C-Linda, Schema-Linda and Prolog-Linda. In so doing we make it easier for them to switch base languages, simplify the job of teaching parallelism, and allow implementation and tool-building investment to be focused on a single coordination model.
"Summary evaluation of Russian students learning APL2 at APL92Most were fluent in Pascal and Assembly Language, some knew C and some OOPS (C++), none knew Prolog or LISP, and one remarked that BASIC was ""not real"" (all agreed)."
CSA: two paradigms of the language for adaptive expert systemsRule-based representation of knowledge can be programmed in the form of production rules (as in OPS5) or in logic (as in Prolog).This is caused by the fact that production rules and logic programming are based on the similar if-then construct production rule: clause (inference rule): PRE ACT_POST ACT_POST : -PRE Permissiontocopywithoutfeeall or partof thismaterialis grantedprovidedthat the copiesare not madeor distributedfor directcommercial advantage,the ACMcopyrightnoticeandthe titleof thepublicationand its dateappear, and noticeis giventhatcopyingis by permissionof the AssociationforComputingMachinery.Tocopyotherwise,or to republish, requires a fee and/or specificpermission. © 1991 ACM 089791-382-5/91/0003/0570 $1.50 570 Production-rules and clauses have the same dual interpretation: ff precondition PRE, then postconditon POST, or if precondition PRE, then action ACT, where PRE and POST consist of conjunction of atomic conditions in simple or negated form, and ACT consists of the set of actions. If such assumption were true, what would be the second element, and in which language should it be implemented - in C, Ada, Lisp, Prolog, Occam, or perhaps it should be a complete new one its own CSA-language?
On solving equations and disequationsThe simplification process preserves equivalence A simple example demonstrates in the model or structure. this position well. Pure Prolog is the use of definite clause logic programs SLD-resolution. logic program: transformation process: intermediate solution forms: simplification process: solution forms: model space: In this subsection, we present on the empty equality theory evaluated using definite clauses SLD-resolution existentially quantified conjunctions of equations the unification algorithm substitutions Herbrand models an abstract system for logic programming that uses the full power of disequation processing developed in Section 4. Lazy theory and its applications to induction and redundancy. unification in PROLOG: An extension of the warren abstract machine. In Proceedingsof the 10 German Workshop on Artzficud Intelhgence. Sprmger-Verlag, New York. LLOYD. J. W., AND TOPOR, R. 1984. Making Prolog more Melbourne, Melbourne, Australia. LUtCWLZ, D. 1989.
Integrating parallel dataflow programming with the Ada tasking modelThey have been incorporated in parallel dataflow languages, including Id [7], Val [8], and Sisal [9], and parallel logic programming languages, including Concurrent Prolog [10] and Parlog [11]. Integration of parallel and sequential composition, parallel and sequential for-loops, and single and multiple assignment variables was described in 1977 by Kessels [12]. Technical Report M-146, Lawrence Livermore Na tional Laboratory, 1983. 10 E. Shapiro . A subset of Concurrent Prolog and its interpreter. Technical Report TR-003, ICOT , Institute for New Generation Computer Technology , Tokyo, Japan , 1983 . 11 K.
Object-oriented integration testingThe familiar languages (Fortran, Cobol, C, Pascal, Ada, and assembly languages) are all imperative, as opposed to declarative languages (e.g., Prolog), in which the source statement order has little to do with execution order.
PAC-learnability of determinate logic programsA similar result is obtained for the determinate literals involving q and existential Thus, we have transformed the ILP problem queries. into a propositional form and the learnability under simple distributions of k-clause, possibly recursive, predicate definitions consisting of determinate function-free Horn clauses with variables of depth up to i then follows from the polynomial learnability of monotone k-term-DNF under simple distributions. u It should be noted that the induced recursive definitions may be highly inefficient or even non-terminating cuted by a PROLOG interpreter. Additional if exe information and techniques, similar to the ones used in FOIL, may be used to prevent the construction of such definitions. 6 On the expressiveness of determinate logic programs Despite the number of syntactic restrictions that were imposed on predicate definitions in the previous sections, the class of determinate logic programs includes many interesting and nontrivial concept definitions. support this claim by listing several determinate We predicate definitions that were actually learned by the ILP systems GOLEM and FOIL. Since the clauses are to contain no function bols, a flattened version of the cons function sym symbol is provided as a background knowledge predicate (components(A, B, [AIB])), as well as the predicate nu//(X), which is true for the empty list only (ntdl(o)). (In PROLOG [All?] stands for cons(A, B), and D stands for the empty list.)
Dialogue management for telephone information systemsIn such cases, system utterances are selected and formulated so as to make explicit to the user the fact that an alternative is being offered. 4 hnplementation Tile Sundial dialogue manager has been implemented in Quintus Prolog and tested on a variety of differem hardware platforms.
Combining local negotiation and global planning in cooperative software development projectsThe kernel of the system is the plan integrator which contains the consistency checker, the conflict resolver, and the action executor. We have enhanced Oval [16] with a Prolog-based inference mechanism and implemented these agents as special Oval agents. This mechanism enables user to combine the PCRM system with the existing Oval applications [14] such as employee databases, decision making systems or schedule management. - A knowledge object in a knowledge base object contains knowledge in a Prolog notation. The conflict resolution strategies and the coordination strategies are represented in this way.
A consideration of some approaches to course organizationEdwards. [8] IS] Yoav Shoham. Artificial Intelligence Techniques in Prolog. Morgan Kaufmann, 1994. [9] [W] Patrick Henry Winston.
Automatic source-file dependency structure extraction for C programsFirst of all, the advantages of our approach: The tool is very easy to use, and is similar to previous versions of the Star tool. Telos Code Lanscape Files OOT Code Prolog Facts C or C++ Code Interface Files Software Landscape Viewer Interface Viewer Hy+ ConceptBase OOT Star Figure 1: Star Architecture It does not depend on other tools that may or may not exist in the environment.
"A unified version model for configuration managementFeature values may be Iiterals, vari ables, and (nested) feature terms, PROLOG-like first-order terms may also be used. As an example, consider the following feature term T, which expresses linguistic ties of a piece of natural language: tense: present, proper = predicate: [verb: sing, agenfi X, what: Y] , subjecr [X, num: sg, person: third], [ objecc Y This term says that the language fragment 1 is in present tense, third person singular, that the agent of the predicate is equal to the subject etc.: T is a representation tence template ""X sings Y"". of the sen The syntax of feature terms is given in table 1, where a denotes a literal (e.g. numbers, strings, and atomic constants), V denotes a variable, and g denote features, and S and T denote feature terms. For terms without unions and complements, feature unifi cation works similar to classical unification of first-order terms, the only difference is that subterms are not iden tified by position (as in PROLOG), but by feature name. Adding unions forces unification to compute a (finite) union of unifiers as well, whereas complements are usu ally handled by constraint solving (similar to negation as failure)."
"Review of ""From discourse to logic: introduction to modeltheoretic semantics of natural language, formal logic and discourse representation theory"" by Hans Kamp and Uwe Reyle. Kluwer Academic Publishers 1993.Careful attention to the DRS construction process has yielded computational implementations of the theory relatively easily, and fragments of the DRS construction algorithm now run in LISP and PROLOG at a variety of sites in the US and Europe. Go and read From Discourse to Logic and follow up with Asher's book."
Multitasking simulation of a boiler system using qualitative model-based reasoningModern as SIMULA and Smalltalk offer many desir able features such as class purpose artificial intelligence and inheritance for simulation [23], General languages such as Lisp or Prolog have also been used in simulation (see [6] and [14]). AI and simulation Languages in Modeling and introduction to model-based reasoning. AZ Expert 5, 1 (Jan. on Prolog basis. In Artificial Intelligence, Expet Systems and Simulation.
Replay, recovery, replication, and snapshots of nondeterministic concurrent programs., The Logix System User Manual, Chapter 21 in Concurrent Prolog: Collcted Popers, E. Shapiro (cd.), MIT Press, 1988. [30] Sistla, A.I'., and Welch, .J.L., Efficient clis tribu ted recovery using message logging, Proc. of 8th ACM PO DC, pp.223-238, Edmonton, Alberta., Augnst, 1989 [31] Strom, R. Comp.i$ys., 3(3), pp.204-226, 1985. [32] Taylor, S., Parallel I,ogic Programming Tech niques, Prentice Hal], 1989. [33] Taylor, S., Sa,fra., S., and Shapiro, E., A Parallel Implementation of Flat Concurrent Prolog, International .Journal oj Parallel Pro gramming 15(3), 245-275, 1987. [34] Unman, J.
University of Sheffield: description of the LaSIE system as used for MUC-6Parsing The LaSIE parser is a simple bottom-up chart parser implemented in Prolog . The grammars it processes are unification-style feature-based context free grammars . During parsing semantic representations of con - stituents are constructed entirely using Prolog term unification . When parsing ceases, i .e. when the parser can generate no further edges, a `best parse selection' algorithm is run on the final chart to chose a singl e analysis .
"Decision lists for lexical ambiguity resolution: application to accent restoration in Spanish and FrenchNote that what was once just a capitalization ambiguity between Prolog (computer language) and prolog (introduction) has is becoming a ""sense"" ambiguity since the computer language is now often written in lower case, indicating the fundamental similarity of these problems."
Knowledge-based approaches to government benefits analysis([Bench-Capon 1987] discusses how logical models of welfare legislation can be used by policy makers to assess problems in current law and the impact proposed revisions. ) The APES system, which of augments PROLOG with facilities for automatically generating dialogues with the user, was used to execute prototype formalizations. Peggy Jo Duffy implemented an expert system in Quintus Prolog to determine whether clients of a Philadelphia legal services program were eligible for Medical Assistance.
AIgorithms: an integrated algorithm analysis, writing and artificial intelligence courseAmong the topics that will be covered are the CYK and Earley parsing, LR parsing, and Prolog style DCG based parsing. 3.4 Project Orientation It is becoming increasingly clear that students are learn and retain more material when they are involved in a ongoing project to build something useful.
Non-literal word sense identification through semantic network path schemataThis process is similar to the spreading activation and marker passing techniques of Hirst [1988], Charniak [1986], and Norvig [1989] and is embodied in the Prolog program metallel based on Fass' program meta 5 (Fass [1988]).
Adaptive algorithms for PASO systemsShared memories that qualify informally as PASOS have been used as coordination languages in a variety of parallel programming systems, e.g., in the context of C [10], Scheme [18], Prolog [9], distributed object-oriented systems [24], Modula-2 [8], program visualization systems [25], math libraries [11], and as part of other coordination mechanisms [1, 22]. Ciancarini. The concurrent Proc. lan guage Shared Prolog. ACM Trans. on Programming Languages and Systems, 13(1):99-123, [10] 1991.
"Inference of inequality constraints in logic programs (extended abstracts)""Termination"" usually to termination of top-down evaluation Prolog), and `(safet y"" refers to the refers (as in property that bottom-up evaluation (using magic for example) generates a finite answer. approach toward logic programming sets, The enunci ated by systems such as NAIL! [AP90] Apt, K. R., Pedreschi, D.: Studies in pure Prolog: termination. Report CS-R9048, Centre for Mathematics and Computer Science, Amsterdam, The Netherlands, Sept. 1990."
Thoughts on large scale programming projectsRobert McLaughlin, Automated Software Testing, The C Users Journal, Volume 9, Number 2, February, 1991. . Robert McLaughlin, A Plea For a Readable Prolog Programming Style, S/GPLAN, Volume 25, Number 11, November, 1990. .
Collaborating on referring expressionsAt present, a computer system has been implemented in Prolog that can construct and recognize initial referring expressions, and that can construct clarifications.
Shape analysis as a generalized path problemThe approach we are using presents us with somewhat of a challenge for communicating our results to the programming-languages community, for the following reasons: q Many people in the programming-languages commun ity are unfamiliar with the bottom-up iapproach to evaluating logic programs, and try to appl:y their intuitions about Prolog programs (which are evaluated using a top-down strategy) to such programs. One disadvantage with top-down, goal-directed search (at least the depth-first one employed in Prolog) is that it is incomplete-it can loop endlessly, failing to find any answer at all, even when answers do exist.
Ubiquitous applications: embedded systems to mainframeConclusion Smalltalk has succeeded where other high-productivity environments such as Lisp, APL, Forth, Prolog, and to some extent Basic have failed. These languages promised interactive, incremental development in a supporting environment, in some cases with libraries of tools and components.
The role of testing in grammar engineeringThe workbench comes with a lexicon, a morphology component, a special purpose editor and output procedures for linguistic type tree output. The program is written in Prolog and runs on PCs. 4 Similar work Concerning the ATS the approach most similar to our own is by Nerbonne and coworkers (1991).
"DiaLaw: a dialogical framework for modeling legal reasoningThe language The language of the dialogues are sentences comparable to fact-clauses in Prolog. Sentences are for instance: law, conference(icail). capital(State, City), Pmticipant(lodder, conference(icail)), but also ""I did not shoot the deputy"". The definitions and rules served as a model, that has been implemented in Prolog. This program (also called DiaLaw) checks whether the input of a player is allowed."
"Space optimization in deductive databasesINTRODUCTION Bottom-up query evaluation, deductive database systems, Bottom-up evaluation of a query proceeds by repeatedly applying facts can be computed. Bottom-up advantages over Prolog-style on a recursively defined view/logic program program rules to generate facts until no new evaluation has been shown to have several top-down evaluation in the area of deductive databases (see, for example, the evaluation is set-oriented (b) repeated computation [Unman 1989]). -lcs(O, O, X). If the strings are of length top-down Prolog evaluation The function ` grows () have (:"") > 275 X 109, m and n, then evaluating the program using the strategy gives a running time that is fl(( ~"" )). extremely quickly. For example, if m = n = 20, we if m = n = 100, we have > 1.8 X 1059. ()`n,"" Clearly, the Prolog evaluation any but the shortest of strings. strategy cannot be used on this program for If"" we take the bottom-up Ramakrishnan 1991] followed approach of rewriting by Magic Sets [Beeri and by semi-naive bottom-up evaluation, the running time is reduced to 0( inn)."
Automatic transformation of series expressions into loopsThe resulting flow between the subexpressions. checks that the expression obeys the on-line cycle the procedures in each cluster are combined into procedures are then combined based on the data To support the combination process, each series ACM Transactions on Programmmg Languagesand Systems, Vol 13, No. 1, January 1991. function SumSqrs begin (V: array [1. .N1 of Integer) : Integer, SumSqrs := CollectSum(Sqr(ChooseIf(Odd, end function SumSqrsPipelined (V: array [1..NI label 0,1, var Element 12, Index 15, Result 5, Sum 2: begin [11 ndex 15 := O, [41 sum 2 := o, [1] 1: Index 15 := l+Index 15, [11 if Index 15>N then goto O, [11 Element 12 := V[Index 15], [21 if not 0dd(Element 12) then goto 1, [31 Result 5 := Sqr(Element 12), [41 sum 2 := Sum 2+Result 5, goto 1, o: SumSqrsPipelined := Sum 2 end [11 -- Scan of a vector --------------------------------- inputs- Vector: array [A'..LI of Scan(V)))) of Integer): Integer, ElementType, outputs- Element: Series of ElementType, vars- Index: Integer, prolog- Index: l-K, body- Index := if Index>L I+Index, then goto O, Element := Vector[Index], [2] -- ChooseIf ----------------------------------------- inputs- function P(X: ElementType): Boolean, Item: Series of ElementTbype, outputs- Item: Series labels- 2, body- 2: NextIn(Item), if not of E1ementType, P(Item) then goto 2, [3] -- Implicit mapping of Sqr __________________________ inputs- Item: Series outputs- Result: Series of ElementType, of ElementType, body- Result := Sqr(Item), [4] -- collcts ------------------------------------------ inputs- Number: Series outputs- Sum: ElementType, prolog- sum := o, of ElementType, body- Sum := Sum+Number, Fig. 12. Integer, 13, No. 1, January 1991. procedure is represented as a loop inputs - Input variables. outputs- Output variables. vars - Auxiliary variables labels- Labels used by the Prolog- Statements that fragment with one or more of the following parts: used by the comput at ion. computation. are executed before the computation starts. body- Statements epilog- Statements that are repetitively executed. that are executed after the loop terminates. The other parts of the fragment appear directly in the label O, 1, Iabek, var vars, begin prolog , 1: body, goto 1, O: epilog, Once each series expression be passed to a standard Pascal ACM Transactions on Programming loop. has been replaced by a loop, the resulting code can compiler.
"Applications of machine learning and rule inductionA common technique is to represent knowledge as Horn clauses (as in the Prolog language), then to phrase problems as ""theorems'' and to search for proofs. And recent work on inductive logic programming, reviewed by Bratko and Muggleton (this issue), adapts algorithms for rule induction to such logical representations as those used in languages like Prolog. These convergences are the signs of a balanced and maturing field."
Interaction with constraints in 3D modelingThey cause polynomial increase of searching time in the number of predicates trying to match predicates to the left side of a rule. 4.3.2 Phase 1: Finding a Symbolic Solution The constraints are sent to the constraint solver in the Prolog predicates. The constraint solver subsequently when form of applies the rewrite rules to these predicates in order to replace them by equiv alent predkates of a lower order, until no further application rules is possible. In Pro.e.d 9D GTaph - Aspects of Labor* [Bru 85] B. D. Briiderlin. Using Prolog for Constructing metric Objects Defined by Constraints.
Static and dynamic semantics processingPresent applications address tackling pattern matching [111 and Prolog [101: environment-wise, sJI the potential substitutions are computed at compile time, control-wise, failure continuations are discovered to be bound statically, enabling backtracking to be determined entirely at compile time. Consel and S. C. Khoo. Semantics-directed genera tion of a Prolog compiler. Research Report 781, Yale University, New Haven, Connecticut, USA, 1990. [11] 0.
"Review of ""Towards a theory of cognition and computing"" by J. Gerard Wolff. Ellis Horwood Limited 1991.In the second half of the book, Wolff generalizes these ideas and methods in the form of a computational notation (SP) analogous to a simplified Prolog. It is this notation that is claimed to be a new language for a unified ""theory of cognition and computing"" (as well as a potential solution to all the problems of software engineering): but neither real evidence nor a convincing argument is offered in support."
Bilingual generation of weather forecasts in an operations environmentWe have implemented a fragment of an existing Meaning-Text model for English[9] and adapted this model for French. 2 91 6 ][mplementation FoG i: written in Quintus Prolog and runs on a Hewlett-Packard 9000 workstation as part of the FPA system.
The 3 R's of optimizing constraint logic programs: refinement, removal and reordering(SUM) sum(N, S)+- N>=l AS=N +SIA NI = N - 1 A sum(Nl, S1). CLP(7?) programs may be thought of as Prolog programs extended to allow linear arithmetic constraints as well as syntactic equality constraints. Theoretical Computer Science, 34:227-240, 1984. [18] H. Simonis and M. Dincbas. Using an Extended Prolog for Digital Circuit Design. In IEEE International Workshop on AI Applications to CAD Systems for Electronics, 165-188, Munich, October 1987. [19] G.L.
Knowledgebase transformationsIn: Proceedings the Second ACM SIGA CT-SIGMOD SIGART Symposium on Principles of Database Systems, pages 352-365, 1983. D. M. Gabbay. N-Prolog: an of exten sion of Prolog with hypothetical plications.
Declarative control architectureThe syntax of clauses is similar to those in the Prolog language. Each clause is of the form Head @ Body (1) where Head is a functional form, p(xj .... In Figure 10, the top-level blocks are implemented by a metainterpreter written in Prolog. It interprets equational logic theory. It uses the inference principles defined in the previous section.
Language features for interoperability of databases with schematic discrepanciesThis is also the case of Horn clause The of the order languages such as J!DL, Dat slog and Prolog. The language teroperability has to be a higher order language. though there were higher order languages proposed literature [AG88, KN88, CKW89], none of them for in Even in the addresses the interoperability needs. This is aconstrnct that is used very similar to the use in Datalog, LDL, Prolog and other Horn clause based languages. The reader can extrapolate its meaning in the obviows manner. any other variables in the expression, in the sense that they can be used to conjunct further selection, join or even projection as we shall see later.
Specification matching of software componentsRollins and Wing proposed the idea of function specifica tion matching and implemented a prototype system in A Prolog using plug-in match [25]. A Prolog does not use equational reasoning, and so the search may miss some functions that match a query but require the use of equational reasoning to determine that they mat ch.
The well-founded semantics of aggregationFor nonmonotonic programs, a more general approach is developed, which involves approximating from above, as well. 2 Notation and Rule Syntax We stay close to the syntax of Prolog for rules. Symbols beginning with a capital letter are variables. Symp. on Logic Programming, Seattle, Aug. 1988). J. W. Lloyd and R. W. Topor. Making Prolog more expressive. Journal of Logic Programming, 1(3):225-240, 1984.
The structure of norm conditions and nonmonotonic reasoning in lawA representation of principal and sesondary facts can be obtained using logic programrnin g languages combining negation by failure and logical negation. Prolog offers instruments for a simple implementation of this double negation: an approximation to negation as failure is offered by Prolog not, while a form of classical negation can be obtained, as we have seen, just by renaming Prdlcates in negative literals.
A CCG approach to free word order languagesA uniform analysis was given for the general linguistic facts involving both local and long distance scrambling. 1 have implemented a small grammar in Prolog to test out the ideas presented in this paper.
A course in computer lawYour boss tells you to make a copy for your secretary's machine. What do yOU do? You've used a Prolog development environment sold with HP workstations.
CRL/NMSU and Brandeis MucBruce: MUC-4 test results and analysisSYSTEM FEATURE S The system consists of three front-end components all of which are C or Lex programs : • A text relevancy marke r • A paragraph relevancy marker • A text tagging pipeline and two MUC specific Prolog programs : • A template constructor • A template formatte r 'We seem to have adopted a philosophical stance for our system nomenclature, and this particular Australian philosophe r seemed to embody some of the ad hoc notions which, at the moment, glue our system together.
A survey of programming languages in CS programsConclusion The list is a principal data structure in Prolog . A small number o f simple plans give a framework for deriving many common recursive algorithms for lists .
Book review: A Prelude to Neural Networks: Adaptive and Learning Systems. Edited by Jerry M. Mendel (PTR Prentice Hall 1994)In particular, this paper describes (1) when we come up with a correct answer irrespective of the order of transformations (this is called ChurchRosser property), (2) how to transform equations into rules (it is called Knuth-Bendix algorithm, and (3) how to incorporate term rewriting into Prolog. How to formalize reasoning about proofs In addition to describing traditional logical and mathematical reasoning, we may want to formalize reasoning about mathematical proofs and logical constructions.
A symbolic constraint solving framework for analysis of logic programsVan Hentenryck. Reexecution abstract interpretation of Prolog. In Joint International in Conference\Syrnposium on Logic Programming, 750-764. Experimen tal evaluation of a generic abstract interpretation rithm for PROLOG. ACM Transactions on ming Languages and Systems, 16(1):35-101, 1994. [18] K.
A knowledge-based machine-aided system for Chinese text abstractionA Note on Implementation MACTAS was implemented in a personal computer environment under DOS, using Turbo PROLOG and the Eten Chinese System. To circumvent the limitations imposed by a single PC, the full system runs on two PC's interconnected by an RS-232C interface.
Separating concurrent languages with categories of language embeddingsSee [21] for a discussion of pragmatic as pects of language embedding and the Concurrent Prolog book [44] for several papers devoted to translations of logic, functional and object-oriented models of concur rency into concurrent logic languages. Hermenegildo (Eds.), MIT Press, 1990. [44] Shapiro, E. (Editor), Concurrent Prolog: Collected Papers, Vols. 1 & 2, MIT Press, 1987. [45] Shapiro, E., The Family of Concurrent Logic Pro gramming Languages, ACM Computing Surveys 21(3), pp. 412-510, 1989. [46] Sussman, G.
Book review: The Engineering of Knowledge-based Systems Theory and Practice by Avelino J. Gonzales and Douglas D. Dankel (Prentice Hall, 1993)In addition to the standard introductory material on propositional and predicate logic, unification, and resolution, the chapter on logic includes some discussion of reasoning techniques involving induction and abduction, as well as a presentation of the Prolog programming language. The two chapters on rule-based reasoning (two of the best in the book), include clear characterizations of forward vs. backwards reasoning, and of architectures which depend primarily on pattern-matching vs. those which rely primarily on inference networks.
"Journal Backlog ReportSmolka, ""Axiomatizing probabilistic processes: ACP with generative probabilities"" Dieter Spreen, ""On some decision problems in programming"" Roberto Barbuti, Michael Codish, Roberto Giacobazzi, and Michael 3. Maher, ""Oracle semantics for Prolog"" Wan Fokkink and Steven Klusener, ""An effective axlomatization for real time ACP"" Alexander Aiken and Dexter Kozen, ""Decidability of systems of set constraints with negative constraints"" Katsutoshi Nakayama and Akira Maruoka, ""Loop circuits and their relation to Razborov's approximation model"" Liming Cai, Jianer Chen, Rodney Downey, and Michael Fellows."
"The application of second natural language acquisition pedagogy to the teaching of programming languages—a research agenda""Software engineering in higher education"" Southampton Institute, 1-874011-00-1. Lee, M. P., Pryce, J.D. & Harrison, A. (1994) ""Prolog as a first programming language"" pp 275-281 IN King, G."
The survival of Lisp: either we share, or it diesWhen uncompressed, the CD-ROMs contain 5 gigabytes of data consisting of 1367 entries contributed by more than 900 authors. 1 A great many of the entries are Lisp programs, but there are also entries containing text and progroms in other languages such as Scheme and Prolog. The 220 page book is primarily an index into the CD-ROMs.
Computer language usage in CS1: survey resultsThe range of languages thought to be best included not only the four languages discussed here, but also BASIC, FORTRAN, Miranda, Modula, Pascal and Prolog. What is SIGCSE Vol 27 No. 3 Sept. 995 Oill Typeo I i 1 I% e+'e.'
Recent DissertationsWe present an abstract description of this method, and sketch its realization in Prolog. The relationship between AET and several problems previously discussed in the literature is discussed.
An introduction to ultimately periodic sets of integersThe author has written a computer system (using the Prolog language) which implement s (among others) the operations between A-sums defined above . 3 An Application : The Lengths of All Paths in a Grap h As an application of the A-sum concept we consider several problems related to the length o f paths in directed graphs .
Consequence relations in DRTIf this is successful, computational lin-1114 own systems using programming languages like Prolog and LISP. There are perhaps several ways to give an operational semantics of DRT.
Collecting interpretations of expressionsACM, New York, 1986, 15 JONES, N., AND SONDERGAARD, H. tion of `Prolog.' In Abstract of the 13th Symposium on Principles of Programmmg pp. 296-306 A semantics-based framework for the abstract interpreta Interpretation of Declaratzue Languages. In SIGPLAN '86 Symposzum on York, 1986, pp. 196-206. Published as SIGPLAN Notices of PROLOG programs. In Abstract Interpretation of Horwood, Chichester, England, 1987, pp. 181-198. 18.
Building a Windows-based bilingual functional semantic processor/I is hcre Ihal we rely on Kil Chunyu(1993)'s LFG parser 1o provkle mpul for subscquenl SClnanlic inlerprelation. The Kil Parser, originally developed in PDC Prolog for the DOS clwiFoIIIllClI[, is being redeveloped as a Windows application WinProlog. using, I.PA Kifs unificalional aclive charl parser (UniPurc('harl) is based on 1 Chillesc l,cxical-l:unclional Grammar (CI.FG) conslrucled by Kil.
The interface between phrasal and functional constraintsThe original implementation for Definite Clause Grammars followed this strategy by translating the grammar into equivalent Prolog clauses and using the general Prolog interpreter to solve them.
Formal language, grammar and set-constraint-based program analysis by abstract interpretationFor example, one can consider: - Infinite regular trees, e.g. to handle lazy func tional programming languages with infinite structures or PROLOG III, - Generalizations of formal (string) language ory such as (hyper)graph language theory grammars (to describe abstract properties) (hyper)graph rewriting techniques (to describe data the and and ab stract semantic transformers) to handle sharing, etc. Experimental evaluation of a generic abstract interpretation algo rithm for Prolog. In Proc. 1992 IEEE ICCL, 137-146, 1992. [27] P.
Higher-order equational logic programmingEquational logic programming paradigm (as in [7, 10, 12, 13, 21, 31, 32, 35, 39] and in the collection [6]) includes first-order extensions of Prolog, where symbols can be specified by equations. Although the higher- and first-order paradigms are successful on their own, no techniques of one paradigm, to our knowledge, have been systematically used in the other. Roughly speaking, the higher-order logic programming paradigm viewed as an extension of Prolog where can be first-order terms are replaced by patterns, and first-order fication by higher-order one.
Reuse-oriented requirements engineering in NATURESeveral tools have been designed and implemented on a SparcStation IPX under UNIX using the ConceptBase object-oriented deductive data base (Jarke et al. 1994) and ProLog by BIM. Others are being implemented on the same platform.
Structuring a simulation modeling environment using a commercial manufacturing simulatorExamples or an include (for the simulation engine - interface respectively): general manufacturing simulator using SIMAN a TURBO PROLOG (Ozdemirel and Mackulak flexible manufacturing system (FMS) simulator SIMAN - BASIC (Haddock 1988), a 1993), a using general manufacturing simulator using GPSWPC - COMMON LISP (Ford and Schroer 1987), a general manufacturing simulator using GPSSIPC - TURBO PASCAL (Schroer 1989), and a robotic manufacturing cell simulator using Q-GERT - FORTRAN (Medeiros and Sadowski 1983). 3.
"Selected, annotated bibliography on process-centered software engineering environmentsWolf, ""A Knowledge-based Software Development Environment Supporting Cooperative Work"", International Journal of So, ware Engineering and Knowledge Engineering, Vol. 2,No. 1, pages 79-106, 1992. Describes the PSEE Merlin that uses a Prolog-like rule language for process representation. 15."
Deep comprehension, generation and translation of weather forecasts (weathra)The formal grammar, morphology and lexicon of Weathra are based on experience from the machine translation system Swetra (Sigurd & Gawronska, 1988), which is also written in Prolog (LPA MacProlog). The Weathra system can understand weather forecasts in a fairly deep sense, depict its comprehension in a map, answer questions about the main contents and consequences, translate English forecasts into Swedish ones and vice versa, and generate various forecast texts in English or Swedish.
"Object-oriented logical specification of time-critical systemsActually, it is somewhat unnatural to interpret TRIO+ function or predicate applications procedural interpretation as procedure calls, because there is not a of a set of axioms as in PROLOG. Nevertheless, TRIO + objects can communicate counterpart of message sending. debt with Eiffel's, we refer via connections, which are a temporal logic The object-oriented syntax of TRIO+ is in the reader to Meyer [1988] for detailed discussions on its advantages and drawbacks. As noted natural concept of state: logic and of an object's identity persisting above, TRIO is a temporal logic with a Object-oriented techniques can thus be introduced without altering its denotational The object-oriented logical for example, Shapiro [1987], characteristics. languages are usually extensions to PROLOG, Kahn et al. [1987], and Conery [1988], but some are new languages, with a declarative semantics for objects and procedural calls based on logical inference, Miller [1984], and O'Keefe [1986]. clauses to model objects with for example, Goguen and Mesegaer [1987], All of them use first-order logic in Horn changing states. ET AL. 1991. Object Chffs, N J SHAPIRO, E 1987. Concurrent Prolog SMULLL4N, R. M. 1968. Fu""st Order SNYDER, A 1986."
DAIDA: an environment for evolving information systems-The graphical knowledge uniform graphical interfaces -The IRIS mapping assistant base editor GraFIc [70] offers the basis for to all other DAIDA components. supports the rationalization of an information system design, given a requirements -The PROLOG-based workbench TaxisDL designs with sample specification- see Section 3. Using the semantics of Telos and be understood as a logic-based specification executable by resolution methods. In DAIDA, this has been in part exploited by Prolog-based prototyping of Telos and TaxisDL that help users to animate [39, 53]. and thus validate their specifications On the other hand, TaxisDL tion language similar to VDM a model of the statics and can also be viewed as a model-based specifica [46] or Z [78]. Schmidt, Eds., Springer-Verlag, 53. MEIRLAEN, E., TRINON, J.-M., Prolog. In Proceedings ESPRIT 54. MOSTOW, J. Towards better New York, 1984, 411-436.
"Bags and viewers: a metaphor for structuring a database browserSDBA has been ported to generate SQL for three relational databases in different domains and to the Prolog ""database"" queried by the ""Chat 80"" natural language system (Warren and Pereira 1982)."
The automation of helpdesksIt must be able to assist in the diagnosis of problems, in the maintenance of client profiles and to do all this in a m.anncr which results in an intelligent explanatory report for the advisor. 220 The System The helpdesk is based on a network of communicating asynchronous blackboard systems (Englemore and Morgan, 1988) written in SEPIA Prolog. A number of system agents are used to interface application programs on remote machines (eg ORACLE used to log client-advisor question-answer in formation, BRS used to store advisory newsletters in an eas ily accessible free text retrievat format).
Representing conceptual and linguistic knowledge for multi-lingual generation in a technical domainAn example of an event category carried by [lock] s[st:s-st[subj:SVSJ :fin: v[:fb: v-fb[agz:AGR, pass :-]] pred:v[st:lock] compl:OBJ]] I SUBJ=np[:fb:np-fb[agr:AGR=agr-fb]] [ OBJ=np 4.3 Discussion The conceptual grammar is a semantic-head grammar, where the semantic head is the top node of the graph a rule analyzes• The grammar processor is a plain Prolog resolution. It behaves as the standard semantichead driven generator (SHDG) (Shieber et al [10]) does when all nodes are pivots, i.e a purely top-down manner.
GEnie Forth roundtableSomeone who knows two different languages like, say Prolog and COBOL or some such, is more ready to accept that languages can be different and is more willing just to look at what Forth offers.
Student created user manuals for a course on programming languagesLaboratory exercises includ e programming assignments using C, LISP , PROLOG, RPG, and SNOBOL . Students in the programming language s class develop their own user manuals fo r the languages mentioned above .
Usenet nuggetsdesign, starting in 1985, we have always asked the question: Is there anything we can do for LISP, Smalltalk, Prolog, etc. which: a) Does not impact the machine cycle time, or use massive amounts of silicon that we cannot afford?
On the syntactic-semantic analysis of bound anaphoraA more conventional system for DRTbased syntactic-semantic analysis that generates admissible scope readings has been implemented in Quintus Prolog at the University of Hamburg, in a DCG style grammar system.
Semantics for null extended nested relations(MAJOR)* (CLASS (EXAM)* (PROJECT)*)* MAJOR CLASS (EXAM)* (PROJECT)* EXAM PROJECT computing databases mid lNF final programming final null maths databases Iinal NF2 UR logic I first-order mid prolog null null mid null final first-order null furrctions predicates languages french mid null null final Moscow hebrew null Genesis Thenested relationr over R(Z'l). MAJOR CLASS EXAM PROJECT computing databases mid lNF computing databases final lNF computing programming final null maths databases final NF2 maths databases final UR logic first-order mid prolog null null final null null first-order null functions nUil first-order null predicates languages french mid null languages nMl! X c S(T), then we say that the tuple t is X-total A (CLASS @M)* (PROJECT)*)* CLASS (EXAM)* (PROJECT)* EXAM PROJECT databases mid lNF final programming final nUll databases final NF2 UR first-order mid prolog null mid null final first-order null functions predicates french mid null null final Moscow hebrew null Genesis Fig. 16.
"The semantic foundations of concurrent constraint programmingThis line of research extends and subsumes (for all intents and purposes) earlier work on the semantics of concurrent logic programming languages, 4 The power of the""logical variable"" has been amply rec ognized in recent years, and numerous authors-too numer ous for us to survey their work in this extended abstract have investigated the combination of functional and logic 4The semantics presented in this paper does not account for the language Concurrent Prolog studied in [G CLS88], we do not, however, view this as a defect in our approach/ Indeed, researchers working with Concurrent Prolog have moved to the Ask-and-Tell cc framework [KYSK88,GMS89]. programming languages [Lin 85,DL86,ANP89, JPP89]. ever, no account of the- basic paradigm comparable Kahn's original account in simplicity and generality How with has been forthcoming. A fully abstract Liechtenstein, [KYSK88] denotational semantics for Flat Concurrent Prolog. 88, 1988. [Gir 87] J.-Y. Girard. Linear logic."
PLEIADES: an object management system for software engineering environments., by fol lowing pointers or fields of records), but imperative pro gramming languages do not directly support associative access, and rule-based languages, such as Prolog [59], in clude only a limited notion of associative access. oceedings of the 1991 ACM SIGMOD Intemaiional Conference on Manage ment of Data, pages 158- 167, May 1991. [59] D.H.D. Warren and L.M. Pereira. Prolog-The Language and Its Implementation Compared to LISP.
A newcomer's impressions of SchemeThis project was my introduction to Scheme, and, except for six intensive months of Prolog while doing an M.Sc. in Artificial Intelligence in 1986, my first significant use of a non-Baekus language (i.e. one outside the Fortran and Algol families).
Sequences, Datalog and transducersThe concatenated sequences (and their subsequences) form the extended active domain of the least fixpoint. u Compared to Datalog with function symbols, or Prolog, two differences are apparent. The first is that Sequence Datalog has no uninterpreted function symbols, so it is not possible to build arbitrarily nested structures. On the other hand, Sequence Datalog has a richer syntax than the [HeadlTail] list constructor of Prolog. This richer syntax is motivated by a natural distinction between two types of recursion, one safe and the other unsafe.
Can we trust in HDLC?It has been shown that, for the subframe to be undetected, the lost prolog or epilog of the frame must be longer than 1 6 bits [ChTr 93, FiSa 92] : because an HDLC frame must be at least 32 bits long, frames not longer than 48 (=32+16) bit s are immune from this problem . However, it can be shown that if we extend a legal frame with a prolog or an epilog of up to 11 bits, whatever the value of thes e bits, the resulting frame is recognized as erroneous [ChTr 93, FiSa 92] .
The POSTGRES next generation database management systemMoreover, if Fred's sahry is not explicitly stored, then further rules would be awakened to find the ultimate answer, and a backward chaining control flow results. This control structure was popularized in Prolog [5]. If Fred receives frequent raises and Joe's salary is rarely queried, then the backward chaining representation will be more efficient. To be published. 5. Clocksin, W. and Mellish, C. Programming in Prolog. Springer-Verlag, Berlin, Germany, 1981. 6. Committee for Advanced DBMS Function.
Prophetic branches: a branch architecture for code compaction and efficient executionIn this section we estimate the code compaction achieved by prophetic branches in comparison to the code generated by delayed branches with delay slot annulling. We use a set of symbolic benchmarks written in Prolog for our analysis. Table 1 gives a brief description of the benchmarks.
"Review of ""Computer processing of natural language"" by Gilbert K. Krulee. Prentice Hall 1991: and ""Computers and human language"" by George W. Smith. Oxford University Press 1991.A syntax-directed translation strategy, based on the output of parsing methods introduced in the preceding chapters, that maps syntactic structures onto a semantic representation, is introduced and illustrated through several detailed examples. A short discussion of Prolog and rules of inference is included to suggest how pragmatic analysis might be incorporated into an application system."
Turtle walk through functional language., Logo Programming for the IBM PC, Addison Wesley & IBM UK International, 1985. [Sa 85] de Saram, H., Programming in mlcro-PROLOG, Ellis Horwood Ltd., New York, 1985. APPENDIX All basic, extended and user-defined functions are listed in LispKlt Lisp source code.
A self-applicable partial evaluator for the lambda calculus: correctness and pragmaticsSince then several other been developed for programs in the form of term rewriting systems [4], for a simple for a subset of Turchin's Refal handling first-order Scheme imperative language [141, for Prolog [121, language [32], and for stronger systems programs [8, 51. Science, 53, Springer-Verlag, New York, pp. 59-77. Mixed computation of Prolog programs. New Gen. Comput. 6, 2 and 3 (1988), 119-141. 13.
met*: a method for discriminating metonymy and metaphor by computerThe Meta 5 Program CS has been implemented in the meta 5 natural language program. The meta 5 program is written in Quintus Prolog and consists of a lexicon holding the sense-frames of just over 500 word senses, a small grammar, and semantic routines that embody collation and screening, the two processes of CS. The metonymic inference rules in meta 5 contain all three key elements. The rules, though written in a prolog-like format, assume no knowledge of Prolog on the part of the reader and fit with the role of metonymy shown in Figures 1 and 4.
"The IPS system""ITS: Interactive translation system"" in Proceedings of the 8th International Conference on Computational Linguistics (COLING-80). Pereira, F. and S. Shieber (1987). Prolog and Natural Language Analysis, CSLI Lectures Notes 10, Chicago Uuiversity Press."
An analysis of Indonesian language for interlingual machine-translation systemMatsumoto, Y. et. al., BUP: A BottomUp Parser Embedded in Prolog, NewGeneration Computing Vol.1No.2, pp. 145-158,1983.
"Complex input: a practical way of increasing the bandwidth for feedback and student modelling in a statute-based tutoring system`There is a erueinl rekirmehip between the interface and the capabilities of the ITS"" (p. 177) A system which accepts complex input `Statutor' is a Prolog program intended as a knowledgebased tutoring system in the domain of statute law."
Generating sentences from different perspectivesThe causal relations between the events are included in the model, and used in the generation of tense and aspect, but their use is not described in this paper. The model is represented declaratively in a Prolog style database. For each event there are two sorts of entry.
Intelligent integration of informationThe list could be limited by only showing, say, just the first 10 choices. In a PROLOG model only the first valid result is presented.
Drawing pictures with natural language and direct manipulationThis system was developed on a SUN workstation using the X-window system and was written in Prolog. Voice input data is recognized on a personal colnputer, and the recognition result is sent to the workstation.
Supporting dynamic displays using active rulesAdam: An object-oriented database system implemented in. prolog. In M.H. Williams, editor, PFOC. British National Conference on Daiabases, pages 147-1Gl.
Information systems security design methods: implications for information systems developmentThe metaphor is particularly useful in comparing system ment methods because a new evolves from the experience decessor without necessarily developgeneration of its pre implying obsolescence of the predecessor. larly, assembly languages (second ation), Cobol (third generation), Simi gener and Prolog (fourth generation) still have priate applications as current appro programming languages. Carroll-Maclver Knowledge Base System Carroll and MacIver [ 1984] exemplify advancements in risk analysis made by employing knowledge base technology for modeling computer security. They used Prolog to implement an experimental computer facility security certification system. Invers{on Model Expert System This knowledge-based system was constructed in both an expert system shell and Prolog [Baskerville 1988]. Its conceptual advance was in the use of a model founded on an historical analysis of trends in losses relevant to the automation of manual systems.
An approach to symbolic timing verificationCLP(R) incorporates an incremental version of the standard simplex linear programming algorithm and a goal based programming language akin to Prolog. Its use has enabled us to focus our attention on the verification rules instead of the symbolic linear programming, unification, and search/backtracking aspects of the methodology.
Chart parsing of robust grammarsA--.B c C,hortli, j] iff Jec DSrre 198'T [TD ] SE Sset S -* wO'A A [BU ] ,- where 5 V 4 The RPSG variant 4.1 Item Concept h the RPSG variant, items are represertted as PROLOG facts item( Iumber, Lind, Rirtd, LRS, Pazsod, To_Parso RofList) where item number, the -possibly indexed- left hand symbol, the list of parsed symbols and the list of symbols yet to parse are well-known item parts.
Unifying test and diagnosis of interconnects and logic clusters in partial boundary scan boardsPESTICIDE diagnosis results The algorithm for computing the D and implemented in C and PESTICIDE in PROLOG. generation of the knowledge bases from sets is The the device description in System Hilom HDL format [10] is done automatically using an in-house compiler [2].
NAUDA: a cooperative natural language interface to relational databasesIn addition, it must adapt the form of expression to the pReferences of the user, who has the possibdity of choosing between two different levels of granularity (that is, short or more precise), Most of the components of our current prototype are implemented in PROLOG. LanguageAccess and the SQL-DS database itself are components which run on an IBM Mainframe (IBM9370) VM while the other components run on a PS/2 under AIX. under The communication is realized by three interface processes.
"Industrial strength compiler construction with equations., Equational Logic as a Programming Language, The MIT Press, Cambridge, Massachusetts (1985). Paakki, 1991. Paakki, J., ""prolog in Practical Compiler Writing,"" The ComputerJournal 34(1) pp. 64-72 (1991). 50"
Demonstration of GENESYS: a very large, semantically based systemic functional generatorFinally, GENESYS introduces probabilities into the operation of the system networks, see Faweett (to appear a). GENF.SYS was developed using Poplog Prolog on a SUN 3/50, using a special tool for writing and testing grammars developed by Wright (called DEFREI., because it defines relations). 3.
"Using artificial intelligence techniques for intelligent simulation in memory re-educationO'Keefe, ""Visual Interactive Simulation - History, recent developments, and major issues,""SIMULATION, ~01.49. 1987, pp.109-116. [4]C.L. Chang and A.Walker,""Prosql: A prolog programming interface with SQL/DS"",Expcrt Database Systems Proceedings From the First International Workshop,1986 pp.233-246. 5 J."
Modals as a problem for MTIt will then have to make changes in the functional representation and move parts of the meaning representations. The following is a general Prolog rule, which moves the epistemic meaning from the predicate to the adverb.
"Agent language NUML and its reduction implementation model based on HOπ. • Sentences of NUML take the form of Horn clauses, which makes NUML an extension of Prolog. Several additional but more powerful facilities is provided in NUML such as : 42 --more strict negation rule than ""negation as failure"" for completely defined predi cates[2], and --the limited form of existential quantifier. • Intelligent agent, in syntax, each is composed of the description of its belief set and the meta--level description of its inference rules."
Principle-Based Parsing: Computation and Psycholinguistics Edited by Robert C. Berwick, Steven P. Abney, and Carol Tenny (Kluwer Academic Publishers Boston/Dordrecht/London, 1991)Covington, M. A. (forthcoming) Natural languageprocessingfor Prolog programmers. Englewood Cliffs, New Jersey. Prentice-Hall.
The “HyTime ”: hypermedia/time-based document structuring languageAssuming there is some reason for all the links to occur in the same document, the document might well be termed a web. 7 2 : use( end ana fill!flies SGML DOCUMENT PROLOG DTD DECLARATIONS data file ENTITY name= local data file address ,,,- NOTATION name= local in terpreter address DOCUMENTCONTENT ENTITY reference SGML Document on the LOCal File System i: /i i! It sets forth the information an application will need to locate the file, to establish a parsing context according to the appropriate prolog, and to retrieve the named element or entity. Addressing by Position HyTime allows addressing of objects in some arbitrary measurable universe by their position in that universe.
Syntactic constraints on relativization in Japanese., which is distinguished by an initial capital letter as in programming language Prolog. Finally, a category of the form [core {pos c, ... }..... sere s] is often abbreviated as el...]
"Dynamics, dependency grammar and incremental interpretationThe sentences John gave Mary a book and Peter a paper"" and Sue sold and Peter thinks Bert bought a painting are accepted since ""Mary a book"" and ""Peter a paper"" perform tile same transitions between syntactic states, ms do ""Sue sold"" and ""Peter thinks Ben botlght"" The gr,'mtmars described in this paper have been implemeuted in Prolog. A dynamic gramnlar based upon the extended version of l,I)Gs is being devel oped to provide incremental interpretation for the natural hmguage interface to a grapllics package."
"Knowledge-based distributed simulation generatorAhmad and R.D. Hurrion, ""Automatic Model Generation Using a Prolog Model-Base"", AI and Simulation: The Diversity of Applications, edited by Henson, SCS, p. 137-142, 1988."
A morphographemic model for error correction in nonconcatenative stringsIn this way only lexical words ae considered, as the variable letter can only he instantiated to letters branching out from the current position on the lexicon tree. Normal prolog backtracking to explore alternative rules/lexical branches applies throughout. 3 Error Checking in Arabic We demonstrate our model on the Arabic verbal stems shown in (4) (McCarthy, 1981).
"Review of ""Reference and computation: an essay in applied philosophy of language"" by Amichai Kronfeld. Cambridge University Press 1990.The last chapter of the book briefly describes a Prolog question-answering program, BERTRAND,that captures some basic computational features of Kronfeld's approach to referring."
Thomson-CSF and Ada for ATC: An experience of eight yearsThe given to the controller by -friendly interface and to especially at the level of the basic idea is to maximize the help the system with an advanced user display only information needed to be seen by the operator. proposed to the controller Automatic conflict resolutions will be (keeping the final human decision) by using Artificial Intelligence experimentations have already been AI languages (LISP, PROLOG, . ..) eventually. technology. Some successful done at THOMSON-CSF by using generating Ada source code To allow a fast and efficient code generation will be application software. tailorisation, automatic Ada source provided for large parts of the However, the most difficult problem, directly related to the (> 1 million) and the increasing number of lines of source code safety needed in ATM, remains the validation and the qualification achieve this, very advanced within the scope of the of the operational programs.
Reducing user effort in collaboration supportHowever, the properties of items in the mail archive can be written as a file of Prolog predicates which, in principle, could be used to extend or customise the current set of heuristics employed.
Letting the cat out of the bag: generation for shake-and-bake MTThe parser has the role of systematically choosing between alternative reductions, while the constraint propagation mechanism tills in the consequences of a particular set of choices. Listing 1 provides a schematic Prolog implementation of the algorithm described in this section.
"Cross-fertilizing FSM verification techniques and sequential diagnosisCheung: ""Circuit repre sent ation and diagnosis using Prolog,"" ISCAS '89: IEEE International Symposium on Circuits And Systems, Portland, OR (USA), May 1989, pp. 957-960 [14] B."
On the interpretation of natural language instructionsFnture research includes exploring how to integrate a hierarchical organization of entities, actions and plans with the action KB. The system is being implemented in Quintus Prolog, with substantial progress having been made in particular on the parser [Whi 92], and on the action KB.
Measuring the user acceptance of generic manufacturing simulation models by review of modeling assumptionsThe on a model building system consists of the generic model base and an interactive user interface which is programmed in Turbo Prolog (approximately 8000 lines of code) and runs on a Compaq 386 machine.
Verification of a production cell controller using symbolic timing diagramsBy contrast, the semantics of STD associates with each diagram a constraint on the set of admissible behaviors of a component, which is analogous to the statement of facts in PROLOG. Since the semantics of STD with finite data types can be expressed using the linear time temporal logic PTL ([17, 3]), the property verification kernel of ICOS is based on the decision procedure for PTL formulae.
Generating VHDL models from natural language descriptionsThis interface is implemented with a semanticgrammar[3] in Prolog. The second interface (Approach II) to the Modeler's Assistant for natural language is substantially more complex, but acceptsmore general English expressions and generatesmultiple-processmodels.
Adjuncts and the processing of lexical rulesID), 1, C):- Figure 8: Definite clause specification 'add_adj' constraint. 3.2 Delayed evaluation of For our current purposes, the co-routining facilities offered by Sicstns Prolog are powerful enough to implement a delayed evaluation strategy for the cases discussed al)ove.
Syllable-based morphologyAn interpreter for the language has been implemented in Prolog, and used to test a wide variety Of morphological functions frorn a range of languages as diverse as English, Arabic and Nakanai.
Generation of extended bilingual statistical reportsWhen there are two semantic nodes with identical lexemic meanings, the realizer uses Syn to lexicalize one differently from the other by finding a synonym. 6 Implementation and Future Directions The LFS system is implemented in Quintus Prolog on Sun 4 workstations. Adaptations to several specific varieties of employment reports have been carried out, including the multi-paragraph general summary reports for English and French, given below in §6.1 and §6.2 respectively.
Directory of educational discounts, donations, and grantsOfferings include (1) CSA Transputer Education Kit and Kit Add-On-Processor boards, (2) the CSA PART series board level products incorporating multiple processors per board, various processor and peripheral interfaces, and a miniature cabling system for interconnectingcomponent devices, (3) the CSA SuperSet and SuperSetPlus which are complete ready-to-use multi-transputer systems with electronically switchable interconnect topologies for single-user and multi-user applications, (4) a variety of CSA and other vendor software development tools including compilers and source-levelnetworkdebuggersfor C, FORTRAN, Modula-2,Pascal, Ada, Prolog and Occam. Educational Discounts: 30% offall PART series, SuperSet, and SuperSetPlus products. 30% off all CSAproduced software.
Degrees of stativity: the lexical representation of verb aspectFor this purpose, we used the English Slot Grammar (Me-Cord 1980, 19901 a broad-coverage parser written in PKOLOG. 7 To obtain counts of verb usages from the representations produced by ESG, we used a tool for querying trees (QT), built by the second author, also in PROLOG. The corpus is the Reader's Digest (RD) corpus, consisting of just over one million words.
SKILL: A CAD system extension languagePrograms of over 30,000 lines in length are in current use, ranging in function from netlisters to module generators to a Prolog interpreter implemented in SKILL. SKILL is widely used both as a rapid prototyping tool and as the principal implementation language for a number of products.
"Using continuations to implement thread management and communication in operating systemsRegisters that are""caller-saved"" have already been saved on the user-level stack, and those that are `(callee-saved"" will be saved on the kernel-level stack as necessary by the optimized system call's compiler-generated prolog. That prolog relative to Mach 2.5, so there was little room provement."
Tagging and morphological disambiguation of Turkish textConditions may refer to absolute feature values or variables (as in Prolog, denoted by the prefix _ in the following examples) which are then used to link conditions.
JDII: parsing Italian with a robust constraint grammarThe sentences contain the grammatical phenomena treated by the grammar (see below). The system is implemented in PROLOG and C. It runs on UNIX and DOS environments• The modularity of the system is guaranteed by the division of linguistic and software knowledge into two indipendent modules.
Software merge: semantics of combining changes to programsThe first semantically of a functional program were given versions of Prolog programs based methods for combining two versions in Berzins [1986]. Programming Research Group, Oxford STERLJN, L., AND L.AKHOTIA, A. 1988. Composing prolog meta-interpreters. In Logic Program ming: Proceeclz ?
Language Systems, Inc.: MUC-3 test results and analysisSince December, approximately 10,000 new lines of commented Prolog code have been written, and are in the process of being debugged.
DISCO: an HPSG-based NLP system and its application for appointment schedulingThe resulting formalisms are usually much closer to PROLOG and do not contain a powerful multipleinheritance type system, e.g. the Core Language Engine (CLE) of SRI Cambridge [1], its derNative tile GEMINI system of SRI International in Menlo Park, the LKP of SIEMENS in Munich [3].
"Aspect: a problem for MT""Slist"" is the semantic representation (formulated as a Prolog list). The predicate ""in list"" checks if an element is a member of the list Slist."
Modelling knowledge for a natural language: understanding systemLeu/2 is being developped at IBM Germany in cooperslion with some unlveralty partners, and il fully implemented in Prolog under AIX. The knowledge ba,e for the domain under investigation consists of about 600 concept definitions, among these some 100 belonging to the upper Itructure.
Team approaches to OO designTable 1 (based on the work of Cole and Nast-Cole [Cole921) outlines the phases of group progression from conception to completion. The ISM methodology was implemented in BNR Prolog at Bell Northern Research's Software Engineering Centre [pollard931.
"Interpreting compounds for machine translation(medicine/allergen)-mcdical tmatnmnt/body function-time period steroid treatment period house dust inhalation period The procedure fot' compound interpretation is base(I on a Prolog formalization of the most frequent patterns. ""File following program fragment shows what the format for basal lexical entries looks like and how the interpretation rules are constructed. lex([asthma] ,n,[synd,'om I...... 2). lox([dust],n,lallergen] ...... ). lex(Ipollenl,n,[allergen] ........ ). lex(Ipatient] ,n ,I patientl ........ ). lex([season],n,[ time_period ]......... ). lex(I steroid I,n ,[ medicine] ....... ). lex(lgrassl,n,l concrete] . . . . . . . )i /* pattern: grass pollen */ tlex([G,P],mean([G,Pl),n, [alle,'gen],F 1,F2,F3):- lex([GI,_,[concretel ......... ), lex(lPl,n,lallergen] ........ )."
Information based intonation synthesisThe overall semantic structure of the response can be determined by instantiating the variable in the lambda expression corresponding to the wh-question with a simple Prolog query. Given the syntactic and focus-marked semantic representation for the response, along with the syntactic and focus-marked semantic representation for the theme of the response, a representation for the rheme of the response can worked 195 out from the grammar rules.
Semantic vs. structural resemblance of classesOmit Yalqinalp and Leon Sterling. An integrated interpreter for explaining prolog's successes and failures. In H. Abramson and M.H.
The intersection of finite state automata and definite clause grammarsDCGs are represented using the same notation we used for context-free grammars, but now of course the category symbols can be first-order terms of arbitrary complexity (note that without loss of generality we don't take into account DCGs having exter]In fact, the standard compilation of DCG into Prolog clauses does something similar using variables instead of actual state names.
"CHATR: a generic speech synthesis systemStre,uns must ])e defined at compile ol,]mr language i/""an int,erFace to the st,ream and ut time but may be selected per nttermice at syntheterance structures is provided for thai,language), It sis time Chat is, defining matw difli:rent streams may ha.ve been possible to write IJ)ewhoh' CIIA[I'I,, does not impinge on the size or efficiency of' the system in IAsp (or Prolog or some other ImlguaRe utterance structures built. designed for symbolic nmnipulal:ion)."
"The correct and efficient implementation of appropriateness specifications for typed feature structuresA disjunctive I""CI{. is of the form: l rl'he ""]'roll,qysl.em was implemented in Quintus Prolog by Dale (lerdemann and '['hilo (]Stz. if an object is of a. cel'taiu kiud then it deserves cerl,a.in [ca,1,tll'Cs with vMues of certa.hi kinds, or it deserves cerl.ahi (pei'ha.liS other) fea.1,ures \vil,h viiiues of terra.in (perlla.ps other) kinds, or ... (31: it i:leserw."
An Artificial Intelligence theory of computer competency<--Acts/Subgoal s 81GCS B 4 .0 SocraTECH : A Computer Competent A I Syste m Our AI system, SocraTECH, includes th e knowledge base discussed above and a syste m of Prolog programs . SocraTECH uses an enhanced form of goal - act schemata .
The parallel complexity of simple logic programsThe issue of implementing simple logic programs such as the ones above in ways more intelligent and efficient is an important area of research. parallel computers is also of than the standard PROLOG interpretation Implementing such programs in massively obvious interest. 8 PAPADIMITRIOU, C. H. On the expresswe power of PROLOG. Bu[l. EA TCS. June 1985 9 ULLMN, J. D. AND VAN GELDER, A. mca 3, 1 (1988), 5-42. 10, V.ARDI, M.
"Constraints among argument sizes in logic programs (extended abstract)In practice, most of linear recursive logic relying on""recursion on structure"" technique translativeness property. programs satisfy Our method is fully amenable to automation. implemented the method in Prolog. [APP+89] F. Afrati, C. Papadimitriou, G. We Papageor giou, A."
Approaching classical algorithms in APL2.: An efficient algorithm for determining g the on a higher conceptual level, analogously to Lisp Prolog progr arnming. APL and its successors, convex hull of a ftite or planar espe cially APL2, are modem languages in many respects, [GuJe 79] set.
"Book reivew: Consciousness Reconsidered by Owen Flanagan (The MIT Press. 1992)Chapter 14 illustrates a modelling method for the simulation of FMS control using augmented predicate transition nets, a class of high level Petri-nets, implemented using Prolog. PART 3: MANUFACTURING OPERATIONS Chapter 15 describes the EXPLAN (Expert System Application to Computer-Aided Generation of Process Plans) project, developed as part of the European research initiative arm aimed at building the ""factory of the future""."
Embedding DRT in a situation theoretic frameworkMost notable is the language PRosv[' [9] which offers a Prolog-like language based on situation theory rather than first order logic.
Recent improvements and benchmark results for the Paramax ATIS systemThe facility has been implemented in a fully general way, so that any test that can be coded in PROLOG can be the trigger for retraction. Currently we use this capability to retract certain inferences which result in a database call with no answers.
Students will assess the advantages and disadvantages of using such a shell, compared with solving a similar problem in an AI language such as LISP or PROLOG. Connections: Related to: HUl, PL1, SP1, SP2, SP3 Prerequisites: Requisite for: A12 A12: Problems, State Spaces, and Search Strategies Identification of fundamental classes of algorithms for artificial intelligence. Non-procedural paradigms and languages, functional (e.g., Lisp), logic (e.g., Prolog), object-oriented (e.g., Smalltalk), and parallel (e.g., Occam) Connections: Related to: All, SP1 Prerequisites: AL3 Requisite for: PL2 PL2: Virtual Machines Actual vs. virtual computers. Develop several short programs in a logic-based language (e.g., Prolog). Student gains familiarization with the logic programming paradigm. 3.
"Might a semantic lexicon support hypertextual authoring?HERMES uses an hypertextual framework where the author ""makes explicit"" information (on document structure and content), and the user creates his own hypertext schema by means of a simple definition language. 1With""documentbase""we refersimplyto the set of documents, while we use the term ""hyperbase""or ""hypertext"" when we referto documentsand linkstogether. 2Theimplementedversionof HERMESsystemactuallyruns on a SUN Sparcworkstation.Logicprogrammingmodules,based on ProLog 3.1 by BIM,are integrated with C libraries, under the SunView and X-Windows environment."
Speeding up test pattern generation from behavioral VHDL descriptions containing several processesFinally, a conclusion regarding our approach and a presentationof our future work concerning behavioral test patterngenerationaregiven. 2: Behavioral test pattern generation for VHDL circuit descriptions containing several processes In this section,we discussthe main concepts involved in the two works concerning behavioral test pattern generation from VHDL descriptions containing several processes[8,91.We briefly evoke the contribution of each author in the areasof circuit and fault modelling and test patterngenerationprinciple. 2.1: Circuit modelling [81 usesthe textual circuit description and converts it into Prolog predicates which represent the basic information of the description : statement types, object names, control and assignment clauses, and so on. [9] representsthe descriptions with the help of two explicit modelsbasedon graph modelling concepts.The first is an input/output model which expressesthe links which exists between the inputs/outputs of the different processes involved in the description and which usesthe finite state machinerepresentationfor the processes.The secondis an activation model, stemming from Petri nets, which expressesthe different phasesinvolved in the execution of processes, namely the initialization phase and the simulation phase.Moreover, an explicit representationof each process is made by associating a process with its inside behavior modelled by two graphs representing the control anddata flows. 2.2: Fault modelling In both approaches, the authors propose a fault modelling based on the failure modes of the basic elements of the description language. [8] introduces the term of perturbation model and lists the perturbations which may occur in a VHDL description. [9] refersto [ 121 who defined and validated a behavioral fault modelling schemebasedon the basic elementsof the programming languageconstructs. 2.3: Generation principle The two authors use a test pattern generation method stemming from path sensitization according to a local resolution approach.
Language Systems, Inc.: description of the DBG system as used for MUC-4DBG runs on all Sun workstations (including Sun 3, Sun 4 and Sun 386i models) under the SunOS (UNIX) operating system using Quintus Prolog. FORMAL TESTING OF THE DBG SYSTEM AND EXTENSION TO NEW DOMAIN S We have conducted formal tests of the DBG system on previously unseen messages from two domains, Spac e Event and Long Range Air.
Report on the ACM CSC '95 panel: “Artificial intelligence: finally in the mainstream?”He exemplified this contention by describing projects that advanced the state of the art in the area of constraint logic programming (project 1106, Prolog III), model-based reasoning (project 820, QUIC), and probabilistic reasoning (project 599, EMG), while at the same time producing significant industrial demonstrators in the areas of diagnosis of technical systems, qualitative process control and medical diagnosis, respectively [2].
Symmetric pattern matching analysis for English coordinate structuresBerwick. 1985. New approaches to parsing conjunctions using prolog. In Proceedings of the 23rd A CL Conference, Chicago.
Syntactic-head-driven generationSuch an extreme case would be a recursive rule for semantically empty particles: ('empty' semantics is represented by the empty list symbol El): / / _ [] () part part X1 X2 x Ilowcver, if we a.ssume that structures of that kind do not occur, a depth-first interpreter will be sufficient, e.g. the inference rules of the algorithm can be encoded and interpreted directly in Prolog. Note that van No ord's method is restricted to grammars where phrases have always a lexical semantic head.
Collaboration on reference to objects that are not mutually knownBy repeatedly using the postponement, elaboration, aud suggestion moves, the two agents collaborate through discourse on refashioning the referring expression until they mutually believe tlmt the recipient is conlidcnt that it is adequate. 6 EXAMPLE We have implemented tile model in Prolog. Table 2 shows the input/output of two copies of the system cue gaging in a simplified version of Example 2.
Virtual polysemyWe devised a version of rec_restricts which given an ambiguous lexical type and the resolving con|rain| returns the appropriate grounded type by I. retrieving all the minimal subtypes of the aml)iguous type 2. collecting the constraints of eae.h subtyl)e into a list 3. returning the subtypes whose Ilst of constraints include tlm resolving constraint. The Prolog code Ibr this Mgorithm is tus shown beh)w, where sub, intro and cone arc ALE predicates whicll encode subsumption, feature introduction and constraint declaration. rec_restrict s (hmbigType, Cons, GroundedType) :- f indall (Type, (subtype (AmbigType, Type), (Type sub [] , Type sub [] intro _)), SubTypes), member (GroundedType, SubTypes), SubType cons Consl, term_expansion(Consl, [] , [] ,ListCons), member cone(Cone,ListCons). rec_reetricte is ealle.d fi:oln within solvehoad_type which was redefined ,s a two place l)redicate whose arguments are: a (polyn,orphie) s y n s e m type, and its resolving contraint a.s provided during the course of rule application, e.g. solve head_type( IV mldir_or IV obl dir_synsem, pp_synsem), In the compih*.d code for solve_head_type, the tmambiguous type given as output 1)y roe. restricts (e.g. iv_undir_synsem) is used to resolve, the input polymorl)hic type (iv_undir_or_iv_obl_dir_synsem) using unification of (atomic) synsc.m types rather than fldly tledged l!'
"Channel routing by constraint logicOne of several techniques used in Zargbam [4] to solve a variety of muting problems is to usc scvsral csmpcrating ""experts"" who work concurrently and each of whom dealswitha sutwctof the problem constraintsusinggsnerate and t=t methodsin Prolog. It should not be expected that a constraintlogicpmgmmming language (clp language)can match ths pdormance that can bc achieved ty lower level methods."
Information retrieval using robust natural language processingFAST PARSING WITH TTP TIP (Tagged Text Parser) is based on the Linguistic String Grammar developed by Sager (1981). Written in Quintus Prolog, the parser currently encompasses more than 400 grammar productions.
Thesaurus-based efficient example retrieval by generating retrieval queries from similaritiesThe full retrieval program calculates the similarity between the input and the example for all the examples in the example database, and retrieves the examples with the greatest similarity. Both programs are implemented in SICStus Prolog 2.1 on a SPARC station-10. Fig. 4 illustrates the results.
"PAD-BASED expert system in small computerLeonardi, P. MeUo, and A. Natali, ""Prototypes in Prolog,"" Z Object-On'entedProgramming, Vol. 2, No. 3, September/October, 1989, pp.20-28. [9] K.S."
Arguing about planning alternativesBut it profides these justifications purely by template matching, not by constructing more general reasoning chains. 8 Current Status We've completely implemented the model diumed in this paper. The program is written in Quintu Prolog and runs on an lIP/APOLLO workstation. Its input is a representation for a stated participant belief, and its output is a representation for m, up. propriate response.
Design of an algorithm simulation and animation environment (ASA)Several classifications may be used to distinguish among this type of software : generic (pseudo-code) or specific (LISP for a specific LISP machine) , declarative (PROLOG) o r procedural (PASCAL, C) or functional (LISP) , emphasis on data structure or emphasis o n functions .
Database querying and constraint programmingPerhaps one of the most important advances in constraint programming in the 1980 's has been the development of Constraint Logic Programming ( CLP) as a general-purpose framework fo r computations, e .g ., in CLP(J2) [41], in Prolog III [23], and in CHIP [28, 78] . For more informatio n on CLP see the surveys in [22, 55], and the proceedings of recent workshops on the subject . e.g . . [46, 11] .
A modular architecture for constraint-based parsingTile second level of modularity consist in split-For example, the built-in parsing method of ring each of the three main components i,lto sev-Prolog for DCGs is olt.ained by combining tim era.1 modules.
An analysis of diffusive load-balancingExamples include there are assumption back-track searches, branch-and-bound optimizations, theorem ing, interpretation of PROLOG programs, adaptive ment techniques for solving PDEs, and ray tracing provrefine [7].
Conference report: empirical studies of programmers: fourth workshopIt also illustrates the progress in and affordability o f computer tutoring in that APCS was rewritten from a 20,000 - line LISP program in eight pages of Prolog code for an IBMAT. Similarly, John Anderson ' s tutoring systems (at Carnegie Mellon) have been ported from Xerox LISP platforms to Macintosh computers.
Subject-based evaluation measures for interactive spoken language systemsThe system accesses the relational version of the Official Airline Guide database (implemented in Prolog), formats the answer and displays it on the screen.
What sort of trees do we speak?: a computational model of the syntax-prosody interface in Tokyo JapaneseHowever, a similar model has been argued for by Briscoe (pc) on the basis of English. The model has been implemented in a Prolog version of PATR-II augmented with a simultaneous equation solver.
SIREDOJ: a legal assistance application about contracts in the building industry. @ ACM O-89791 -399 -Xf 91/0600/0260 $1.50 legislation, court decisions and doctrinal bibliography, and in the building of expert systems in some areas of civil law, developed in languages such as LISP or PROLOG, or shells such as CRYSTAL. In this paper we present SIREDOJ, an application which has characteristics of both the expert systems and the database management systems.
An algorithm for generating non-redundant quantifier scopingsProceedings of COLING 90. Pereira, F.C.N. and Shieber, S.M. (1987): Prolog and Natal-language Analysis. CSLI Lecture Notes No. 10, CSLI, Stanford.
A task independent oral dialogue modelThe system is currently under development in Quintus Prolog on a Sun Sparc Station. We now have a first integrated small prototype which runs in three languages (English, French and German) and for three different applications: flight reservation, flight enquiries, and train timetable enquiries.
Real programmers don't use spreadsheetsIn Lotus 1-2-3, there is no such thing as the cut in prolog. The complete sorting program for 12 numbers is: Ai: 12 BI: +$Ai-@COLS($BI..Bi)+i A3: @ROWS(B$3..B3) B3: @IF($A3=B$1,@MAX(A$29..A29),A29) Bi 6: @IF($A3
An approach to integrating and creating flexible software environments supporting the design of complex systemsIt is a distributed, multilingual the and both and environ ment that is largely written in Prolog, C and but also supports external programs written eral languages.
Issue abstractsTo illustrate our technique, optimal instruction sets are derived for data structure creation in Prolog. SIGmicro Newsletter, September 1991 Page 14 Increasing User Interaction During High-Level Synthesis Robert A.
Integrating mathematics and programming into a three tiered model for computer science educationLogic programming will be introduced via Prologb[8], a pure logic subsetof the Prolog syntax that usesa breadth-frost searchstrategyto guaranteesolution for all valid queries, regardlessof the orderingof clausesor goals. 5.
Combining knowledge sources to reorder N-best speech hypothesis listsThis made it possible to impose moderately realistic resource limits: linguistic analysis was allowed a maximum of 12 CPU seconds per hypothesis, running SICStus Prolog on a Sun SPARCstation 10/412. Analysis that overran the time limit was cut off, and corresponding data replaced by null values.
Database research at IPSICurrently, we extend the rules of [NS88] to cover more kinds of inconsistencies, and to assist also the merging of complex data on the basis of simple correspondence assertions given for their constituents. These rules are being implemented in Prolog. Specific emphasis is given to inference strategies which do not require that all correspondence assertions are available, but prompt the user for missing or uncertain assertions [FN92].
OOSPEC: an executable object-oriented specification languageIn order to achieve executable specifications, assertion predicatesaregiven someaspectsof procedural lanaguages, this follows in the same fashion that Prolog allows a procedural interpretation. OOSPEC predicates allow sequential, conditional, and iterative evaluation.
A theory model core for module interconnection languagesThe last step in developing a theory is to translate the ER model and the additional constraints to some inference engine such as Prolog. The base categories and relations are templates for facts, whereas derived categories and relations are represented as rules that use the facts.
An annotated bibliography on object-orientation and deductionDLP (Distributed Logic Programming) [E191] is an extension of PROLOG with active objects. In DLP, parallelism and communication between concurrently active objects is possible.
Re-engineering hardware specifications by exploiting design semanticsThese expressions are heuristic rules that constrain the variables in the model (using Prolog syntax). The slots used include: i- class name: provides a name for the class of cells. ii- cell types: provides four sub-slot,s to describe t.he level of abstraction, the type of logic, the purpose of this class of cells in a. design and the flow of data.
Resolving zero anaphora in Japanese[Gazdar and Mellish, 1989] Gerald Gazdar and Chris Mellish. Natural Language Processing in Prolog. Addison-Wesley Publishing Co., New York, 1989.
Conceptual structures and CCG: linking theory and incorporated argument adjunctsIt has argued that (1) Conceptual Semantics need only be minimally modified to adapt it to tile CCG paradigm, thus providing CCG with a more complete account of thematic role identities, and (2) these changes need not affect CCG at all if Conceptual Semantics' Incorporated Argument Adjuncts are treated as oblique arguments. A Prolog implementation of the framework presented herein is currently in progress.
Validating real-time systems by history-checking TRIO specificationsA prototype version of the specification environment, including tools based on the tableaux mented in Prolog. However, the algorithm for satisfiabilityj was impleintrinsic complexity of the algorithm, com bined with the inefficiencies of executing Prolog programs, prevented the use of the tools for real-life cases.
Integrating qualitative reasoning and text planning to generate causal explanationsThe following elementary transitions (in a simplified form) both lead to the intrcluction of a cause-effect relation (in PROLOG notation, arguments in capitalized letters represent variables): transition(inform_of_a_causal link, inform(cause(C,t ), cause-effect(equi,C,E)). transition(explain with a causal link, [explain(C,E), cause(C, E)I, cau.'
An acquisition model for both choosing and resolving anaphora in conjoined Mandarin Chinese sentencesG-UNIMEM, a modified version of UNIMEM, is an incremental learning system that uses GBM(Geueralized-based Memory) to generalize concepts from a large set of training instances. The program was implemented in Quintus PROLOG and on SUN workstation. G-UNIMEM differs from UNIMEM in two respects.
The gist of GIUKU: graphical interactive intelligent utilities for knowledgeable users of data base systemsTechnical report, Servio Corp., 1990. [3] Anjo Anjewierden. Pce-prolog 1.0 beta, reference manual. Technical Report ESPRIT Project 1098, University of Amsterdam, 1986. [4] Jorge B.
"The well-founded semantics for general logic programsAlthough we avoid such constructs for simplicity of presentation, the well-founded semantics is easily generalized to such syntax, so we continue to use the word ""general. "" In keeping with Prolog's letter, constants, functions, use the same symbol, for relation. Morgan Kaufmann, San Mateo, Calif., 1983, pp. 500-506. Makin% Prolog more expressive. J. Logic Prog. 1, 3 of logic programs."
An automated tool for analyzing completeness of equational specificationsIn [3], the generation of test cases is guided using a Prolog interpreter which is used to generate values satisfying the associated conditions. Narrowing conit is in satisfy techniques discussed in the term rewriting literature as well as Prolog interpreter can be used for generating concrete values satisfying a conjunction of conditions, similar to the ideas discussed in [3].
The role of computer software in numerical analysis teachingAnother categorization might be in the following three groups: traditional languages including COBOL, Fortran, Pascal (heir to the ALGOL tradition) and PL/1, more specialized and stylistically diverse languages including APL, LISP and SNOBOL, languages representing more contemporary concepts and trends such as Ada, C, Modula-2 and PROLOG. We will limit our brief discussion of computer programming languages to two examples, namely Fortran and Ada while recognizing that many universities are also teaching their numerical analysis students C and Pascal, among others. 2.2 Fortran 2.2.1 Fortran 77 We can see from the foregoing list that the more widely used high-order languages, namely the variations of Fortran and Cobol, were created early in the history of computer science (before the problems of large system development were understood). While Bob Skeel readily acknowledges that all of the foregoing can probably be handled by Maple [13], Mathematica also permits new data types to be defined and more importantly, allows one to define rules, like in Prolog. In a special projects course his students had to define rules for interval arithmetic which was then used to create (except for roundoff error which was neglected) a rootfinder that would find all the roots of a function.
"Institutions: abstract model theory for specification and programmingBut also popular are abstract data types, and Horn clause logic, as for example, Prolog. More exotic logical second-order polymorphic lambda calculus, modal logic, continuous algebra, infinitary type theory, and intensional logic have been proposed to handle problems such as concurrency, overloading, exceptions, nontermination, program construction, apparent that many general results and natural language. These mechanisms programming languages such as (pure) specification languages like Clear, support generic modules for logical Prolog, OBJ, and Eqlog, as well as and program development systems like LIL. This too is obviously an institution `"" More precisely, the order-sorted because it is just a restriction of ordinary [53] variant of this loge is the basis. first-order logic, it is the basis Prolog [71]. Let us denote for the logical programming language (pure) this institution YF `."
Deterministic consistency checking of LP constraintsCambridge University Press. Gregor Erbach. 1995. ProFIT: Prolog with Features, Inheritance and Templates. In Seventh Conference of the EACL (This Vol.), Dublin, Ireland, March.
Intelligent software technology for the new decadeGamma-SETL: Very High-Level Programming System Since its inception the SETL [5] has belonged to the same group of new-generation languages as Prolog and Smalltalk. For more than 10 years--beginning in the mid 1970s--our laboratory used it as the main instrumental language.
Specification by interface separationThis behaviour resembles that of backtracking in logic programming languages such as Prolog. On the other hand for the sequential composition, 'P, Q', of P and Q, the assumption is that P computes its result independently of whether or not Q terminates on inputting that result.
A tool for collecting domain dependent sortal constraints from corporaIt hms a main window for displaying and editing the sorts and a set of buttons that help the user to either display additional information or perform actions such as : • load or save a sort file, • select a fimctor among tile list. of Ml fimctors and disphty the list of its possible arguments, result and probabilities, • deletion and insertion of a sort definition, • display a sample of sentences associated to a specific sort definition, • mapping between the sort definitions and a reference sort file (for evaluation), • changing the way the sort definitions are displayed (result or not, mapping or not, global prolmhility, conditional to a functor, or relative to the first argument of a definition), • use of a threshold on the In'ol>abilities to filter the sort definitions, • retrieve I.he list or I'unctors giwm a certain argu[|I(HIL) • display the sentences associated to a sort definition, • display the list of predicates which have been excluded form the extraction, • specification of a sortal hierarchy to be used with the sort definitions for the next iteration, • use of a whiteboard to save specific sentences and information daring a session. The tool uses ProXT, the Quintus Prolog interface to MOTIF widget, set and the X-Toolkit. 601 6 EVALUATION AND RESULTS Evaluate the porting to a new domain require rneasuring how the new sort file contributes to perform the target task within the new domain.
"EBL: an approach to automatic lexical acquisitionThis is done while still keeping the justilication reformation, since this might contaht evidence indicating other word-senses or holnographs 4 hnI)lementation status A prelimiuary versi(u of the lexieal acquisition sys tern has been implemented in Prolog. ""File mealtile extracting telnplates froln Selltences with knowll words is [uily operational."
SRI international results February 1992 ATIS benchmark testWhen a template including contextually inherited slots is produced, the TRAVELOGUE produces, optimizes, and runs a PROLOG database query, generating the final answer. 3.
APT—a productivity tool for supporting expert analysis of time series dataThis minimizes generation of garbageand resuhs in high performance, at the expense of a large control stack. A commit operator, analogous to Prolog's cut, allows the programmer to specify thelevel at which backtracking should take place.
Towards machine translation using contextual informationThe program eui'rently consists of several hundred lines of PROLOG. 6 Final Remarks The idea of using contextual information in Machine Translation has been proposed before ([br exainple [Wada 90],[Elwrle 92],[llaendt 921), ho,vev,'r, there SeelfiS to be little researc]l carried ()lit ill the field.
"Shake-and-bake machine translationIn addition, features called ARGO,ARG] and so on provide useful ""handles"" for allowing the bilingual lexicon to access the semantic indices, but they are not strictly necessary for the grammars The signs presented are only shorthand abbreviations of the full ones used, and the interested reader is referred to [Beaven 92] for a more complete view. The PATR-II notation will be used, with the Prolog convention that names starting with upper case stand for variables. tion, for the sake of clarity and brevity, the non-In addiessential features will be omitted, as will be their names when these are are obvious."
Garbage collection in object oriented systemsOur main insight is that the threads paradigm and the use of a standard threads system suggests a heap memory layout and garbage collection technique which is quite different from existing Lisp and Prolog Systems. A High-Performance Architecture for Automatic Storage Management for Real-Time Garbage Collection Kelvin Nilsen Systems with Real Time Constraints Dept. of Computer Science Iowa State University Ames, IA 50011 (5 15) 294-2259 kelvin@cs.iastate.edu uunet!
A toolkit for the incremental implementation of heterogeneous database management systemsSo far, the types of constraints that we have identified can be effectively captured by a declarative first-order logic programming language like Prolog (Sterling and Shapiro, 1986). Second, it is not a goal to identify all possible constraints that apply to heterogeneous systems integration, the current set seems to be a first good approximation based on our experience with the domain. IEEE Bulletin on Office and Knowledge Engineering, Summer, 1990. Sterling, L and Shapiro, E. TheArt of Prolog. Cambridge: MIT Press, 1986. Stonebraker, M. and Rowe, L.
Un systeme inferentiel oriente objet pour des applications en langues naturellesCette solution semblt plus awmtageust ,5 c616 d'unt hnpl 6meutation lisp ou prolog 6tendu. • Le troisime niveau Iui impl 6mente le module objet h l'aide du lormalisme logique sous-jaceut. 7 - CONCLUSION Dials ce document, nous avons pr 6sent 6 Ull systilne inf 6reutiel orient 6 objets pouvtmt tre utilis 6 daas diverses applications eu Ilmgaes naturelles.
Software development in Core: the application of Ada and spiral developmentMultiple application program languages are supported by the generic system includlng GOAL (a custom NASA test language), A&L C, Fortran, pascal, Prolog, and LISP. Users and Operators interact with test applications and the Core system through Display Processors (DPs), which are connected to Al% via the Display Network Subsystem (DNS).
A reusable lexical database tool for machine translation., Wolff, S. (1988): The Lexicon and Morphology for LMT, a Prolog-based MT system, Research P,eport RC 13403, IBM Research Division, Yorktown Ileights, NY 1(1598.
Teaching the English tense: integrating naive and formal grammars in an intelligent tutor for foreign language teachingA series of computational experiments with the new Verb Generation Expert, implemented in PROLOG on a MaclI, is under way with the goal of establishing the reliability of the proposed approach.
Categorial Grammar and Discourse Representation TheoryA reader who has worked himself through one or two of these examples will be happy to learn from Moortgat [11988] that there are relatively fast Prolog programs that automatically find all semantic recipes for a given sentence. 5.
A faster algorithm for constructing minimal perfect hash functionsThe LEND (Large External object-oriented Network Database) system, used in CODER, has evolved as well, through two major versions. While CODER originally used Prolog database facilities, or relied upon special manager routines coded in C to provide access to large collections of data or information, all shared access to information by CODER modules now involves use of Version 1 or Version 2 of LEND.
Efficient face-based feature recognitionHenderson [14] : Represented the B-rep data-stNcture ssasetof prolog clausea. Featumcan thenbe identified though the application of logical rules.
Behavioral fault simulation in VHDLThe Preprocessor also constructs any necessary internal representation (e.g. Prolog predicates) required by the Test Generation Algorithm and appends this representation to the text of the source file.
PLAID: proactive legal assistanceA prototype, illustrating the functionality and componentsof the systemand implementedin PROLOG, is described. INTRODUCTION One very common task, in many walks of life, is the preparation of a brief.
Hardware/software resolution of pipeline hazards in pipeline synthesis of instruction set processorsIt was used by the Advanced Computer Architecture Laboratory at University of Southern California for the studies of Prolog compilation and design automation. The minimal achievable latency of this processor is five, i.e., any effort to synthesize thk processor with au instruction initiation tatency less than five will introduce pipeline hazards.
On abstract finite-state morphologyGiven such FSTs and equivalent transition networks for Arabic noun and verb structures, Prolog was used to implement the automata. Start and end states are declared with the predicates start_state(X) and end_state(Y) where X and Y represent state numbers, and arc declarations have the form: arc (CurrentState, NextState, [InputString], [Output-String]).
"The nondirectional representation of Systemic Functional Grammars and semantics as typed feature structuresInquiries of this type are necessary since they provide an additional interface structure between actual upper model concel)ts and objects in the system IUsing Prolog's ""neck"" symbol to introduce the condition. AcrEs DECOLING-92, NAN'rES,23-28 AOUr 1992 9 1 8 PEso. or COI.1NGO2, NAIrES,AUG.Z3-28. 1992 network."
Accommodating context changeInitial Implementation Entity Introduction and Elimination The Natural Language and reasoning components of the AnimNL project are being implemented in Prolog. In our initial implementation of context change, entities can be entered into the context by either entity introduction or event simulation, but they are never actually removed.
Inferencing in information retrievalSPECIALIST runs on Sun workstations and is implemented in Quintus Prolog, with some support modules written in C. We have recently conducted experiments using a test collection of user queries and MEDLINE citation records retrieved for those queries.
On seamless prototypingAlthough a commercial grade version has yet to result, the prototype itself satisfied all of the initial design requirements, and was easily modifiable to the planned extensions, including (a) forms generation to GAO standards, (b) portability to UNIX platforms (the program was written in ANSI C and Edinburgh syntax Prolog), (c) linkage to external databases and (d) GUI interface for Windows users.
TTP: a fast and robust parser for natural languageTTP is based on the Linguistic String Grammar developed by Sager (1981). Written in Quintus Prolog, the parser currently encompasses more than 400 grammar productions, s TIP produces a regularized representation of each Imrsed sentence that reflects the sentence's logical structure.
Automatic program generation using sequent calculusThe Synthesis Methodology In this research two major components are needed: a turget kzngurzgein which programs will be constructed, and a comrtruction method in which both proofs and programs are generated. Our target language, catled Ls, is a simple Prolog-like language in which programs are constructed using pedieates and functions.
Reflective programming in the relational algebraS1 .50 a fee in the relational algebra abstract) Van Guchtt Gottfried Vossen$ University Universitat Giessen programming constructs provided in various lan guages for logic or functional programming (e.g., eval in Lisp and clause in Prolog) are a simple and good example. The essence of reflection is that programs can be treated as data and vice versa.
Solving geometric constraints by homotopyThe decomposition is performed either by the inference engine of some expert system like in Buthion [But 79] or Verroust et ai [VSR92] to cite a few, either by the matching mecanism provided by some programming language such as Prolog, as for example Bruderlin [Bru 86], or by searches in graphs, like Owen Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copyin is by permission of the Association of Computing 7 Machinery. o copy otherwise, or to republish, requires a fee and/or specific permission.
The Primordial Soup Algorithm: a systematic approach to the specification of parallel parsersThis makes it almost trivial to derive prototype implementations in (parallel) logic programming languages like Prolog or Parlog [JPSZ]. [Earl J. Earley. An efficient Context-Free Parsing Algorithm.
Information retrieval using robust natural language processingFAST PARSING WITH TI'P PARSER TIP flagged Text Parser) is based on the Linguistic String Grammar developed by Sager (1981). Written in Quintus Prolog, the parser currently encompasses more than 400 grammar productions.
"A tool in modelling disagreement in law: preferring the most specific argumentAnother approach principle is approach to is to use some kind of consistency- or nonprovability-operator in combination with exception clauses, formulated specifically, as e.g. in Etherington Reiter (1983) and McCarty (1988), or either and generally, as e g+ in Routen (1989), containing implementation in PROLOG. However, for philosophical reasons a legal I will concentrate on using the principle as a metarule choosing between competing arguments, since for as such it more naturally fits into the disagreement"" view on legal reasoning than approaches, which do not aiiow arguments."
"On the inference of configuration structures from source code#endif In the theory of concept lattices, the resulting table is called the ""dichotomised context"". Prolog programmers have known the same trick (explicit rules for negated predicates) for a long time."
LITES, an intelligent tutoring system for legal problem solving in the domain of Dutch Civil lawWe also got the work of Sherman. constructing a Prolog-program which is able to permission to COPY without fee all or part of this material is granted provided that dte copies ae not made or dismibtkd for direct comme&l adv&ttage, the ACM copyright notice and the title of dte publication and its date appear, and rtotice is given that copying is by permission of the, Association for Computing Macbtnery.
Understanding natural language instructions: the case of purpose clauses., 1989), the algorithm is being implemented in QUINTUS PROLOG. refer both to input descriptions and to action types.
A cost effective question asking strategyBased on this notation a Horn ctause swstem can be expressed as: iF (Aj is true for aii j c I(i,d)) THEN for any i c N and d c D(i) (Ai is true) Horn clause systems are a special class of a logical system which is widely used in practice (see, for instance, [Hooker, 1988a and 1988b]). PROLOG, a popular logic programming language, relies on Horn ciauses.
Automatic instantiation in AdaIt is possible to buildknowledge of these constraints into the algorithm, but we instead use the algorithm as described, and construct dummy generics and parameters to express the relationship between types. These dummy generics form a Prolog-like logic program. For example, we can define overloaded instances of the procedumz is-range.
PRESTIGE: a CASE workbench for the JSD implementorDavis [8] shows how an algebraic specification can be transformed into Prolog and therefore be given a convenient operational interpretation.
Multi-tape two-level morphology: a case study in semitic non-linear morphologyPulman whom I thank fro' guidance, support and feedback. q'hanks to 13r ,Iohn Carroll for editm'ial comments, Arturo 'lh'u-jillo for useful 'chats' ,rod Tanya Bow(h!n for Prolog tips, 180 Two-level implementations either work directly on rules or compile rules into FSTs.
F-PATR: functional constraints for unification-based grammarsIn contrast to the research projects that implement unification-based grammar formalisms on top of Prolog, this implementation has built a unification environment on top of Lisp.
"Finite representation of infinite query answersDatalog. in [14, 17] (it was called functional deductiue is a superset of Datalog and a subset of (pure) Prolog. In [13, 14], we show that Datalog is decidable using the methods of [22]. We generally follow fk( `"""" f,(t) """". ) as fk the Prolog notation. We write a cc,mplex term """". fl(t), ( . .. ((0+1) +1)"""""" +1) as n and n tLme 5 ( """""" ((T +1) +1) ... +1) as T + n."
CASE tool architecture for knowledge-based regression testingCURRENT STATUS AND FURTHER WORK Our frame-based TMS maintains a bowledge-base test-related objects and their relationships, and for makes inferences to support regression testing. Our prototype implemented in Prolog ([JEON92]). The is current implementation supports structural unit testing techniques based on the data flow analysis method introduced PS85].
A formalization of the CORDS Process Model using MondelFor Mondel, this part i s defined using context-free and attribute grammar s [Leco 89] and is implemented by a compile r written in Prolog, which also produces the interna l representation used by the Mondel interpreter .
Lexical choice in context: generating procedural textsMost of these algorithms have been implemented by Kosseim 1992. The generator uses Prolog anti specifically Definite Clause Grammar (DCG) to produce text.
Object oriented simulation with SMALLTALK-80: a case studyWith Ada, the potential was almost unlimited but the price to pay was high, the goat with Ada was to satisfy the needs of so many application areas that it resulted in a very language. complex In the mean time, Lisp and Prolog were proposed as the solution for artificial intelligence programming.
History cache: hardware support for reverse executionIEEE Transactions on Knowledge and Data Engineering, 6(4), August 1994. [26] L. Sterling and E. Shapiro. The Art of Prolog. MIT Press, Cambridge, MA, 1986. [27] T. Teitelbaum and T.
Quantifier elimination for formulas constrained by quadratic equationsSpringer-Verlag, Berlin, 1975. Vol. 33. [4] A. Colmerauer. An Introduction to Prolog III. Communications of the ACM, 33(7):69-90, 1990. [5] N.
"Robust processing of real-world natural-language textsInside Computer Understanding: Five Programs Plus Miniatures, Lawrence Erlbaum, Hillsdale, New Jersey. [14] Stickel, Mark E., 1988. ""A Prolog-like Inference System for Computing Minimum-Cost Abductive Explanations in Natural-Language Interpretation"", Proceedings of the International Computer Science Conference-88, pp. 343-350, Hong Kong, December 1988."
A data dictionary as a Lexicon: an application of linguistics in information systemsThe Natural Language generating part of the lexicon is implemented in Prolog. This SUN-windows based i' In linguistic theoriesa distinction k madebetween a logical and a syntactic subject.
An investigation of a standard simulation-knowledge interfaceOthers have written all the requisite parts of the intelligent simulation in a traditionally language such as PROLOG [0'Keefe 1989], another approach has been the development hybrid languages that provide simulation Al Still of constructs and statistic-gathering properties with pattern-matching abilities and reasoning capabilities [Ruiz-Meir and Talavage 1989], Unfortunately, there seem to be almost as many solutions to the problem of integrating simulation and artificial intelligence as there are investigators into the problem.
"On representing the temporal structure of a natural language textFormally, for instance with respect to X=""eontinuation"", X is evident, if for P with Ve (ORS s[es/e] ---* P(e)), we can infer that 3e (P(e) A e,j"" -< el, but neither that e (P(e)AeCe,.l)nor 3e (P(e)AeProlog. So tile order of the rules is important. Thus, we get a preference relation over the allowed readings."
Querying office systems about document rolesFor example, using the above referenced concepts of the loan granting domain, the following rules (in Prolog-style notation) define when warrants are required needs_warrant(Loan_id) :- loan(Loan_id,Customer), company (Customer) amount(Loan_id, Money), greater(Money, 10000) warranted(Loan_id) :- loan(Loan_id,Customer), needs_warrant(Loan-id), warrantor(Loan_id,Wl ), warrantor(Loan_id,W2), WI # W2 The former rule states that a warrant is needed if the loan amount granted to a Company (as opposite to a private customer) exceeds $10,000, the latter rule states that if the loan must be warranted, two warrantors are required. retrieval system, this rule implies the existence For the of two warrant letters associated to the dossier of the credit reciDient 1 when this recipient is a company, therefore, the implicit relationship between the Customer-Dossier document and Warrant-Letter document is considered through a knowledge inference process.
Specification matching for software reuse: a foundationThat is, only the following modifications are necessary: the operator size is implemented operator card and the sort int can be specialized the sort real. 5 Implementation by the from A prototype system for applying specification matching process to constructing the hierarchical library trieving reusable components from that library and re has been implemented in the Quintus ProWindows language dialect of Prolog that supports the object-oriented 1, a orga nizat ion of graphical elements.
Designing hypertext support for computational applicationsBuilders and developers can declare them, for example, as expert system rules or database tuples, or as with one author's current prototype under development [4], as bridge laws [3, 24] in Prolog predicates. Following the hypertext philosophy of maximum access prompts developers to scrutinize an application in a new light.
Knowledge bases for user guidance in information seeking dialoguesIts dynamic and static knowledge bm.es are based on CLOS, the object-orientedextension of CommonLISP, andon CRL, aframerepresentation language of Knowledge Craft and CRL-PROLOG [10]. The Cordis data were transferred into the relational database system SYBASE.
Applied text generationIssues such as word order in relative clauses, the morphological form of the complementizer, and conjunction reduction can be dealt with at further stages of processing. 6 The Linguistic Realizer The linguistic component is based on Meaning-Text Theory (MTT) (Mel'uk 1988), and is a reimplementation (in Lisp) of Polgure's Prolog implementation of a Meaning-Text model for English (Iordanskaja et al 1988, Iordanskaja et al 1991).
Bonded arity Datalog (≠) queries on graphs[Pa 85] Papadimitriou, C. H. A Note on the Power of Prolog. Bulletin of EATCS, Pp. 21-23. [Sh 87] of Database Expressive Shmueli, O.
Adaptive query optimization in a deductive database systemAdlti [20] is a multi-user, disk-based, deductive database system. Aditi programs are written in a vari ant of Prolog and are compiled, via two intermediate languages, into a low level procedural relational lan guage (RL) that is similar to IGlue.
Program representation and behavioural matching for localizing similar code fragmentsSome of the most common program representation methods include (a) Abstract Syntax Trees [12], [5] , (b) Prolog rules [2] , (c) code and concept objects [5] , (d) code action frames [16] , (e) attributed data flow graphs [19] , (f) control and data flow graphs [6] , and (g) lambda calculus [11] .
Sussex University: description of the Sussex system used for MUC-5The system has been developed entirely within the POPLOG programming environment, combining Popll , Prolog, Lisp and C . Our thanks to the POPLOG development and support team at Sussex and ISL for providin g such a productive environment to work with .
KICS: a knowledge-intensive case-based reasoning system for statutory building regulations and case historiesWe are just beginning to implement the previous system in Prolog. Along with implementation, there are two is sues that need further investigation.
The simulation model development environment: an overviewThe prototyp also includes a rule-based expert system component, developed in Prolog on a VAX 8600, to pro duce a simplified action cluster incidence graph using knowledge generic to simulation and knowledge specific to the application domain (Overstreet and Nance 1986).
A treatment of negative descriptions of typed feature structuresSubtype relationships on type correspond to subsnmption relationships on denotations of types. Based on this framework, an extension to Prolog, LOGIN[2], has becn developed. Smolka[20] proposes a feature logic with subsorts.
Datalog expressiveness of chain queries: grammar tools and characterizationsPapadimitriou. A note on the expressive power of prolog. In Bulletin EATCS. June 1985. Daniel J. Rosenkratz.
More IA needed in AI: interpretation assistance for coping with the problem of multiple structural interpretationsstate In other words, which of the following between-sentence connective is the main connective: If.. . then (Alternative Provided, That (Alternative A) If 1. any licensee shall permit any person A) B) who is a legally qualified candidate for any public office to use a broadcasting station, then 2. a) he shall afford equal opportunities other such candidates for that office use of such broadcasting station: Provided, That b) such licensee shall have no power to all in the of censorship over the material broadcast under the provisions of this section. 7The MULTINT system is implemented on an IBM PC using a combination of Pascal, C, and Prolog. The IA system for $315(a) from MULTINT will be available for demonstration the conference. '47 U.
A dynamic extent control operator for partial continuationsNon local exits or jumps (stop, goto), ception handling, failure semantics in Prolog-like dy in can ex lan guages are usually described with continuations 77, Schmidt 86].
A model of the acquisition of menu knowledge by explorationThe model described here is called Ayn. It is programmed in Prolog and has been tested on scenarios drawn from Microsoft's Word for the Apple Macintosh.
"The 16-fold way: a microparallel taxonomyIsaman, ""The Metaflow Architecture,""IEEE Micro, June 1991. [SlnghalSQ] Ashok Singhal, ""A High Performance Prolog Processor with Multiple Functional Units,"" Proceedings of the 16th Annual International Symposium on Computer Arch&xture."
A symbolic simulation model of the organization of human procedural knowledge. & Kn@t, IC Artificial Intelligence 2.eL McGraw-Hil New York NY 1991 17 Rowe, N. C: Artifiaal Intelligen= through PROLOG, Prentiee-Hal Englewood Cliffs NJ 1988 1 .tl] Rummelh @ D.
"SIROG: a responsive hypertext manualA language can be a human language like ""English"" or ""Japanese"", a program language like ""68040 Assembler"" or ""PROLOG"", or any other""language"" like dependence is mainly achieved by attaching situation types ""technical text"", `novice text"", or ""pictures only""."
Towards robust PATRY,O Xl X2 (XO cat) = VP (Xl cat) = NP (X2 cat) = VP (X0subject) = Xl (Xl hum) = (X2 hum) Figure 2: PATti version of the Epistle rule Making PATR Robust The Basic Mechanism In this section, we describe an experimental system, written in Prolog, that is designed to support the mechanisms necessary to apply PATR-type rules to solve constraints selectively.
A review of barriers to expert system diffusionIt is certainly not clear that any of these boundaries still necessarily exist. Some applications have evolved from a LISP (or PROLOG) programming language to *C* and other more common languages found on existing hardware platforms.
A cognitive temporal model for the planning in aircraft maintenanceThe calculus of events is formalized here in first order logic, particularly by meansof horn clausesaugmentedby negation by failure, therefore, the modef can be executed as a PROLOG program [Kowalski, Sergot M]. An important remark must be made here: the database is updatedby adding, without deleting, informations about the events, nevertheless, the relations which do not more hold after the update arc automatically withdrawn.
Building geometry-based widgets by exampleLN. This is very similar to what might happen if a Prolog clause were matched against a data object. The generalization of objects into patterns and the assignment of values to variables as part of the match operation are central to our map learning algorithm.
Fortran program specializationDespite the successful application of partial evaluation to declarative languages, such as Scheme or Prolog, only few attempts have been made to study partial evaluation of imperative languages and only few results have been reported so far.
A computational treatment of sentence-final 'then'The first argument to the predicate 'dis' is responsible for building the tree structure associated with the parse. The second and third arguments, the Prolog variables 'In' and 'Out', enable threading of discourse referents from the sentence just parsed to the remaining discourse.
Experimental classification facilities for SmalltalkThe mechanics of most logic programming languages are even more alien to mainstream object-oriented systems-contrast, for example, Prolog's unification-based parameter passing and backtracking control flow with the more conventional mechanisms found in C++ or Smalltalk.
Transforming acyclic programsAND DUNG, P. M. 1993. Reasoning about termination of pure Prolog programs. 1993. On the correctness of unfold/fold transformation of normal and extended logic programs.
Explaining type errors in polymorphic languagesIn this and MacQueen 1991]. paper [Sergot et al. 1986] concerning the British paper the authors described capturing the legal requirements for establishing Because the requirements British citizenship in a PROLOG program. for British citizenship are so complex it is useful to have a system that explains the steps taken to reach a conclusion.
"An APL rule-based system architecture for image interpretation strategies., actions in which the system reflects that a actions ""meta on the state of its computation and, based on this, decides next action to execute. the Most commonly used languages in the field of artificial intelligence require special constructs to perform such metareasoning activities, as shown in reflective extensions of PROLOG [19], and LISP [20]. Instead, APL allows the development of systems with reflective abilities without having to expand the language."
"An annotated bibliography on active databases (short version)We distinguish direct References to ""original author"" publications, and secondary literature, e.g. comparative papers. 2.1 ADAM ADAM is an object-oriented DBMS project. A prototype is implemented in PROLOG. Active extensions to ADAM treat method invocations as events."
Coping with changeIn these systems the necessary knowledge is fwst assembled into a data base, and auxiliary programs then compile this data into a Prolog program. The authors propose that the associations between the rules and the sources of the law (cases and statutory provisions) should be kept in separate ASCII files.
"Guardians in a generation-based garbage collectorThis is ""generation-friendly"" in the sense that the additional overhead within a generation-based garbage collector is proportional to the work already done there, and the overhead within the mutator is proportional to the number of clean-up actions actually performed. 1 Introduction Many programming systems, such as Scheme, Comnnon Lisp, ML, and Prolog, support dynamic allocation i>nd automatic deallocation of objects."
"Making deductive databases a practical technology: a step forwardIS the basis of a panel session The area IS often considered more paper-oriented (thcorctlcal) than system-oriented (practical) Two reasons can explain this First, the Datalog-like languages do not provide complete programmlng language capablhtles control and mcta-control structures (I e, cxpresslve power), mam memory variables (e g , user envlronment variables), procedure calls or side-effects, mput/output interaction with the user They arc also more query-oriented, database updates are hard to support within rule programs The second reason stems from the way relational database system are built In a relatlonal database system, abstract layers range from evaluating high-level relational calculus expressions to lower-level operations All the operations are performed on the data at the lowest levels and the final result IS finally returned to the mterface process In comparuon, many expert system shells are built on LISP environments Therefore, all the power of LISP 1savailable to the rule programmer who can directly reference LISP functions wlthm rules We believe in the challenge of ""using deductive database technology to build efficient systems that Improve application programmer productlvlty"" The development of the LDL system [Tsur86], at MCC provides a substantial contnbutlon m this direction The LDL language [Naqv1891, 1sa Datalog-like language extended with powerful constructs such as negation, updates, control structures (cut, choice operator), and a data model including complex terms such as sets, functors and externals (e g , C procedures) [Chlmentl89] The general approach IS to define a declarative semantics (actually, a fixpoint semantics) for a logic programmmg language close to Prolog Efficient compllatlon and optlmlzatlon of LDL ISthus possible Our approach 1sm the spirit of the LDL system However, it has some important differences First, our kernel language 1s a production rule language, called RDLl, [MamdrevllleSBal RDLl 1s formally defined as an extension of Datalog with multiple hterals m heads of rules and negative or positive hterals m bodies and heads of rules [Ablteboul891 A negative literal m a head 1s interpreted as deletion of facts Second, the RDLl system 1sintegrated wlthm a relational database system One consequence 1sthat all the data manipulated m the rule language can also be queried or updated using an extended version of SQL Another consequence 1s that all the standard database features are supported by the RDLl system A last difference with the LDL system 1s that we have an extensible architecture with Abstract Data Types (ADT) [Klernan891 Other related work can be found m [Delcambre88, Wldom89, Stonebraker88b, Stonebraker891 In [Delcambre88], the use of database technology to support OPS-like languages 1smvestlgated As a result, their proposed language, RPL, 1svery similar to our language The Starburst project emphasizes the extension of a database system with a production rule-based facility, [Wldom89] Their rule language expresses triggers m a way slmllar to [Daya188] This work IS therefore complementary to ours Rnally, the POSTGRES project, [Stonebrake&Jb], proposes the extension of a relational database system with rules The hmltatlons of this rule language are analyzed m [Stonebraker89] no support for VICWprocessmg, problems for controllmg rule actlvatlon, etc A new language, called PRSII, 1sproposed to allevlate these hmltatlons This language 1svery close to the one described m [Wldom89] This paper presents the design and Implementatlon of the RDLl system with emphasis on practical aspects The system includes many programming features usually found m expert system shells for which we have provided a formal semantics and an efflclent lmplementatlon The paper 1sorganized as follows Section 2 presents the data model and the languages supported by the RDLl system Section 3 presents the overall system architecture This architecture 1s an extension of an existing relational system Section 4 describes the techniques used to Implement expert system shell features m the database framework Also, lessons learned from the Implementatlon of the system are glven Section 5 concludes the paper and points out open issues 2."
The continuous zoom: a constrained fisheye technique for viewing and navigating large information spacesWhile the need for such aids is widespread, ranging from understanding Prolog programs [6] to road maps[l 5], our interest is large real time systems such as power generation/distribution, telecommunications and process control where the operators must work with very large networks representing the system being controlled.
Linguistic knowledge acquisition from parsing failuresBy this hypothesis, an unknown word as well as a known word is assigned into an expected category. Actually, this process is implemented on Prolog and each hypothesis is generated alternatively.
Compiling the polymorphic λ-calculusThe compilation tion which we describe here has been func implemented in A Prolog [13], embedded in the framework Ergo Support System.
Compiling inheritance using partial evaluationConsel and S. C. Khoo. Semantics-directed generation of a prolog compiler. Research Re port 781, YaJe University, New Haven, Con necticut, USA, 1990.
"Legislative knowledge base systems for public administration: some practical issuesResearch Centre for Computers and Law. [Sherman] on Legal Norwegian David Sherman,""A Prolog Model of the Income Act of Canada""'. In Roceedings of the International Conference on ArMcial Intelligence the Law, Boston, May 1987, 127."
Introducing semantics in conceptual schema reuseIn fact, the mechanism sents one of the components of an overall system to the aid of conceptual schema development. repre dedicated It thus makes use of its graphical interface and its dictionaries the processing of natural language specifications. tual version, the mechanism, implemented in Prolog, queries ivolving a single criterium for each condition no conjunction or disjunction of criteria is permited same condition).
Active mail—a framework for implementing groupware., The Logix System User Manual, Version 1.21, in Concurrent Prolog: Collected Papers, Vol 2, Chapter 21, MIT press, 1987. [24] Yardeni, E., Kliger, S., and Shapiro, E., The Languages FCP(:) and FCP(:,?)
A framework for defining logicsVariable-binding operators constants whose domain is of functional type, in contrast to the usual representations guages such as ML [34] and Prolog approach is that it enables the of abstract syntax in programming lan [7]. Feferman based on a general system of finitary and Howe [8] demonstrated the use of emphasizing the use of the richer type in an encoding. More recently, Felty has in A-Prolog, in particular, the LF type [32] are developing the theory of MaTh mathematics on a machine that is similarly systems, albeit of a rather different flavor has proposed a theory of formal systems inductive definitions [17].
"A gentle introduction to HaskellThere are three other Pattern matching in Haskell is very different from that found in logic programming languages such as Prolog, in particular, it can be viewed as %he-way"" matching, whereas Prolog allows ""two-way"" matching (via unification), along with implicit backtracking in its evaluation mechanism. 1°The Report calls these variables."
Direct end-user access to remote information., time and/or cost limitations) and/or the formatting of responses language The language in which the message text is written. (e.g., reply must be a list of Prolog vars and bindings), This simplifies parsing by the recipient by indicating which parser (among possibly many) to use.
CAS/PI: a portable and extensible interface for computer algebra systemsMost of this size is used by the Centaur kernel process which includes a large Lisp core, GfxObj graphic toolkit, Figue, a Prolog interpreter, etc. In the near future, it should be possible to decide which subparts to embed in Centaur's kernel which could significantly reduce the memory size needed.
"The CAEDE performance analysis tool., Karam, G.M. and van der Loo, K., ""Experiments with Prolog design descriptions and tools in CAEDE"", 8'th Int."
On the power of bounded concurrency II: pushdown automata., boundedly is merely to pass along carries in the extremely simple form of cooperation. depend on the choice of the language for it is easy to see that the results hold for concurrent, finite-state) versions of most conven tional models of parallel statecharts [Harel, 1987], computation, such as Petri nets [Reisig, 1985], CSP [Hoare, 1978], CCS [Milner, 1980], or the concurrent versions of standard Prolog. The reason is that these Drusinsky and Harel [1994] programming languages such as Pascal or are all equivalent to the C-machines of to within polynomial differences in size.
An extended classification of inter-instruction dependency and its application in automatic synthesis of pipelined processorsThe SM2aprocessor was used by the Advanced Computer Architecture Laboratory at University of Southern California for the studies of Prolog compilation and design automation. best performance of currently available synthesis techniques.
Parallelizing Datalog programs by generalized pivotingHorn-clauses with exactly one positive lit eral and no negative literal are facts, Horn-clauses with exactly one positive literal and at least one negative lit eral are rules. We adopt the Prolog convention to write facts and rules. Variables begin with a capital letter and predicate names are strings built from small let ters.
The development and operation of edinburgh parallel computing centre's summer scholarship programmeSeveral of that year's projects were continuations of projects done in the previous year, while two System '89 '90 '91 '92 '93 '94 Occam 4 1 2 C/CS Tools 4 6 8 1 Fortran/CS Tools 3 3 3 1 Fortran-Plus 4 6 C-Linda 1 Prolog-Linda 2 C/Unix 1 1 6 1 1 C/CHIMP 12 12 3 RPL/RPL-2 2 1 2 Concurrent ML 1 CM-FORTRAN 5 3 2 C* 1 C/MPI 8 FORTRAN/MPI 4 none 1 2 (These numbers may not sum correctly, as some students used several systems.)
An integrated approach to quality assurance of expert system knowledge bases., 1991]. Both ap programs are written in Quintus Prolog, and run on Sun Sparc 2/ Workstation. Of the DIY!
A unification-based approach to multiple VP ellipsis resolutionThe model described in this paper has been implemented in SICSTUS PROLOG and runs on a SUN 4 computer, It has been tested in analysis as well as in generation mode.
The logic of the whole truthRepresentative of recent work is Sergot and his colleagues' excellent treatment of expressing and applying legislation in a logic program written in PROLOG [5]. In addition, there are several collections [6,7,8,9--listed from earliest to most recent] and an interesting monograph [10] well worth examining.
Process control for large complex systemsTraditional rule-based languages, like scoped rule OPS '83 or Prolog, have only limited expressive capability sometime makes the task of formulating rules very tedious.
A hybrid knowledge representation approach to reusability of legal knowledge basesA prototype of the integrated decision support system described in this paper is currently being developed on a Sun workstation using Prolog. 3 T@og to integrate legal knowledge in an alication aysem that is not knowledge-based would mske no sense. 4.2 Outlook: Terminology Integration One and the same application domain can be represented in quite different ways.
StaCS: a Static Control Superscalar architecture. /* CMPa , ALUa ADRa label (-entry) cont( ___, ---, mov(0, hl), cont( ___, --_ , -_-, cont( ___, --_ , ___, cont( ___, -__, ___, abra( -exit, -__, -__, label (-prolog) cont( ___, __-, ld04(pl,l,pl), cont( ___. __-, ___, cont( ___, _--, ld04(pl,l,pl), cont( ___, lls(hl,2,tl), _-_, label (-kernel) cont( -_-, adu(tl,ubb,hl), ldO4(pl,l,pl), abra(_kernel, lls(hl,2,tl), -_-, label (-exit) cont( ---, and(hl,cst,r), ---, CMPb ALUb cop, lni(COOOl,cst), ___, _-_ t ---, -_-, equ(mvb,O), _-- , -_-, ___, ld04(pl ,O,__)) --_, __-, --_ ) -_-I -_- , ldO4(pl,O,__)) ---, ___ 9 --- ) neq(uba,O), ---, --_, ldO4(pl,O,__)) -__, ___1 ---, ADRb */ ldO3(pl,O,__)) --- ) Figure 11: The gee-cpp hash loop software pipelined ou Stats 2.2. label(_prolog) cont( __-, ___ 9 Id03(pl,l,pl), __-, __-, Id03(pl,O,__)) cont( _--, _--, __-, -_-, __-, -__ 1 cont( ___, lls(hl,2,tl), ldO3(pl,l,pl), -_-, __-, Id03(pl,O,__)) label(_kernel) cant ( ___, adu(tl,ubb,hl), -__ I neq(uba,O), --_, --- ) abra(_kernel, lls(hl,2,tl), ld'X(pl,l,pl), _--, __-, ld03(pl,O,__)) Figure 12: Software pipeline of the gee-cpp hash loop with memory conflicts involvement in motivating people, providing technical guidelines, setting up collaborations, and gathering fundings, the Stats project would never have existed.
"“Normalising knowledge objects”Int Jo Sydney, August Napheys, B. & Herkimer, D.,""A Look at Loosely-Coupled Prolog/Database Systems"", in Procee nce on ase George Mason University, 1988."
Finite-state approximation of phrase structure grammarsIn the current implementation, the construction of the equivalent CFG is is done by a Prolog program, while the approximator, determinizer and minimizer are written in C.
Loading data into description reasonersIt is also possible to determine if queries inconsistent, and thus alert the user to problems. q Query and result reification by making it are easy to add new concepts, relationships and individuals, the analyst can organize the intermediate the analysis (for example, by creating results of individuals corresponding to queries) in much more forms than the original tabular databases flexible [11]. 3.2 The problem Previous research in data management has considered the problem of connecting so-called expert systems to databases, particularly providing Prolog programs with access to relational databases [12, 17, 20, 28].
"Multi-media document representation and retrieval""An Integrated Expert System Design- Coupling Relational Database and PROLOG Systems"", MSc Thesis, Dept. of Computer Science, Arizona State University, Tempe, Arizona. [5] CHOU, YIN-CHIN [1988]."
"MAFIA—an active mail-filter-agent for an intelligent document processing supportThe type definitions are transformed automatically into PROLOG predicates . The predicat e representation for the types and related CSDs is based on simple ""AND/OR"" rules ."
A new approach to debugging optimized codeStep granularity is an expression source unit. Upon entry to the routine, prolog code is executed that sets up the runtime environment and then execution stops on the tirst Soume unit (_add_+ (OX8 ) ): n=2 Stepping once stops on the second source unit to be eXeCURd (_add_+ ( Oxc ) ).
A methodology for prototyping-in-the-largeObLog's logic programming capability supports a declarative style of programming based on predicate calculus representation and Horn clause resolution using a language called LogLisp. This style is similar to that of Prolog but is more general: the programmer can influence the direction of the deduction cycle by specifying how the deduction tree is to be searched, and also by making calls to functions written in Com mon Lisp.
Updating relational databases through object-based viewsACM Trans. on Database for Systems, 10(5):322-346, 1985. [7] B.C. Cohen. Views and objects in OB1: A Prolog based view-object-oriented database. Technical port PRRL-88-TR-O05, David Sarnoff Research Princeton, NJ, 1988. [8] Re Center, P.
A language for queries on structure and contents of textual databasesThe idea is to model, both the structure of the database and the query (a pattern on structure), as trees, to find an embedding of the pattern into the database which respects the hierarchical relationships between nodes of the pattern. The language is enriched by Prolog-1ike variables, which can be used to express requirements on equality between parts of the matched substructure, and to retrieve another part of the match, not only the root.
"Compiling actions by partial evaluationThe semantics of actions defines that if the first chosen action haa changed the store or in some other way""committed"" to the current alternative (like cut in Prolog), then back-tracking is not allowed, so the performance of the entire action fails."
"On Datalog vs. polynomial time (extended abstract)Papadimitriou, ""A note on the expressive power of Prolog"", Bull. of the EATCS 26, pp. 21-23, 1985. [Ra 85a] A."
"Using a language of functions and relations for VLSI specificationCausality analysis for forms of relation which appear in T-Ruby is similar data the to mode analysis for well-moded Prolog programs, which be decidable. However, the algorithm in current is known to use has no backtracking, so if the choice of partitioning when there several possibilities is the""wrong"" one, then are it may not be possible to find a complete causal partitioning for the entire relation, even though one exists."
Executing formal specifications: the ASTRAL to TRIO translation approachSeveral prototype execution environments for TRIO specifications have been developed. One of these prototypes, which is Prolog has@ is described in [GMM 90]. Thedevelopment of a more advanced environment based on the tableaux algorithm outlined above and discussed in detail in [MGG 90] is currently under development.
Link-time optimization of address calculation on a 64-bit architectureIf the two procedures also sharethe sameGAT, we can change the destination of the BSR to skip the GP-setting instructions in the destination procedure prolog. This in turn means that we have no more use for the destination address in the PV, and can omit that address load.
Extending the Potts and Bruns model for recording design rationaleThe hypertext is /augmented by a rule-based system, implemented as a Prolog database, that can check the consistency of the knowledge base as well as provide abstractions through virtual links that are rule-based compositions of the existing links.
Proving concurrent constraint programs correctThe issue of the design of proof systems appropriate to proving correctness of ccp pro grams has received no attention so far. For logic lan guages like Prolog the proof techniques of Hoare-Logic ([16]) have been applied in [10] to reason about prop erties of the flow of control and a process algebra for ccp has been developed in [8] along the lines of ACP ([5]).
A dynamic distributed load balancing algorithm with provable good performanceIn this paper we will present the complete analysis dynamically distributed load balancing algorithm, of a which is bssed on a method described in [7], fulfills the requirements listed above and has successfully been used for a number different applications, like best first branch and bound implementing concurrent prolog [4] and distributed of [8], graphic algorithms [11].
Queries are easier than you thought (probably)This allows to save work by slowly moving to the normal form computation when possible without the large overhead of computing it ahead of time. Some measures obtained with a Prolog prototype already confirm the potential of the technique. 2 A Large Class of Queries In this section, we review briefly the main query languages of interest in the paper.
Detecting redundant tuples during query evaluationBy maintaining low time and space overhead for runtime tests, our techniques the problems inherent avoid to intelligent backtracking in Prolog [PePo 82]. 7 Conclusion We have addressed the problem of detecting dant tuples during bottom-up evaluation. cussed the payoffs in detecting redundancy evaluation.
Constraint patterns as a basis for object oriented programmingThe CLP(R) system [Jaffar90] provides an integration of Prolog-like logic programming and constraints over the real numbers.
Differential logic programmingApt and D. Pedreschi. Proving Termination of General Prolog Programs. In T. Ito and to of A .R. Meyer, editors, Proc. of Int.
The DataLex legal workstation: integrating tools for lawyersFor example, the ideal of logic programming that `every rule in such a system is supposed to be a formal paraphrase of some clause in the legislation'37 is not dictated by Prolog, but derives from arguments about what makes a legal expert system legally sound.
"How to make AXIOM into a scratchpadSimilarly, the the ith element x in u for i in lgMatching on expressions however is always' done in contrast to logic programming that does resolution from""outside-in"". An interesting challenge is to smoothly PROLOG-like matching rules within AXIOM. We have ""inside-Out"" matching integrate not done this. u, logRules*, trigRules first evaluates u, then applies logRules repeatedly, andfinally applies trigRules once."
Semantics of type classes revisitedFor convergent classes, which include all classes definable in HA SKELL, the established type inference approach for type classes based on Prolog-like reasoning (treating in stance declarations like Horn clauses) and the associated dictionary-based implementation can be used without loss of generality.
Monitoring semantics: a formal framework for specifying, implementing, and reasoning about execution monitorsShapiro. Meta interpreters for real. In Concurrent Prolog, collected papers, volume 2. MIT Press, 1989. J.
An incrementally extensible document retrieval system based on linguistic and logical principlesImplementation and Results LogDoc is implemented as a fully functional prototype, programmed in Prolog, running under Unix. It uses a breadth-first, bottom-up chart parser with ranking of solutions according to pReferences computed on the basis of two general preference rules, the Principle of Right Association and the Principle of Minimal Attachment, modified by local syntactic and lexicalised criteria, each with empirically determined preference semantic weights.
Nested relation based database knowledge representationFurthermore, any knowledge representation should be based on a consistent semantics framework. dation of PROLOG based knowledge representation gramming (LP) theory based on First-Order power than formalism The founis Logic Pro Logic(FOL) [LL083], which can be used to deal with deductive [GAL84] [RE184], but has many limitations in handling structures.
The representation of policies as system objectsAlthough hierarchies. He uses a language similar to Prolog to record the the language allows expression of obligation as well as permission, the examples are all cordlned to permission, and the dationship Modal Action Logic (MAL) [Jeremaes 1987] provides between obligation and permission is not explored. a means of system specification using modal logic.
Constraint checking with partial informationHere, we assume emp is a predicate representing the traditional Employee Department relation. We follow the common Prolog convention that names beginning with a lower-case letter are constants (including predicate names), and names beginning with a capital are variables. u Example 2.2: The following constraint says that every employee with a salary under 100 must be as signed to a department. panic :- emp(E, D,S) & not dept (D) & s < 100 This constraint query is not a CQ, because it has a negated subgoal.
Do Russian children like APL2?It was much better than the same process in the PROLOG system, because they worked with the same data structure as in the data base and other Here we also introduced user defined operators. example of operator GRAND to modify functions and FATHER was very appropriate.
Storage management for knowledge basesUnfortunately, most of the existing knowledge base building tools such as expert system shells, Lisp and Prolog, will not support the development of large knowledge bases, precisely for the reasons given above.
Frame-sliced partitioned parallel signature filesSuch features have cal approaches to the signature file fragmentation. this way, a new, mixed decomposition scheme, ularly suit able for parallel implement ation, In become attractive for many application areas includpartic- ing information retrieval, office automation, statisti is achieved. cal databases, computerized libraries, Prolog databases, The organization, based on this fragmentation is called Fragmented Signature File.
Compiling away the meta-level in object-oriented concurrent reflective languages using partial evaluationMeta interpreters for real. In E. Shapiro, editor, Concurrent Prolog: Collected Papers, vol. 2, chapter 25, pp. 166-179.
Simulation and analysis of business processes using GOLOGThe interpreter of GOLOG accepts definitions of primitive and complex actions in Prolog. The specifier must also 316 supply the precondition and effect for primitive events.
Universal finiteness and satisfiability (extended abstract)[ss 86] Leon Sterling and Ehud Shapiro. The of Art of Prolog. Advanced Programming Techniques. MIT Press, Cambridge, Massachusetts, 1986.
Space optimization in the bottom-up evaluation of logic programs.$1 .50 If the strings are of both of length n, then evaluating the program using the top-down Prolog evaluation strategy gives a running time that is Q( J) ).
Parametric design and its impact on solid modeling applicationsBruderlin implemented this approach storing the predicates and rules in a prolog database and using calls to the procedural programming language modula-2 to numerically evaluate the construction steps (the intersections).
Stack caching for interpretersInterpreters are still the dom inant implementation method of general-purpose lan guages like Prolog, Forth and APL, probably the ma jority of special-purpose language implementations are interpreters, and they are even used in special imple ment ations of traditionally compiled languages like C.
"Workflow management systems for financial servicesA knowledge-base has been created after a deep analysis done together with the users. An Inference Engine has been implemented as a Prolog-meta-intepreter with explanation pabilities. The system acts as an ""artificial actor"" ca which identifies an overdraft on the client's records, makes a reasoning about ig evaluates the seriousness for the bank and the appropriate action should be taken to recover it."
Shortening the OED: experience with a grammar-defined databaseThis problem, and from it, we have drawn have been written without use of Using a lower-level language such requiring the creation of many tens code would not only have taken much longer to write, but when understand and maintain. finished, it would have been much harder to Using a high-level language such as LISP, Smalltalk, Prolog or SNOBOL resulting in an unacceptably languages, we are convinced ment a library of routines would have been more tractable, but likely slow implementation.
Optimization of array accesses by collective loop transformationsIf software pipelining is attempted on that code directly, we will have a maximum I+ LB Figure L2 cl 11.- 3: Buffer prolog Allocation for an LCG i PAR Sl: C4(I-4) = C4(I-5) r S2 d=c2+c3 S3: c2=c1 + d +99 S1S2S3S4S5S6S7S8 t epilog (a) Figure S4: c3=cl+bb S5: cl=a+b S6: bb=b S7: a= N+ S8: b= I-1 I epilog (b) 4: Software Pipelined Code l-I throughput of one iteration every two cycles operation to compute b and the two operations because the to compute cl and C2 from consecutive iterations cannot be overlapped and scheduled during the same cycle.
"Visualization using timelinesTime is used to represent the time stamp of the event and has two formats: (1) absolute time --- cSeconds> --- where each is a positive integer number, and (2) Julian time --- DDD.HH.MM.SS.FFFFFF - -. where DDD is the day of the year (day 1 is by conven site_cavecat"""" user ""p4"" CONNECT 274.15 :46:50.0 PERSON p4 ""Person Four"" partner ""p5"" BATCH_END 274.15 :46:50.0 IIIF_SERVER site_cavecat"""" BATCH_START 274.15 :46:51.0 TAS_SERVER BATCH_UPDATE 274.15 :46:52.0 TAS_SERVER BATCH_END 274.15 :46:53.0 TAS_SERVER site_tas """" user ""` p4'"" site_tas """" site_tas """" BATCH_START 274.15 :47:06.0 IIIF_SERVER site_cavecat"""" user ""p4"" DISCONNECT 274.15 :47:07.0 PERSON p4 ""Person Four"" partner ""p5"" PATCH_END 274.15 :47:07.0 IIIF_SERVER Table 1: Example of Event site_cavecat"""" Stream from Client-Server System abstract superclasses that form an object-oriented ork, similar to the model-view-controller framew- tion January 1), HH is the hour using the 24 hour time paradigm in system, MM is the minute, SS is the second, and FFFFFF Smalltalk. MLog [10], a locally developed object-oriented Prolog, was used to support the programming model for Xtg. (3) A set of human interface operations was defined in consultation with a number of companies and universities, and through experience gained in applying xtg to real data sets."
Signature matching: a key to reuseRollins and Wing also implemented a system in Lambda prolog that includes the equivalent of mat&,eo,d.r* o 7WtChWKUWv* [RW91].
"The OODB path-method generator (PMG) using precomputed access relevance[cM81] Clocksin, W .F., Mellish, C. S.,""Prograrmning PROLOG"" Springer Verlag, New York, 1981. [FN92] Fankhauser, P., Neuhold, E, J."
Towards multiple self-applicationFor most specializcrs S = R where S = subset of a high-level language like Lisp or Prolog. 2.3 Multiple Metasystem Transition (appx. fig. 10) We will present a general scheme for the formulation of multiple metasystem transition for a subject program with n parameters.
Does conversation analysis have a role in computational linguistics?The rules that control all this are expressed in a Prolog-like notation. Some examples (from the authors' Table 9.3) are shown in Figure 1.
Syntactical characterization of a subset of domain-independent formulasThe implementation of evaluable formulas has been implemented in PROLOG. The program given in this paper. is very simple and fast, and is close to the definitions We think that it is possible domain-independent formulas, complex.
"Where are we headed?Let me give you an examexplicitly. ple. If you look at Flat Concurrent Prolog (the work Rudi Barkal: In the next 10 years, I Shapiro haS done), some people think we will still see different look at it and say ""shared memarchitectures."
Branch prediction for freeThese benchmarks (23 of them) are listed in Table 1, along with a size Program Description Lng. (lKb) congress Interp. for Prolog-like lang. c* 856 ghostview X postscript previewer c 831 gcc * GNU C compiler c 688 lCC Fraser & Hanson's C cmplr. c 254 m Net news reader c 221 espresso * PLA minimization c 188 qpt Profiling and tracing tool c 143 awk Pattern scanner & processer c 102 Xlisp * Lisp interpreter c 78 eqntott * Boolean eqns. to truth table c 45 addalg Integer program solver c 33 compress File compression utility c 25 qP Search file for regular expr. c 20 Py Polydominoes game c 16 splce 2g6 * Cwcmt smmlahon F 385 doduc * Hydrocode simulation F 184 fPPPP* Two-electron integral denv.
A speech-act-based negotiation protocol: design, implementation, and test useAn example system which uses case-based reasoning existing models in the form of is PERSUADER [Sycara 1991], to simulate/support the mediator's role during negotiation. Another 1991], a Prolog-based expert simulate/support decision ture. (3) Empirical research of the example is NEGOPLAN [Kersten et al. system that uses a rule-based formalism to situations in an evolving negotiation struc negotiation process.
Using Hy+ for network management and distributed debuggingCurrently, there are three back-end quer y processors : the LDL deductive database syste m developed at MCC [31], CORAL [32], and th e third one implemented in Prolog [17] . The system has the ability to invoke external programs that, for instance, browse an ob - ject being represented by a node in one of the graphs displayed by the system .
A meta-environment for generating programming environmentsThis interface between the kernel a number of useful data types but does not make for instance, the logic underlying the language generality is achieved by permitting a simple and logical engines such as a Prolog interpreter ACM Transactions on Software Engmeermg and Methodology, Vol. 2, No. 2, Aprd 1993. or a rewrite rule interpreter.
"An integrated approach to system modeling using a synthesis of artificial intelligence, software engineering and simulation methodologiesFor instance, programming either declarative [1, 49] or functional [6, programming languages (such as Prolog) empha size changes in state where structures-a simple variable ""states"" are best coded as particular data being the most commonly used form for a state."
"Inductive definitions, semantics and abstract interpretationsWith McCarthy's fair parallel semantics, non termination is possible when both executions of c1 and cz may not terminate: pFcl+p' + pl-cz%+p"" pt- [cc2]+p' pl- [clc2]+#' + (65) pcl+ A phc 2-x-+ pb[clcz]-'+l - q With Smyth's unfair demoniac semantics, termina tion of [cl c2] is possible only when both that of c1 and C2 are guaranteed whereas non-termination is pos sible whenever that of c1 or C2 is possible: p+cl-p' Apbcl+l Apl-c2 *1+ (66) p F [ccz] + # ptcz++/i'Apcl-f+Apt- C2-++1 -I- (67) p F [ccz] + #' pl-cl+.l pl-cz-.l - (68) pl- [CIDC2] + 1 `- pl- [ccz] - L . With the unfair, & la Prolog, left to right semantics, termination of [cl cz] is possible when that of c1 is possible or when c1 cannot diverge and C2 may ter minate."
The virtual machineSome work has been performed that uses optimistic synchronization techniques for general purpose parallel computation. ParaTran [18,19] and Cleary's work on PROLOG programs [1] are examples. However, these are strictly software based approaches.
Total correctness by local improvement in program transformationPettorossi. Semantics preserv ing transformation rules for Prolog. In Proceed ings of the symposium on Partial Evaluation and Semantics-Based Program Manipulation.
Sequence query processingACM SIGMOD Record , 20 ( 1 ): 14 - 23 , March 1991 . D. Stott Parker. Stream Data Analysis in Prolog, chapter 8. MIT Press, 1990. Praveen Seshadri, Hamid Pirahesh, and Cliff Leung.
Incremental processing and the hierarchical lexiconThis interpreter takes the rules of a calculus as data and applies these recursively to the sequent associated with the input in order to prove that it is a theorem of the calculus. The system is written in Quintus Prolog. No empirical studies of the efficiency of the system have been undertaken so far. 7.
A contingency approach to the application software generationsExpert systems development may use logic programming, impure logic programming languages, such as Prolog (Minch , 1989), or expert system shells . The word expert i s misleading , a term such as knowledge-based technolog y would be more meaningful .
The POLYLITH software busACKNOWLEDGMENTS The author wishes to thank John dispatching. This has been a successful LISP and PROLOG implementations into Gannon, Udaya Shankar, Marvin Zelkowitz, Ralph Wachter, Bill Gear, and Elizabeth White for Paul Saylor, Jack Callahan, Christine Hofmeister, their many helpful comments and suggestions concerning this research and document.
Efficient maintenance of rule-derived data through join pattern indexingRule 1 is defined join of these relations. A language similar of each rela below on a to Prolog is used in the definition. The common variables in the constraints identify the pairs of join X and Y attributes.
On formal requirements modeling languages: RML revisitedA subset of Telos was implemented at the University of Crete, using C++, and has been tested as part of the above mentioned ITHACA project to manage software repositories containing hundreds of thousands of software object c scriptions. Thrc independent Prolog-based implementations of Telos hvc been developed at SCS (Hamburg) [Ga.1186], the University of Passau [Jark 88] and the University of Crete [Vassiliou 90] and are in use at several sites.
Using types to avoid redundant specializationM. Kahn. A partial evaluator of Lisp written in Prolog. In M. V. Caneghem, First International Logic Programming programs editor, Conference, pages 19-25, Marseille, France, 1982. [11] J.
Intelligent Manufacturing-Simulation Agents Tool (IMSAT)In Proceedings Simulation Methodology-Intelligent MASCOT: A prolog-based simulation modelling and of the 4th International Symposium on Modelling and Environments and Goal-Directed Models (1987).
A direct algorithm for type inference in the rank-2 fragment of the second-order λ-calculusSystem F< relates to object-oriented languages [Pie 92], and tle been which M_Icalculus which relates to extensions of -Prolog Against this recent background, it is desirable [Dow 93]. to demarcate precisely where the boundary between decidable undecidable typability lies wit hin various stratifications and of System F.
Design and evaluation of a compiler algorithm for prefetchingFurthermore, it takes three loops to implement the innermost loop. The first loop is the prolog, which prefetches data for the initial set of iterations, the second loop is the steady state where each iteration executes the code for the iteration and prefetches for future iterations, the third loop is the epilog that executes the last iterations.
Nonmonotonic default modal logicsFor example, on the basis of incomplete knowledge, this conclusion may be invalidated in the future by the new facts about the external world. In Prolog, proved goals can become invalid with its negation by failure semantics, the after the addition of new facts to the database.
Second-order signature: a tool for specifying data models, query processing, and optimizationHence constructor might be defined as: (IDENT u DATA)+ + CATALOG atalog the type The only special thing about this type is that tests whether tuples are present can be written like PROLOG within an optimization role (see Section 5). Cataiog predicates objects are used to establish connections between a model object representation objects.
A rule-based language with functions and setsIMPLEMENTATION A toy implementation of COL the ML family) is described in CAML [181 (a typed functional language of in [37]. An implementation in Prolog is described in [301. In this section focusing on the integration we briefly discuss the implementation in CAML of COL with a functional host language that is provided by the implementation.
Signature matching: a tool for using software librariesThey use queries to generate operations on the set to permit more-efli ultimately perform is similar to our unify implemented a system in Lambda-Prolog match,, O,e,. o matchU.CU ,, Y.. The NORA includes a retrieval tool that uses a eO,,,. o match U., Y, they use variables in types to allow incomplete components has implemented a signature [Snelting et al. 1991].
LaSSIE: a knowledge-based software information systemThen the structure of the communicate concept would be displayed on the terminal, and the user would be prompted to fill in keywords for objects associated with this structure, these would then be matched with stored descriptions to find close matches. The algorithm is implemented in Prolog, the retrieved components are listed in order of closest match, depending on how many keywords matched.
"A call to orderAlso, many functional, applicative and logic lan guages have constructors that create an ordered ture from smaller structures of the same type. lists a.s in LISP, Prolog and Standard ML struc ""Cons"" are the ob vious example."
Soft typingA theory of type polymorphism in Alain Colmerauer. Prolog and infinite trees. In programming. Journal of Computer and System K.
LLO: an object-oriented deductive language with methods and method inheritanceLogin [AiNa 86] is another example for integrating data inheritance with Prolog. We follow the same route here and try to build a query model that will in clude current logical models (declarative and conventionally value-oriented) as its subsets.
Process modelingMARVEL employs a COMMUNICATIONS OF THE ACM/September 1992/Vol.35,No.9 87 rule-based approach based on ideas from languages used for knowledge-based systems (e.g., OPS5 and Prolog). The underlying paradigm uses typed parameters, preconditions, the process elements (currently restricted to simple tool invocations), and postconditions. tam.
A bibliography of parallel debuggers, 1990 editionAlgorithmic debugging of GHC programs and its implementation in GHC. In E. Shapiro, editor, Concurrent Prolog: Collected Papers, pages 180--196. MIT Press, Boston, 1987.
Modularity and information content classes in principle-based parsingThe third clause assigns AI in a condition that is more complex than the others, to deal with subject-oriented parasitic-gaps. 15 In Figure 5, I show schematically how these algorithms build chains. A pseudo-Prolog notation is used, which is similar to the output of the parser, where chains are represented as lists enclosed in square brackets.
Ada experience in the undergraduate curriculumAda remains the core language for subsequent modules in the degree program, it goes without saying that students gain experience in a wide variety of other languages as well-- including Fortran, Pascal, Cobol, C, and Prolog. The university of New Orleans Jaime Nifio, Associate Professor, Departuent of Computer Science.
Trusted computing systems: the ProCoS experienceMachine Language ML 11. Correct Complng.Specific.:PL to ML 12. A Prolog Implementation of PL 13. Operational Semantics for PL III: Compiler Development : 1.
"TIPSTER phase I final reportThe relative threshold would'require ""x"" percent of the words from the ""concepts"" section to appear in a document 88 Cluster 1 i Cluster 2 Cluster 3 Cluster 4 Cluster 5 launch at&t maiden sprint titan cable payload "" transmit pad fcc navigation tariff shuttle mci rocket gte navstar fiber gooch transmitted nasa coaxial unmanned marketplace orbit distance booster optic delt phone atl copper satellite breakup space Its challenger deregulation discovery competition snow commando interface gust guerilla specific shower shiite portable appalachians lebanon architecture dakato gunman processor wisconsin insurgent logic wyoming moslem programming scatter afghan database thunderstorm manilla graph commuter alih diagnostic lake dash software buffalo hezbollah prolog minnesota islamabad maintenance eastem fled hardware upper mujahedeen interact idaho palestin concur picket pakistan function nebraska vorontsov computer wind wound query valley beirut language Table 12."
"An efficient resource-constrained global scheduling technique for superscalar and VLIW processorsAfter the innermost loop is software pipelined, the RISC instruc tions that were""popped-out"" of the strongly connected part of the inner loop (the prolog and epilog of the software pipelined loop) are merged with the outer loop, and the outer loop is software-pipelined similarly."
"Knowledge-based document retrieval in office environments: the Kabiria systemFor example, in the of documents both in the procedural context of laws and regulations of the application referenced case study, a specific aspect of loan funding may be described like notation), where the latter defines the implication needed by the office. by the following two rules (illustrated in a Prolog former defines a juridical requirement, and the of this requirement on the documents which are {Rl } needs - warrant(Loan) :- is-instance (Loan,loan - contract), Loan, Client.Type = ""Company"", Loan."
"A syntactic analysis method of long Japanese sentences based on the detection of conjunctive structuresC. (1985). ""New approach to parsing conjunctions using Prolog."" In Proceedings, 23th Annual Meeting of Association for Computational Linguistics, 118-126."
"Normalising the associative law: An experiment with Martin-Löf's type theoryThe ""strictness"" comes from the second clause, which forces evaluation under a constructor. at(m) ,norm, at(m) X ] norm ) b/ at(m) x I norm) at(m) 9 u x'(y'z) l "" (x 9 y) 9 z I norm ) U Note that apart from trivial syntactical abuses, this inductive definition is the PROLOG program corresponding to norm_mul. The query ?(el norm ) y) will succeed with Y =f, provided e is a multiplicative expression and f is its normal form."
CONS should not CONS its arguments, or, a lazy alloc is a smart alloc[Hieb 90] rediscovered phantom stacks and gives an analysis which is more appropriate for the execution of Scheme on a modern RISC processor. Both Prolog [Warren 83] and Forth [Moore 80] make more extensive use of stacks than do traditional Lisp implementations, and gain substantially in elegance and speed as a result. 8.
Reasoning about functional dependencies generalized for semantic data modelsAnd second, each selection term t of Q is added to T if t e Ter-ms(Ql). 6.3 Cut Insertion Mendelzon [14] has demonstrated an application of functional dependency theory to the problem of automatically Horn clauses of a Prolog program. An applies to circumstances where the evaluating join operations.
Declarative updates of relational databasesS -C. 1991. assumption. In the International 137-146. in pure Prolog. In Proceedings of FGCS Institute for (Tokyo), 244-253.
Learning via queriesThe basic paradigm formulas [2], context-free of asking questions has been applied to DNF grammars [3], deterministic one-counter automata [9], deterministic bottom up tree automata [37], deterministic skeletal automata [36], Prolog programs [38]. Valient also considered the issue briefly [42].
"Computing with features as formulaeFoundations of Disjunctive Logic Programming. MIT Press. Loveland, D. W. (1987). ""Near-Horn Prolog."" In LogicProgramming: Papersfor the Fourth International Conferenceon Logic Programming, edited by Jean-Louis Lassez, 456-469."
Type inference with polymorphic recursionSome languages, scoping, but only top-level function (or SETL [63], and Prolog [64]. definitions is, indeed, a workable however, do not provide nested procedure) definitions: e.g., ABC [18], Consequently, all such top-level definitions combined have to be considered tion.
"Metalevel building blocks for modular systemsWe can easily provide other languages that provide implicit kinds of functionality usually not available in most dynamic environments. (Lisp, ML, and Prolog are three notable examples. ) For example, we can""undefine"" a binding in our top-level environment: (FE-undefine Name) - (set!"
Dynamic partitioning of signature filesRecently, a variation of the designed and implemented methods [3, 28], and Prolog databases [9, signature file access method has been for the Starburst Database System [4].
Undecidable optimization problems for database logic programsIn Proceedings of the A CM June 18-21). ACM, New York, Y. An optimizing Prolog front-end to a relational Conference on Management of Data (Boston, Mass., 1984, pp. 296-306. 24.
A method for automatic rule derivation to support semantic query optimizationJarke mantic query simplification graph-based simplification [25] describes a graph-theoretic approach to se implemented in Prolog. Shenoy [40] uses a method. Chakravarthy [8] describes a method for using theorem-proving techniques tions, but does not define methods tions.
"Machine translation divergences: a formal description and proposed solutionTechnical report, Department of Linguistics and Philosophy, Massachusetts Institute of Technology, Cambridge, Massachusetts. McCord, Michael C. (1989). ""Design of LMT: A prolog-based machine translation system."" Computational Linguistics 15(1):33-52."
Collaborating on referring expressionsThe action schemas make use of a number of predicates, and these are defined in Table 1. We adopt the Prolog convention that variables begin with an uppercase letter, and all predicates and constants begin with a lowercase letter.
Templar: a knowledge-based language for software specifications using temporal logicFurthermore, MAL sign specification languages. specifications can be mapped into certain de For example, a restricted set of MAL specifica tions can be mapped into Prolog effort to map MAL specifications than such languages as TRIO 1991], because MAL supports [Costa et al. 1990].
Generalized probabilistic LR parsing of natural language (Corpora) with unification-based grammarsCategories are combined using fixed-arity term unification (Prolog-style). The results and techniques we report below should generalize to many other unification-based formalisms.
An efficient probabilistic context-free parsing algorithm that computes prefix probabilitiesPereira, Fernando C. N., and Shieber, Stuart M. (1987). Prolog and Natural-Language Analysis. CLSI Lecture Notes Series, Number 10.
Amalgamating knowledge basesIn fact, the approach as that of metalogic programming Perhaps closer to our goal is that of Whang Prolog is a suitable framework for schema of Whang et al. [1991] is in the same spirit discussed earlier.
"Programmable applications: interpreter meets interfacePursuing this point for a moment: users of multi-language programmable applications might well find themselves making choices among ""best"" or ""primary"" languages for given application domains. For database systems, a language based around Prolog might be ideal, for applications involving massive parallelism (such as cellular automata, or simulations of ant colonies), a language like *Logo [35] might provide the foundation of a perfect match, for algebra, a language like ISETL [8] might be preferred."
A taxonomy for secure object-oriented databasesRules specify how the protection are accessed by a message that -In the law-based approach of other entities is influenced when they has such associated profiles. proposed by Minsky and Rozenshtein [ 1987], a set of Prolog rules or laws messages in the system. aspects of object orientation security restrictions, but may be specified to manage the exchange of This approach is intended to describe general such as inheritance, it can be used to describe is too general to be practical for this application.
Integrating pointer variables into one-way constraint modelsPointer variables have been languages, such as CLP [Jaffar examined also in the context of logic-oriented and Lassez 1987], Prolog 3 [Cohen 1990], and Concurrent Constraint Programming be represented as unbound variables some object.
An execution model for limited ambiguity rules and its application to derived data updateThe developed there is close to our notion of comple PROLOG to provide an exhaustive search through the space of alternative extensions not guarantee termination except we use special properties of a user-requested update, and does under severe restriction ns.
Subtyping recursive typesThe algorithm is not expressed of rules that resembles a Prolog logical implication of judgments: as an ordinary procedure but as a collection program.
APPL/A: a language for software process programmingMerlin [Junkermann et al. 1994] centered software environment that uses et al. [19941), although when they may also represent con approach to the representation may have graphical user is a knowledge-based process PROLOG-like rules. Rules are organized to describe a process process, and project, which developer interaction and at three different levels of generality: kernel, together provide a working-context model of cooperation.
